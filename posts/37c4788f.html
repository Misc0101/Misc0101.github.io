<!DOCTYPE html>
<html lang='zh-CN'>


<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0" theme-name="Stellar" theme-version="1.25.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>反射式加载（一）：自加载 - Misc0101</title>

  
    <meta name="description" content="反射式加载（Reflective Loader）是一种自己实现PE文件内存加载的技术，摆脱了Windows系统只能从磁盘文件加载的限制。本篇文章讲解反射式加载中的自加载技术，即在程序自身的进程空间中加载一个PE文件。实现过程中参考了MemoryModule项目，文中还包括对该项目的学习笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="反射式加载（一）：自加载">
<meta property="og:url" content="https://misc0101.github.io/posts/37c4788f.html">
<meta property="og:site_name" content="Misc0101">
<meta property="og:description" content="反射式加载（Reflective Loader）是一种自己实现PE文件内存加载的技术，摆脱了Windows系统只能从磁盘文件加载的限制。本篇文章讲解反射式加载中的自加载技术，即在程序自身的进程空间中加载一个PE文件。实现过程中参考了MemoryModule项目，文中还包括对该项目的学习笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%8D%E5%B0%84%E5%BC%8F%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A0%E8%BD%BD/image-20240610212556861.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%8D%E5%B0%84%E5%BC%8F%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A0%E8%BD%BD/image-20240610212029813.png">
<meta property="article:published_time" content="2024-06-10T03:53:58.000Z">
<meta property="article:modified_time" content="2024-06-10T03:53:58.000Z">
<meta property="article:author" content="Misc0101">
<meta property="article:tag" content="内存加载技术">
<meta property="article:tag" content="PE加载器（PE Loader）">
<meta property="article:tag" content="反射式加载（Reflective Loader）">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://misc0101.github.io/Typora_images/%E5%8F%8D%E5%B0%84%E5%BC%8F%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A0%E8%BD%BD/image-20240610212556861.png">
  
  
  
  <meta name="keywords" content="内存加载技术,PE加载器（PE Loader）,反射式加载（Reflective Loader）">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="title" href="/"><div class="main" ff="title">Misc0101</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/about/">关于</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1705074644177" class="icon search-icon" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc" collapse="false"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%BB%E5%8F%96pe%E6%96%87%E4%BB%B6%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD"><span class="toc-text"> 1. 读取PE文件到内存中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A3%80%E9%AA%8C%E6%98%AF%E5%90%A6%E6%98%AFpe%E6%96%87%E4%BB%B6"><span class="toc-text"> 2. 检验是否是PE文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-text"> 3. 是否有重定位表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text"> 4. 申请内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%86pe%E6%96%87%E4%BB%B6%E6%8B%89%E4%BC%B8%E5%88%B0%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%AD"><span class="toc-text"> 5. 将PE文件拉伸到内存空间中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BF%AE%E5%A4%8D%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE"><span class="toc-text"> 6. 修复重定位数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BF%AE%E6%AD%A3iat%E8%A1%A8"><span class="toc-text"> 7. 修正IAT表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%9B%B4%E6%96%B0imagebase"><span class="toc-text"> 8. 更新ImageBase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E9%A1%B5%E5%B1%9E%E6%80%A7"><span class="toc-text"> 9. 修改内存页属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B7%B3%E8%BD%AC%E5%88%B0%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-text"> 10. 跳转到入口点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text"> 完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%BC%94%E7%A4%BA"><span class="toc-text"> 执行演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E4%BC%98%E5%8C%96%E5%AE%8C%E5%96%84%E7%9A%84"><span class="toc-text"> 未来可以继续优化完善的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memorymodule%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95"><span class="toc-text"> MemoryModule项目学习记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#memoryloadlibrary%E5%92%8Cmemoryloadlibraryex"><span class="toc-text"> MemoryLoadLibrary和MemoryLoadLibraryEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hmemorymodule%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text"> HMEMORYMODULE结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86memoryloadlibrary"><span class="toc-text"> 核心代码部分（MemoryLoadLibrary）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87hmemorymodule%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97"><span class="toc-text"> 通过HMEMORYMODULE使用这个内存模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8memorymodule"><span class="toc-text"> 使用MemoryModule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="toc-text"> 其他方面的学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90"><span class="toc-text"> 参考资源</span></a></li></ol></div></div></widget>






</div>


    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">PE文件格式</a></div><div id="post-meta"><span class="author">发布于</span>
    <span class="created"><time datetime="2024-06-10T03:53:58.000Z">2024-06-10</time></span>
    
    <span class="updated">，更新于&nbsp;<time datetime="2024-06-10T03:53:58.000Z">2024-06-10</time></span>
    </div></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>反射式加载（一）：自加载</span></h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>加载器（Loader）是一段为执行准备其他代码的代码。在Windows系统上，当用户双击一个exe文件时，系统加载器会将该exe文件加载到内存中并执行。同样，对于DLL文件，也是通过系统API函数LoadLibraryA加载到进程的内存空间中。系统加载器的主要作用是将程序或库的数据准备好，以便读取、修改和/或执行。<br />
然而，Windows系统上的内置加载器（built-in loader）仅支持从磁盘上加载二进制文件。如果我们不依赖系统这个加载器，也不通过调用LoadLibraryA函数加载DLL文件，而是自己实现内存加载，这样就可以摆脱只能从磁盘文件加载的限制。数据可以来自网络、内存或自身的某个位置，从而实现“无文件攻击”。这种技术就是<strong>反射式加载器（Reflective Loader）</strong>。反射式加载器可以分为两种：</p>
<ul>
<li><strong>自加载</strong>：程序本身加载一个PE文件到自己的内存空间中并使用它</li>
<li><strong>进程注入</strong>：将PE文件注入到另一个进程的进程空间中并设法使用。</li>
</ul>
<p>反射式加载器（Reflective Loader）的核心步骤包括PE文件的拉伸、重定位数据修复和IAT表修正等。本篇文章将讲解如何实现自加载，即手工模拟PE加载器（PE Loader），通过程序本身加载一个PE文件到自身的内存空间中。在实现过程中，我参考了MemoryModule项目，对该项目的学习笔记在文章后面部分。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<ol>
<li>
<p>读取PE文件到内存中（lpFileBuffer，未拉伸）</p>
</li>
<li>
<p>检验是否是PE文件</p>
</li>
<li>
<p>是否有重定位表</p>
</li>
<li>
<p>申请大小为ImageBase的内存空间</p>
<ul>
<li>
<p>如果没重定位表，按ImageBase申请，申请不到就退出程序</p>
<blockquote>
<p>如果要内存加载的exe没有重定位表，可以在编译器中修改ManualPELoader.exe运行时的ImageBase，确保要内存加载的exe能申请到它的基址</p>
</blockquote>
</li>
<li>
<p>如果有重定位表</p>
<ul>
<li>先按ImageBase申请</li>
<li>申请不到，则再次申请，让系统决定分配的内存地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>将PE文件拉伸到申请的lpImageBuffer内存空间中</p>
</li>
<li>
<p>修复重定位数据</p>
</li>
<li>
<p>修正IAT表</p>
</li>
<li>
<p>更新ImageBase（按实际加载的基址更新PE中的ImageBase字段）</p>
</li>
<li>
<p>修改内存页属性<br />
根据节表中节属性字段得知该内存页属性，可读，可写，可执行的组合</p>
</li>
<li>
<p>跳转到入口点<br />
通过函数指针调用入口函数<br />
根据FileHeader.Characteristics &amp; IMAGE_FILE_DLL判断它是dll还是exe</p>
<ul>
<li>如果是dll，用dllmain函数指针调用dllmain方法，传递DLL_PROCESS_ATTACH参数</li>
<li>如果是exe，以int main(void)调用main函数</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><figcaption><span>main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1: Read PE file into memory</span></span><br><span class="line">    <span class="comment">//const char* peFilePath = &quot;D:\\005_Codefield\\VS2019\\ManualPELoader\\Debug\\TestDll.dll&quot;;          //测试dll   ok</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* peFilePath = <span class="string">&quot;D:\\005_Codefield\\VS2019\\ManualPELoader\\Debug\\TestExe.exe&quot;</span>;           <span class="comment">//测试exe   ok</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">//const char* peFilePath = &quot;E:\\_Reversing\\IDA Pro\\IDA_Pro_v7.5_Portable\\ida.exe&quot;;</span></span><br><span class="line">    <span class="comment">//const char* peFilePath = &quot;E:\\_Reversing\\snapshot_2024-03-19_14-17\\release\\x32\\x32dbg.exe&quot;;</span></span><br><span class="line"></span><br><span class="line">    LPVOID lpFileBuffer = <span class="built_in">ReadPEFile</span>(peFilePath);</span><br><span class="line">    <span class="keyword">if</span> (!lpFileBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to read PE file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Validate PE file</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ValidatePEFile</span>(lpFileBuffer))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Invalid PE file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Check for relocation table</span></span><br><span class="line">    <span class="type">bool</span> hasRelocationTable = <span class="built_in">HasRelocationTable</span>(lpFileBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: Allocate memory</span></span><br><span class="line">    LPVOID lpImageBuffer = <span class="built_in">AllocateMemoryForPE</span>(lpFileBuffer, hasRelocationTable);</span><br><span class="line">    <span class="keyword">if</span> (!lpImageBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5: Copy PE file to allocated memory</span></span><br><span class="line">    <span class="built_in">CopyPEToMemory</span>(lpFileBuffer, lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6: Fix relocations</span></span><br><span class="line">    <span class="built_in">FixRelocations</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 7: Repair IAT</span></span><br><span class="line">    <span class="built_in">RepairIAT</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 8: Update ImageBase</span></span><br><span class="line">    <span class="built_in">UpdateImageBase</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 9: Set memory permissions</span></span><br><span class="line">    <span class="built_in">SetMemoryPermissions</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 10: Jump to entry point</span></span><br><span class="line">    <span class="built_in">JumpToEntryPoint</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-读取pe文件到内存中"><a class="markdownIt-Anchor" href="#1-读取pe文件到内存中"></a> 1. 读取PE文件到内存中</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">ReadPEFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Reading PE file: %s\n&quot;</span>, filePath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(</span><br><span class="line">        filePath,             <span class="comment">// 文件路径</span></span><br><span class="line">        GENERIC_READ,         <span class="comment">// 以只读方式打开文件</span></span><br><span class="line">        FILE_SHARE_READ,      <span class="comment">// 允许其他进程读取文件</span></span><br><span class="line">        <span class="literal">NULL</span>,                 <span class="comment">// 无安全属性</span></span><br><span class="line">        OPEN_EXISTING,        <span class="comment">// 打开现有文件</span></span><br><span class="line">        FILE_ATTRIBUTE_NORMAL,<span class="comment">// 文件为普通属性</span></span><br><span class="line">        <span class="literal">NULL</span>                  <span class="comment">// 无模板文件句柄</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateFile failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwFileSize == INVALID_FILE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] GetFileSize failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">    LPVOID lpFileBuffer = <span class="built_in">VirtualAlloc</span>(</span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// 让系统决定分配内存的地址</span></span><br><span class="line">        dwFileSize,          <span class="comment">// 分配文件大小的内存空间</span></span><br><span class="line">        MEM_RESERVE | MEM_COMMIT, <span class="comment">// 保留并提交内存</span></span><br><span class="line">        PAGE_READWRITE       <span class="comment">// 读写权限</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!lpFileBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAlloc failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容到内存</span></span><br><span class="line">    DWORD dwBytesRead;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(</span><br><span class="line">        hFile,                <span class="comment">// 文件句柄</span></span><br><span class="line">        lpFileBuffer,         <span class="comment">// 目标缓冲区地址</span></span><br><span class="line">        dwFileSize,           <span class="comment">// 要读取的字节数</span></span><br><span class="line">        &amp;dwBytesRead,         <span class="comment">// 实际读取的字节数</span></span><br><span class="line">        <span class="literal">NULL</span>                  <span class="comment">// 不使用重叠I/O</span></span><br><span class="line">    ) || dwBytesRead != dwFileSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] ReadFile failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">VirtualFree</span>(lpFileBuffer, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] PE file read successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> lpFileBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-检验是否是pe文件"><a class="markdownIt-Anchor" href="#2-检验是否是pe文件"></a> 2. 检验是否是PE文件</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ValidatePEFile</span><span class="params">(LPVOID lpFileBuffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)lpFileBuffer;</span><br><span class="line">    <span class="keyword">if</span> (dosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Invalid DOS signature.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFileBuffer + dosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (ntHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Invalid NT signature.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-是否有重定位表"><a class="markdownIt-Anchor" href="#3-是否有重定位表"></a> 3. 是否有重定位表</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HasRelocationTable</span><span class="params">(LPVOID lpFileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Checking for relocation table...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFileBuffer + ((PIMAGE_DOS_HEADER)lpFileBuffer)-&gt;e_lfanew);</span><br><span class="line">    <span class="type">bool</span> hasReloc = ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Relocation table %s found.\n&quot;</span>, hasReloc ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> hasReloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-申请内存空间"><a class="markdownIt-Anchor" href="#4-申请内存空间"></a> 4. 申请内存空间</h3>
<p>申请大小为ImageBase的内存</p>
<ol>
<li>
<p>如果没重定位表，按ImageBase申请，申请不到就退出程序</p>
<blockquote>
<p>如果要内存加载的exe没有重定位表，可以在编译器中修改ManualPELoader.exe运行时的ImageBase，确保要内存加载的exe能申请到它的基址</p>
</blockquote>
</li>
<li>
<p>如果有重定位表</p>
<ul>
<li>先按ImageBase申请</li>
<li>申请不到，则再次申请，让系统决定分配的内存地址</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">AllocateMemoryForPE</span><span class="params">(LPVOID lpFileBuffer, <span class="type">bool</span> hasRelocationTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFileBuffer + ((PIMAGE_DOS_HEADER)lpFileBuffer)-&gt;e_lfanew);</span><br><span class="line">    LPVOID lpImageBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRelocationTable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有重定位表，按ImageBase申请内存</span></span><br><span class="line">        lpImageBuffer = <span class="built_in">VirtualAlloc</span>(</span><br><span class="line">            (LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, <span class="comment">// 指定基址</span></span><br><span class="line">            ntHeaders-&gt;OptionalHeader.SizeOfImage,       <span class="comment">// 映像大小</span></span><br><span class="line">            MEM_COMMIT | MEM_RESERVE,                    <span class="comment">// 内存分配类型</span></span><br><span class="line">            PAGE_READWRITE                               <span class="comment">// 内存保护类型</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!lpImageBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation at ImageBase failed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 有重定位表，先尝试按ImageBase申请内存</span></span><br><span class="line">        lpImageBuffer = <span class="built_in">VirtualAlloc</span>(</span><br><span class="line">            (LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, <span class="comment">// 指定基址</span></span><br><span class="line">            ntHeaders-&gt;OptionalHeader.SizeOfImage,       <span class="comment">// 映像大小</span></span><br><span class="line">            MEM_COMMIT | MEM_RESERVE,                    <span class="comment">// 内存分配类型</span></span><br><span class="line">            PAGE_READWRITE                               <span class="comment">// 内存保护类型</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!lpImageBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果按ImageBase申请失败，尝试任意位置申请内存</span></span><br><span class="line">            lpImageBuffer = <span class="built_in">VirtualAlloc</span>(</span><br><span class="line">                <span class="literal">NULL</span>,                                    <span class="comment">// 让系统决定分配内存的地址</span></span><br><span class="line">                ntHeaders-&gt;OptionalHeader.SizeOfImage,   <span class="comment">// 映像大小</span></span><br><span class="line">                MEM_COMMIT | MEM_RESERVE,                <span class="comment">// 内存分配类型</span></span><br><span class="line">                PAGE_READWRITE                           <span class="comment">// 内存保护类型</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (!lpImageBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lpImageBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-将pe文件拉伸到内存空间中"><a class="markdownIt-Anchor" href="#5-将pe文件拉伸到内存空间中"></a> 5. 将PE文件拉伸到内存空间中</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CopyPEToMemory</span><span class="params">(LPVOID lpFileBuffer, LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Copying PE headers and sections to allocated memory...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> dosHeader = (PIMAGE_DOS_HEADER)lpFileBuffer;</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFileBuffer + dosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">auto</span> sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)ntHeaders + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SizeOfHeaders直接对拷</span></span><br><span class="line">    <span class="built_in">memcpy</span>(lpImageBuffer, lpFileBuffer, ntHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">    <span class="comment">//从节.PointerToRawData拷节.SizeOfRawData到  -&gt;  节.VirtualAddress</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((LPVOID)((DWORD)lpImageBuffer + sectionHeader[i].VirtualAddress),</span><br><span class="line">            (LPVOID)((DWORD)lpFileBuffer + sectionHeader[i].PointerToRawData),</span><br><span class="line">            sectionHeader[i].SizeOfRawData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] PE headers and sections copied successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-修复重定位数据"><a class="markdownIt-Anchor" href="#6-修复重定位数据"></a> 6. 修复重定位数据</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FixRelocations</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Fixing relocations...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    DWORD dwDelta = (DWORD)lpImageBuffer - ntHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="keyword">if</span> (dwDelta == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] No relocations needed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> pReloc = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)lpImageBuffer +</span><br><span class="line">        ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pReloc-&gt;VirtualAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pTypeOffset = (PWORD)((DWORD)pReloc + <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION));                   <span class="comment">//TypeOffset数组的指针</span></span><br><span class="line">        DWORD dwRelocCount = (pReloc-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(WORD);  <span class="comment">//项数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dwRelocCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD wType = pTypeOffset[i] &gt;&gt; <span class="number">12</span>;         <span class="comment">//高4位是类型</span></span><br><span class="line">            DWORD wOffset = pTypeOffset[i] &amp; <span class="number">0x0FFF</span>;    <span class="comment">//低12位是偏移</span></span><br><span class="line">            <span class="keyword">if</span> (wType == IMAGE_REL_BASED_HIGHLOW)       <span class="comment">//对于 HIGHLOW 类型是数据，进行修正</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//修正数据</span></span><br><span class="line">                <span class="keyword">auto</span> addressToFix = (PDWORD)((DWORD)lpImageBuffer + pReloc-&gt;VirtualAddress + wOffset);</span><br><span class="line">                *addressToFix += dwDelta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pReloc + pReloc-&gt;SizeOfBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Relocations fixed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-修正iat表"><a class="markdownIt-Anchor" href="#7-修正iat表"></a> 7. 修正IAT表</h3>
<p>对于每一张导入表所描述的dll，先用GetModuleHandleA看是否已加载这个dll，如果未加载，则用LoadLibraryA加载这个dll。然后，根据IAT表表项是序号方式还是名字方式导入，用GetProcAddress得到导入函数的地址，修正IAT表表项</p>
<blockquote>
<p>假设test.exe导入表描述了需要加载A.dll，B.dll和C.dll。而A.dll的导入表描述了需要加载a1.dll，a2.dll，B.dll的导入表描述了需要加载a1.dll，b1.dll。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test.exe  </span><br><span class="line">    ├── A.dll</span><br><span class="line">    │   ├── a1.dll</span><br><span class="line">    │   └── a2.dll</span><br><span class="line">    ├── B.dll</span><br><span class="line">    │   ├── a1.dll</span><br><span class="line">    │   └── b1.dll</span><br><span class="line">    └── C.dll    </span><br></pre></td></tr></table></figure>
<p>我们用系统的LoadLibraryA来加载A.dll，系统这个api会帮我们处理好A.dll它还需要加载的dll的问题，也就是说，系统会处理递归加载的问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RepairIAT</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Repairing Import Address Table...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    DWORD importTableRVA = ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line">    <span class="keyword">if</span> (!importTableRVA)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] No import table.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpImageBuffer + importTableRVA);</span><br><span class="line">    <span class="keyword">while</span> (importDescriptor-&gt;Name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* dllName = (<span class="type">const</span> <span class="type">char</span>*)((DWORD)lpImageBuffer + importDescriptor-&gt;Name);</span><br><span class="line">        HMODULE hModule = <span class="built_in">GetModuleHandleA</span>(dllName);                <span class="comment">//如果这个dll已加载过</span></span><br><span class="line">        <span class="keyword">if</span> (hModule == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hModule = <span class="built_in">LoadLibraryA</span>(dllName);</span><br><span class="line">            <span class="keyword">if</span> (hModule == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[-] LoadLibrary failed for %s.\n&quot;</span>, dllName);</span><br><span class="line">                importDescriptor++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> thunkINT = (PDWORD)((DWORD)lpImageBuffer + importDescriptor-&gt;OriginalFirstThunk);</span><br><span class="line">        <span class="keyword">auto</span> thunkIAT = (PDWORD)((DWORD)lpImageBuffer + importDescriptor-&gt;FirstThunk);</span><br><span class="line">        <span class="keyword">while</span> (*thunkINT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IMAGE_SNAP_BY_ORDINAL</span>(*thunkINT))       <span class="comment">//最高位为1，序号方式输入</span></span><br><span class="line">            &#123;</span><br><span class="line">                *thunkIAT = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="built_in">LPCSTR</span>(*thunkINT &amp; <span class="number">0x7fff</span>));</span><br><span class="line">                <span class="keyword">if</span> (!*thunkIAT)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[-] GetProcAddress failed for 0x%08X in %s.\n&quot;</span>, *thunkINT &amp; <span class="number">0x7fff</span>, dllName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                       <span class="comment">//最高位为0，函数名方式输入</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> importByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)lpImageBuffer + *thunkINT);</span><br><span class="line">                *thunkIAT = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, importByName-&gt;Name);</span><br><span class="line">                <span class="keyword">if</span> (!*thunkIAT)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[-] GetProcAddress failed for %s in %s.\n&quot;</span>, importByName-&gt;Name, dllName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            thunkINT++;</span><br><span class="line">            thunkIAT++;</span><br><span class="line">        &#125;</span><br><span class="line">        importDescriptor++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Import Address Table repaired.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-更新imagebase"><a class="markdownIt-Anchor" href="#8-更新imagebase"></a> 8. 更新ImageBase</h3>
<p>将ImageBase更新为此时PE实际加载的基址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateImageBase</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Updating ImageBase in PE headers...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    ntHeaders-&gt;OptionalHeader.ImageBase = (DWORD)lpImageBuffer;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ImageBase updated.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-修改内存页属性"><a class="markdownIt-Anchor" href="#9-修改内存页属性"></a> 9. 修改内存页属性</h3>
<p>内存页由这三个方面任意组合：可读，可写，可执行。</p>
<p>根据节表.Characteristics字段确定是否可读、可写、可执行。内存页至少是可读的，以下是具体的组合情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">可读</span><br><span class="line">├── 可执行</span><br><span class="line">│   ├── 可写</span><br><span class="line">│   │   └── 可读可写可执行（PAGE_EXECUTE_READWRITE）</span><br><span class="line">│   └── 不可写</span><br><span class="line">│       └── 可读可执行（PAGE_EXECUTE_READ）</span><br><span class="line">└── 不可执行</span><br><span class="line">    ├── 可写</span><br><span class="line">    │   └── 可读可写（PAGE_READWRITE）</span><br><span class="line">    └── 不可写</span><br><span class="line">        └── 可读（PAGE_READONLY）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMemoryPermissions</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Setting memory permissions...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">auto</span> sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)ntHeaders + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD oldProtect;</span><br><span class="line">        DWORD newProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_EXECUTE)   <span class="comment">//可执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            newProtect = (sectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_WRITE) ? PAGE_EXECUTE_READWRITE : PAGE_EXECUTE_READ; <span class="comment">//还可写：PAGE_EXECUTE_READWRITE</span></span><br><span class="line">        &#125;                                                                                                                       <span class="comment">//不可写：PAGE_EXECUTE_READ可执行可读</span></span><br><span class="line">        <span class="keyword">else</span>                                                            <span class="comment">//不可执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            newProtect = (sectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_WRITE) ? PAGE_READWRITE : PAGE_READONLY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD)lpImageBuffer + sectionHeader[i].VirtualAddress), sectionHeader[i].Misc.VirtualSize, newProtect, &amp;oldProtect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Memory permissions set.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-跳转到入口点"><a class="markdownIt-Anchor" href="#10-跳转到入口点"></a> 10. 跳转到入口点</h3>
<p>根据<code>FileHeader.Characteristics &amp; IMAGE_FILE_DLL</code>判断它是dll还是exe</p>
<ul>
<li>如果是dll，用dllmain函数指针调用dllmain方法，传递DLL_PROCESS_ATTACH参数</li>
<li>如果是exe，用mian函数指针执行main方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">JumpToEntryPoint</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    DWORD entryPoint = ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">    DWORD imageBase = (DWORD)lpImageBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ntHeaders-&gt;FileHeader.Characteristics &amp; IMAGE_FILE_DLL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是DLL</span></span><br><span class="line">        <span class="keyword">using</span> DllEntryProc = <span class="built_in">BOOL</span>(WINAPI*)(HINSTANCE, DWORD, LPVOID);</span><br><span class="line">        <span class="keyword">auto</span> dllMain = (DllEntryProc)(imageBase + entryPoint);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Calling DllMain at: 0x%08X\n&quot;</span>, imageBase + entryPoint);</span><br><span class="line">        <span class="built_in">dllMain</span>((HINSTANCE)lpImageBuffer, DLL_PROCESS_ATTACH, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] DllMain called successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是EXE</span></span><br><span class="line">        <span class="keyword">using</span> ExeEntryProc = <span class="built_in">int</span>(WINAPI*)();</span><br><span class="line">        <span class="keyword">auto</span> exeMain = (ExeEntryProc)(imageBase + entryPoint);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Calling ExeMain at: 0x%08X\n&quot;</span>, imageBase + entryPoint);</span><br><span class="line">        <span class="built_in">exeMain</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] ExeMain called successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h3>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>完整代码</span></summary><div class="body"><figure class="highlight cpp"><figcaption><span>ManualPELoader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">ReadPEFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ValidatePEFile</span><span class="params">(LPVOID lpFileBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HasRelocationTable</span><span class="params">(LPVOID lpFileBuffer)</span></span>;</span><br><span class="line"><span class="function">LPVOID <span class="title">AllocateMemoryForPE</span><span class="params">(LPVOID lpFileBuffer, <span class="type">bool</span> hasRelocationTable)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CopyPEToMemory</span><span class="params">(LPVOID lpFileBuffer, LPVOID lpImageBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FixRelocations</span><span class="params">(LPVOID lpImageBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RepairIAT</span><span class="params">(LPVOID lpImageBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateImageBase</span><span class="params">(LPVOID lpImageBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMemoryPermissions</span><span class="params">(LPVOID lpImageBuffer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JumpToEntryPoint</span><span class="params">(LPVOID lpImageBuffer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1: Read PE file into memory</span></span><br><span class="line">    <span class="comment">//const char* peFilePath = &quot;D:\\005_Codefield\\VS2019\\ManualPELoader\\Debug\\TestDll.dll&quot;;          //测试dll   ok</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* peFilePath = <span class="string">&quot;D:\\005_Codefield\\VS2019\\ManualPELoader\\Debug\\TestExe.exe&quot;</span>;           <span class="comment">//测试exe   ok</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">//const char* peFilePath = &quot;E:\\_Reversing\\IDA Pro\\IDA_Pro_v7.5_Portable\\ida.exe&quot;;</span></span><br><span class="line">    <span class="comment">//const char* peFilePath = &quot;E:\\_Reversing\\snapshot_2024-03-19_14-17\\release\\x32\\x32dbg.exe&quot;;</span></span><br><span class="line"></span><br><span class="line">    LPVOID lpFileBuffer = <span class="built_in">ReadPEFile</span>(peFilePath);</span><br><span class="line">    <span class="keyword">if</span> (!lpFileBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to read PE file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Validate PE file</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ValidatePEFile</span>(lpFileBuffer))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Invalid PE file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Check for relocation table</span></span><br><span class="line">    <span class="type">bool</span> hasRelocationTable = <span class="built_in">HasRelocationTable</span>(lpFileBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: Allocate memory</span></span><br><span class="line">    LPVOID lpImageBuffer = <span class="built_in">AllocateMemoryForPE</span>(lpFileBuffer, hasRelocationTable);</span><br><span class="line">    <span class="keyword">if</span> (!lpImageBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5: Copy PE file to allocated memory</span></span><br><span class="line">    <span class="built_in">CopyPEToMemory</span>(lpFileBuffer, lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6: Fix relocations</span></span><br><span class="line">    <span class="built_in">FixRelocations</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 7: Repair IAT</span></span><br><span class="line">    <span class="built_in">RepairIAT</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 8: Update ImageBase</span></span><br><span class="line">    <span class="built_in">UpdateImageBase</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 9: Set memory permissions</span></span><br><span class="line">    <span class="built_in">SetMemoryPermissions</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 10: Jump to entry point</span></span><br><span class="line">    <span class="built_in">JumpToEntryPoint</span>(lpImageBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">ReadPEFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Reading PE file: %s\n&quot;</span>, filePath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(</span><br><span class="line">        filePath,             <span class="comment">// 文件路径</span></span><br><span class="line">        GENERIC_READ,         <span class="comment">// 以只读方式打开文件</span></span><br><span class="line">        FILE_SHARE_READ,      <span class="comment">// 允许其他进程读取文件</span></span><br><span class="line">        <span class="literal">NULL</span>,                 <span class="comment">// 无安全属性</span></span><br><span class="line">        OPEN_EXISTING,        <span class="comment">// 打开现有文件</span></span><br><span class="line">        FILE_ATTRIBUTE_NORMAL,<span class="comment">// 文件为普通属性</span></span><br><span class="line">        <span class="literal">NULL</span>                  <span class="comment">// 无模板文件句柄</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] CreateFile failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwFileSize == INVALID_FILE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] GetFileSize failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">    LPVOID lpFileBuffer = <span class="built_in">VirtualAlloc</span>(</span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// 让系统决定分配内存的地址</span></span><br><span class="line">        dwFileSize,          <span class="comment">// 分配文件大小的内存空间</span></span><br><span class="line">        MEM_RESERVE | MEM_COMMIT, <span class="comment">// 保留并提交内存</span></span><br><span class="line">        PAGE_READWRITE       <span class="comment">// 读写权限</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!lpFileBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] VirtualAlloc failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容到内存</span></span><br><span class="line">    DWORD dwBytesRead;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(</span><br><span class="line">        hFile,                <span class="comment">// 文件句柄</span></span><br><span class="line">        lpFileBuffer,         <span class="comment">// 目标缓冲区地址</span></span><br><span class="line">        dwFileSize,           <span class="comment">// 要读取的字节数</span></span><br><span class="line">        &amp;dwBytesRead,         <span class="comment">// 实际读取的字节数</span></span><br><span class="line">        <span class="literal">NULL</span>                  <span class="comment">// 不使用重叠I/O</span></span><br><span class="line">    ) || dwBytesRead != dwFileSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] ReadFile failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">VirtualFree</span>(lpFileBuffer, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] PE file read successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> lpFileBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ValidatePEFile</span><span class="params">(LPVOID lpFileBuffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)lpFileBuffer;</span><br><span class="line">    <span class="keyword">if</span> (dosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Invalid DOS signature.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFileBuffer + dosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (ntHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Invalid NT signature.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HasRelocationTable</span><span class="params">(LPVOID lpFileBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Checking for relocation table...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFileBuffer + ((PIMAGE_DOS_HEADER)lpFileBuffer)-&gt;e_lfanew);</span><br><span class="line">    <span class="type">bool</span> hasReloc = ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Relocation table %s found.\n&quot;</span>, hasReloc ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> hasReloc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">AllocateMemoryForPE</span><span class="params">(LPVOID lpFileBuffer, <span class="type">bool</span> hasRelocationTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFileBuffer + ((PIMAGE_DOS_HEADER)lpFileBuffer)-&gt;e_lfanew);</span><br><span class="line">    LPVOID lpImageBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRelocationTable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有重定位表，按ImageBase申请内存</span></span><br><span class="line">        lpImageBuffer = <span class="built_in">VirtualAlloc</span>(</span><br><span class="line">            (LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, <span class="comment">// 指定基址</span></span><br><span class="line">            ntHeaders-&gt;OptionalHeader.SizeOfImage,       <span class="comment">// 映像大小</span></span><br><span class="line">            MEM_COMMIT | MEM_RESERVE,                    <span class="comment">// 内存分配类型</span></span><br><span class="line">            PAGE_READWRITE                               <span class="comment">// 内存保护类型</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!lpImageBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation at ImageBase failed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 有重定位表，先尝试按ImageBase申请内存</span></span><br><span class="line">        lpImageBuffer = <span class="built_in">VirtualAlloc</span>(</span><br><span class="line">            (LPVOID)ntHeaders-&gt;OptionalHeader.ImageBase, <span class="comment">// 指定基址</span></span><br><span class="line">            ntHeaders-&gt;OptionalHeader.SizeOfImage,       <span class="comment">// 映像大小</span></span><br><span class="line">            MEM_COMMIT | MEM_RESERVE,                    <span class="comment">// 内存分配类型</span></span><br><span class="line">            PAGE_READWRITE                               <span class="comment">// 内存保护类型</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!lpImageBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果按ImageBase申请失败，尝试任意位置申请内存</span></span><br><span class="line">            lpImageBuffer = <span class="built_in">VirtualAlloc</span>(</span><br><span class="line">                <span class="literal">NULL</span>,                                    <span class="comment">// 让系统决定分配内存的地址</span></span><br><span class="line">                ntHeaders-&gt;OptionalHeader.SizeOfImage,   <span class="comment">// 映像大小</span></span><br><span class="line">                MEM_COMMIT | MEM_RESERVE,                <span class="comment">// 内存分配类型</span></span><br><span class="line">                PAGE_READWRITE                           <span class="comment">// 内存保护类型</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (!lpImageBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lpImageBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CopyPEToMemory</span><span class="params">(LPVOID lpFileBuffer, LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Copying PE headers and sections to allocated memory...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> dosHeader = (PIMAGE_DOS_HEADER)lpFileBuffer;</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpFileBuffer + dosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">auto</span> sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)ntHeaders + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SizeOfHeaders直接对拷</span></span><br><span class="line">    <span class="built_in">memcpy</span>(lpImageBuffer, lpFileBuffer, ntHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">    <span class="comment">//从节.PointerToRawData拷节.SizeOfRawData到  -&gt;  节.VirtualAddress</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((LPVOID)((DWORD)lpImageBuffer + sectionHeader[i].VirtualAddress),</span><br><span class="line">            (LPVOID)((DWORD)lpFileBuffer + sectionHeader[i].PointerToRawData),</span><br><span class="line">            sectionHeader[i].SizeOfRawData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] PE headers and sections copied successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FixRelocations</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Fixing relocations...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    DWORD dwDelta = (DWORD)lpImageBuffer - ntHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    <span class="keyword">if</span> (dwDelta == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] No relocations needed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> pReloc = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)lpImageBuffer +</span><br><span class="line">        ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pReloc-&gt;VirtualAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pTypeOffset = (PWORD)((DWORD)pReloc + <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION));                   <span class="comment">//TypeOffset数组的指针</span></span><br><span class="line">        DWORD dwRelocCount = (pReloc-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(WORD);  <span class="comment">//项数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dwRelocCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD wType = pTypeOffset[i] &gt;&gt; <span class="number">12</span>;         <span class="comment">//高4位是类型</span></span><br><span class="line">            DWORD wOffset = pTypeOffset[i] &amp; <span class="number">0x0FFF</span>;    <span class="comment">//低12位是偏移</span></span><br><span class="line">            <span class="keyword">if</span> (wType == IMAGE_REL_BASED_HIGHLOW)       <span class="comment">//对于 HIGHLOW 类型是数据，进行修正</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//修正数据</span></span><br><span class="line">                <span class="keyword">auto</span> addressToFix = (PDWORD)((DWORD)lpImageBuffer + pReloc-&gt;VirtualAddress + wOffset);</span><br><span class="line">                *addressToFix += dwDelta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pReloc + pReloc-&gt;SizeOfBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Relocations fixed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RepairIAT</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Repairing Import Address Table...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    DWORD importTableRVA = ntHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line">    <span class="keyword">if</span> (!importTableRVA)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] No import table.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpImageBuffer + importTableRVA);</span><br><span class="line">    <span class="keyword">while</span> (importDescriptor-&gt;Name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* dllName = (<span class="type">const</span> <span class="type">char</span>*)((DWORD)lpImageBuffer + importDescriptor-&gt;Name);</span><br><span class="line">        HMODULE hModule = <span class="built_in">GetModuleHandleA</span>(dllName);                <span class="comment">//如果这个dll已加载过</span></span><br><span class="line">        <span class="keyword">if</span> (hModule == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hModule = <span class="built_in">LoadLibraryA</span>(dllName);</span><br><span class="line">            <span class="keyword">if</span> (hModule == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[-] LoadLibrary failed for %s.\n&quot;</span>, dllName);</span><br><span class="line">                importDescriptor++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> thunkINT = (PDWORD)((DWORD)lpImageBuffer + importDescriptor-&gt;OriginalFirstThunk);</span><br><span class="line">        <span class="keyword">auto</span> thunkIAT = (PDWORD)((DWORD)lpImageBuffer + importDescriptor-&gt;FirstThunk);</span><br><span class="line">        <span class="keyword">while</span> (*thunkINT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IMAGE_SNAP_BY_ORDINAL</span>(*thunkINT))       <span class="comment">//最高位为1，序号方式输入</span></span><br><span class="line">            &#123;</span><br><span class="line">                *thunkIAT = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="built_in">LPCSTR</span>(*thunkINT &amp; <span class="number">0x7fff</span>));</span><br><span class="line">                <span class="keyword">if</span> (!*thunkIAT)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[-] GetProcAddress failed for 0x%08X in %s.\n&quot;</span>, *thunkINT &amp; <span class="number">0x7fff</span>, dllName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                       <span class="comment">//最高位为0，函数名方式输入</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> importByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)lpImageBuffer + *thunkINT);</span><br><span class="line">                *thunkIAT = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, importByName-&gt;Name);</span><br><span class="line">                <span class="keyword">if</span> (!*thunkIAT)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[-] GetProcAddress failed for %s in %s.\n&quot;</span>, importByName-&gt;Name, dllName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            thunkINT++;</span><br><span class="line">            thunkIAT++;</span><br><span class="line">        &#125;</span><br><span class="line">        importDescriptor++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Import Address Table repaired.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateImageBase</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Updating ImageBase in PE headers...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    ntHeaders-&gt;OptionalHeader.ImageBase = (DWORD)lpImageBuffer;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ImageBase updated.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMemoryPermissions</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Setting memory permissions...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">auto</span> sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)ntHeaders + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD oldProtect;</span><br><span class="line">        DWORD newProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_EXECUTE)   <span class="comment">//可执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            newProtect = (sectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_WRITE) ? PAGE_EXECUTE_READWRITE : PAGE_EXECUTE_READ; <span class="comment">//还可写：PAGE_EXECUTE_READWRITE</span></span><br><span class="line">        &#125;                                                                                                                       <span class="comment">//不可写：PAGE_EXECUTE_READ可执行可读</span></span><br><span class="line">        <span class="keyword">else</span>                                                            <span class="comment">//不可执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            newProtect = (sectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_WRITE) ? PAGE_READWRITE : PAGE_READONLY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD)lpImageBuffer + sectionHeader[i].VirtualAddress), sectionHeader[i].Misc.VirtualSize, newProtect, &amp;oldProtect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Memory permissions set.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JumpToEntryPoint</span><span class="params">(LPVOID lpImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ntHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpImageBuffer + ((PIMAGE_DOS_HEADER)lpImageBuffer)-&gt;e_lfanew);</span><br><span class="line">    DWORD entryPoint = ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">    DWORD imageBase = (DWORD)lpImageBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ntHeaders-&gt;FileHeader.Characteristics &amp; IMAGE_FILE_DLL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是DLL</span></span><br><span class="line">        <span class="keyword">using</span> DllEntryProc = <span class="built_in">BOOL</span>(WINAPI*)(HINSTANCE, DWORD, LPVOID);</span><br><span class="line">        <span class="keyword">auto</span> dllMain = (DllEntryProc)(imageBase + entryPoint);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Calling DllMain at: 0x%08X\n&quot;</span>, imageBase + entryPoint);</span><br><span class="line">        <span class="built_in">dllMain</span>((HINSTANCE)lpImageBuffer, DLL_PROCESS_ATTACH, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] DllMain called successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是EXE</span></span><br><span class="line">        <span class="keyword">using</span> ExeEntryProc = <span class="built_in">int</span>(WINAPI*)();</span><br><span class="line">        <span class="keyword">auto</span> exeMain = (ExeEntryProc)(imageBase + entryPoint);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Calling ExeMain at: 0x%08X\n&quot;</span>, imageBase + entryPoint);</span><br><span class="line">        <span class="built_in">exeMain</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] ExeMain called successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details></div>
<h2 id="执行演示"><a class="markdownIt-Anchor" href="#执行演示"></a> 执行演示</h2>
<div class="tag-plugin tabs" align="center"id="tab_1"><div class="nav-tabs"><div class="tab active"><a href="#tab_1-1">示例exe</a></div><div class="tab"><a href="#tab_1-2">示例dll</a></div><div class="tab"><a href="#tab_1-3">其他exe</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_1-1"><figure class="highlight cpp"><figcaption><span>main函数中的PE文件路径</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* peFilePath = <span class="string">&quot;D:\\005_Codefield\\VS2019\\ManualPELoader\\Debug\\TestExe.exe&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>手动拉伸的exe名为TestExe.exe，在任务管理器中只能看到ManualPELoader.exe的运行，看不到TestExe.exe。TestExe.exe此时是ManualPELoader.exe进程中的“<strong>数据</strong>”</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%8D%E5%B0%84%E5%BC%8F%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A0%E8%BD%BD/image-20240610212556861.png" alt="image-20240610212556861" /></p>
<figure class="highlight cpp"><figcaption><span>示例exe的代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;This is a exe to be tested&quot;</span>, <span class="string">&quot;123&quot;</span>, MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_1-2"><figure class="highlight cpp"><figcaption><span>main函数中的PE文件路径</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* peFilePath = <span class="string">&quot;D:\\005_Codefield\\VS2019\\ManualPELoader\\Debug\\TestDll.dll&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%8D%E5%B0%84%E5%BC%8F%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A0%E8%BD%BD/image-20240610212029813.png" alt="image-20240610212029813" /></p>
<figure class="highlight cpp"><figcaption><span>示例dll的代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Init&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Init&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_1-3"><p>找了其他两个x86的exe想内存加载试一下，但是有问题，这里记录下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const char* peFilePath = &quot;E:\\_Reversing\\IDA Pro\\IDA_Pro_v7.5_Portable\\ida.exe&quot;;</span></span><br><span class="line"><span class="comment">//const char* peFilePath = &quot;E:\\_Reversing\\snapshot_2024-03-19_14-17\\release\\x32\\x32dbg.exe&quot;;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>LoadLibraryA加载dll的路径问题</li>
</ol>
<p>像上面的TestExe.exe，它没有用到自己当前目录的其他dll，因此能成功进行内存加载。但是像ida.exe这样的程序，它在它自身目录下有需要加载的dll。如果我直接在VS的编译文件夹下执行ManualPELoader.exe，试图内存加载ida.exe，在进行IAT表修复那一步，用LoadLibraryA加载ida程序中导入表描述的dll时，LoadLibraryA的查找路径是ManualPELoader.exe的路径，然后是系统路径。</p>
<blockquote>
<p>LoadLibraryA可以给个绝对路径，但如果传参给的是绝对路径，它就只会在给的绝对路径下进行查找了</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\ida.exe + 其他dll</span><br><span class="line"></span><br><span class="line">D:\ManualPELoader.exe</span><br><span class="line"></span><br><span class="line">在D:\下运行ManualPELoader.exe，ida.exe做IAT表修复时用LoadLibraryA加载ida导入表中描述的dll时候查找顺序是：</span><br><span class="line">    <span class="number">1</span>、D:\</span><br><span class="line">    <span class="number">2</span>、系统目录</span><br><span class="line"></span><br><span class="line">正确的应该是：</span><br><span class="line">    <span class="number">1</span>、C:\（ida.exe所在目录）</span><br><span class="line">    <span class="number">2</span>、系统目录</span><br><span class="line"></span><br><span class="line">解决办法：将ManualPELoader.exe拷到与ida.exe同一目录下执行</span><br><span class="line"></span><br><span class="line">这样的话，只能用调试器调试执行，不能用VS调试执行了</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>其他问题</li>
</ol>
<p>内存加载加载mfc的dll会有问题，因为内存加载还是有别于系统加载，当跳到PE入口执行时会做检查，如果没有这个东西，程序会抛异常</p>
<p>这里先做记录，后续遇到再回来解决，参考资料</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-280791-1.htm">修复内存加载mfc dll的Bug，x64</a><br />
<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-203236.htm">内存加载带mfc 的dll失败问题</a><br />
<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-207155.htm">关于内存加载MFC DLL问题研究与解决</a></p>
<blockquote>
<p>这是误打误撞，还是能作为一种反内存加载的技术呢？</p>
</blockquote>
<blockquote>
<p>上面测的exe用MemoryModule也试了，一样的报错，所以放心了，我的代码没问题hhhh</p>
</blockquote></div></div></div>
<h2 id="未来可以继续优化完善的"><a class="markdownIt-Anchor" href="#未来可以继续优化完善的"></a> 未来可以继续优化完善的</h2>
<ol>
<li>
<p>x64的支持</p>
<ul>
<li>重定位表判断要改下，PE32+有些字段有变化，还有哪些地方（？）<br />
可以参考<a target="_blank" rel="noopener" href="http://www.rohitab.com/discuss/topic/44186-c-pe-loader-64-and-32-crashes-some-programs/">c++ pe loader 64 and 32 crashes some programs</a></li>
</ul>
</li>
<li>
<p>更细致地处理区块的节属性</p>
<ul>
<li>
<p>处理可丢弃的区块IMAGE_SCN_MEM_DISCARDABLE</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考MemoryModule项目<span class="function"><span class="type">static</span> BOOL <span class="title">FinalizeSections</span><span class="params">(PMEMORYMODULE <span class="keyword">module</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置区块内存页属性时，考虑不经过缓存的区块IMAGE_SCN_MEM_NOT_CACHED</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考MemoryModule项目<span class="function"><span class="type">static</span> BOOL <span class="title">FinalizeSection</span><span class="params">(PMEMORYMODULE <span class="keyword">module</span>, PSECTIONFINALIZEDATA sectionData)</span>函数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>执行TLS回调函数</p>
<ul>
<li>设置完区块内存页属性后，执行TLS回调函数，因为TLS回调函数先于main函数执行</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考MemoryModule项目<span class="function"><span class="type">static</span> BOOL <span class="title">ExecuteTLS</span><span class="params">(PMEMORYMODULE <span class="keyword">module</span>)</span>函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>资源的释放</p>
<ul>
<li>上面的代码应该是有部分申请的资源没做释放处理，不够细致。如果有需要，可以将代码封装成C++的类，以便于资源管理</li>
</ul>
</li>
<li>
<p>没有卸载MemoryModule的功能</p>
<ul>
<li>加个VirtualFree，很快的</li>
<li>但是如何标记这块内存是自己内存加载的内存？MemoryModule项目就是用了一个HMEMORYMODULE结构体来描述这个信息</li>
</ul>
</li>
<li>
<p>内存加载dll后，理论上要返回这个模块的基址，并提供一个自实现的GetProcAddress用于查询导出函数</p>
<ul>
<li>用系统的GetProcAddress就能查（应该可以，没试）</li>
<li>自己实现的话，其实就是对拉伸模块导出表查询的事。<a href="/wiki/PE/%E5%AF%BC%E5%87%BA%E8%A1%A8.html#%E6%9F%A5%E8%A1%A8%E8%BF%87%E7%A8%8B">之前写过的</a>，写过序号方式查询和名字方式查询，将这两个查询合并为一个函数即可</li>
</ul>
</li>
</ol>
<h2 id="memorymodule项目学习记录"><a class="markdownIt-Anchor" href="#memorymodule项目学习记录"></a> MemoryModule项目学习记录</h2>
<p>项目链接<a target="_blank" rel="noopener" href="https://github.com/fancycode/MemoryModule">MemoryModule</a>，配套说明<a target="_blank" rel="noopener" href="https://www.joachim-bauch.de/tutorials/loading-a-dll-from-memory/">Loading a DLL from memory</a></p>
<p>MemoryModule项目代码整体可以分为两部分进行学习</p>
<ol>
<li>将PE文件手工拉伸到内存中，返回一个HMEMORYMODULE供后续使用（可以理解为一个handle句柄）</li>
<li>通过HMEMORYMODULE对“MemoryModule”进行后续使用</li>
</ol>
<h3 id="memoryloadlibrary和memoryloadlibraryex"><a class="markdownIt-Anchor" href="#memoryloadlibrary和memoryloadlibraryex"></a> MemoryLoadLibrary和MemoryLoadLibraryEx</h3>
<p>MemoryModule.h文件前面定义了5个函数指针</p>
<figure class="highlight cpp"><figcaption><span>MemoryModule.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">LPVOID</span><span class="params">(*CustomAllocFunc)</span><span class="params">(LPVOID, SIZE_T, DWORD, DWORD, <span class="type">void</span>*)</span></span>;    <span class="comment">//VirtualAlloc</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*CustomFreeFunc)</span><span class="params">(LPVOID, SIZE_T, DWORD, <span class="type">void</span>*)</span></span>;              <span class="comment">//VirtualFree</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HCUSTOMMODULE</span><span class="params">(*CustomLoadLibraryFunc)</span><span class="params">(LPCSTR, <span class="type">void</span>*)</span></span>;             <span class="comment">//LoadLibraryA</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(*CustomGetProcAddressFunc)</span><span class="params">(HCUSTOMMODULE, LPCSTR, <span class="type">void</span>*)</span></span>; <span class="comment">//GetProcAddress</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CustomFreeLibraryFunc)</span><span class="params">(HCUSTOMMODULE, <span class="type">void</span>*)</span></span>;              <span class="comment">//FreeLibrary</span></span><br></pre></td></tr></table></figure>
<p>当使用MemoryLoadLibrary进行内存加载时，内部调用MemoryLoadLibraryEx，此时上面5个函数指针指向系统的API函数VirtualAlloc、VirtualFree、LoadLibraryA、GetProcAddress、FreeLibrary</p>
<figure class="highlight cpp"><figcaption><span>MemoryLoadLibrary函数实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMEMORYMODULE <span class="title">MemoryLoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">void</span>* data,       <span class="comment">//PE文件数据指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> size             <span class="comment">//PE文件数据的大小，size用于函数内部做大小检验用</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MemoryLoadLibraryEx</span>(data, size, MemoryDefaultAlloc, MemoryDefaultFree, MemoryDefaultLoadLibrary, MemoryDefaultGetProcAddress, MemoryDefaultFreeLibrary, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">MemoryDefaultAlloc</span><span class="params">(LPVOID address, SIZE_T size, DWORD allocationType, DWORD protect, <span class="type">void</span>* userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(userdata);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">VirtualAlloc</span>(address, size, allocationType, protect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">MemoryDefaultFree</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType, <span class="type">void</span>* userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(userdata);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">VirtualFree</span>(lpAddress, dwSize, dwFreeType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HCUSTOMMODULE <span class="title">MemoryDefaultLoadLibrary</span><span class="params">(LPCSTR filename, <span class="type">void</span>* userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE result;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(userdata);</span><br><span class="line">    result = <span class="built_in">LoadLibraryA</span>(filename);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (HCUSTOMMODULE)result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FARPROC <span class="title">MemoryDefaultGetProcAddress</span><span class="params">(HCUSTOMMODULE <span class="keyword">module</span>, LPCSTR name, <span class="type">void</span>* userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(userdata);</span><br><span class="line">    <span class="keyword">return</span> (FARPROC)<span class="built_in">GetProcAddress</span>((HMODULE)<span class="keyword">module</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryDefaultFreeLibrary</span><span class="params">(HCUSTOMMODULE <span class="keyword">module</span>, <span class="type">void</span>* userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(userdata);</span><br><span class="line">    <span class="built_in">FreeLibrary</span>((HMODULE)<span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用MemoryLoadLibraryEx来做内存加载，要额外传递6个参数，其中5个是自定义实现的函数。在MemoryModule项目中，没有提供自定义实现的</p>
<p>VirtualAlloc、VirtualFree、LoadLibraryA、GetProcAddress、FreeLibrary，留MemoryLoadLibraryEx估计是为了未来扩展时用。</p>
<figure class="highlight cpp"><figcaption><span>MemoryLoadLibraryEx函数声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMEMORYMODULE <span class="title">MemoryLoadLibraryEx</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">    CustomAllocFunc allocMemory,</span></span></span><br><span class="line"><span class="params"><span class="function">    CustomFreeFunc freeMemory,</span></span></span><br><span class="line"><span class="params"><span class="function">    CustomLoadLibraryFunc loadLibrary,</span></span></span><br><span class="line"><span class="params"><span class="function">    CustomGetProcAddressFunc getProcAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    CustomFreeLibraryFunc freeLibrary,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* userdata)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="hmemorymodule结构体"><a class="markdownIt-Anchor" href="#hmemorymodule结构体"></a> HMEMORYMODULE结构体</h3>
<p>为了描述MemoryModule内存模块更多的信息，用了一个结构体来描述它。比如它的基址，exe入口，是否是dll等信息。使用时可以把它理解为handle来使用。但因为它是用hMemoryModule来使用，导致MemoryModule项目耦合度较高，想改造的话拆代码就比较麻烦。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    PIMAGE_NT_HEADERS headers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* codeBase;</span><br><span class="line">    HCUSTOMMODULE* modules;</span><br><span class="line">    <span class="type">int</span> numModules;</span><br><span class="line">    BOOL initialized;</span><br><span class="line">    BOOL isDLL;</span><br><span class="line">    BOOL isRelocated;</span><br><span class="line">    CustomAllocFunc alloc;</span><br><span class="line">    CustomFreeFunc free;</span><br><span class="line">    CustomLoadLibraryFunc loadLibrary;</span><br><span class="line">    CustomGetProcAddressFunc getProcAddress;</span><br><span class="line">    CustomFreeLibraryFunc freeLibrary;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ExportNameEntry</span>* nameExportsTable;</span><br><span class="line">    <span class="type">void</span>* userdata;</span><br><span class="line">    ExeEntryProc exeEntry;</span><br><span class="line">    DWORD pageSize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    POINTER_LIST* blockedMemory;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; MEMORYMODULE, * PMEMORYMODULE;</span><br></pre></td></tr></table></figure>
<h3 id="核心代码部分memoryloadlibrary"><a class="markdownIt-Anchor" href="#核心代码部分memoryloadlibrary"></a> 核心代码部分（MemoryLoadLibrary）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMEMORYMODULE <span class="title">MemoryLoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">void</span>* data,       <span class="comment">//PE文件数据指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> size             <span class="comment">//PE文件数据的大小，size用于函数内部做大小检验用</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>MemoryLoadLibrary函数中主要流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MemoryLoadLibrary</span><br><span class="line">  <span class="comment">//一些大小，字段，对齐值倍数等的检查</span></span><br><span class="line">  <span class="comment">//获取当前系统页的大小，算对齐用</span></span><br><span class="line">  allocMemory               <span class="comment">//尝试按PE文件的ImageBase申请空间；申请失败就随机申请地址</span></span><br><span class="line">  HeapAlloc                 <span class="comment">//用HeapAlloc申请MEMORYMODULE结构体大小的内存空间，填充相关字段</span></span><br><span class="line">  <span class="comment">//拷贝头部SizeOfHeaders，将实际申请到的基址更新ImageBase；拷贝区段CopySections</span></span><br><span class="line">  PerformBaseRelocation     <span class="comment">//修复重定位数据</span></span><br><span class="line">  BuildImportTable          <span class="comment">//修正IAT表</span></span><br><span class="line">  FinalizeSections          <span class="comment">//处理PE加载后可以丢弃的区块，处理区块中不用经过缓存的数据（节属性为IMAGE_SCN_MEM_NOT_PAGED）</span></span><br><span class="line">  ExecuteTLS                <span class="comment">//执行TLS回调函数</span></span><br><span class="line">  <span class="comment">//指向PE入口</span></span><br><span class="line">    <span class="comment">//（1）如果该PE是dll，以DLL_PROCESS_ATTACH调用dllmain</span></span><br><span class="line">    <span class="comment">// (2) 如果该PE是exe，指向main函数入口（没调用）</span></span><br><span class="line">  <span class="comment">//返回HMEMORYMODULE，供后续使用</span></span><br></pre></td></tr></table></figure>
<h3 id="通过hmemorymodule使用这个内存模块"><a class="markdownIt-Anchor" href="#通过hmemorymodule使用这个内存模块"></a> 通过HMEMORYMODULE使用这个内存模块</h3>
<p>调用MemoryLoadLibrary成功后，得到HMEMORYMODULE，通过它来使用这个内存模块。该项目中提供了如下函数进行使用</p>
<figure class="highlight cpp"><figcaption><span>内存模块是exe</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MemoryCallEntryPoint</span><span class="params">(HMEMORYMODULE)</span></span>;    <span class="comment">//如果该内存模块是exe，调用exe的main函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>自实现的GetProcAddress，获取该MEMORYMODULE中导出表的函数，支持序号和名字查询</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">MemoryGetProcAddress</span><span class="params">(HMEMORYMODULE, LPCSTR)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>资源相关的</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the location of a resource with the specified type and name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">HMEMORYRSRC <span class="title">MemoryFindResource</span><span class="params">(HMEMORYMODULE, LPCTSTR, LPCTSTR)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the location of a resource with the specified type, name and language.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">HMEMORYRSRC <span class="title">MemoryFindResourceEx</span><span class="params">(HMEMORYMODULE, LPCTSTR, LPCTSTR, WORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the size of the resource in bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">DWORD <span class="title">MemorySizeofResource</span><span class="params">(HMEMORYMODULE, HMEMORYRSRC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get a pointer to the contents of the resource.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LPVOID <span class="title">MemoryLoadResource</span><span class="params">(HMEMORYMODULE, HMEMORYRSRC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load a string resource.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MemoryLoadString</span><span class="params">(HMEMORYMODULE, UINT, LPTSTR, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load a string resource with a given language.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MemoryLoadStringEx</span><span class="params">(HMEMORYMODULE, UINT, LPTSTR, <span class="type">int</span>, WORD)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用memorymodule"><a class="markdownIt-Anchor" href="#使用memorymodule"></a> 使用MemoryModule</h3>
<p>将PE文件的lpFileBuffer和大小传给MemoryLoadLibrary进行内存加载</p>
<ul>
<li>如果是dll，内存加载后，通过MemoryGetProcAddress + 函数指针的方式来使用导出表中的函数</li>
<li>如果是exe，内存加载后，通过MemoryCallEntryPoint调用main函数</li>
</ul>
<h3 id="其他方面的学习"><a class="markdownIt-Anchor" href="#其他方面的学习"></a> 其他方面的学习</h3>
<p>MemoryLoadLibrary函数中对于资源的清理使用了goto语句，中途出错则goto到末尾的error进行资源的统一释放</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error:</span><br><span class="line">    <span class="comment">// cleanup</span></span><br><span class="line">    <span class="built_in">MemoryFreeLibrary</span>(result);</span><br></pre></td></tr></table></figure>
<h2 id="参考资源"><a class="markdownIt-Anchor" href="#参考资源"></a> 参考资源</h2>
<table>
<thead>
<tr>
<th>链接🔗</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272091-1.htm">MemoryModule x86x64 内存加载DLL</a></td>
<td>还没看，有东西可供后续深入学习</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.kn0sky.com/?p=37#%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BDdll%E6%89%A7%E8%A1%8C%E6%BC%94%E7%A4%BA">手工模拟PE加载器</a></td>
<td>代码编写时参考了飞师傅的这篇文章</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.joachim-bauch.de/tutorials/loading-a-dll-from-memory/">Loading a DLL from memory</a></td>
<td>MemoryModule项目原理说明，其实写得很详细了</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.ambray.dev/writing-a-windows-loader/">Writing a Windows Loader (Part 1)</a></td>
<td>前言部分参考了这个网站</td>
</tr>
</tbody>
</table>
<p>下面这些是笔者实现后上网再次搜寻资料发现的，对你可能有用，这里记录一下</p>
<table>
<thead>
<tr>
<th>链接🔗</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.cnblogs.com/theseventhson/p/14732937.html">windows：3环自行加载PE文件实现进程隐藏</a></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-858841-1-1.html">PE加载器的简单实现</a></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/potats0/PeLoader">PeLoader</a></td>
<td>可以参考：过程中加一些打印输出，方便观察</td>
</tr>
</tbody>
</table>
<p>更多资料，搜索引擎搜如下关键词</p>
<ul>
<li>PE加载器</li>
<li>PE装配器</li>
<li>PE Loader</li>
</ul>



<div class="article-footer reveal fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">较早文章</div><a href="/posts/e1c55744.html">在Windows窗口程序中新建一个用于输出调试信息的控制台</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body twikoo'>
      

<div id="twikoo_container"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>
    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">wiki</span><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a href="/wiki/tags/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a><a href="/wiki/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a><a href="/wiki/tags/%E5%85%B6%E4%BB%96/">其他</a></div><div class="sitemap-group"><span class="fs14">关于</span><a href="/about/">关于</a></div></div><div class="text"><p>本站由 <a href="/">Misc0101</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0">Stellar 1.25.0</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.25.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".fancybox img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
    function load_twikoo() {
        if (!document.querySelectorAll("#twikoo_container")[0]) return;
        stellar.loadScript('https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js', {defer: true}).then(function () {
            const el = document.getElementById("twikoo_container");
            var path = el.getAttribute('comment_id');
            if (!path) {
                path = decodeURI(window.location.pathname);
            }
            twikoo.init(Object.assign({"js":"https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js","envId":"https://twikooblogcomment-tkkws-projects-20e4cf59.vercel.app"}, {
                el: '#twikoo_container',
                path: path,
            }));
        });
    }

    window.addEventListener('DOMContentLoaded', (event) => {
        load_twikoo();
    });
</script>






<!-- inject -->


  </div>
</body>
</html>
