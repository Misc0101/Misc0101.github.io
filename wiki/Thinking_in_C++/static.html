<!DOCTYPE html>
<html lang='zh-CN'>


<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0" theme-name="Stellar" theme-version="1.25.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Thinking in C++：static - Misc0101</title>

  
    <meta name="description" content="In both C and C++ the keyword static has two basic meanings, which unfortunately often step on each other’s toes:  Static storage  Allocated once at a fixed address; that is, the object is created in">
<meta property="og:type" content="website">
<meta property="og:title" content="static">
<meta property="og:url" content="https://misc0101.github.io/wiki/Thinking_in_C++/static.html">
<meta property="og:site_name" content="Misc0101">
<meta property="og:description" content="In both C and C++ the keyword static has two basic meanings, which unfortunately often step on each other’s toes:  Static storage  Allocated once at a fixed address; that is, the object is created in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/static/image-20200425142233717.png">
<meta property="article:published_time" content="2024-03-04T07:31:00.000Z">
<meta property="article:modified_time" content="2024-03-04T07:31:00.000Z">
<meta property="article:author" content="Misc0101">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://misc0101.github.io/Typora_images/static/image-20200425142233717.png">
  
  
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1.2em" height="1.2em" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有项目</a><a class="title" href="/wiki/Thinking_in_C++/Pointers.html"><div class="main" ff="title">Thinking in C++</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/Thinking_in_C++/" placeholder="在/wiki/Thinking_in_C++/中搜索..."><svg t="1705074644177" class="icon search-icon" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc multi" id="data-toc" collapse="false"><div class="widget-header cap dis-select"><span class="name">Ch8 Constants</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Thinking_in_C++/Pointers.html#start"><span class="toc-text">Pointers</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Thinking_in_C++/Function_arguments&return_values.html"><span class="toc-text">Function arguments & return values</span></a></div></div><div class="widget-header cap dis-select"><span class="name">Ch10 Name Control</span></div><div class="widget-body fs14"><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/Thinking_in_C++/static.html"><span class="toc-text">static</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E8%A1%A5%E5%85%85"><span class="toc-text"> 概念补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-text"> 存储位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text"> 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9Fscoping"><span class="toc-text"> 作用域（Scoping）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5linkage"><span class="toc-text"> 连接(linkage)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern"><span class="toc-text"> extern</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-elements-in-cc"><span class="toc-text"> static elements in C&#x2F;C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static-free-functions"><span class="toc-text"> Static free functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-local-variables"><span class="toc-text"> static local variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#example"><span class="toc-text"> Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#confusion"><span class="toc-text"> Confusion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text"> 静态对象的构造和析构调用顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-initialization-dependency"><span class="toc-text"> Static initialization dependency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-members-in-c"><span class="toc-text"> Static members in C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static-members"><span class="toc-text"> Static members</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-member-function"><span class="toc-text"> Static member function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text"> 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text"> 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text"> 分析方法</span></a></li></ol></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Thinking_in_C++/static%EF%BC%88%E5%BA%9F%E5%BC%83%E8%8D%89%E7%A8%BF%EF%BC%89.html"><span class="toc-text">static（废弃草稿）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Thinking_in_C++/Namespaces.html"><span class="toc-text">Namespaces</span></a></div></div><div class="widget-header cap dis-select"><span class="name">Ch11 References&the Copy-Constructor</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Thinking_in_C++/%E5%BC%95%E7%94%A8I-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html"><span class="toc-text">引用I-基础概念</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Thinking_in_C++/%E5%BC%95%E7%94%A8II.html"><span class="toc-text">引用II</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Thinking_in_C++/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0I.html"><span class="toc-text">拷贝构造I</span></a></div></div></widget>

<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多：计算机基础</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/Assembly_Language/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8_%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99.html"><span class="title">汇编语言</span><span class="excerpt">x86汇编笔记：以滴水三期_汇编语言课程为框架，《汇编语言4th-王爽》和《汇编语言-基于x86处理器-第七版》为补充。</span></a><a class="item wiki" href="/wiki/C++/%E5%B0%81%E8%A3%85%E5%92%8Cthis%E6%8C%87%E9%92%88.html"><span class="title">C++</span><span class="excerpt">滴水三期_C++语言笔记，C++能做的C都能做，只不过如果使用C++，可以节省很多时间，因为编译器帮编程人员做了很多工作，让编程人员省事。学习的目标：相对于C，编译器替我们做了哪些工作。</span></a><a class="item wiki" href="/wiki/C/%E5%87%BD%E6%95%B0.html"><span class="title">C</span><span class="excerpt">滴水三期_C语言笔记，以逆向角度看待和学习C语言，精彩点：堆栈图与指针。</span></a><a class="item wiki" href="/wiki/Modern_C++/%E7%B1%BB.html"><span class="title">Modern C++</span><span class="excerpt">C++98及其之前的C++ 特性称之为traditional C++（传统C++），C++11/14/17/20被称为Modern C++（现代 C++ ）。补充从传统C++“升级”到现代C++的知识。</span></a><a class="item wiki" href="/wiki/Proxy_Protocols/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86_%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8A%80%E6%9C%AF.html"><span class="title">科学上网技术</span><span class="excerpt">从正常网络通信数据包通信过程出发，逐步推导到使用代理协议进行科学上网，随后依次介绍各代理协议ss、trojan、vmess、vless原理与节点搭建，还有相关的工具、技术、概念介绍。</span></a><a class="item wiki" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html"><span class="title">Windows API编程</span><span class="excerpt">滴水三期_win32 api笔记，学习Windows API编程的困难并不在于函数参数参数众多或者英文不好这类表象原因，而是需要从Windows系统的整体知识架构出发来学习这些API，深入理解每个参数背后的含义和背景。如此，未来查阅MSDN时便不再像是看天书。</span></a><a class="item wiki" href="/wiki/representation_and_computation_of_data/%E8%BF%9B%E5%88%B6.html"><span class="title">数据的运算与表示</span><span class="excerpt">滴水三期_进制笔记，学习与理解进制、数据宽度、数的表示、位运算等概念。</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      
  





      


<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">项目</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/Thinking_in_C++/Pointers.html">Thinking in C++</a></div><div id="post-meta">
    <span>更新于&nbsp;<time datetime="2024-03-04T07:31:00.000Z">2024-03-04</time></span>
    </div></div></div>

<article class='md-text content wiki'>
<h1 class="article-title"><span>static</span></h1>
<p>In both C and C++ the keyword <strong>static</strong> has two basic meanings, which unfortunately often step on each other’s toes:</p>
<ol>
<li>Static storage
<ul>
<li><u>Allocated once at a fixed address</u>; that is, the object is created in a special <strong>static data area</strong> rather than on the stack each time a function is called.</li>
</ul>
</li>
<li>Visibility of a name
<ul>
<li><u>Local to a particular translation unit</u> (and local to a class scope in C++, as you will see later). Here, <strong>static</strong> controls the <strong>visibility</strong> of a name, so that name cannot be seen outside the translation unit or class. This also describes the concept of <strong>linkage</strong>, which determines what names the linker will see.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="概念补充"><a class="markdownIt-Anchor" href="#概念补充"></a> 概念补充</h2>
<h3 id="存储位置"><a class="markdownIt-Anchor" href="#存储位置"></a> 存储位置</h3>
<p>变量存放在哪，全局区，栈，堆。</p>
<p>堆：new出来的<br />
全局区：函数地址，全局变量<br />
栈：局部变量</p>
<h3 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h3>
<p>变量所在的内存从分配到释放的这段时间</p>
<h3 id="作用域scoping"><a class="markdownIt-Anchor" href="#作用域scoping"></a> 作用域（Scoping）</h3>
<p>Scoping rules tell you where a variable is valid, where it is created, and where it gets destroyed (i.e., goes out of scope). The scope of a variable extends from the point where it is defined to the first closing brace that matches the closest opening brace before the variable was defined. That is, a scope is defined by its “nearest” set of braces. To illustrate:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C03:Scope.cpp</span></span><br><span class="line"><span class="comment">// How variables are scoped</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> scp1;</span><br><span class="line">  <span class="comment">// scp1 visible here</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// scp1 still visible here</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="type">int</span> scp2;</span><br><span class="line">    <span class="comment">// scp2 visible here</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// scp1 &amp; scp2 still visible here</span></span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">      <span class="type">int</span> scp3;</span><br><span class="line">      <span class="comment">// scp1, scp2 &amp; scp3 visible here</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="comment">// &lt;-- scp3 destroyed here</span></span><br><span class="line">    <span class="comment">// scp3 not available here</span></span><br><span class="line">    <span class="comment">// scp1 &amp; scp2 still visible here</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="comment">// &lt;-- scp2 destroyed here</span></span><br><span class="line">  <span class="comment">// scp3 &amp; scp2 not available here</span></span><br><span class="line">  <span class="comment">// scp1 still visible here</span></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125; <span class="comment">// &lt;-- scp1 destroyed here</span></span><br><span class="line"><span class="comment">///:~ </span></span><br></pre></td></tr></table></figure>
<p>The example above shows when variables are visible and when they are unavailable (that is, when they <em>go out of scope</em>). A variable can be used only when inside its scope. Scopes can be nested, indicated by matched pairs of braces inside other matched pairs of braces. Nesting means that you can access a variable in a scope that encloses the scope you are in. In the example above, the variable <strong>scp1</strong> is available inside all of the other scopes, while <strong>scp3</strong> is available only in the innermost scope.</p>
<h3 id="连接linkage"><a class="markdownIt-Anchor" href="#连接linkage"></a> 连接(linkage)</h3>
<p>In an executing program, an identifier is represented by storage in memory that holds a variable or a compiled function body. Linkage describes this storage as it is seen by the linker. There are two types of linkage: <strong>internal linkage</strong> and <strong>external linkage</strong>.</p>
<ol>
<li>
<p>内部链接（internal linkage）</p>
<ul>
<li>Internal linkage means that storage is created to represent the identifier only for the file being compiled.</li>
<li>内部链接意味着对象或函数只在定义它的编译单元内部可见。这意味着即使其他文件中有相同名称的变量或函数，它们也是不同的，各自在自己的编译单元中独立存在。</li>
</ul>
</li>
<li>
<p>外部链接（External Linkage）</p>
<ul>
<li>
<p>External linkage means that a single piece of storage is created to represent the identifier for all files being compiled. The storage is created once, and the linker must resolve all other references to that storage.</p>
</li>
<li>
<p>外部链接意味着在多个编译单元中可以访问同一个对象或函数。</p>
<p>如果你在一个文件中声明了一个全局变量或函数，你可以在其他文件中访问它，只要你在那些文件中提供了适当的声明。例如，如果你在一个文件中定义了一个函数 <code>void myFunction()</code>，并且在另一个文件中声明了这个函数（通常通过包含一个头文件），那么你可以在第二个文件中调用 <code>myFunction()</code></p>
</li>
<li>
<p>函数之外的所有变量（在C++中除了const）和函数定义默认为外部连接，也可以在定义时使用关键字extern显式指定标识符具有外部连接。但通常情况下我们都是省略了extern。</p>
</li>
</ul>
</li>
</ol>
<p>一般来说，在文件作用域（file scope）的name是external linkage，对所有编译单元可见，比如一个全局的变量和函数名，可以使用<code>static</code>关键字将一个全局的变量/函数改为内部链接（internal linkage）属性</p>
<h3 id="extern"><a class="markdownIt-Anchor" href="#extern"></a> extern</h3>
<p><code>extern</code>主要用于两个方面：声明外部链接的变量或函数，和在某些情况下显式声明函数原型。显式声明函数原型上面提到过了。说下声明外部链接的变量或函数这个用途：</p>
<p>The <strong>extern</strong> keyword has already been briefly described and demonstrated. It tells the compiler that a variable or a function exists, even if the compiler hasn’t yet seen it in the file currently being compiled. This variable or function may be defined in another file or further down in the current file. As an example of the latter:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C03:Forward.cpp</span></span><br><span class="line"><span class="comment">// Forward function &amp; data declarations</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is not actually external, but the </span></span><br><span class="line"><span class="comment">// compiler must be told it exists somewhere:</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i; <span class="comment">// The data definition</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  cout &lt;&lt; i;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
<p>When the compiler encounters the declaration ‘<strong>extern int i</strong>’, it knows that the definition for <strong>i</strong> must exist somewhere as a global variable. When the compiler reaches the definition of <strong>i</strong>, no other declaration is visible, so it knows it has found the same <strong>i</strong> declared earlier in the file. If you were to define <strong>i</strong> as <strong>static</strong>, you would be telling the compiler that <strong>i</strong> is defined globally (via the <strong>extern</strong>), but it also has file scope (via the <strong>static</strong>), so the compiler will generate an error.</p>
<p>extern告诉编译器elsewhere会有这个变量i，于是编译就能通过，link时由链接器去找。</p>
<hr />
<p>仅从visibility上对比，extren表示这个名字对所有translation units都可见，是static的opposite（visible only in this translation unit）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价写法</span></span><br><span class="line"><span class="keyword">extern</span>  <span class="type">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>但如果是static，则表示a这个名字只在当前文件可见</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="static-elements-in-cc"><a class="markdownIt-Anchor" href="#static-elements-in-cc"></a> static elements in C/C++</h2>
<h3 id="static-free-functions"><a class="markdownIt-Anchor" href="#static-free-functions"></a> Static free functions</h3>
<p><code>函数（非成员函数）</code>VS<code>static 函数（非成员函数）</code><br />
函数名本身就是全局的</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>存储类型</td>
<td>全局</td>
<td>-&gt;</td>
<td>不变</td>
<td></td>
<td>全局</td>
</tr>
<tr>
<td>作用域</td>
<td>文件作用域</td>
<td>-&gt;</td>
<td>改变</td>
<td></td>
<td>当前文件</td>
</tr>
<tr>
<td>链接属性</td>
<td>外部链接</td>
<td>-&gt;</td>
<td>改变</td>
<td></td>
<td>内部链接</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// external linkage</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价写法</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>加static就表明函数f()只在当前文件可见，有时称作文件静态（file static）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="static-local-variables"><a class="markdownIt-Anchor" href="#static-local-variables"></a> static local variables</h3>
<p><code>局部变量（基本类型）</code>VS<code>static 局部变量（基本类型）</code></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>存储类型</td>
<td>栈</td>
<td>-&gt;</td>
<td>改变</td>
<td></td>
<td>全局</td>
</tr>
<tr>
<td>作用域</td>
<td>函数作用域</td>
<td>-&gt;</td>
<td>不变</td>
<td></td>
<td>函数作用域</td>
</tr>
</tbody>
</table>
<p>初始化时机：函数第一次被调用<br />
初始化的值：如果没有指定，则是0</p>
<p>Example:</p>
<ul>
<li>num_calls将在每次函数执行时候++<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num_calls = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    num_calls++;</span><br><span class="line">&#125; <span class="comment">// 全局变量，但只能在函数里访问</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>局部变量（对象）</code>VS<code>static 局部变量（对象）</code></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>存储类型</td>
<td>栈</td>
<td>-&gt;</td>
<td>改变</td>
<td></td>
<td>全局</td>
</tr>
<tr>
<td>作用域</td>
<td>函数作用域</td>
<td>-&gt;</td>
<td>不变</td>
<td></td>
<td>函数作用域</td>
</tr>
</tbody>
</table>
<p>初始化时机：函数第一次被调用，由构造函数进行初始化<br />
初始化的值：看构造函数实现</p>
<h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h3>
<p><code>g_global</code>：</p>
<ul>
<li>File1中的<code>g_global</code>是个全局变量，对所有translation units可见，所以在File12中可以用<code>extern int g_global</code>来表明g_global定义在别处，然后就可以使用g_global1了。</li>
</ul>
<p><code>s_local</code>：</p>
<ul>
<li>static，只对当前文件可见。即使File2中用<code>extern int s_local</code>表明s_local定义在别处，编译能过，但link时过不去（File1说s_local只给自己这个文件用）</li>
</ul>
<p><code>hidden</code>：</p>
<ul>
<li>static，函数名只对当前文件可见，File2不可见，不可使用</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/static/image-20200425142233717.png" alt="image-20200425142233717" /></p>
<h3 id="confusion"><a class="markdownIt-Anchor" href="#confusion"></a> Confusion</h3>
<p>通过上面的例子，可以发现，正因为static关键字可以表示两种含义（<strong>存储类型</strong>和<strong>可见性</strong>），所以会造成理解上的困扰。给全局变量加static，改的是链接属性；给局部变量加static，改的持久存储；给函数（非成员函数）加static，改的是链接属性。换个角度其实可以理解，加上static后，无法同时将两个含义都修改，加上static后变的只有一个含义，如：</p>
<ul>
<li>全局变量，本身就是全局存储，加了static还是全局存储，所以加static就是限制可见性</li>
<li>局部变量，本身可见性是在函数作用域，加了static可见性还是在函数作用域里，所以加static就是修改为持久存储</li>
<li>函数（非成员），函数地址本身就是全局地址，加了static还是全局，所以加static就是限制可见性</li>
</ul>
<p>核心点还是从static的两种基本含义<strong>存储类型</strong>和<strong>可见性</strong>方面进行分析。</p>
<h2 id="静态对象的构造和析构调用顺序"><a class="markdownIt-Anchor" href="#静态对象的构造和析构调用顺序"></a> 静态对象的构造和析构调用顺序</h2>
<ul>
<li>Construction occurs when definition is encountered
<ul>
<li>Constructor called at-most once 构造只发生一次，在函数第一次被调用时发生</li>
<li>The constructor arguments must be satisfied</li>
</ul>
</li>
<li>Destruction takes place on exit from program 析构在程序结束时发生
<ul>
<li>Compiler assures LIFO order of destructors 所有被创建的对象的析构函数按创建时相反的顺序被调用</li>
</ul>
</li>
</ul>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>析构函数具体调用时机</span></summary><div class="body"><p>多数情况下main()函数结尾是通过调用exit()来结束程序，在exit()被调用时析构被调用。</p><p>如果用C标准库的abort()函数来退出程序，静态对象的析构函数不会被调用。</p><p>可以用标准C库函数atexit()来指定当前程序跳出main()（或调用exit()）时应执行的操作。这样，在跳出main()或调用exit()之前按，用atexit()注册的函数可以在所有对象的析构函数之前被调用。</p></div></details></div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C10:StaticDestructors.cpp</span></span><br><span class="line"><span class="comment">// Static object destructors</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;statdest.out&quot;</span>)</span></span>; <span class="comment">// Trace file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="type">char</span> c; <span class="comment">// Identifier</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Obj</span>(<span class="type">char</span> cc) : <span class="built_in">c</span>(cc) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Obj::Obj() for &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Obj</span>() &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Obj::~Obj() for &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Obj <span class="title">a</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>; <span class="comment">// Global (static storage)</span></span><br><span class="line"><span class="comment">// Constructor &amp; destructor always called</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> Obj <span class="title">b</span><span class="params">(<span class="string">&#x27;b&#x27;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> Obj <span class="title">c</span><span class="params">(<span class="string">&#x27;c&#x27;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;inside main()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">f</span>(); <span class="comment">// Calls static constructor for b</span></span><br><span class="line">  <span class="comment">// g() not called</span></span><br><span class="line">  out &lt;&lt; <span class="string">&quot;leaving main()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Obj::<span class="built_in">Obj</span>() <span class="function"><span class="keyword">for</span> a</span></span><br><span class="line"><span class="function">inside <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Obj::Obj</span><span class="params">()</span> <span class="keyword">for</span> b</span></span><br><span class="line"><span class="function">leaving <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Obj::~<span class="title">Obj</span><span class="params">()</span> <span class="keyword">for</span> b</span></span><br><span class="line"><span class="function">Obj::~<span class="title">Obj</span><span class="params">()</span> <span class="keyword">for</span> a</span></span><br></pre></td></tr></table></figure>
<p>The constructor for <strong>a</strong> is called before <strong>main( )</strong> is entered, and the constructor for <strong>b</strong> is called only because <strong>f( )</strong> is called. When <strong>main( )</strong> exits, <u>the destructors for the objects that have been constructed are called in reverse order of their construction.</u> This means that if <strong>g( )</strong> <em>is</em> called, the order in which the destructors for <strong>b</strong> and <strong>c</strong> are called depends on whether <strong>f( )</strong> or <strong>g( )</strong> is called first.</p>
<h2 id="static-initialization-dependency"><a class="markdownIt-Anchor" href="#static-initialization-dependency"></a> Static initialization dependency</h2>
<p>有多个文件都有作用域为多个translation units的静态对象，这些静态对象之间互有依赖，如</p>
<figure class="highlight cpp"><figcaption><span>一个文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> x = y + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>另一个文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>谁先初始化谁后初始化的顺序是不确定的</p>
<p>解决办法：</p>
<ol>
<li>不使用，避免静态对象之间初始化的依赖</li>
<li>将所有有依赖的这些静态对象放到同一个文件中，文件中的顺序就是初始化的顺序</li>
<li>两种办法
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cs.swarthmore.edu/~newhall/unixhelp/thinkinginc++/Chapter10.html">10: Name Control</a>What to do标题</li>
</ul>
</li>
</ol>
<h2 id="static-members-in-c"><a class="markdownIt-Anchor" href="#static-members-in-c"></a> Static members in C++</h2>
<p>有时我们需要一个在所有类的对象都共享的变量，在C中可以用全局变量实现，但全局变量没有隐藏在类的内部。如果既能让所有类的对象都共享，并且能放在类里，那就再理想不过了。<code>static数据成员</code>就是这个问题的解决方法。</p>
<h3 id="static-members"><a class="markdownIt-Anchor" href="#static-members"></a> Static members</h3>
<p>在C中，static意味着<strong>Hidden</strong>和<strong>Persistent</strong>。members本身在类中，由access rules(访问控制符，public，protected，private）来做<strong>Hidden</strong>的事，所以static用来实现Hidden的任务结束了（像先前在C那样，将name修改为本文件可见）。加上static后表示这个成员是全局的，起<strong>Persistent</strong>的作用，表示这么一个东西，它不会随着对象的不同而不同，它是对象instances之间共享的东西。所以说static成员变量是class-wide（类级别）上的东西。</p>
<ol>
<li>
<p>static member也是类的成员，类外对静态成员变量的访问需要遵守access rules(访问控制符，public，protected，private）</p>
</li>
<li>
<p>静态成员变量存储在全局区，且必须在一个地方定义（definition）<br />
类中的是declaration，declaration并没分空间。必须有一个地方写上definition，编译器才会给静态成员变量分空间。通常是.h放类的declaration，在.cpp中写definition</p>
<div class="tag-plugin grid"  style="grid-template-columns: repeat(2, 1fr);"><div class="cell" style="">
    <figure class="highlight cpp"><figcaption><span>.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
    <div class="cell" style="">
    <p><strong>正确的写法</strong></p><div class="tag-plugin colorful note" color="green" child="codeblock"><div class="body"><figure class="highlight cpp"><figcaption><span>.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition</span></span><br><span class="line"><span class="type">int</span> A::i;               <span class="comment">// ok,编译器会默认初始化为0</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition</span></span><br><span class="line"><span class="type">int</span> A::i = <span class="number">20</span>;          <span class="comment">// ok,编译器会初始化为20</span></span><br></pre></td></tr></table></figure></div></div><p><strong>错误的写法</strong></p><p>从设计上来讲，static限制<code>A::i</code>只在当前文件可见，但<code>A::i</code>已经在类A中是private，private是说只有类才能访问，这会冲突。所以definition这里前面不用再加上static</p><div class="tag-plugin colorful note" color="red" child="codeblock"><div class="body"><figure class="highlight cpp"><figcaption><span>.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> A::i;        <span class="comment">//error</span></span><br></pre></td></tr></table></figure></div></div>
    </div>
    </div>
</li>
<li>
<p>静态成员变量是所有对象instances共享的，是属于整个类的一部分，所以：</p>
<ul>
<li>
<p>不能在构造函数初始化列表中进行初始化，因为静态成员变量与是否有对象实例无关。初始化列表只能对非静态成员变量进行初始化</p>
</li>
<li>
<p>可以在构造函数的函数体中进行赋值，因为静态成员变量也是类的成员，类中的函数可以访问到。对象也可以通过this指针访问到</p>
</li>
<li>
<p>两种访问方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:                     <span class="comment">//public，所以main中可以直接访问到i</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;           <span class="comment">//如果private的，main中的两行也访问不到</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> r1 = A::i;          <span class="comment">//方式一：类名::静态数据成员</span></span><br><span class="line">    <span class="type">int</span> r2 = a.i;           <span class="comment">//方式二：类对象名 静态数据成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="static-member-function"><a class="markdownIt-Anchor" href="#static-member-function"></a> Static member function</h3>
<ol>
<li>
<p>static member function也是类的成员，类外对静态成员变量的访问需要遵守access rules(访问控制符，public，protected，private）</p>
</li>
<li>
<p>出现在类外的函数定义（definition）不用再写关键字static</p>
</li>
<li>
<p>静态成员函数只能访问静态成员变量和其他静态成员函数<br />
因为，静态成员函数与是否有对象实例无关，那也就没有this指针(this指针指向当前调用成员函数的对象)，没有this指针，也就访问不到非静态成员，也不能调用非静态的成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C10:StaticMemberFunctions.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(<span class="type">int</span> ii = <span class="number">0</span>) : <span class="built_in">i</span>(ii) </span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">// Non-static member function can access static member function or data:</span></span><br><span class="line">    j = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">incr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//! i++; </span></span><br><span class="line">    <span class="comment">// Error: static member functioncannot access non-static member data</span></span><br><span class="line">    <span class="keyword">return</span> ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//! val(); </span></span><br><span class="line">    <span class="comment">// Error: static member function cannot access non-static member function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">incr</span>(); <span class="comment">// OK -- calls static</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> X::j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X x;</span><br><span class="line">  X* xp = &amp;x;</span><br><span class="line"></span><br><span class="line">  x.<span class="built_in">f</span>();</span><br><span class="line">  xp-&gt;<span class="built_in">f</span>();</span><br><span class="line">  X::<span class="built_in">f</span>(); <span class="comment">// Only works with static members</span></span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调用静态成员函数的两种方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: C10:SimpleStaticMemberFunction.cpp </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//方式一</span></span><br><span class="line">  X::<span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方式二</span></span><br><span class="line">  X x;</span><br><span class="line">  x.<span class="built_in">f</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>However, it’s more typical to call a <strong>static</strong> member function by itself, without any specific object, using the scope-resolution operator</p>
</li>
</ol>
<p>静态成员函数提供了一种方法：在一个类没有创建任何对象之前来调用类中的函数；有这么一个东西，与是否存在类的对象无关的<br />
静态成员变量同理：在一个类没有创建任何对象示例之前，就能让其他人来访问类中的数据</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<table>
  <tr>
    <th colspan="2">Uses of "static" in C++</th>
  </tr>
  <tr>
    <td>Static free functions</td>
    <td><del>Internal Linkage </del>(deprecated)</td>
  </tr>
  <tr>
    <td>Static global variables</td>
    <td><del>Internal Linkage </del>(deprecated)</td>
  </tr>
  <tr>
    <td>Static local variables</td>
    <td>Persistent storage</td>
  </tr>
  <tr>
    <td>Static member variables</td>
    <td>Shared by all instances</td>
  </tr>
  <tr>
    <td>Static member function</td>
    <td>Shared by all instances, can only access static member variables</td>
  </tr>
</table>
<ol>
<li>Static free functions：指的是在类外定义的、具有静态链接（internal linkage）的函数。这意味着这些函数仅在定义它们的翻译单元（通常是一个.cpp文件）内部可见，而不能被其他翻译单元看到或链接。这样可以避免与其他翻译单元中具有相同名称的函数发生命名冲突。</li>
<li>Static global variables：指的是在所有函数外面定义的、具有静态链接的全局变量。这种变量也只在定义它的翻译单元内部可见，从而避免了在不同的翻译单元之间共享。</li>
</ol>
<p>废弃（deprecated）<br />
自C++11开始，匿名命名空间（anonymous namespaces）被推荐用于替代静态全局变量和静态自由函数，因为它提供了更好的封装和防止命名冲突的手段。</p>
<h3 id="分析方法"><a class="markdownIt-Anchor" href="#分析方法"></a> 分析方法</h3>
<p>从存储类型和可见性两方面进行分析。然后，注意静态成员变量和静态成员函数的一些特点。比如静态成员变量注意要有definition，静态成员函数只能访问静态成员变量和调用静态成员函数等。</p>



<div class="article-footer reveal fs14"></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/Thinking_in_C++/Function_arguments&return_values.html">Function arguments & return values</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/Thinking_in_C++/static%EF%BC%88%E5%BA%9F%E5%BC%83%E8%8D%89%E7%A8%BF%EF%BC%89.html">static（废弃草稿）</a></div></section></div>



  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body twikoo'>
      

<div id="twikoo_container"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>
    </section>
  </div>


      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">wiki</span><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a href="/wiki/tags/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a><a href="/wiki/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a><a href="/wiki/tags/%E5%85%B6%E4%BB%96/">其他</a></div><div class="sitemap-group"><span class="fs14">关于</span><a href="/about/">关于</a></div></div><div class="text"><p>本站由 <a href="/">Misc0101</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0">Stellar 1.25.0</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.25.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".fancybox img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
    function load_twikoo() {
        if (!document.querySelectorAll("#twikoo_container")[0]) return;
        stellar.loadScript('https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js', {defer: true}).then(function () {
            const el = document.getElementById("twikoo_container");
            var path = el.getAttribute('comment_id');
            if (!path) {
                path = decodeURI(window.location.pathname);
            }
            twikoo.init(Object.assign({"js":"https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js","envId":"https://twikooblogcomment-tkkws-projects-20e4cf59.vercel.app"}, {
                el: '#twikoo_container',
                path: path,
            }));
        });
    }

    window.addEventListener('DOMContentLoaded', (event) => {
        load_twikoo();
    });
</script>






<!-- inject -->


  </div>
</body>
</html>
