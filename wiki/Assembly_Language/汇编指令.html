<!DOCTYPE html>
<html lang='zh-CN'>


<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0" theme-name="Stellar" theme-version="1.25.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>汇编语言：汇编指令 - Misc0101</title>

  
    <meta name="description" content="汇编指令 指令操作数符号  白皮书二卷P115页3.1.1.3     操作数 说明     reg 通用寄存器   m 内存   imm 立即数       r8 8位通用寄存器   m8 8位内存操作数   imm8 8位立即数       以此类推      MOV 将源操作数复制到目标操作数；源操作数不会发生改变 1mov destination,source 操作数 12345MOV">
<meta property="og:type" content="website">
<meta property="og:title" content="汇编指令">
<meta property="og:url" content="https://misc0101.github.io/wiki/Assembly_Language/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4.html">
<meta property="og:site_name" content="Misc0101">
<meta property="og:description" content="汇编指令 指令操作数符号  白皮书二卷P115页3.1.1.3     操作数 说明     reg 通用寄存器   m 内存   imm 立即数       r8 8位通用寄存器   m8 8位内存操作数   imm8 8位立即数       以此类推      MOV 将源操作数复制到目标操作数；源操作数不会发生改变 1mov destination,source 操作数 12345MOV">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230919103148868.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211218657.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211614163.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211719753.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211741122.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211959808.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217212043726.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217212104876.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217212148464.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230918151501356.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230918151552564.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230918151833079.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230918151804856.png">
<meta property="article:published_time" content="2023-09-20T02:05:59.000Z">
<meta property="article:modified_time" content="2023-09-20T02:05:59.000Z">
<meta property="article:author" content="Misc0101">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://misc0101.github.io/Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230919103148868.png">
  
  
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1.2em" height="1.2em" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有项目</a><a class="title" href="/wiki/Assembly_Language/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8_%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99.html"><div class="main" ff="title">汇编语言</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/Assembly_Language/" placeholder="在/wiki/Assembly_Language/中搜索..."><svg t="1705074644177" class="icon search-icon" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc multi" id="data-toc" collapse="false"><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Assembly_Language/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8_%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99.html#start"><span class="toc-text">通用寄存器_内存读写</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/Assembly_Language/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4.html"><span class="toc-text">汇编指令</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-text"> 汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mov"><span class="toc-text"> MOV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xchg"><span class="toc-text"> XCHG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offset%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> OFFSET运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lea%E6%8C%87%E4%BB%A4"><span class="toc-text"> LEA指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add"><span class="toc-text"> ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adc"><span class="toc-text"> ADC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sub"><span class="toc-text"> SUB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sbb"><span class="toc-text"> SBB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptr%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> PTR运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-text"> 位运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#and"><span class="toc-text"> AND</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#or"><span class="toc-text"> OR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xor"><span class="toc-text"> XOR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#not"><span class="toc-text"> NOT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-text"> 移位指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shl"><span class="toc-text"> SHL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shr"><span class="toc-text"> SHR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sal"><span class="toc-text"> SAL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sar"><span class="toc-text"> SAR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rol"><span class="toc-text"> ROL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ror"><span class="toc-text"> ROR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rcl"><span class="toc-text"> RCL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rcr"><span class="toc-text"> RCR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-text"> 字符串操作指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#movs%E6%8C%87%E4%BB%A4"><span class="toc-text"> MOVS指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stos%E6%8C%87%E4%BB%A4"><span class="toc-text"> STOS指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%90%91%E6%A0%87%E5%BF%97%E4%BD%8Ddf"><span class="toc-text"> 方向标志位DF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rep%E6%8C%87%E4%BB%A4"><span class="toc-text"> REP指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-text"> 堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#push"><span class="toc-text"> PUSH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop"><span class="toc-text"> POP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pushad"><span class="toc-text"> PUSHAD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pushfd"><span class="toc-text"> PUSHFD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9eip%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text"> 修改EIP的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jmp"><span class="toc-text"> JMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call"><span class="toc-text"> CALL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret"><span class="toc-text"> RET</span></a></li></ol></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Assembly_Language/%E8%BF%87%E7%A8%8B.html"><span class="toc-text">过程</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Assembly_Language/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8CJCC%E6%8C%87%E4%BB%A4.html"><span class="toc-text">标志寄存器和JCC指令</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Assembly_Language/%E5%A0%86%E6%A0%88%E5%9B%BE.html"><span class="toc-text">堆栈图</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Assembly_Language/%E5%B0%8F%E7%BB%93_assembly.html"><span class="toc-text">小结</span></a></div></div></widget>

<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多：计算机基础</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/C++/%E5%B0%81%E8%A3%85%E5%92%8Cthis%E6%8C%87%E9%92%88.html"><span class="title">C++</span><span class="excerpt">滴水三期_C++语言笔记，C++能做的C都能做，只不过如果使用C++，可以节省很多时间，因为编译器帮编程人员做了很多工作，让编程人员省事。学习的目标：相对于C，编译器替我们做了哪些工作。</span></a><a class="item wiki" href="/wiki/C/%E5%87%BD%E6%95%B0.html"><span class="title">C</span><span class="excerpt">滴水三期_C语言笔记，以逆向角度看待和学习C语言，精彩点：堆栈图与指针。</span></a><a class="item wiki" href="/wiki/Modern_C++/%E7%B1%BB.html"><span class="title">Modern C++</span><span class="excerpt">C++98及其之前的C++ 特性称之为traditional C++（传统C++），C++11/14/17/20被称为Modern C++（现代 C++ ）。补充从传统C++“升级”到现代C++的知识。</span></a><a class="item wiki" href="/wiki/Thinking_in_C++/Pointers.html"><span class="title">Thinking in C++</span><span class="excerpt">《Thinking in C++ vol 1》笔记，知识内化后的输出，少部分是摘抄，少用的细节不做记录用时在查，参考视频：《面向对象程序设计_C++_翁恺老师》。</span></a><a class="item wiki" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html"><span class="title">Windows API编程</span><span class="excerpt">滴水三期_win32 api笔记，学习Windows API编程的困难并不在于函数参数参数众多或者英文不好这类表象原因，而是需要从Windows系统的整体知识架构出发来学习这些API，深入理解每个参数背后的含义和背景。如此，未来查阅MSDN时便不再像是看天书。</span></a><a class="item wiki" href="/wiki/Proxy_Protocols/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86_%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8A%80%E6%9C%AF.html"><span class="title">科学上网技术</span><span class="excerpt">从正常网络通信数据包通信过程出发，逐步推导到使用代理协议进行科学上网，随后依次介绍各代理协议ss、trojan、vmess、vless原理与节点搭建，还有相关的工具、技术、概念介绍。</span></a><a class="item wiki" href="/wiki/representation_and_computation_of_data/%E8%BF%9B%E5%88%B6.html"><span class="title">数据的运算与表示</span><span class="excerpt">滴水三期_进制笔记，学习与理解进制、数据宽度、数的表示、位运算等概念。</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      
  





      


<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">项目</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/Assembly_Language/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8_%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99.html">汇编语言</a></div><div id="post-meta">
    <span>更新于&nbsp;<time datetime="2023-09-20T02:05:59.000Z">2023-09-20</time></span>
    </div></div></div>

<article class='md-text content wiki'>
<h1 class="article-title"><span>汇编指令</span></h1>
<h2 id="汇编指令"><a class="markdownIt-Anchor" href="#汇编指令"></a> 汇编指令</h2>
<p>指令操作数符号</p>
<blockquote>
<p>白皮书二卷P115页3.1.1.3</p>
</blockquote>
<table>
<thead>
<tr>
<th>操作数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>reg</td>
<td>通用寄存器</td>
</tr>
<tr>
<td>m</td>
<td>内存</td>
</tr>
<tr>
<td>imm</td>
<td>立即数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>r8</td>
<td>8位通用寄存器</td>
</tr>
<tr>
<td>m8</td>
<td>8位内存操作数</td>
</tr>
<tr>
<td>imm8</td>
<td>8位立即数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>以此类推</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="mov"><a class="markdownIt-Anchor" href="#mov"></a> MOV</h3>
<p>将源操作数复制到目标操作数；源操作数不会发生改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov destination,source</span><br></pre></td></tr></table></figure>
<p><strong>操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV reg,reg</span><br><span class="line">MOV mem,reg</span><br><span class="line">MOV reg,mem</span><br><span class="line">MOV mem,imm</span><br><span class="line">MOV reg,imm</span><br></pre></td></tr></table></figure>
<ul>
<li>两个操作数的宽度必须同等大小</li>
<li>两个操作数不能同时为内存操作数</li>
<li>指令指针寄存器（IP、EIP或RIP）不能作为目的操作数</li>
</ul>
<h3 id="xchg"><a class="markdownIt-Anchor" href="#xchg"></a> XCHG</h3>
<p>XCHG(交换数据)指令交换两个操作数内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XCHG reg,reg</span><br><span class="line">XCHG reg,mem</span><br><span class="line">XCHG mem,reg</span><br></pre></td></tr></table></figure>
<p>例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XCHG AL,CL</span><br><span class="line">XCHG DWORD PTR DS:[12FFC4],EAX</span><br><span class="line">XCHG BYTE PTR DS:[12FFC4],AL</span><br></pre></td></tr></table></figure>
<h3 id="offset运算符"><a class="markdownIt-Anchor" href="#offset运算符"></a> OFFSET运算符</h3>
<blockquote>
<p>《汇编语言-基于x86处理器第七版》P87</p>
</blockquote>
<p>OFFSET运算符返回数据标号的偏移量。<u>这个偏移量按字节计算</u>，表示的是该数据标号距离数据段起始地址的距离。</p>
<p>如下图所示为数据段内名为myByte的变量。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230919103148868.png" alt="image-20230919103148868" /></p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">bVal  BYTE  ?</span><br><span class="line">wVal  WORD  ?</span><br><span class="line">dVal  DWORD ?</span><br><span class="line">dVal2 DWORD ?</span><br></pre></td></tr></table></figure>
<p>假设bVal在偏移量为0040 4000(十六进制)的位置，则OFFSET运算符返回值如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                                            偏移</span><br><span class="line">mov esi,OFFSET bVal    ;ESI =00404000h      0</span><br><span class="line">mov esi,OFFSET wVal    ;ESI =00404001h      BYTE</span><br><span class="line">mov esi,OFFSET dVal    ;ESI =00404003h      BYTE+WORD</span><br><span class="line">mov esi,OFFSET dVal2   ;ESI =00404007h      BYTE+WORD+DWORD</span><br></pre></td></tr></table></figure>
<h3 id="lea指令"><a class="markdownIt-Anchor" href="#lea指令"></a> LEA指令</h3>
<blockquote>
<p>《汇编语言-基于x86处理器第七版》P236</p>
</blockquote>
<p>LEA指令返回间接操作数的地址。<u>由于间接操作数中包含一个或多个寄存器，因此会在运行时计算这些操作数的偏移量</u>。</p>
<p>为了演示如何使用LEA，现在来看下面的C++程序,该程序声明了一个局部数组 myString，并引用它来分配数组值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">makeArray</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> myString[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)</span><br><span class="line">        myString[i]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之等效的汇编代码在堆栈中为myString分配空间，并将地址——间接操作数——赋给ESI。虽然数组只有30个字节，但是ESP还是递减了32以对齐双字边界。注意如何使用LEA把数组地址分配给ESI:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">makeArray PROC</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp,esp</span><br><span class="line">    sub esp,32                  ;myString位于EBP-30的位置</span><br><span class="line">    lea esi,[ebp-30]            ;加载myString的地址</span><br><span class="line">    mov ecx,30                  ;循环计数器</span><br><span class="line">L1: mov BYTE PTR [esi],&#x27;*&#x27;      ;填充一个位置</span><br><span class="line">    inc esi                     ;指向下一个元素</span><br><span class="line">    loop L1                     ;循环，直到ECX=0</span><br><span class="line">    add esp,32                  ;删除数组（恢复ESP）</span><br><span class="line">    pop ebp</span><br><span class="line">    ret</span><br><span class="line">makeArray ENDP </span><br></pre></td></tr></table></figure>
<p><strong>与OFFSET运算符的区别</strong></p>
<p>不能用OFFSET获得堆栈参数的地址，因为OFFSET只适用于编译时已知的地址。下面的语句无法汇编:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov esi,OFFSET [ebp-30]     ;错误</span><br></pre></td></tr></table></figure>
<h3 id="add"><a class="markdownIt-Anchor" href="#add"></a> ADD</h3>
<p>将源操作数与目标操作数相加之和，存入目标操作数；源操作数不会发生改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add destination,source</span><br></pre></td></tr></table></figure>
<p><strong>操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ADD r/m8, imm8</span><br><span class="line">ADD r/m16,imm16</span><br><span class="line">ADD r/m32,imm32</span><br><span class="line">ADD r/m16, imm8</span><br><span class="line">ADD r/m32, imm8</span><br><span class="line">ADD r/m8, r8</span><br><span class="line">ADD r/m16, r16</span><br><span class="line">ADD r/m32, r32</span><br><span class="line">ADD r8, r/m8</span><br><span class="line">ADD r16, r/m16</span><br><span class="line">ADD r32, r/m32</span><br></pre></td></tr></table></figure>
<p><strong>标志位</strong>  影响进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位、奇偶标志位，根据存入目标操作数的数值进行变化</p>
<h3 id="adc"><a class="markdownIt-Anchor" href="#adc"></a> ADC</h3>
<p>ADC(带进位加法)指令将源操作数和<u>进位标志位的值</u>都与目的操作数相加。</p>
<p>功能：操作对象1=操作对象1+操作对象2+CF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADC reg,reg</span><br><span class="line">ADC mem,reg</span><br><span class="line">ADC reg,mem</span><br><span class="line">ADC mem,imm</span><br><span class="line">ADC reg,imm</span><br></pre></td></tr></table></figure>
<p>例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC AL,CL</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC BYTE PTR DS:[12FFC4],2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC BYTE PTR DS:[12FFC4],AL</span><br></pre></td></tr></table></figure>
<h3 id="sub"><a class="markdownIt-Anchor" href="#sub"></a> SUB</h3>
<p>目标操作数减去源操作数，结果存入目标操作数；源操作数不会发生改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub destination,source</span><br></pre></td></tr></table></figure>
<p><strong>操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SUB r/m8, imm8</span><br><span class="line">SUB r/m16,imm16</span><br><span class="line">SUB r/m32,imm32</span><br><span class="line">SUB r/m16, imm8</span><br><span class="line">SUB r/m32, imm8</span><br><span class="line">SUB r/m8, r8</span><br><span class="line">SUB r/m16, r16</span><br><span class="line">SUB r/m32, r32</span><br><span class="line">SUB r8, r/m8</span><br><span class="line">SUB r16, r/m16</span><br><span class="line">SUB r32, r/m32</span><br></pre></td></tr></table></figure>
<p><strong>标志位</strong>  影响进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位、奇偶标志位，根据存入目标操作数的数值进行变化</p>
<h3 id="sbb"><a class="markdownIt-Anchor" href="#sbb"></a> SBB</h3>
<p>SBB(带借位减法）指令从目的操作数中减去源操作数和进位标志位的值。允许使用的操作数与ADC指令相同。</p>
<p>功能：操作对象1=操作对象1-操作对象2-CF</p>
<p>例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SBB AL,CL</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SBB BYTE PTR DS:[12FFC4],2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SBB BYTE PTR DS:[12FFC4],AL</span><br></pre></td></tr></table></figure>
<h3 id="ptr运算符"><a class="markdownIt-Anchor" href="#ptr运算符"></a> PTR运算符</h3>
<p>类型转换运算符，用于指定操作数的大小或类型。PTR运算符可以用于强制将一个操作数解释为特定类型的指针，这样可以确保正确的内存大小被访问。</p>
<p><strong>用途一</strong>  用来重写一个已经被声明过的操作数的大小类型。</p>
<p>例如，假设想要将一个双字变量myDouble的低16位传送给AX。由于操作数大小不匹配，因此，汇编器不会允许这种操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">myDouble DWORD 12345678h</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">mov ax,myDouble</span><br></pre></td></tr></table></figure>
<p>但是,使用WORD PTR运算符就能将低位字（5678h)送入AX:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,WORD PTR myDouble</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>用途二</strong>  一个操作数的大小可能无法从指令中直接看出来，要用PTR运算符确认操作数的大小类型。</p>
<p>比如，在向内存传立即数时，要用PTR声明用多大的内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov BYTE PTR ds:[0x12345678],1234h</span><br></pre></td></tr></table></figure>
</br>
<p>PTR必须与一个标准汇编数据类型一起使用，这些类型包括：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD或TBYTE</p>
<h2 id="位运算指令"><a class="markdownIt-Anchor" href="#位运算指令"></a> 位运算指令</h2>
<h3 id="and"><a class="markdownIt-Anchor" href="#and"></a> AND</h3>
<p>两个操作数的对应位之间进行（按位）逻辑与（AND）操作，结果存放在目标操作数中；源操作数不会发生改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and destination,source</span><br></pre></td></tr></table></figure>
<p><strong>操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AND reg,reg</span><br><span class="line">AND reg,mem</span><br><span class="line">AND reg,imm</span><br><span class="line">AND mem,reg</span><br><span class="line">AND mem,imm</span><br></pre></td></tr></table></figure>
<ul>
<li>两个操作数必须同等大小</li>
</ul>
<p><strong>标志位</strong> 总是清除溢出和进位进位标志位，并根据目标操作数的值来修改符号标志位、零标志位、奇偶标志位。</p>
<h3 id="or"><a class="markdownIt-Anchor" href="#or"></a> OR</h3>
<p>两个操作数的对应位之间进行（按位）逻辑或（OR）操作，结果存放在目标操作数中；源操作数不会发生改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">or destination,source</span><br></pre></td></tr></table></figure>
<p><strong>操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OR reg,reg</span><br><span class="line">OR reg,mem</span><br><span class="line">OR reg,imm</span><br><span class="line">OR mem,reg</span><br><span class="line">OR mem,imm</span><br></pre></td></tr></table></figure>
<ul>
<li>两个操作数必须同等大小</li>
</ul>
<p><strong>标志位</strong> 总是清除溢出和进位进位标志位，并根据目标操作数的值来修改符号标志位、零标志位、奇偶标志位。</p>
<h3 id="xor"><a class="markdownIt-Anchor" href="#xor"></a> XOR</h3>
<p>两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，结果存放在目标操作数中；源操作数不会发生改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor destination,source</span><br></pre></td></tr></table></figure>
<p><strong>操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XOR reg,reg</span><br><span class="line">XOR reg,mem</span><br><span class="line">XOR reg,imm</span><br><span class="line">XOR mem,reg</span><br><span class="line">XOR mem,imm</span><br></pre></td></tr></table></figure>
<ul>
<li>两个操作数必须同等大小</li>
</ul>
<p><strong>标志位</strong> 总是清除溢出和进位进位标志位，并根据目标操作数的值来修改符号标志位、零标志位、奇偶标志位。</p>
<h3 id="not"><a class="markdownIt-Anchor" href="#not"></a> NOT</h3>
<p>翻转操作数中的所有位。</p>
<p><strong>操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOT reg</span><br><span class="line">NOT mem</span><br></pre></td></tr></table></figure>
<p><strong>标志位</strong> 不影响标志位。</p>
<h2 id="移位指令"><a class="markdownIt-Anchor" href="#移位指令"></a> 移位指令</h2>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>SHL</td>
<td>左移</td>
<td>Shift Left</td>
</tr>
<tr>
<td>SHR</td>
<td>右移</td>
<td>Shift Right</td>
</tr>
<tr>
<td>SAL</td>
<td>算数左移</td>
<td>Shift Arithmetic Left</td>
</tr>
<tr>
<td>SAR</td>
<td>算数右移</td>
<td>Shift Arithmetic Right</td>
</tr>
<tr>
<td>ROL</td>
<td>循环左移</td>
<td>Rotate Left</td>
</tr>
<tr>
<td>ROR</td>
<td>循环右移</td>
<td>Rotate Right</td>
</tr>
<tr>
<td>RCL</td>
<td>带进位的循环左移</td>
<td>Rotate through Carry Left</td>
</tr>
<tr>
<td>RCR</td>
<td>带进位的循环右移</td>
<td>Rotate through Carry Right</td>
</tr>
</tbody>
</table>
<h3 id="shl"><a class="markdownIt-Anchor" href="#shl"></a> SHL</h3>
<p>SHL(左移)指令使目的操作数逻辑左移一位，最低位用0填充。最高位移入进位标志位,而进位标志位中原来的数值被丢弃:<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211218657.png" alt="image-20231217211218657" /></p>
<p>SHL的第一个操作数是目的操作数,第二个操作数是移位次数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHL destination,count</span><br></pre></td></tr></table></figure>
<p>该指令可用的操作数类型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHL reg,imm8</span><br><span class="line">SHL mem, imm8</span><br><span class="line">SHL reg, CL</span><br><span class="line">SHL mem, CL</span><br></pre></td></tr></table></figure>
<p>x86处理器允许imm8为0～255中的任何整数。另外，CL寄存器包含的是移位计数。上述格式同样适用于SHR、SAL、SAR、ROR、ROL、RCR和RCL指令。</p>
<h3 id="shr"><a class="markdownIt-Anchor" href="#shr"></a> SHR</h3>
<p>SHR（右移)指令使目的操作数逻辑右移一位，最高位用0填充。最低位复制到进位标志位,而进位标志位中原来的数值被丢弃:<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211614163.png" alt="image-20231217211614163" /></p>
<h3 id="sal"><a class="markdownIt-Anchor" href="#sal"></a> SAL</h3>
<p>SAL(算术左移）指令的操作与SHL指令一样。每次移动时，SAL都将目的操作数中的每一位移动到下一个最高位上。最低位用0填充;最高位移入进位标志位，该标志位原来的值被丢弃:<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211719753.png" alt="image-20231217211719753" /></p>
<blockquote>
<p>对于有符号数或无符号数，用SAL或SHL指令其实一样的，都是低位补0，最高位移到CF。</p>
</blockquote>
<h3 id="sar"><a class="markdownIt-Anchor" href="#sar"></a> SAR</h3>
<p>SAR（算术右移)指令将目的操作数进行算术右移:<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211741122.png" alt="image-20231217211741122" /></p>
<h3 id="rol"><a class="markdownIt-Anchor" href="#rol"></a> ROL</h3>
<p>ROL(循环左移）指令把所有位都向左移。最高位复制到进位标志位和最低位。指令格式与SHL指令相同:<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217211959808.png" alt="image-20231217211959808" /></p>
<h3 id="ror"><a class="markdownIt-Anchor" href="#ror"></a> ROR</h3>
<p>ROR(循环右移)指令把所有位都向右移，最低位复制到进位标志位和最高位。该指令格式与SHL指令相同:<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217212043726.png" alt="image-20231217212043726" /></p>
<h3 id="rcl"><a class="markdownIt-Anchor" href="#rcl"></a> RCL</h3>
<p>RCL(带进位循环左移）指令把每一位都向左移，进位标志位复制到LSB，而MSB复制到进位标志位:<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217212104876.png" alt="image-20231217212104876" /></p>
<h3 id="rcr"><a class="markdownIt-Anchor" href="#rcr"></a> RCR</h3>
<p>RCR(带进位循环右移）指令把每一位都向右移，进位标志位复制到MSB,而LSB复制到进位标志位:<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20231217212148464.png" alt="image-20231217212148464" /></p>
<h2 id="字符串操作指令"><a class="markdownIt-Anchor" href="#字符串操作指令"></a> 字符串操作指令</h2>
<h3 id="movs指令"><a class="markdownIt-Anchor" href="#movs指令"></a> MOVS指令</h3>
<p>传送字符串数据：将ESI指向的内存位置复制到EDI指向的内存位置。ESI和EDI自增或自减，由方向标志位的值决定。可使用重复前缀。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>完整形式</th>
<th>含义</th>
<th>ESI和EDI增加或减少的数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>MOVSB</td>
<td>MOVS BYTE PTR ES:[EDI], BYTE PTR DS:[ESI]</td>
<td>传送（复制）字节</td>
<td>1</td>
</tr>
<tr>
<td>MOVSW</td>
<td>MOVS WORD PTR ES:[EDI], WORD PTR DS:[ESI]</td>
<td>传送（复制）字</td>
<td>2</td>
</tr>
<tr>
<td>MOVSD</td>
<td>MOVS DWORD PTR ES:[EDI], DWORD PTR DS:[ESI]</td>
<td>传送（复制）双字</td>
<td>4</td>
</tr>
</tbody>
</table>
<h3 id="stos指令"><a class="markdownIt-Anchor" href="#stos指令"></a> STOS指令</h3>
<p>保存字符串数据：将累加器的内容保存到EDI寻址的内存位置。EDI根据方向标志位的值自增或自减。可使用重复前缀。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>完整形式</th>
<th>含义</th>
<th>EDI增加或减少的数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>STOSB</td>
<td>STOS BYTE PTR ES:[EDI]</td>
<td>将AL的值储存到EDI指定的内存地址</td>
<td>1</td>
</tr>
<tr>
<td>STOSW</td>
<td>STOS WORD PTR ES:[EDI]</td>
<td>将AX的值储存到EDI指定的内存地址</td>
<td>2</td>
</tr>
<tr>
<td>STOSD</td>
<td>STOS DWORD PTR ES:[EDI]</td>
<td>将EAX的值储存到EDI指定的内存地址</td>
<td>4</td>
</tr>
</tbody>
</table>
<h3 id="方向标志位df"><a class="markdownIt-Anchor" href="#方向标志位df"></a> 方向标志位DF</h3>
<p>可用CLD和STD指令显式修改方向标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLD;方向标志位清零（正向）</span><br><span class="line">STD;方向标志位置1（反向）</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方向标志位的值</th>
<th>对ESI和EDI的影响</th>
<th>地址顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>增加</td>
<td>低到高</td>
</tr>
<tr>
<td>1</td>
<td>减少</td>
<td>高到低</td>
</tr>
</tbody>
</table>
<h3 id="rep指令"><a class="markdownIt-Anchor" href="#rep指令"></a> REP指令</h3>
<p>重复前缀,REP  ECX&gt;0时重复。每执行一次，ECX寄存器中的值减一，直至为零。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REP MOVSB</span><br><span class="line">REP MOVSW</span><br><span class="line">REP MOVSD</span><br><span class="line">REP STOSB</span><br><span class="line">REP STOSW</span><br><span class="line">REP STOSD</span><br></pre></td></tr></table></figure>
<p>示例：<strong>复制字符串</strong></p>
<p>下面的例子中，MOVSB从string1传送10个字节到string2。重复前缀在执行MOVSB指令之前，首先测试ECX是否大于0。若ECX=0，MOVSB指令被忽略，控制传递到程序的下一行代码；若ECX&gt;0，则ECX减1并重复执行MOVSB指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cld                      ;清除方向标志位</span><br><span class="line">mov esi, OFFSET Stringl  ;ESI指向源串</span><br><span class="line">mov edi, OFFSET string2  ;EDI执行目的串</span><br><span class="line">mov ecx,10               ;计数器赋值为10</span><br><span class="line">rep movsb                ;传送10个字节</span><br></pre></td></tr></table></figure>
<h2 id="堆栈"><a class="markdownIt-Anchor" href="#堆栈"></a> 堆栈</h2>
<p>进程线性地址空间4GB中一块特殊的内存。</p>
<p>堆栈使用，由高地址向低地址方向使用。</p>
<p>用DTDebug随便打开一个程序，查看fs.base的值，然后在内存窗口输入<code>dd 3003000</code>查看，就能看到堆栈的地址范围</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230918151501356.png" alt="image-20230918151501356" /></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230918151552564.png" alt="image-20230918151552564" /></p>
<p>栈顶：02F30000。栈底：02F1F000。将堆栈窗口拉到顶部和底部，可以证实。02F2FFFC占4字节，+4，就是02F30000</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230918151833079.png" alt="image-20230918151833079" /></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/image-20230918151804856.png" alt="image-20230918151804856" /></p>
<hr />
<p>ESP栈顶指针总是指向最后压入堆栈的数据项。EBP栈底指针表示当前使用堆栈的第一个地址。</p>
<p>ESP-EBP，就知道这个堆栈使用了多少内存空间。</p>
<p>要读取堆栈中的某个数据时，既可以通过ESP加偏移，也可以通过EBP加偏移的方式来寻址。</p>
<blockquote>
<p>debug编译的exe为EBP寻址，release的为ESP寻址。</p>
</blockquote>
<p><strong>堆栈应用</strong></p>
<p>运行时堆栈在程序中有一些重要用途:</p>
<ul>
<li>当寄存器用于多个目的时,堆栈可以作为寄存器的一个方便的临时保存区。在寄存器被修改后,还可以恢复其初始值。</li>
<li>执行CALL指令时,CPU在堆栈中保存当前过程的返回地址。</li>
<li>调用过程时,输入数值也被称为参数，通过将其压入堆栈实现参数传递。</li>
<li>堆栈也为过程局部变量提供了临时存储区域。</li>
</ul>
<h3 id="push"><a class="markdownIt-Anchor" href="#push"></a> PUSH</h3>
<p>先减少ESP的值，再将源操作数复制到堆栈。</p>
<ul>
<li>操作数是16位的，则ESP减2</li>
<li>操作数是32位的，则ESP减4</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;不能push al			 ;不能push 8位的寄存器/内存</span><br><span class="line">PUSH reg/mem16</span><br><span class="line">PUSH reg/mem32</span><br><span class="line">PUSH imm8/imm16/imm32	;立即数都是-4字节</span><br></pre></td></tr></table></figure>
</br>
<p><strong>等价指令</strong></p>
<p>压栈做了两件事：</p>
<ol>
<li>抬栈</li>
<li>将源操作数复制到堆栈</li>
</ol>
<p>抬栈的等价指令：</p>
<ul>
<li><code>sub esp,0x4</code></li>
<li><code>lea esp,dword ptr ss:[esp-4]</code></li>
</ul>
<p>将源操作数复制到堆栈的等价指令：</p>
<ul>
<li><code>mov dword ptr ss:[esp-4],0xAAAAAAAA</code>，然后抬栈</li>
<li>先抬栈后，<code>mov dword ptr ss:[esp],0xAAAAAAAA</code></li>
</ul>
<p>组合一下，如果是先抬栈，然后将源操作数复制到堆栈</p>
<p>等价指令1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub esp,0x4</span><br><span class="line">mov dword ptr ss:[esp],0xAAAAAAAA</span><br></pre></td></tr></table></figure>
<p>等价指令2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea esp,dword ptr ss:[esp-4]</span><br><span class="line">mov dword ptr ss:[esp],0xAAAAAAAA</span><br></pre></td></tr></table></figure>
<p>如果是将源操作数复制到堆栈，然后再抬栈</p>
<p>等价指令1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ss:[esp-4],0xAAAAAAAA</span><br><span class="line">sub esp,0x4</span><br></pre></td></tr></table></figure>
<p>等价指令2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ss:[esp-4],0xAAAAAAAA</span><br><span class="line">lea esp,dword ptr ss:[esp-4]</span><br></pre></td></tr></table></figure>
<h3 id="pop"><a class="markdownIt-Anchor" href="#pop"></a> POP</h3>
<p>先把ESP指向的堆栈元素内容复制到目的操作数中，再增加ESP的值。</p>
<ul>
<li>操作数是16位的，则ESP加2</li>
<li>操作数是32位的，则ESP加4</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP reg/mem16</span><br><span class="line">POP reg/mem32</span><br></pre></td></tr></table></figure>
</br>
<p>不需要这个数据时，直接下降栈顶指针ESP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add esp, 0x4 </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea esp,dword ptr ss:[esp+4]</span><br></pre></td></tr></table></figure>
</br>
<p><strong>作业</strong></p>
<ol>
<li>使用2种方式实现：push esp</li>
</ol>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>答案</span></summary><div class="body"><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea eax,dword ptr ss:[esp]</span><br><span class="line">push eax                    ;分成两步，用等价指令也可以，我这里偷懒了</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ss:[esp-4],esp</span><br><span class="line">lea esp,dword ptr ss:[esp-4]    ;sub exp,0x4也可以</span><br></pre></td></tr></table></figure></div></details></div>
<ol start="2">
<li>使用2种方式实现：pop esp</li>
</ol>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>答案</span></summary><div class="body"><p>如果执行pop esp，它做了两件事：降栈，esp的值是堆栈里弹出来的值</p><blockquote><p>不过其实esp值被改了，平栈操作其实没啥意义，算是题目的局限性吧</p></blockquote><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add esp,4</span><br><span class="line">mov esp,dword ptr ss:[esp-4]</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr ss:[esp]</span><br><span class="line">add esp,4</span><br><span class="line">mov esp,eax</span><br></pre></td></tr></table></figure></div></details></div>
<h3 id="pushad"><a class="markdownIt-Anchor" href="#pushad"></a> PUSHAD</h3>
<p>pushad指令按照EAX，ECX，EDX，EBX，ESP（执行PUSHAD之前的值），EBP，ESI和EDI的顺序，将所有32位通用寄存器压入堆栈。</p>
<p>popad指令按相反顺序将寄存器弹出堆栈。</p>
<blockquote>
<p>上边寄存器的顺序就是之前文章写的要记住的编号顺序，也是OD从上往下显示的顺序。</p>
</blockquote>
<p>与之相似，PUSHA指令按序（AX、CX、DX、BX、SP、BP、SI和DI)将16位通用寄存器压入堆栈。POPA指令按照相反顺序将同样的寄存器弹出堆栈。在16位模式下，只能使用PUSHA和POPA指令。</p>
<h3 id="pushfd"><a class="markdownIt-Anchor" href="#pushfd"></a> PUSHFD</h3>
<p>PUSHFD指令把32位EFLAGS寄存器内容压入堆栈，而POPFD指令则把栈顶单元内容弹出到EFLAGS寄存器。</p>
<h2 id="修改eip的指令"><a class="markdownIt-Anchor" href="#修改eip的指令"></a> 修改EIP的指令</h2>
<h3 id="jmp"><a class="markdownIt-Anchor" href="#jmp"></a> JMP</h3>
<p>修改EIP的值为指定的指令地址.</p>
<blockquote>
<p>无条件跳转到目标地址。海哥说跟这个没关系，记住修改eip就行，然后CPU根据eip决定下一条执行的指令。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 寄存器/立即数/内存</span><br></pre></td></tr></table></figure>
<p>在含义上好似：<code>mov IP,ax</code>.（并不是说真有mov IP,ax这样的指令，而是用mov指令的语法来说明jmp指令的功能）。</p>
<h3 id="call"><a class="markdownIt-Anchor" href="#call"></a> CALL</h3>
<p>与JMP唯一的区别：在堆栈中存储call指令的下一行地址。</p>
<p>CALL指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器。当过程准备返回时，它的RET指令从堆栈把返回地址弹回到指令指针寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL 寄存器/立即数/内存</span><br></pre></td></tr></table></figure>
<p>在含义上好似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 地址B          ;当前eip地址+指令长度=下一条要执行指令的地址</span><br><span class="line">MOV EIP,地址A/寄存器</span><br></pre></td></tr></table></figure>
<h3 id="ret"><a class="markdownIt-Anchor" href="#ret"></a> RET</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RET</span><br></pre></td></tr></table></figure>
<p>在含义上好似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add esp,4</span><br><span class="line">mov eip,[esp-4]	    </span><br><span class="line">;或LEA ESP,[ESP+4]</span><br><span class="line">;或pop eip</span><br></pre></td></tr></table></figure>
<p>（并不是说真有mov IP,ax这样的指令，而是用mov指令的语法来说明ret修改eip的功能）。</p>



<div class="article-footer reveal fs14"></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/Assembly_Language/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8_%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99.html">通用寄存器_内存读写</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/Assembly_Language/%E8%BF%87%E7%A8%8B.html">过程</a></div></section></div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">wiki</span><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a href="/wiki/tags/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a><a href="/wiki/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a><a href="/wiki/tags/%E5%85%B6%E4%BB%96/">其他</a></div><div class="sitemap-group"><span class="fs14">关于</span><a href="/about/">关于</a></div></div><div class="text"><p>本站由 <a href="/">Misc0101</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0">Stellar 1.25.0</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.25.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".fancybox img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->






<!-- inject -->


  </div>
</body>
</html>
