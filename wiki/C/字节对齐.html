<!DOCTYPE html>
<html lang='zh-CN'>


<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0" theme-name="Stellar" theme-version="1.25.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>C：字节对齐 - Misc010</title>

  
    <meta name="description" content="sizeof运算符 sizeof运算符以字节为单位返回运算对象的大小。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float），则必须用圆括号将其括起来。 C语言规定，sizeof返回size_t类型的值。这是一个无符号整数类型，size_t是语言定义的标准类型。在C头文件中，用了typedef将size_t作为unsigned int或unsigned long的">
<meta property="og:type" content="website">
<meta property="og:title" content="字节对齐">
<meta property="og:url" content="https://misc0101.github.io/wiki/C/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.html">
<meta property="og:site_name" content="Misc010">
<meta property="og:description" content="sizeof运算符 sizeof运算符以字节为单位返回运算对象的大小。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float），则必须用圆括号将其括起来。 C语言规定，sizeof返回size_t类型的值。这是一个无符号整数类型，size_t是语言定义的标准类型。在C头文件中，用了typedef将size_t作为unsigned int或unsigned long的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231017112451425.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231017112829041.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231017113640770.png">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e092ff.png">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e0ab55.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/howProgrammersSeeMemory-16975976730481.jpg">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e07da3.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/singleByteAccess-16975988799594.jpg">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e07da3.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/doubleByteAccess-16975991984817.jpg">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e07da3.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/quadByteAccess.jpg">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e092ff.png">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e0ab55.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/unalignedAccess.jpg">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019142229455.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019142445508.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019143238396.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019144950799.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231020113150876.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019170541525.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019153405715.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019171932939.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019171231281.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019172848761.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019175553498.png">
<meta property="article:published_time" content="2023-10-17T02:27:55.000Z">
<meta property="article:modified_time" content="2023-10-17T02:27:55.000Z">
<meta property="article:author" content="Misc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://misc0101.github.io/Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231017112451425.png">
  
  
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1.2em" height="1.2em" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有项目</a><a class="title" href="/wiki/C/%E5%87%BD%E6%95%B0.html"><div class="main" ff="title">C</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/C/" placeholder="在/wiki/C/中搜索..."><svg t="1705074644177" class="icon search-icon" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc multi" id="data-toc" collapse="false"><div class="widget-header cap dis-select"><span class="name">函数</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%87%BD%E6%95%B0.html#start"><span class="toc-text">函数</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A5%E5%8F%A3.html"><span class="toc-text">函数的入口</span></a></div></div><div class="widget-header cap dis-select"><span class="name">基本数据类型</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B.html"><span class="toc-text">整数类型和浮点类型</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.html"><span class="toc-text">字符和字符串</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html"><span class="toc-text">全局变量和局部变量</span></a></div></div><div class="widget-header cap dis-select"><span class="name">构造数据类型</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E6%95%B0%E7%BB%84.html"><span class="toc-text">数组</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84.html"><span class="toc-text">多维数组</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E7%BB%93%E6%9E%84%E4%BD%93.html"><span class="toc-text">结构体</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/C/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.html"><span class="toc-text">字节对齐</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> sizeof运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-text"> 字节对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text"> 为什么需要内存对齐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="toc-text"> 对齐规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99%E5%B0%8F%E7%BB%93"><span class="toc-text"> 对齐规则小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text"> 例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text"> 参考</span></a></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84.html"><span class="toc-text">结构体数组</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E8%81%94%E5%90%88%E4%BD%93.html"><span class="toc-text">联合体</span></a></div></div><div class="widget-header cap dis-select"><span class="name">指针数据类型</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E6%8C%87%E9%92%88%E7%89%B9%E5%BE%81%E6%8E%A2%E6%B5%8B.html"><span class="toc-text">指针特征探测</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%8F%96%E5%9D%80%E5%92%8C%E5%8F%96%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6.html"><span class="toc-text">取址&运算符和取值*运算符</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E7%94%A8%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84.html"><span class="toc-text">用指针操作数组</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2.html"><span class="toc-text">指针与字符串</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84.html"><span class="toc-text">指针数组</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88.html"><span class="toc-text">结构体指针</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88.html"><span class="toc-text">多级指针</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88.html"><span class="toc-text">数组指针</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88.html"><span class="toc-text">函数指针</span></a></div></div><div class="widget-header cap dis-select"><span class="name">流程控制语句</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5.html"><span class="toc-text">分支语句</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5.html"><span class="toc-text">循环语句</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/Switch%E8%AF%AD%E5%8F%A5.html"><span class="toc-text">Switch语句</span></a></div></div><div class="widget-header cap dis-select"><span class="name">其他</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"><span class="toc-text">运算符和表达式</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/typedef.html"><span class="toc-text">typedef</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E9%A2%84%E5%A4%84%E7%90%86.html"><span class="toc-text">预处理</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE.html"><span class="toc-text">内存分配与释放</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/C/%E9%9A%8F%E6%89%8B%E8%AE%B0%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0.html"><span class="toc-text">随手记一些函数</span></a></div></div></widget>

<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多：计算机基础</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/Assembly_Language/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8_%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99.html"><span class="title">汇编语言</span><span class="excerpt">x86汇编笔记：以滴水三期_汇编语言课程为框架，《汇编语言4th-王爽》和《汇编语言-基于x86处理器-第七版》为补充。</span></a><a class="item wiki" href="/wiki/C++/%E5%B0%81%E8%A3%85%E5%92%8Cthis%E6%8C%87%E9%92%88.html"><span class="title">C++</span><span class="excerpt">滴水三期_C++语言笔记，C++能做的C都能做，只不过如果使用C++，可以节省很多时间，因为编译器帮编程人员做了很多工作，让编程人员省事。学习的目标：相对于C，编译器替我们做了哪些工作。</span></a><a class="item wiki" href="/wiki/Modern_C++/%E7%B1%BB.html"><span class="title">Modern C++</span><span class="excerpt">C++98及其之前的C++ 特性称之为traditional C++（传统C++），C++11/14/17/20被称为Modern C++（现代 C++ ）。补充从传统C++“升级”到现代C++的知识。</span></a><a class="item wiki" href="/wiki/Proxy_Protocols/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86_%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8A%80%E6%9C%AF.html"><span class="title">科学上网技术</span><span class="excerpt">从正常网络通信数据包通信过程出发，逐步推导到使用代理协议进行科学上网，随后依次介绍各代理协议ss、trojan、vmess、vless原理与节点搭建，还有相关的工具、技术、概念介绍。</span></a><a class="item wiki" href="/wiki/Thinking_in_C++/Pointers.html"><span class="title">Thinking in C++</span><span class="excerpt">《Thinking in C++ vol 1》笔记，知识内化后的输出，少部分是摘抄，少用的细节不做记录用时在查，参考视频：《面向对象程序设计_C++_翁恺老师》。</span></a><a class="item wiki" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html"><span class="title">Windows API编程</span><span class="excerpt">滴水三期_win32 api笔记，学习Windows API编程的困难并不在于函数参数参数众多或者英文不好这类表象原因，而是需要从Windows系统的整体知识架构出发来学习这些API，深入理解每个参数背后的含义和背景。如此，未来查阅MSDN时便不再像是看天书。</span></a><a class="item wiki" href="/wiki/representation_and_computation_of_data/%E8%BF%9B%E5%88%B6.html"><span class="title">数据的运算与表示</span><span class="excerpt">滴水三期_进制笔记，学习与理解进制、数据宽度、数的表示、位运算等概念。</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      
  





      


<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">项目</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/C/%E5%87%BD%E6%95%B0.html">C</a></div><div id="post-meta">
    <span>更新于&nbsp;<time datetime="2023-10-17T02:27:55.000Z">2023-10-17</time></span>
    </div></div></div>

<article class='md-text content wiki'>
<h1 class="article-title"><span>字节对齐</span></h1>
<h2 id="sizeof运算符"><a class="markdownIt-Anchor" href="#sizeof运算符"></a> sizeof运算符</h2>
<p><code>sizeof</code>运算符以字节为单位返回运算对象的大小。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float），则必须用圆括号将其括起来。</p>
<p>C语言规定，<code>sizeof</code>返回<code>size_t</code>类型的值。这是一个无符号整数类型，<code>size_t</code>是语言定义的标准类型。在C头文件中，用了typedef将<code>size_t</code>作为<code>unsigned int</code>或<code>unsigned long</code>的别名，在使用<code>size_t</code>类型时，编译器根据不同的系统替换标准类型。</p>
<p>C99做了进一步调整，新增了%zd转换说明用于printf()显示size_t类型的值。如果系统不支持%zd，可使用%u或%lu代替%zd。</p>
<div class="tag-plugin tabs" align="center"id="tab_11"><div class="nav-tabs"><div class="tab active"><a href="#tab_11-1">基本类型</a></div><div class="tab"><a href="#tab_11-2">数组</a></div><div class="tab"><a href="#tab_11-3">结构体</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_11-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)); 	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>));	<span class="comment">//短整型，short的完整写法</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));   	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">int</span>));	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(__int64));	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">float</span>));	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">double</span>));	</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(x));	</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231017112451425.png" alt="image-20231017112451425" /></p></div><div class="tab-pane" id="tab_11-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line"><span class="type">short</span> arr2[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line"><span class="type">int</span> arr3[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line">	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr1));	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr2));	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr3));	</span><br><span class="line">	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr1[<span class="number">10</span>]));	<span class="comment">//打印arr1数组第10个元素的大小，虽然越界了，还是能打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr2[<span class="number">10</span>]));	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr3[<span class="number">10</span>]));	</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231017112829041.png" alt="image-20231017112829041" /></p></div><div class="tab-pane" id="tab_11-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    S1 x;</span><br><span class="line">    S2 y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(y));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(S1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(S2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231017113640770.png" alt="image-20231017113640770" /></p></div></div></div>
<h2 id="字节对齐"><a class="markdownIt-Anchor" href="#字节对齐"></a> 字节对齐</h2>
<p>现代计算机的内存是以byte为基本单元，这让程序员误以为数据可以存放在任何起始地址，但实际上并不是这样。</p>
<blockquote>
<p>The chips in your computer are very good at working with fixed-size numbers. This is the reason why the basic integer types in C grow in powers of two (<code>char</code> = 1 byte, <code>short</code> = 2 bytes, <code>int</code> = 4 bytes, <code>long</code> = 8 bytes). But it further turns out that the computer can only work efficiently if these fixed-size numbers are <em>aligned</em> at specific addresses in memory.</p>
<p>参考：<a target="_blank" rel="noopener" href="https://cs.brown.edu/courses/csci1310/2020/notes/l05.html">Lecture 5: Structures and Alignment</a></p>
</blockquote>
<p>简单点说，因为计算机用二进制数，对2的幂次方的数据处理起来更高效。如果我们将这些固定大小的变量类型（fixed-size numbers）放在特定的地址上，而不是按顺序一个接着一个存放，这样计算机处理起来会更高效。</p>
<p>实际上，每个对象（Object）除了有大小（size）之外，还有对齐要求（alignment requirement）的属性，The alignment means that <strong>all objects of this type must start at an address divisible by the alignment</strong>. In other words, an integer with size 4 and alignment 4 must always start at an address divisible by 4.</p>
<p>字节对齐，实际上是变量起始内存地址的对齐，编译器并不让object连续地紧挨在一起，而是会安排每个pbject在内存中的排布，让每个object都满足它的alignment requirement（对齐于一个能被它的alignment整除的地址上，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mtext> </mtext><mi mathvariant="normal">%</mi><mtext> </mtext><mi>a</mi><mi>l</mi><mi>i</mi><mi>g</mi><mi>n</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">adress\ \% \ alignment=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94444em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord">%</span><span class="mspace"> </span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>），这是一种以空间换取时间的策略。两个objec之间的空隙，编译器会填充一些无效的字节（padding）。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/598708950">字节对齐与填充（Data Alignment and Padding In C）</a></p>
</blockquote>
<h3 id="为什么需要内存对齐"><a class="markdownIt-Anchor" href="#为什么需要内存对齐"></a> 为什么需要内存对齐？</h3>
<p>非对齐的内存访问（unaligned memory access），其影响因处理器体系结构而异。</p>
<ul>
<li>
<p>一些处理器根本就不支持非对齐的内存访问，一旦访问就抛出异常</p>
<blockquote>
<p>增加对非对齐地址访问的能力，会增加电路复杂性。增加budget。这些电路设计原本可以用于处理更多的数据或设计为其他功能。</p>
</blockquote>
</li>
<li>
<p>一些处理器能处理非对齐内存访问的情况，但这需要额外的访存次数，会使性能下降</p>
</li>
<li>
<p>一些处理器支持非对齐内存访问，而且没有明显的性能损失</p>
</li>
</ul>
<p>一般而言，数据对齐的目的，是为了减少cpu访存次数，提高系统性能。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。</p>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>内存的设计特性</span></summary><div class="body"><blockquote><p>大概看一下就好了，深入下去要了解内存的硬件组成</p></blockquote><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/479476352/answer/2483053419">内存为什么要字节对齐？ - 知乎</a></p><p>内存读写是并行的，而不是串行的。</p><p>这里先提一下访问一块内存具体的过程，假如我去访问[00~31]32bit大小内存，意味着需要在内存条上找32个存储单元，找32个bit内存，那整个过程是依次串行去找的吗？先找第一个，然后找第二个，…，直到找到32个？如果去访问64bit的话那就要串行收集64次！串行找太慢了！！</p><p>实际上，<strong>内存读写是并行的</strong></p><p>拿出你的内存条，你会发现内存条上有存储芯片颗粒，或为8个，或为16个或4个。一般单个颗粒称为一个chip，而一个chip有多个bank，比如8个，cpu会把所有在线的内存，每一个颗粒都选取一样数目的bit，集合成一个cpu位宽，比如64bit，可能由你内存条上8个颗粒每一个都提供8bit。所以，在 [00~63] 或 [63~127]，这样单个成为cpu位宽的成为单次读写访问的数据，就是按64位对齐的！无法更改！访问某对齐地址上64个bit，可能由8个内存chip，每一个chip的8个bank各自提供一个bit，在同一时间快速就集齐64bit！并行这种思维在ic里是很常见的。</p><p>所以内存的设计特性决定了，需要进行内存对齐。</p></div></details><details class="folder" index="1"><summary><span>cache命中</span></summary><div class="body"><p>实际上，cpu取数据，会先到cache中读取，如果miss，才从内存读取。如果不对齐，一小块cache line没法将需要的数存进去，又浪费了cache</p></div></details><details class="folder" index="2"><summary><span>拓展阅读：不同内存访问粒度的情况下，CPU是如何访问的</span></summary><div class="body"><blockquote><p>参考：<a target="_blank" rel="noopener" href="https://developer.ibm.com/articles/pa-dalign/">Data alignment: Straighten up and fly right</a></p></blockquote><div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e092ff.png" />Processor's memory access granularity<img class="icon suffix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e0ab55.png" /></p></div><div class="tag-plugin colorful note" ><div class="title">本小节能回答以下疑问：</div><div class="body"><p>如果我将一个int类型变量的起始地址放在地址1处（奇数地址，没有对齐），然后让CPU从地址1开始读取，不也就能通过一次访问就读取到了数据吗？</p></div></div><p>内存以byte作为基本单元，这让程序员习惯性地认为不同类型的数据可以随意存储在内存的任意地址上（如下图），但事实并非如此。这是因为cpu的硬件原因，cpu访问内存不是以字节块（chunks）为大小作为单位进行访问，而是以2、4、8、16甚至32字节为单位访问内存。这个大小称为内存访问粒度（memory access granularity）。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/howProgrammersSeeMemory-16975976730481.jpg" alt="How Programmers See Memory" /></p><p>在cpu此硬件特性上，假设编译器在编译时不作数据对齐的工作，而允许数据任意存放。我们做这么一个实验：</p><ul><li>储存方式1：假设一个4字节的数据存储在起始地址0上</li><li>储存方式2：假设一个4字节的数据存储在起始地址1上</li></ul><p>在不同的内存访问粒度（memory access granularity）下，观察分别从地址0和地址1读取4字节到寄存器中所需要的内存访问次数以及耗费时间。</p><table><thead><tr><th></th><th>Single-byte memory access granularity</th><th>Double-byte memory access granularity</th><th>Quad-byte memory access granularity</th></tr></thead><tbody><tr><td>从地址0开始依次读取4字节到寄存器中</td><td></td><td></td><td></td></tr><tr><td>从地址1开始依次读取4字节到寄存器中</td><td></td><td></td><td></td></tr></tbody></table><div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />Single-byte memory access granularity</p></div><p>当内存访问粒度为1字节时，cpu从内存读取数据的行为如下：</p><ul><li>储存方式1：依次读取地址0，地址1，地址2，地址3的数据。</li><li>储存方式2：依次读取地址1，地址2，地址3，地址4的数据。</li></ul><p>在该内存访问粒度下，无论数据是以储存方式1还是储存方式2存储，cpu访问内存的次数一样。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/singleByteAccess-16975988799594.jpg" alt="Single-byte memory access granularity" /></p><div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />Double-byte memory access granularity</p></div><p>当内存访问粒度为2字节时，从内存读取数据的行为如下：</p><ul><li>储存方式1：从地址0开始读取2字节数据-&gt;从地址2开始读取2字节数据</li><li>储存方式2：从地址0开始读取2字节数据-&gt;从地址2开始读取2字节数据-&gt;从地址3开始读取2字节数据，丢弃地址0和地址5的数据，拼接地址1到地址4一共4字节数据到寄存器中。</li></ul><blockquote><p>⚠️在该内存访问粒度下，cpu只会从能被2整除的地址开始读取，比如从地址0开始读取，从地址2开始读取…，从地址2n开始读取…。</p></blockquote><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/doubleByteAccess-16975991984817.jpg" alt="Double-byte memory access granularity" /></p><p>对于储存方式1，内存访问粒度为2字节会比内存访问粒度为1字节少一半的内存访问次数。因为每次内存访问会产生固定的开销，减少了次数就是提高了性能。</p><p>然而，对于储存方式2，由于这4字节数据不能很好地落在cpu的访问边界上，cpu作了额外的访问次数。</p><div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />Quad-byte memory access granularity</p></div><p>当内存访问粒度为4字节时，从内存读取数据的行为如下：</p><ul><li>储存方式1：从地址0开始读取4字节数据。</li><li>储存方式2：从地址0开始读取4字节数据-&gt;从地址4开始读取4字节数据，丢弃地址0和地址5、6、7的数据，拼接地址1到地址4一共4字节数据到寄存器中。</li></ul><blockquote><p>⚠️在该内存访问粒度下，cpu只会从能被4整除的地址开始读取，比如从地址0开始读取，从地址2开始读取…，从地址4n开始读取…。</p></blockquote><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/quadByteAccess.jpg" alt="Quad-byte memory access granularity" /></p><p>在该内存访问粒度下，储存方式2仍比存储方式1多了额外的内存访问次数。</p><p>综上，理论上，增大cpu每次的内存访问粒度，就可以减少访问次数，也就提高了性能。但如果不对数据存放的地址进行对齐，还随意存在非对齐地址上，增大的内存访问粒度这一特点反而会变成短板，通过增加内存访问粒度带来的性能提升会被抵消甚至变成劣势。</p><div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e092ff.png" />how processors handle unaligned memory acess<img class="icon suffix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e0ab55.png" /></p></div><p>在前面的实验中，像地址1这样的地址就被称为非对齐地址（unaligned address）。A processor has to perform some tricks when instructed to access an unaligned address.回到内存访问粒度为4字节的实验中，当cpu访问地址1时，采取的tricks如下：<br />The processor needs to read the first chunk of the unaligned address and shift out the “unwanted” bytes from the first chunk. Then it needs to read the second chunk of the unaligned address and shift out some of its information. Finally, the two are merged together for placement in the register. It’s a lot of work.</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/unalignedAccess.jpg" alt="How processors handle unaligned memory access" /></p><p>但是，要知道，一些处理器是无法处理访问非线性地址的情况！比如，original 68000处理器，它是一个内存访问粒度为2的处理器，当它访问非对齐地址时，由于缺少处理这种情况下的电路，会直接抛出异常，如果是Mac OS系统，会让用户重启机器。后面新出的680x0系列处理器，比如68020，就解除了这种限制，使得处理器能够处理访问非对齐地址的情况。但为了能处理非对齐地址，需要增加处理器的晶体管（transistors）数量，这会增加成本（transistor budget），而这些预算本来可以用来加快处理器其他部分的工作速度或新增其他功能。 MIPS处理器直接就不支持非对齐内存地址的访问，把这些预算投入到处理速度上。</p><p>PowerPC用的是混合方法，为非对齐的32位整数提供硬件支持。虽然访问非对齐仍会对性能造成影响，但这种影响被降低了很多。但另一方面，现代PowerPC处理器缺乏对未对齐64位浮点数访问的硬件支持。当要求从内存中加载未对齐的浮点数时，现代PowerPC处理器会抛出异常，让操作系统在软件中执行对齐工作，在软件中执行对齐会比在硬件中执行慢得多。</p></div></details></div>
<h3 id="对齐规则"><a class="markdownIt-Anchor" href="#对齐规则"></a> 对齐规则</h3>
<div class="tag-plugin quot"><p class="content" type="text">规则一：内置类型的对齐值</p></div>
<p>在默认情况下（即不指定对齐要求），对于内置类型，比如char，short，int，指针等等，其对齐值=（sizeof的结果），又称自然对齐。</p>
<p>一个内置类型变量的宽度为n个字节，则该变量的起始地址是n的整数倍。即<code>存放起始地址%n=0</code>。This applies independently of whether the object is inside a collection, such as a struct or array, or not.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Size</th>
<th>Address restriction</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1</td>
<td>No restriction</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>Multiple of 2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>Multiple of 4</td>
</tr>
<tr>
<td>long int</td>
<td>4</td>
<td>Multiple of 4</td>
</tr>
<tr>
<td>__int64</td>
<td>8</td>
<td>Multiple of 8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>Multiple of 4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>Multiple of 8</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后缀为.c文件，.cpp全局变量从高地址到低地址分配，没细究</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="type">short</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">long</span> d;</span><br><span class="line">__int64 e;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> f;</span><br><span class="line"><span class="type">double</span> g;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">    b=<span class="number">2</span>;</span><br><span class="line">    c=<span class="number">3</span>;</span><br><span class="line">    d=<span class="number">4</span>;</span><br><span class="line">    e=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    f=<span class="number">6</span>;</span><br><span class="line">    g=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019142229455.png" alt="image-20231019142229455" /></p>
<p>应该是编译器优化了变量的地址布局，所以这里没法看出padding。算了，用这个例子可以看出变量的起始地址都是变量宽度的整数倍，是对齐的。</p>
<div class="tag-plugin quot"><p class="content" type="text">规则二：结构体或类的对齐值</p></div>
<p>结构体变量的<strong>起始地址</strong>是所有成员中最宽的数据类型的整数倍。假设一个结构体有成员1，成员2…，则该结构体变量的<code>存放起始地址%max&#123;成员1的宽度，成员2的宽度，...&#125;=0</code>。</p>
<blockquote>
<p>有数组的话，是看数组的基本数据类型，而不是整个数组的长度。很好记，假如结构体有<code>char [7]</code>成员，不可能按7对齐吧。</p>
</blockquote>
<blockquote>
<p>如果一个结构里有结构体成员，则该结构体成员的对齐值为内部最宽数据类型的宽度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">double</span> c;   <span class="comment">//最宽的数据类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">d</span>;</span>        <span class="comment">//这个成员以8字节进行对齐</span></span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还会影响到的：</span></span><br><span class="line"><span class="comment">//结构体A的整个大小要是8的倍数，因为最宽的成员为B，是8</span></span><br><span class="line"><span class="comment">//这是后面规则三的内容</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>.c文件下不允许声明空结构体，.cpp文件可以声明空结构体和空类，空结构体和空类大小为1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test_1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;v_1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test_2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    __int64 b;</span><br><span class="line">&#125;v_2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line"></span><br><span class="line">    v_1.a=<span class="number">1</span>;</span><br><span class="line">    v_1.b=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    v_2.a=<span class="number">3</span>;</span><br><span class="line">    v_2.b=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019142445508.png" alt="image-20231019142445508" /></p>
<p>上述例子可以看出结构体变量的起始地址是所有成员中最宽的数据类型的整数倍。<code>Test_1</code>结构体变量的对齐值是4，<code>Test_2</code>结构体变量的对齐值是8。</p>
<p>另外，在结构体中的变量也遵守规则一，即结构体中各个变量的起始地址也要对齐自身的数据类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;v_1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    __int64 b;</span><br><span class="line">&#125;v_2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line"></span><br><span class="line">    v_1.a=<span class="number">1</span>;</span><br><span class="line">    v_1.b=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    v_2.a=<span class="number">3</span>;</span><br><span class="line">    v_2.b=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-30s%-10s%-20s%-10s\n&quot;</span>, <span class="string">&quot;结构体成员的数据类型&quot;</span>, <span class="string">&quot;size&quot;</span>, <span class="string">&quot;成员起始address&quot;</span>, <span class="string">&quot;成员起始地址能否被size整除&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-30s%-10lu%-20p%-10s\n&quot;</span>, <span class="string">&quot;char&quot;</span>, <span class="keyword">sizeof</span>(v_1.a), &amp;(v_1.a), ((<span class="type">size_t</span>)&amp;(v_1.a) % <span class="keyword">sizeof</span>(v_1.a)) == <span class="number">0</span> ? <span class="string">&quot;能&quot;</span> : <span class="string">&quot;不能&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-30s%-10lu%-20p%-10s\n&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="keyword">sizeof</span>(v_1.b), &amp;(v_1.b), ((<span class="type">size_t</span>)&amp;(v_1.b) % <span class="keyword">sizeof</span>(v_1.b)) == <span class="number">0</span> ? <span class="string">&quot;能&quot;</span> : <span class="string">&quot;不能&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-30s%-10lu%-20p%-10s\n&quot;</span>, <span class="string">&quot;char&quot;</span>, <span class="keyword">sizeof</span>(v_2.a), &amp;(v_2.a), ((<span class="type">size_t</span>)&amp;(v_2.a) % <span class="keyword">sizeof</span>(v_2.a)) == <span class="number">0</span> ? <span class="string">&quot;能&quot;</span> : <span class="string">&quot;不能&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-30s%-10lu%-20p%-10s\n&quot;</span>, <span class="string">&quot;__int64&quot;</span>, <span class="keyword">sizeof</span>(v_2.b), &amp;(v_2.b), ((<span class="type">size_t</span>)&amp;(v_2.b) % <span class="keyword">sizeof</span>(v_2.b)) == <span class="number">0</span> ? <span class="string">&quot;能&quot;</span> : <span class="string">&quot;不能&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看Test结构体，char类型从00427E30开始，占1个字节。然后编译器考虑放int类型的成员，但此时00427E31这个地址不能%4=0，于是填充3个字节，直到00427E34处，放置int类型的成员。</p>
<p>Test2结构体同理。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019143238396.png" alt="image-20231019143238396" /></p>
<div class="tag-plugin quot"><p class="content" type="text">规则三：整个结构体的大小</p></div>
<p>整个结构体的大小需要是内部成员中最宽的数据类型的整数倍，即<code>sizeof（结构体）%max&#123;成员1的宽度，成员2的宽度，...&#125;=0</code>。</p>
<blockquote>
<p>有数组的话，是看数组的基本数据类型，而不是整个数组的长度。很好记，假如结构体有<code>char [7]</code>成员，不可能按7对齐吧。</p>
</blockquote>
<p>有如下结构体，按照我们上面讲述的规则一和规则二来分析，只能分析出该结构体占9个字节，但实际上占12个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">//1+3</span></span><br><span class="line">    <span class="type">int</span> b;      <span class="comment">//4</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">//1</span></span><br><span class="line">    	        <span class="comment">//1 +  3??</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019144950799.png" alt="image-20231019144950799" /></p>
<p>这是因为要满足规则三。之所以编译器在后面补充3个字节，是为了实现结构数组的存取效率。试想如果定义一个结构A的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x00009，这显然不能满足结构体起始地址的对齐。因此要把结构体补充成有效对齐大小的整数倍。</p>
<blockquote>
<p>其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。</p>
</blockquote>
<hr />
<p>当内存空间比较宝贵，或有其他条件要求时，可修改编译器的对齐值。</p>
<ol>
<li>
<p>VC<ins>下，在Project-&gt;setting，C</ins>选项卡，Category的<code>Code Generation</code>，在<code>Struct Member Alignment</code>中修改。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231020113150876.png" alt="image-20231020113150876" /></p>
</li>
<li>
<p>在代码中使用<code>#pragma pack(value)</code>指定对齐值。</p>
</li>
</ol>
<ul>
<li>使用伪指令#pragma pack(value)：C编译器将按照value个字节对齐，value需是2的幂次方，可设定为1、2、4、8，VC编译器默认是8。</li>
<li>使用伪指令#pragma pack()： 取消自定义字节对齐方式。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     </span><br><span class="line">    <span class="type">int</span> b;      </span><br><span class="line">    <span class="type">char</span> c;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<p>⚠️#pragma pack(value)影响的是结构体中<u>成员的对齐方式</u>，而不影响结构体起始地址</u>的对齐方式。</p>
<div class="tag-plugin quot"><p class="content" type="text">规则四：加入指定对齐值后的变化</p></div>
<p>由于手动指定了程序的对齐值。当计算结构体中成员的对齐值时，<code>#pragma pack(value)</code>的对齐值会与<code>规则一</code>冲突，此时，有两种选择，要么是<code>程序指定的对齐值</code>，要么是<code>内置类型的对齐值</code>，此时取两者最小值，即<code>min&#123;指定对齐值，内置类型的对齐值&#125;</code>。</p>
<p>由于手动指定了程序的对齐值。当计算整个结构体大小的对齐值时，<code>#pragma pack(value)</code>的对齐值会与<code>规则二</code>冲突，此时，有两种选择，要么是<code>程序指定的对齐值</code>，要么是<code>结构体成员中最宽的数据类型的整数倍</code>。此时取两者之间最小值，即<code>min&#123;指定对齐值，结构体成员中最宽的数据类型的整数倍&#125;</code>。</p>
<blockquote>
<p>因为是取min，所以如果#pragma pack(value)的指定对齐值比<code>结构体成员内置类型的对齐值</code>和<code>结构体成员中最宽的数据类型</code>都大的话，实际上也就没起作用。</p>
</blockquote>
<p><strong>例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     </span><br><span class="line">    <span class="type">int</span> b;      </span><br><span class="line">    <span class="type">char</span> c;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     </span><br><span class="line">    <span class="type">int</span> b;      </span><br><span class="line">    <span class="type">char</span> c;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     </span><br><span class="line">    <span class="type">int</span> b;      </span><br><span class="line">    <span class="type">char</span> c;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019170541525.png" alt="image-20231019170541525" /></p>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>代码输出各成员偏移</span></summary><div class="body"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET(st, field)     (size_t)&amp;(((st*)0)-&gt;field)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     </span><br><span class="line">    <span class="type">int</span> b;      </span><br><span class="line">    <span class="type">char</span> c;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     </span><br><span class="line">    <span class="type">int</span> b;      </span><br><span class="line">    <span class="type">char</span> c;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     </span><br><span class="line">    <span class="type">int</span> b;      </span><br><span class="line">    <span class="type">char</span> c;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct A: %lu\n  a-%lu, b-%lu, c-%lu\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(<span class="keyword">struct</span> A), OFFSET(<span class="keyword">struct</span> A, a), OFFSET(<span class="keyword">struct</span> A, b), OFFSET(<span class="keyword">struct</span> A, c));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct B: %lu\n  a-%lu, b-%lu, c-%lu\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(<span class="keyword">struct</span> B), OFFSET(<span class="keyword">struct</span> B, a), OFFSET(<span class="keyword">struct</span> B, b), OFFSET(<span class="keyword">struct</span> B, c));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct C: %lu\n  a-%lu, b-%lu, c-%lu\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(<span class="keyword">struct</span> C), OFFSET(<span class="keyword">struct</span> C, a), OFFSET(<span class="keyword">struct</span> C, b), OFFSET(<span class="keyword">struct</span> C, c));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                               <span class="comment">//常量0</span></span><br><span class="line">(st *)<span class="number">0</span>                         <span class="comment">//转为st指针类型</span></span><br><span class="line">((st *)<span class="number">0</span>)-&gt;field                <span class="comment">//取st结构体中的field成员的值</span></span><br><span class="line">&amp; (((st *)<span class="number">0</span>)-&gt;field)            <span class="comment">//取field成员的地址，类型为field成员的类型加上一个*号；这是一个值</span></span><br><span class="line">(<span class="type">size_t</span>) &amp; (((st *)<span class="number">0</span>)-&gt;field)   <span class="comment">//将field成员地址这个值转为size_t类型</span></span><br></pre></td></tr></table></figure><p>用OFFSET宏来获取每个成员在结构体中的偏移量。工作原理：</p><ul><li>首先将地址0转换为结构体类型的指针</li><li>然后获取结构体成员的地址</li><li>由于这个地址是相对于结构体起始地址，所以这个地址就是成员的偏移地址。</li></ul></blockquote><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019153405715.png" alt="image-20231019153405715" /></p></div></details></div>
<h3 id="对齐规则小结"><a class="markdownIt-Anchor" href="#对齐规则小结"></a> 对齐规则小结</h3>
<p>上面的概念利于给初学者进行讲解和理解，但如果从整个结构体起始地址、成员地址、尾部成员填充的思考路线来看，以下总结的对齐准则更合适。</p>
<ol>
<li>结构体变量的首地址能够被其<strong>最宽</strong>基本类型成员的大小所整除；</li>
<li>结构体每个成员相对结构体首地址的偏移量(offset)都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mtext>指定对齐值，成员自身对齐值</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">min\{指定对齐值，成员自身对齐值\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">{</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">齐</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">员</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">身</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">齐</span><span class="mord cjk_fallback">值</span><span class="mclose">}</span></span></span></span>大小的整数倍。如有需要，编译器会在成员之间加上填充字节（internal padding）；</li>
<li>结构体的总大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mtext>指定对齐值，结构体中最宽基本类型成员大小的对齐值</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">min\{指定对齐值，结构体中最宽基本类型成员大小的对齐值\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">{</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">齐</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">构</span><span class="mord cjk_fallback">体</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">宽</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">员</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">齐</span><span class="mord cjk_fallback">值</span><span class="mclose">}</span></span></span></span>大小的整数倍。如有需要，编译器会在最末一个成员之后加上填充字节（trailing padding）。</li>
</ol>
<p>对以上三条规则的说明如下：</p>
<p>第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</p>
<p>第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mtext>指定对齐值，成员自身对齐值</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">min\{指定对齐值，成员自身对齐值\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">{</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">齐</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">员</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">身</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">齐</span><span class="mord cjk_fallback">值</span><span class="mclose">}</span></span></span></span>大小的整数倍。若是，则直接存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</p>
<p>第三条：给最后一个成员分配完地址后，还需要检查目前整个结构体的大小是否是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mtext>指定对齐值，结构体中最宽基本类型成员大小的对齐值</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">min\{指定对齐值，结构体中最宽基本类型成员大小的对齐值\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">{</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">齐</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">构</span><span class="mord cjk_fallback">体</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">宽</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">员</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">齐</span><span class="mord cjk_fallback">值</span><span class="mclose">}</span></span></span></span>大小的整数倍，如果不是，编译器会在最末一个成员之后继续填充字节。</p>
<p>补充：</p>
<ul>
<li>结构体成员有数组，是看数组的基本类型，而不是整个数组的长度</li>
<li>结构体A中有结构体B成员，则结构体B的对齐值为结构体B中最宽的成员的对齐值</li>
<li>空结构体和空类的大小为1</li>
</ul>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3>
<p>根据上面小结的三条对齐规则完成下面的例题。</p>
<blockquote>
<p>这里我出的题，直接就按自然对齐来出题；如果有指定对齐值，一样的，第二条、第三条就取min。</p>
</blockquote>
<p>例1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>答案</span></summary><div class="body"><p>答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">//1 + 3</span></span><br><span class="line">    <span class="type">int</span> b;      <span class="comment">//4</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">//1 + 3</span></span><br><span class="line">&#125;;              <span class="comment">//总大小12</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET(st, field)     (size_t)&amp;(((st*)0)-&gt;field)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct A: %lu\n  a-%lu, b-%lu, c-%lu\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(<span class="keyword">struct</span> A), OFFSET(<span class="keyword">struct</span> A, a), OFFSET(<span class="keyword">struct</span> A, b), OFFSET(<span class="keyword">struct</span> A, c));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019171932939.png" alt="image-20231019171932939" /></p><p>分析过程：</p><p>结构体中成员的最宽数据类型是int类型，4字节。</p><p>第一条：结构体起始地址能被4整除。</p><p>第二条：</p><ol><li>第1个成员a，分配1字节。</li><li>第2个成员b，相对结构体起始地址偏移是1，不能被4整除，要在成员a后面填充3个字节。</li><li>第3个成员c，相对结构体起始地址偏移是8，能被1整除，不填充。</li></ol><p>第三条：目前整个结构体大小是4+4+1=9，不能整除4，要在尾部填充3字节。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019171231281.png" alt="image-20231019171231281" /></p><blockquote><p>实际分析的话，直接写就行了。不用画图，这里画图只是为了直观展示。</p></blockquote></div></details></div>
<p>例2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="type">char</span> e[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>答案</span></summary><div class="body"><blockquote><p>数组还是看char类型，而不是数组总长度</p></blockquote><p>答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">//1 + 1</span></span><br><span class="line">    <span class="type">short</span> b;    <span class="comment">//2</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">//1 + 3</span></span><br><span class="line">    <span class="type">int</span> d;      <span class="comment">//4</span></span><br><span class="line">    <span class="type">char</span> e[<span class="number">6</span>];  <span class="comment">//6 + 2</span></span><br><span class="line">&#125;;              <span class="comment">//总大小：20</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET(st, field) (size_t) &amp; (((st *)0)-&gt;field)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">//1 + 1</span></span><br><span class="line">    <span class="type">short</span> b;    <span class="comment">//2</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">//1 + 3</span></span><br><span class="line">    <span class="type">int</span> d;      <span class="comment">//4</span></span><br><span class="line">    <span class="type">char</span> e[<span class="number">6</span>];  <span class="comment">//6 + 2</span></span><br><span class="line">&#125;;              <span class="comment">//总大小：20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct A: %lu\n  a-%lu, b-%lu, c-%lu, d-%lu\n  e[0]-%lu, e[1]-%lu, e[2]-%lu\n e[3]-%lu, e[4]-%lu, e[5]-%lu\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(<span class="keyword">struct</span> A), OFFSET(<span class="keyword">struct</span> A, a), OFFSET(<span class="keyword">struct</span> A, b),</span><br><span class="line">           OFFSET(<span class="keyword">struct</span> A, c), OFFSET(<span class="keyword">struct</span> A, d), OFFSET(<span class="keyword">struct</span> A, e[<span class="number">0</span>]),</span><br><span class="line">           OFFSET(<span class="keyword">struct</span> A, e[<span class="number">1</span>]), OFFSET(<span class="keyword">struct</span> A, e[<span class="number">2</span>]), OFFSET(<span class="keyword">struct</span> A, e[<span class="number">3</span>]),</span><br><span class="line">           OFFSET(<span class="keyword">struct</span> A, e[<span class="number">4</span>]), OFFSET(<span class="keyword">struct</span> A, e[<span class="number">5</span>]), OFFSET(<span class="keyword">struct</span> A, e[<span class="number">6</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019172848761.png" alt="image-20231019172848761" /></p></div></details></div>
<p>例3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">d</span>;</span></span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>答案</span></summary><div class="body"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;       <span class="comment">//1  +  3</span></span><br><span class="line">    <span class="type">int</span> b;        <span class="comment">//4  </span></span><br><span class="line">    <span class="type">double</span> c;     <span class="comment">//8</span></span><br><span class="line">&#125;;                <span class="comment">//总大小：16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> c;      <span class="comment">//2  +  6</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">d</span>;</span>   <span class="comment">//16</span></span><br><span class="line">    <span class="type">int</span> e;        <span class="comment">//4  +  4</span></span><br><span class="line">&#125;;                <span class="comment">//总大小：32</span></span><br></pre></td></tr></table></figure><p>结构体B成员和总大小的分析略。</p><p>下面分析结构体A：</p><ul><li><p>成员c，占2个字节。</p></li><li><p>成员d，要占16个字节。对齐值是结构体B中最宽的成员的宽度，是double类型，对齐值是8。所以要在成员c后面补6个字节</p></li><li><p>成员e，目前偏移整个结构体起始地址2+6+16=24，能被4整除，不填充，放成员e。</p></li></ul><p>尾部填充：整个结构体大小需要是成员中最宽的数据类型的倍数，最宽的是d，为8。目前是2+6+16+4=28，不能被8整除，需要填充4字节。</p><blockquote><p>为什么不是16？</p><p>不能把struct看成一个整体，要这样看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> c;        <span class="comment">//2+6</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span>        //对齐于8</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">char</span> a;     <span class="comment">//1  +  3</span></span><br><span class="line">        <span class="type">int</span> b;      <span class="comment">//4</span></span><br><span class="line">        <span class="type">double</span> c;   <span class="comment">//8</span></span><br><span class="line">    &#125;d;             <span class="comment">//总大小：16</span></span><br><span class="line">    <span class="type">int</span> e;          <span class="comment">//4  +  8 or 16??? </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而且这样展开后，也就明白了，成员d的对齐值为什么要是成员中最宽的数据类型的倍数。因为对齐于最宽，其他成员肯定就对齐了。</p></blockquote><p>所以总大小为32字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET(st, field)     (size_t)&amp;(((st*)0)-&gt;field)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">d</span>;</span></span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct B: %lu\n  a-%lu, b-%lu, c-%lu\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(<span class="keyword">struct</span> B), OFFSET(<span class="keyword">struct</span> B, a), OFFSET(<span class="keyword">struct</span> B, b), OFFSET(<span class="keyword">struct</span> B, c));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct A: %lu\n  c-%lu, d.a-%lu, d.b-%lu, d.c-%lu, e-%lu\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(<span class="keyword">struct</span> A), OFFSET(<span class="keyword">struct</span> A, c), OFFSET(<span class="keyword">struct</span> A, d.a), OFFSET(<span class="keyword">struct</span> A, d.b), OFFSET(<span class="keyword">struct</span> A, d.c), OFFSET(<span class="keyword">struct</span> A, e));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/image-20231019175553498.png" alt="image-20231019175553498" /></p></div></details></div>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<table>
<thead>
<tr>
<th><strong>链接</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.cnblogs.com/clover-toeic/p/3853132.html">C语言字节对齐问题详解</a></td>
<td>写得很详细</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/598708950">字节对齐与填充（Data Alignment and Padding In C）</a></td>
<td>写得太发散了</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://cs.brown.edu/courses/csci1310/2020/notes/l05.html">Lecture 5: Structures and Alignment</a></td>
<td>University of Washington的课，写得也很好</td>
</tr>
</tbody>
</table>



<div class="article-footer reveal fs14"></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/C/%E7%BB%93%E6%9E%84%E4%BD%93.html">结构体</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/C/%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84.html">结构体数组</a></div></section></div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">wiki</span><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a href="/wiki/tags/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a><a href="/wiki/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a><a href="/wiki/tags/%E5%85%B6%E4%BB%96/">其他</a></div><div class="sitemap-group"><span class="fs14">关于</span><a href="/about/">关于</a></div></div><div class="text"><p>本站由 <a href="/">Misc</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0">Stellar 1.25.0</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.25.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".fancybox img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->






<!-- inject -->


  </div>
</body>
</html>
