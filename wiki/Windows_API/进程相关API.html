<!DOCTYPE html>
<html lang='zh-CN'>


<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0" theme-name="Stellar" theme-version="1.25.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Windows API编程：进程相关API - Misc0101</title>

  
    <meta name="description" content="ID与句柄 使用CreateProcess创建进程时会返回一个结构体LPPROCESS_INFORMATION，里面是进程句柄，线程句柄，进程ID，线程ID字段。我们已经知道句柄就是当前进程私有句柄表里的一个索引了，那么这里就讲讲ID是什么。 123456typedef struct _PROCESS_INFORMATION &#123;  HANDLE hProcess;          &#x2F;">
<meta property="og:type" content="website">
<meta property="og:title" content="进程相关API">
<meta property="og:url" content="https://misc0101.github.io/wiki/Windows_API/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API.html">
<meta property="og:site_name" content="Misc0101">
<meta property="og:description" content="ID与句柄 使用CreateProcess创建进程时会返回一个结构体LPPROCESS_INFORMATION，里面是进程句柄，线程句柄，进程ID，线程ID字段。我们已经知道句柄就是当前进程私有句柄表里的一个索引了，那么这里就讲讲ID是什么。 123456typedef struct _PROCESS_INFORMATION &#123;  HANDLE hProcess;          &#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309205353331.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309205612936.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309212110014.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309211249630.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309211949945.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309201917249.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309201814931.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309204611951.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309204558338.png">
<meta property="article:published_time" content="2024-03-09T11:09:43.000Z">
<meta property="article:modified_time" content="2024-03-09T11:09:43.000Z">
<meta property="article:author" content="Misc0101">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://misc0101.github.io/Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309205353331.png">
  
  
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1.2em" height="1.2em" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有项目</a><a class="title" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html"><div class="main" ff="title">Windows API编程</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/Windows_API/" placeholder="在/wiki/Windows_API/中搜索..."><svg t="1705074644177" class="icon search-icon" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc multi" id="data-toc" collapse="false"><div class="widget-header cap dis-select"><span class="name">字符</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html#start"><span class="toc-text">字符编码</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AE%BD%E5%AD%97%E7%AC%A6.html"><span class="toc-text">C语言中的宽字符</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/Win32_API%E4%B8%AD%E7%9A%84%E5%AE%BD%E5%AD%97%E7%AC%A6.html"><span class="toc-text">Win32 API中的宽字符</span></a></div></div><div class="widget-header cap dis-select"><span class="name">进程</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B.html"><span class="toc-text">创建进程</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%8F%A5%E6%9F%84%E8%A1%A8.html"><span class="toc-text">句柄表</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/Windows_API/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API.html"><span class="toc-text">进程相关API</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#id%E4%B8%8E%E5%8F%A5%E6%9F%84"><span class="toc-text"> ID与句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E6%98%8E%E5%85%A8%E5%B1%80%E5%92%8C%E7%A7%81%E6%9C%89"><span class="toc-text"> 证明全局和私有</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createprocess"><span class="toc-text"> CreateProcess</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dwcreationflags"><span class="toc-text"> dwCreationFlags</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%82%E8%B5%B7%E8%BF%9B%E7%A8%8B"><span class="toc-text"> 创建挂起进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lpcurrentdirectory"><span class="toc-text"> lpCurrentDirectory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3api"><span class="toc-text"> 其他进程相关API</span></a></li></ol></div></div><div class="widget-header cap dis-select"><span class="name">线程</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B.html"><span class="toc-text">创建线程</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B.html"><span class="toc-text">控制线程</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%B8%B4%E7%95%8C%E5%8C%BA.html"><span class="toc-text">临界区（Critical Section）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%BA%92%E6%96%A5%E4%BD%93.html"><span class="toc-text">互斥体（Mutex）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%BA%8B%E4%BB%B6.html"><span class="toc-text">事件（Event）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%BF%A1%E5%8F%B7%E9%87%8F.html"><span class="toc-text">信号量（Semaphore）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.html"><span class="toc-text">线程互斥与线程同步问题</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B.html"><span class="toc-text">远程线程</span></a></div></div><div class="widget-header cap dis-select"><span class="name">窗口程序编写及逆向分析</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.html"><span class="toc-text">窗口的本质</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html"><span class="toc-text">消息队列</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F.html"><span class="toc-text">第一个窗口程序</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B.html"><span class="toc-text">消息类型</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.html"><span class="toc-text">窗口程序逆向分析</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%AD%90%E7%AA%97%E5%8F%A3.html"><span class="toc-text">子窗口</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%AD%90%E7%AA%97%E5%8F%A3%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91%E5%8F%8A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.html"><span class="toc-text">子窗口消息处理逻辑及逆向分析</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9A%E4%BD%8D.html"><span class="toc-text">对话框及回调函数定位</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%A0%87.html"><span class="toc-text">使用图标</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6.html"><span class="toc-text">通用控件</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%9E%9A%E4%B8%BE%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E5%92%8C%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98.html"><span class="toc-text">枚举窗口与模拟鼠标和模拟键盘</span></a></div></div><div class="widget-header cap dis-select"><span class="name">内存管理</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.html"><span class="toc-text">虚拟内存与物理内存</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE.html"><span class="toc-text">私有内存的申请和释放</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE.html"><span class="toc-text">共享内存的申请和释放</span></a></div></div><div class="widget-header cap dis-select"><span class="name">文件系统</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html"><span class="toc-text">文件系统</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6.html"><span class="toc-text">内存映射文件</span></a></div></div></widget>

<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多：计算机基础</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/C++/%E5%B0%81%E8%A3%85%E5%92%8Cthis%E6%8C%87%E9%92%88.html"><span class="title">C++</span><span class="excerpt">滴水三期_C++语言笔记，C++能做的C都能做，只不过如果使用C++，可以节省很多时间，因为编译器帮编程人员做了很多工作，让编程人员省事。学习的目标：相对于C，编译器替我们做了哪些工作。</span></a><a class="item wiki" href="/wiki/Assembly_Language/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8_%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99.html"><span class="title">汇编语言</span><span class="excerpt">x86汇编笔记：以滴水三期_汇编语言课程为框架，《汇编语言4th-王爽》和《汇编语言-基于x86处理器-第七版》为补充。</span></a><a class="item wiki" href="/wiki/C/%E5%87%BD%E6%95%B0.html"><span class="title">C</span><span class="excerpt">滴水三期_C语言笔记，以逆向角度看待和学习C语言，精彩点：堆栈图与指针。</span></a><a class="item wiki" href="/wiki/Modern_C++/%E7%B1%BB.html"><span class="title">Modern C++</span><span class="excerpt">C++98及其之前的C++ 特性称之为traditional C++（传统C++），C++11/14/17/20被称为Modern C++（现代 C++ ）。补充从传统C++“升级”到现代C++的知识。</span></a><a class="item wiki" href="/wiki/Thinking_in_C++/Pointers.html"><span class="title">Thinking in C++</span><span class="excerpt">《Thinking in C++ vol 1》笔记，知识内化后的输出，少部分是摘抄，少用的细节不做记录用时在查，参考视频：《面向对象程序设计_C++_翁恺老师》。</span></a><a class="item wiki" href="/wiki/Proxy_Protocols/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86_%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8A%80%E6%9C%AF.html"><span class="title">科学上网技术</span><span class="excerpt">从正常网络通信数据包通信过程出发，逐步推导到使用代理协议进行科学上网，随后依次介绍各代理协议ss、trojan、vmess、vless原理与节点搭建，还有相关的工具、技术、概念介绍。</span></a><a class="item wiki" href="/wiki/representation_and_computation_of_data/%E8%BF%9B%E5%88%B6.html"><span class="title">数据的运算与表示</span><span class="excerpt">滴水三期_进制笔记，学习与理解进制、数据宽度、数的表示、位运算等概念。</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      
  





      


<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">项目</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html">Windows API编程</a></div><div id="post-meta">
    <span>更新于&nbsp;<time datetime="2024-03-09T11:09:43.000Z">2024-03-09</time></span>
    </div></div></div>

<article class='md-text content wiki'>
<h1 class="article-title"><span>进程相关API</span></h1>
<h2 id="id与句柄"><a class="markdownIt-Anchor" href="#id与句柄"></a> ID与句柄</h2>
<p>使用CreateProcess创建进程时会返回一个结构体<strong>LPPROCESS_INFORMATION</strong>，里面是进程句柄，线程句柄，进程ID，线程ID字段。我们已经知道句柄就是当前进程私有句柄表里的一个索引了，那么这里就讲讲ID是什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">  HANDLE hProcess;          <span class="comment">//进程句柄</span></span><br><span class="line">  HANDLE hThread;           <span class="comment">//线程句柄</span></span><br><span class="line">  DWORD  dwProcessId;       <span class="comment">//进程id</span></span><br><span class="line">  DWORD  dwThreadId;        <span class="comment">//线程id</span></span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>
<p>每个进程都会有一张私有的句柄表，表里存储了当前进程创建，打开的所有内核对象。</p>
<p>实际上，操作系统还有一张句柄表，这张表是全局的。这张全局句柄表包含了操作系统中所有正运行中的进程、线程。如下图，左边那一列是索引（进程ID和线程ID），右边是存储的进程、线程内核对象地址。PROCESS_INFORMATION中的进程ID和线程ID就是这个索引号。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309205353331.png" alt="image-20240309205353331" /></p>
<p>进程ID（Process ID）可以通过任务管理器看到。这个PID号是唯一的，不会有两个进程的PID号相同。一个进程结束后，它的PID号可能分配给另一个新的进程。</p>
<p>线程ID也是唯一的，不会出现某两个线程，某个进程和某个线程，某两个进程的id号一样。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309205612936.png" alt="image-20240309205612936" /></p>
<h3 id="证明全局和私有"><a class="markdownIt-Anchor" href="#证明全局和私有"></a> 证明全局和私有</h3>
<p>PID是全局的，在任何进程中都有意义，都可以使用，而句柄则是局部的、私有的。下面让其他进程分别使用目标进程的句柄（私有的）和PID号（全局的）来关闭目标进程notepad，来证明全局和私有。</p>
<p><strong>例</strong><br />
被关闭的目标程序<br />
这个程序会启动notepad应用程序，并打印其进程ID（PID）和句柄值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建记事本进程</span></span><br><span class="line">    <span class="keyword">if</span> (!CreateProcess(</span><br><span class="line">        TEXT(<span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>),  <span class="comment">// 程序名称</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// 命令行参数</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// 进程安全属性</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// 线程安全属性</span></span><br><span class="line">        FALSE,                                       <span class="comment">// 句柄继承选项</span></span><br><span class="line">        <span class="number">0</span>,                                           <span class="comment">// 创建标志</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// 使用父进程的环境变量</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// 使用父进程的当前目录</span></span><br><span class="line">        &amp;si,                                         <span class="comment">// 指向STARTUPINFO的指针</span></span><br><span class="line">        &amp;pi                                          <span class="comment">// 指向PROCESS_INFORMATION的指针</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess failed (%d).\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Notepad launched with PID: %x\n&quot;</span>, pi.dwProcessId);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Notepad handle: %x\n&quot;</span>, pi.hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待，直到按下任意键</span></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309212110014.png" alt="image-20240309212110014" /></p>
<div class="tag-plugin tabs" align="center"id="tab_223"><div class="nav-tabs"><div class="tab active"><a href="#tab_223-1">尝试使用私有句柄终止进程</a></div><div class="tab"><a href="#tab_223-2">尝试使用PID号打开进程并结束进程</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_223-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">TerminateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HANDLE hProcess,</span></span><br><span class="line"><span class="params">  [in] UINT   uExitCode</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess?devlangs=cpp&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(PROCESSTHREADSAPI%252FTerminateProcess)%3Bk(TerminateProcess)%3Bk(DevLang-C%252B%252B)%3Bk(TargetOS-Windows)%26rd%3Dtrue">TerminateProcess</a>函数函数用于结束进程和该进程所有线程</p>
<ul>
<li>uExitCode：关闭进程后退出的ExitCode，自己指定。随后可以用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess">GetExitCodeProcess</a>函数捕捉到这个ExitCode。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess?devlangs=cpp&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(PROCESSTHREADSAPI%252FTerminateProcess)%3Bk(TerminateProcess)%3Bk(DevLang-C%252B%252B)%3Bk(TargetOS-Windows)%26rd%3Dtrue">TerminateProcess</a>函数</p>
<p>Terminates the specified process and all of its threads.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] hProcess</span><br></pre></td></tr></table></figure>
<p>A handle to the process to be terminated.</p>
<p>The handle must have the <strong>PROCESS_TERMINATE</strong> access right. For more information, see <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] uExitCode</span><br></pre></td></tr></table></figure>
<p>The exit code to be used by the process and threads terminated as a result of this call. Use the <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess">GetExitCodeProcess</a> function to retrieve a process’s exit value. Use the <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getexitcodethread">GetExitCodeThread</a> function to retrieve a thread’s exit value.</p>
</blockquote>
<p>在程序B中，将notepad的私有句柄传给<code>TerminateProcess</code>函数来尝试关掉notepad进程。因为这个句柄是notepad私有的，对程序B没有意义，所以关闭失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//输入目标程序的私有句柄</span></span><br><span class="line">    HANDLE hProcess = (HANDLE)<span class="number">0x114</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试终止进程</span></span><br><span class="line">    <span class="keyword">if</span> (!TerminateProcess(hProcess, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;TerminateProcess failed (%d).\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Notepad terminated successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309211249630.png" alt="image-20240309211249630" /></p></div><div class="tab-pane" id="tab_223-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">OpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwDesiredAccess,</span></span><br><span class="line"><span class="params">  [in] BOOL  bInheritHandle,</span></span><br><span class="line"><span class="params">  [in] DWORD dwProcessId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess?devlangs=cpp&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(PROCESSTHREADSAPI%252FOpenProcess)%3Bk(OpenProcess)%3Bk(DevLang-C%252B%252B)%3Bk(TargetOS-Windows)%26rd%3Dtrue">OpenProcess</a>函数用于打开一个已存在的进程</p>
<ul>
<li>dwDesiredAccess：打开的目标进程希望拥有什么权限</li>
<li>bInheritHandle：打开目标进程后得到的的这个句柄能否被子进程继承
<ul>
<li>如果允许，在这个程序中在创建一个子进程，子进程就可以继承这个句柄</li>
</ul>
</li>
<li>dwProcessId：目标进程的PID</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess?devlangs=cpp&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(PROCESSTHREADSAPI%252FOpenProcess)%3Bk(OpenProcess)%3Bk(DevLang-C%252B%252B)%3Bk(TargetOS-Windows)%26rd%3Dtrue">OpenProcess</a>函数</p>
<p>Opens an existing local process object.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] dwDesiredAccess</span><br></pre></td></tr></table></figure>
<p>The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights">process access rights</a>.</p>
<p>If the caller has enabled the <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants#SE_DEBUG_NAME">SeDebugPrivilege privilege</a>, the requested access is granted regardless of the contents of the security descriptor.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] bInheritHandle</span><br></pre></td></tr></table></figure>
<p>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] dwProcessId</span><br></pre></td></tr></table></figure>
<p>The identifier of the local process to be opened.</p>
<p>If the specified process is the System Idle Process (0x00000000), the function fails and the last error code is <code>ERROR_INVALID_PARAMETER</code>. If the specified process is the System process or one of the Client Server Run-Time Subsystem (CSRSS) processes, this function fails and the last error code is <code>ERROR_ACCESS_DENIED</code> because their access restrictions prevent user-level code from opening them.</p>
<p>If you are using <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocessid">GetCurrentProcessId</a> as an argument to this function, consider using <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess</a> instead of OpenProcess, for improved performance.</p>
</blockquote>
<p>通过PID号使用<code>OpenProcess</code>函数来得到一个指向notepad进程的新句柄，这个新句柄是当前进程特有的，它不同于原始进程（在这里例子中是记事本）创建时获取的句柄。因为程序中说了要用<code>PROCESS_TERMINATE</code>访问权限，这意味着得到的句柄可以用来终止目标进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填入目标进程的PID号</span></span><br><span class="line">    DWORD dwProcessId = <span class="number">0x6b2c</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用PID打开进程</span></span><br><span class="line">    hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, dwProcessId);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess failed (%d).\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试终止进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TerminateProcess(hProcess, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;TerminateProcess failed (%d).\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Notepad terminated successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309211949945.png" alt="image-20240309211949945" /></p></div></div></div>
<h2 id="createprocess"><a class="markdownIt-Anchor" href="#createprocess"></a> CreateProcess</h2>
<p>通过前面的学习已经知道了CreateProcess函数中的一些参数，现在讲下剩下的几个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCWSTR lpApplicationName,                 <span class="comment">// 要启动的程序名（要完整文件路径）</span></span></span><br><span class="line"><span class="params">    LPWSTR lpCommandLine,                      <span class="comment">// 命令行参数</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// 进程句柄是否允许/可以被继承</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">// 线程句柄是否允许/可以被继承</span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandles,                      <span class="comment">// 是否继承句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags,                     <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPVOID lpEnvironment,                      <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPCWSTR lpCurrentDirectory,                <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPSTARTUPINFOW lpStartupInfo,              <span class="comment">// 启动信息</span></span></span><br><span class="line"><span class="params">    LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// OUT参数，传出进程和线程的信息</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p><code>lpEnvironment</code>：表示当前创建进程的环境块，这个参数一般没什么用，填NULL</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, optional] lpEnvironment</span><br></pre></td></tr></table></figure>
<p>A pointer to the environment block for the new process. If this parameter is <strong>NULL</strong>, the new process uses the environment of the calling process.</p>
<p>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</p>
<p><em>name</em>=<em>value</em>\0</p>
<p>Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</p>
<p>An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by <em>lpEnvironment</em> contains Unicode characters, be sure that <em>dwCreationFlags</em> includes <strong>CREATE_UNICODE_ENVIRONMENT</strong>.</p>
<p>The ANSI version of this function, <strong>CreateProcessA</strong> fails if the total size of the environment block for the process exceeds 32,767 characters.</p>
<p>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</p>
</blockquote>
<h3 id="dwcreationflags"><a class="markdownIt-Anchor" href="#dwcreationflags"></a> dwCreationFlags</h3>
<blockquote>
<p>The flags that control the priority class and the creation of the process. For a list of values, see <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</p>
</blockquote>
<p>这个参数用于控制新进程的创建方式。比如创建想让创建的子进程单独起一个cmd输出，就将<code>dwCreationFlags</code>字段设置为<code>CREATE_NEW_CONSOLE</code></p>
<blockquote>
<p>The new process has a new console, instead of inheriting its parent’s console (the default). For more information, see <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/console/creation-of-a-console">Creation of a Console</a>.<br />
This flag cannot be used with <strong>DETACHED_PROCESS</strong>.</p>
</blockquote>
<p><strong>例</strong><br />
被调用程序A</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from Program A!\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tag-plugin tabs" align="center"id="tab_224"><div class="nav-tabs"><div class="tab active"><a href="#tab_224-1">dwCreationFlags置NULL</a></div><div class="tab"><a href="#tab_224-2">dwCreationFlags使用 CREATE_NEW_CONSOLE</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_224-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from Program B!\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程A，不使用 CREATE_NEW_CONSOLE</span></span><br><span class="line">    <span class="keyword">if</span> (!CreateProcess(</span><br><span class="line">        TEXT(<span class="string">&quot;D:/005_Codefield/VS2019/DiShui_Test/Debug/TestA.exe&quot;</span>),    <span class="comment">// 要启动的程序名</span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// 命令行参数</span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// 进程句柄不允许/可以被继承</span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// 线程句柄不允许/可以被继承</span></span><br><span class="line">        FALSE,                                                          <span class="comment">// 不继承父进程句柄</span></span><br><span class="line">        <span class="number">0</span>,                                                              <span class="comment">// 创建标志，0表示没有设置</span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// </span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// </span></span><br><span class="line">        &amp;si,                                                            <span class="comment">// 指向STARTUPINFO的指针</span></span><br><span class="line">        &amp;pi                                                             <span class="comment">// 指向PROCESS_INFORMATION的指针</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess failed (%d).\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待进程A结束</span></span><br><span class="line">    WaitForSingleObject(pi.hProcess, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭进程和线程的句柄</span></span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程就会和父进程共用一个cmd</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309201917249.png" alt="image-20240309201917249" /></p></div><div class="tab-pane" id="tab_224-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from Program B!\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程A，使用 CREATE_NEW_CONSOLE</span></span><br><span class="line">    <span class="keyword">if</span> (!CreateProcess(</span><br><span class="line">        TEXT(<span class="string">&quot;D:/005_Codefield/VS2019/DiShui_Test/Debug/TestA.exe&quot;</span>),    <span class="comment">// 要启动的程序名</span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// 命令行参数</span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// 进程句柄不允许/可以被继承</span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// 线程句柄不允许/可以被继承</span></span><br><span class="line">        FALSE,                                                          <span class="comment">// 不继承父进程句柄</span></span><br><span class="line">        CREATE_NEW_CONSOLE,                                             <span class="comment">// 创建标志，使用 CREATE_NEW_CONSOLE</span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// </span></span><br><span class="line">        <span class="literal">NULL</span>,                                                           <span class="comment">// </span></span><br><span class="line">        &amp;si,                                                            <span class="comment">// 指向STARTUPINFO的指针</span></span><br><span class="line">        &amp;pi                                                             <span class="comment">// 指向PROCESS_INFORMATION的指针</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess failed (%d).\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待进程A结束</span></span><br><span class="line">    WaitForSingleObject(pi.hProcess, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭进程和线程的句柄</span></span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程就会新起一个cmd输出，不和父进程共用一个cmd</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309201814931.png" alt="image-20240309201814931" /></p></div></div></div>
<h4 id="创建挂起进程"><a class="markdownIt-Anchor" href="#创建挂起进程"></a> 创建挂起进程</h4>
<p>dwCreationFlags中常用的一个参数是<code>CREATE_SUSPENDED</code>，以挂起的方式创建一个进程，挂起态进程被创建后，只有调用<code>ResumeThread</code>函数被调用，这个进程才会继续执行。</p>
<blockquote>
<p>The primary thread of the new process is created in a suspended state, and does not run until the <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread"><strong>ResumeThread</strong></a> function is called.</p>
</blockquote>
<p>如果是以挂起态的方式创建进程，之前讲到的进程的创建过程就会有变化：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 将EXE文件映射到低2G的空间中</span><br><span class="line">   - PE文件中的字段说了在哪加载</span><br><span class="line">2. 在高2G创建该进程的`内核对象EPROCESS`</span><br><span class="line">   - 每个进程被创建，都要在内核空间创建一个EPROCESS</span><br><span class="line">3. 将系统DLL（ntdll.dll）映射到低2G空间中</span><br><span class="line">4. 在高2G创建该进程的`线程内核对象ETHREAD`</span><br><span class="line">   - 进程提供了空间上的资源，跑起来要线程。一个进程至少需要一个线程，它才能跑起来</span><br><span class="line"><span class="addition">+ 5. 如果是以挂起方式创建的，在这里会等待，直至ResumeThread被调用</span></span><br><span class="line">6. 恢复后继续执行：</span><br><span class="line">   - 映射DLL（ntdll.LdrInitializeThunk）</span><br><span class="line">   - 线程开始执行</span><br></pre></td></tr></table></figure>
<p>那也就说明了：进程就是为程序提供资源，像步骤1、2、3、4；而真正执行的是线程（因为上面将线程挂起后，就没动了，直到ResumeThreadn恢复线程的执行）</p>
<p>在ResumeThread恢复执行前，我们可以动手脚，比如狸猫换太子，提前注入，Process Hollowing，傀儡进程等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 CREATE_SUSPENDED 创建一个初始状态为挂起的记事本进程</span></span><br><span class="line">    <span class="keyword">if</span> (!CreateProcess(</span><br><span class="line">        TEXT(<span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>),  <span class="comment">// 程序名称</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// 命令行参数</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// 进程句柄不允许/可以被继承</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// 线程句柄不允许/可以被继承</span></span><br><span class="line">        FALSE,                                       <span class="comment">// 不继承父进程句柄</span></span><br><span class="line">        CREATE_SUSPENDED,                            <span class="comment">// 创建标志，使用 CREATE_SUSPENDED</span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// </span></span><br><span class="line">        <span class="literal">NULL</span>,                                        <span class="comment">// </span></span><br><span class="line">        &amp;si,                                         <span class="comment">// 指向STARTUPINFO的指针</span></span><br><span class="line">        &amp;pi                                          <span class="comment">// 指向PROCESS_INFORMATION的指针</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess failed (%d).\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在ResumeThread前可以做一些处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处恢复线程，从而开始执行记事本进程</span></span><br><span class="line">    ResumeThread(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待进程结束</span></span><br><span class="line">    WaitForSingleObject(pi.hProcess, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭进程和线程的句柄</span></span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lpcurrentdirectory"><a class="markdownIt-Anchor" href="#lpcurrentdirectory"></a> lpCurrentDirectory</h3>
<p>当前进程的工作目录，如果设置为NULL，默认和父进程的工作目录一样</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, optional] lpCurrentDirectory</span><br></pre></td></tr></table></figure>
<p>The full path to the current directory for the process. The string can also specify a UNC path.</p>
<p>If this parameter is <strong>NULL</strong>, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</p>
</blockquote>
<p>这里说下什么是模块目录和工作目录：</p>
<ul>
<li>模块目录：模块所在的路径</li>
<li>工作目录：程序工作目录。父进程使用CreateProcess时传的参数，如果是NULL，那工作目录就和和父进程的工作目录一样</li>
</ul>
<p><strong>例</strong></p>
<p>通过<strong>GetModuleFileName</strong>和<strong>GetCurrentDirectory</strong>函数分别获得当前模块（执行文件）的目录和当前工作目录：</p>
<ul>
<li><code>GetModuleFileName</code> 函数用于获取当前执行的模块（例如，您的程序）的完整路径。这包括了模块所在的目录以及模块的文件名。</li>
<li><code>GetCurrentDirectory</code> 函数获取程序的当前工作目录，即程序运行时的活动目录。这个目录可以与模块所在的目录不同，取决于CreateProcess时lpCurrentDirectory参数的设置</li>
</ul>
<figure class="highlight c"><figcaption><span>Unicode版</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    TCHAR modulePath[MAX_PATH];  <span class="comment">// 存储模块路径</span></span><br><span class="line">    TCHAR currentPath[MAX_PATH]; <span class="comment">// 存储当前工作路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前模块的完整路径（包括执行文件的名称）</span></span><br><span class="line">    <span class="keyword">if</span> (GetModuleFileName(<span class="literal">NULL</span>, modulePath, MAX_PATH) == <span class="number">0</span>) &#123;</span><br><span class="line">        _tprintf(_T(<span class="string">&quot;Error getting module file name.\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前工作目录的路径</span></span><br><span class="line">    <span class="keyword">if</span> (GetCurrentDirectory(MAX_PATH, currentPath) == <span class="number">0</span>) &#123;</span><br><span class="line">        _tprintf(_T(<span class="string">&quot;Error getting current directory.\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印模块路径和当前工作路径</span></span><br><span class="line">    _tprintf(_T(<span class="string">&quot;Module Path: %s\n&quot;</span>), modulePath);</span><br><span class="line">    _tprintf(_T(<span class="string">&quot;Current Working Directory: %s\n&quot;</span>), currentPath);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tag-plugin tabs" align="center"id="tab_225"><div class="nav-tabs"><div class="tab active"><a href="#tab_225-1">VS执行，父进程是VS</a></div><div class="tab"><a href="#tab_225-2">双击执行，父进程是explorer</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_225-1"><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309204611951.png" alt="image-20240309204611951" /></p></div><div class="tab-pane" id="tab_225-2"><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API/image-20240309204558338.png" alt="image-20240309204558338" /></p></div></div></div>
<p>用途，比如fopen读文件时，未使用绝对路径，寻找的路径就是进程的当前工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen(<span class="string">&quot;D:/005_Codefield/VS2019/DiShui_Test/Debug/TestA.exe&quot;</span>, <span class="string">&quot;r&quot;</span>);   <span class="comment">//绝对路径</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen(<span class="string">&quot;A.exe&quot;</span>, <span class="string">&quot;r&quot;</span>);                                                <span class="comment">//在进程的当前工作目录下寻找&quot;A.exe&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="其他进程相关api"><a class="markdownIt-Anchor" href="#其他进程相关api"></a> 其他进程相关API</h2>
<p>获取当前进程ID（PID）：GetCurrentProcessId</p>
<p>获取当前进程句柄：GetCurrentProcess</p>
<p>获取命令行：GetCommandLine</p>
<p>获取启动信息：GetStartupInfo</p>
<p>获取系统中所有进程的PID：EnumProcesses</p>
<p>快照：CreateToolhelp32Snapshot</p>
<ul>
<li>猜测为什么起名叫快照：内核程序的运行时是千变万化的，比如某个线程现在存在但过一会可能就执行完了。当执行CreateToolhelp32Snapshot函数的一瞬间将系统中的信息保留下来，供开发者进行分析。这个快照是拍摄时的系统状态，相当于在这个时刻给系统内核拍了一个快照，而拍摄后系统内核的状态可能发生了变化。</li>
</ul>



<div class="article-footer reveal fs14"></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/Windows_API/%E5%8F%A5%E6%9F%84%E8%A1%A8.html">句柄表</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/Windows_API/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B.html">创建线程</a></div></section></div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">wiki</span><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a href="/wiki/tags/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a><a href="/wiki/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a><a href="/wiki/tags/%E5%85%B6%E4%BB%96/">其他</a></div><div class="sitemap-group"><span class="fs14">关于</span><a href="/about/">关于</a></div></div><div class="text"><p>本站由 <a href="/">Misc0101</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0">Stellar 1.25.0</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.25.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".fancybox img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->






<!-- inject -->


  </div>
</body>
</html>
