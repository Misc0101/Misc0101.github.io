<!DOCTYPE html>
<html lang='zh-CN'>


<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0" theme-name="Stellar" theme-version="1.25.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Windows API编程：句柄表 - Misc010</title>

  
    <meta name="description" content="前言 使用CreateProcess创建进程时会返回一个结构体LPPROCESS_INFORMATION，里面是进程句柄，线程句柄，进程ID，线程ID字段。 123456typedef struct _PROCESS_INFORMATION &#123;  HANDLE hProcess;          &#x2F;&#x2F;进程句柄  HANDLE hThread;           &#x2F;&#x2F;线程句柄  DW">
<meta property="og:type" content="website">
<meta property="og:title" content="句柄表">
<meta property="og:url" content="https://misc0101.github.io/wiki/Windows_API/%E5%8F%A5%E6%9F%84%E8%A1%A8.html">
<meta property="og:site_name" content="Misc010">
<meta property="og:description" content="前言 使用CreateProcess创建进程时会返回一个结构体LPPROCESS_INFORMATION，里面是进程句柄，线程句柄，进程ID，线程ID字段。 123456typedef struct _PROCESS_INFORMATION &#123;  HANDLE hProcess;          &#x2F;&#x2F;进程句柄  HANDLE hThread;           &#x2F;&#x2F;线程句柄  DW">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308193153913.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308193001617.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308193954986.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308194908748.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308222558026.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308224550673.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240309155728707.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240309155747945.png">
<meta property="article:published_time" content="2024-03-08T11:24:14.000Z">
<meta property="article:modified_time" content="2024-03-08T11:24:14.000Z">
<meta property="article:author" content="Misc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://misc0101.github.io/Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308193153913.png">
  
  
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1.2em" height="1.2em" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有项目</a><a class="title" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html"><div class="main" ff="title">Windows API编程</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/Windows_API/" placeholder="在/wiki/Windows_API/中搜索..."><svg t="1705074644177" class="icon search-icon" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc multi" id="data-toc" collapse="false"><div class="widget-header cap dis-select"><span class="name">字符</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html#start"><span class="toc-text">字符编码</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AE%BD%E5%AD%97%E7%AC%A6.html"><span class="toc-text">C语言中的宽字符</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/Win32_API%E4%B8%AD%E7%9A%84%E5%AE%BD%E5%AD%97%E7%AC%A6.html"><span class="toc-text">Win32 API中的宽字符</span></a></div></div><div class="widget-header cap dis-select"><span class="name">进程</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B.html"><span class="toc-text">创建进程</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/Windows_API/%E5%8F%A5%E6%9F%84%E8%A1%A8.html"><span class="toc-text">句柄表</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 内核对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 如何管理内核对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="toc-text"> 句柄表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84%E6%93%8D%E4%BD%9C%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text"> 使用句柄操作内核对象的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 多进程共享一个内核对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E6%97%B6%E8%AE%BE%E7%BD%AE%E8%AF%A5%E5%8F%A5%E6%9F%84%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%85%81%E8%AE%B8%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="toc-text"> 创建内核对象时，设置该句柄是否&quot;可以&#x2F;允许&quot;被继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%8F%A5%E6%9F%84%E6%98%AF%E5%90%A6%E8%A2%AB%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%BB%A7%E6%89%BF"><span class="toc-text"> 父进程句柄是否被子进程继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E8%AE%B2"><span class="toc-text"> 串讲</span></a></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API.html"><span class="toc-text">进程相关API</span></a></div></div><div class="widget-header cap dis-select"><span class="name">线程</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B.html"><span class="toc-text">创建线程</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B.html"><span class="toc-text">控制线程</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%B8%B4%E7%95%8C%E5%8C%BA.html"><span class="toc-text">临界区（Critical Section）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%BA%92%E6%96%A5%E4%BD%93.html"><span class="toc-text">互斥体（Mutex）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%BA%8B%E4%BB%B6.html"><span class="toc-text">事件（Event）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%BF%A1%E5%8F%B7%E9%87%8F.html"><span class="toc-text">信号量（Semaphore）</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.html"><span class="toc-text">线程互斥与线程同步问题</span></a></div></div><div class="widget-header cap dis-select"><span class="name">窗口程序编写及逆向分析</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.html"><span class="toc-text">窗口的本质</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html"><span class="toc-text">消息队列</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F.html"><span class="toc-text">第一个窗口程序</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B.html"><span class="toc-text">消息类型</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.html"><span class="toc-text">窗口程序逆向分析</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%AD%90%E7%AA%97%E5%8F%A3.html"><span class="toc-text">子窗口</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%AD%90%E7%AA%97%E5%8F%A3%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91%E5%8F%8A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.html"><span class="toc-text">子窗口消息处理逻辑及逆向分析</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9A%E4%BD%8D.html"><span class="toc-text">对话框及回调函数定位</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%A0%87.html"><span class="toc-text">使用图标</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6.html"><span class="toc-text">通用控件</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%9E%9A%E4%B8%BE%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E5%92%8C%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98.html"><span class="toc-text">枚举窗口与模拟鼠标和模拟键盘</span></a></div></div><div class="widget-header cap dis-select"><span class="name">内存管理</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.html"><span class="toc-text">虚拟内存与物理内存</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE.html"><span class="toc-text">私有内存的申请和释放</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE.html"><span class="toc-text">共享内存的申请和释放</span></a></div></div><div class="widget-header cap dis-select"><span class="name">文件系统</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html"><span class="toc-text">文件系统</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Windows_API/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6.html"><span class="toc-text">内存映射文件</span></a></div></div></widget>

<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多：计算机基础</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/C++/%E5%B0%81%E8%A3%85%E5%92%8Cthis%E6%8C%87%E9%92%88.html"><span class="title">C++</span><span class="excerpt">滴水三期_C++语言笔记，C++能做的C都能做，只不过如果使用C++，可以节省很多时间，因为编译器帮编程人员做了很多工作，让编程人员省事。学习的目标：相对于C，编译器替我们做了哪些工作。</span></a><a class="item wiki" href="/wiki/Assembly_Language/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8_%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99.html"><span class="title">汇编语言</span><span class="excerpt">x86汇编笔记：以滴水三期_汇编语言课程为框架，《汇编语言4th-王爽》和《汇编语言-基于x86处理器-第七版》为补充。</span></a><a class="item wiki" href="/wiki/C/%E5%87%BD%E6%95%B0.html"><span class="title">C</span><span class="excerpt">滴水三期_C语言笔记，以逆向角度看待和学习C语言，精彩点：堆栈图与指针。</span></a><a class="item wiki" href="/wiki/Modern_C++/%E7%B1%BB.html"><span class="title">Modern C++</span><span class="excerpt">C++98及其之前的C++ 特性称之为traditional C++（传统C++），C++11/14/17/20被称为Modern C++（现代 C++ ）。补充从传统C++“升级”到现代C++的知识。</span></a><a class="item wiki" href="/wiki/Proxy_Protocols/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86_%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8A%80%E6%9C%AF.html"><span class="title">科学上网技术</span><span class="excerpt">从正常网络通信数据包通信过程出发，逐步推导到使用代理协议进行科学上网，随后依次介绍各代理协议ss、trojan、vmess、vless原理与节点搭建，还有相关的工具、技术、概念介绍。</span></a><a class="item wiki" href="/wiki/Thinking_in_C++/Pointers.html"><span class="title">Thinking in C++</span><span class="excerpt">《Thinking in C++ vol 1》笔记，知识内化后的输出，少部分是摘抄，少用的细节不做记录用时在查，参考视频：《面向对象程序设计_C++_翁恺老师》。</span></a><a class="item wiki" href="/wiki/representation_and_computation_of_data/%E8%BF%9B%E5%88%B6.html"><span class="title">数据的运算与表示</span><span class="excerpt">滴水三期_进制笔记，学习与理解进制、数据宽度、数的表示、位运算等概念。</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      
  





      


<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">项目</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/Windows_API/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html">Windows API编程</a></div><div id="post-meta">
    <span>更新于&nbsp;<time datetime="2024-03-08T11:24:14.000Z">2024-03-08</time></span>
    </div></div></div>

<article class='md-text content wiki'>
<h1 class="article-title"><span>句柄表</span></h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>使用CreateProcess创建进程时会返回一个结构体<strong>LPPROCESS_INFORMATION</strong>，里面是进程句柄，线程句柄，进程ID，线程ID字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">  HANDLE hProcess;          <span class="comment">//进程句柄</span></span><br><span class="line">  HANDLE hThread;           <span class="comment">//线程句柄</span></span><br><span class="line">  DWORD  dwProcessId;       <span class="comment">//进程id</span></span><br><span class="line">  DWORD  dwThreadId;        <span class="comment">//线程id</span></span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>
<p>本小节就来说下什么是句柄</p>
<h2 id="内核对象"><a class="markdownIt-Anchor" href="#内核对象"></a> 内核对象</h2>
<p>像进程、线程、文件、互斥体、事件等在内核都有一个对应的结构体，这些结构体由内核负责管理。我们管这样的对象叫做内核对象。</p>
<ul>
<li>当我们创建一个进程时，操作系统就会在内核层单独给这个进程准备一个结构体EPROCESS</li>
<li>当我们创建一个线程时，操作系统就会在内核层单独给这个线程准备一个结构体ETHREAD</li>
<li>当我们创建一个文件时，操作系统就会在内核层单独给这个文件准备一个结构体FILE_OBJECT</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308193153913.png" alt="image-20240308193153913" /></p>
<p>可以在MSDN查询<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle?devlangs=cpp&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(HANDLEAPI%252FCloseHandle)%3Bk(CloseHandle)%3Bk(DevLang-C%252B%252B)%3Bk(TargetOS-Windows)%26rd%3Dtrue">CloseHandle</a>函数（函数功能：用来关闭句柄）来知道哪些是内核对象：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308193001617.png" alt="image-20240308193001617" /></p>
<h3 id="如何管理内核对象"><a class="markdownIt-Anchor" href="#如何管理内核对象"></a> 如何管理内核对象</h3>
<p>如下图所示，每个进程会有一个内核对象，进程结构体EPROCESS。假设这个进程里</p>
<ul>
<li>通过CreateProcess又创建了一个进程内核对象，那么在内核层就有一个相应的结构体</li>
<li>通过CreateThread又创建了一个线程内核对象，那么在内核层就有一个相应的结构体</li>
<li>通过CreateEvent又创建了一个事件内核对象，那么在内核层就有一个相应的结构体</li>
<li>通过CreateFile又创建了一个文件内核对象，那么在内核层就有一个相应的结构体</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308193954986.png" alt="image-20240308193954986" /></p>
<p>随之而来的一个问题：我们如何管理，如何使用这些结构体？最简单的办法：比如调用CreateProcess后你就将对应内核结构体的地址返回给我用。这种方案比较高效，但不安全。假设返回来的内核地址是0x81234567，如果应用层一不小心将返回来的地址修改为0x81234580，然后访问该地址。在应用层如果我们访问一个没挂物理页的地址会报0xC0000005的错误，但我们访问的是错误的内核地址，操作系统会直接蓝屏。</p>
<h2 id="句柄表"><a class="markdownIt-Anchor" href="#句柄表"></a> 句柄表</h2>
<p>微软为了安全性，不会将内核结构体的地址直接暴露给应用层。相反，它使用句柄表来间接引用这些对象。但请注意，不是每一个内核对象都有一个句柄表。比如文件、线程、事件（Event）虽然是内核对象，但它们没有句柄表。句柄表是每个进程才有一个句柄表。</p>
<p>如下图，每个进程有一个内核结构体EPROCESS，这个结构体里有一个成员是指针，该指针指向了一张表。表里存的是每个内核对象结构体A、B、C、D的地址，并给这些地址编上编号。当应用层想使用内核对象时，就将相应的编号返回去，如：</p>
<ul>
<li>进程想使用进程内核对象A，则将A的编号1返给应用层</li>
<li>进程想使用线程内核对象B，则将B的编号2返给应用层</li>
<li>进程想使用事件内核对象，则将C的编号3返给应用层</li>
<li>进程想使用文件内核对象，则将D的编号4返给应用层</li>
</ul>
<p>也就是说开发者在应用层拿到的Handle其实是句柄表里的一个索引值。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>存的内核地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
</tr>
<tr>
<td>3</td>
<td>C</td>
</tr>
<tr>
<td>4</td>
<td>D</td>
</tr>
</tbody>
</table>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308194908748.png" alt="image-20240308194908748" /></p>
<p><strong>小结</strong></p>
<p>每个进程都有一张句柄表，表里存的是当前进程创建的所有内核对象的一种映射关系，应用层得到的Handle的值实际上是表里的一个索引。有了句柄，才能操作内核对象。只有通过句柄才能操作内核对象。</p>
<h3 id="使用句柄操作内核对象的例子"><a class="markdownIt-Anchor" href="#使用句柄操作内核对象的例子"></a> 使用句柄操作内核对象的例子</h3>
<p>比如使用<code>pi.Thread</code>句柄来挂起notepad进程。在SuspendThread那行下断点，调试运行。notepad被正常创建后能正常使用，单步执行SuspendThread后就处于挂起状态，假死，无法操作，再单步执行ResumeThread就恢复正常了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR childProcessName[] = TEXT(<span class="string">&quot;C:/WINDOWS/system32/notepad.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));    <span class="comment">//置0</span></span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));    <span class="comment">//置0</span></span><br><span class="line"></span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);             <span class="comment">//填充该成员，记录结构体大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CreateProcess(</span><br><span class="line">        childProcessName,           <span class="comment">//进程名称</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//命令行参数</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//进程句柄不可以被继承</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//线程句柄不可以被继承</span></span><br><span class="line">        FALSE,                      <span class="comment">//不继承父进程句柄</span></span><br><span class="line">        <span class="number">0</span>,                          <span class="comment">//没有创建标志</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//使用父进程环境变量</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//使用父进程目录作为当前目录，可以自己设置目录</span></span><br><span class="line">        &amp;si,                        <span class="comment">//STARTUPINFOW结构体详细信息</span></span><br><span class="line">        &amp;pi)                        <span class="comment">//PROCESS_INFORMATION结构体进程信息</span></span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess Successfully! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess Error: %d \n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SuspendThread(pi.hThread);      <span class="comment">//挂起线程</span></span><br><span class="line">    ResumeThread(pi.hThread);       <span class="comment">//恢复线程</span></span><br><span class="line"></span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多进程共享一个内核对象"><a class="markdownIt-Anchor" href="#多进程共享一个内核对象"></a> 多进程共享一个内核对象</h2>
<p>0环是所有进程都共用的内存，这意味着同一个内核对象可以在不同的进程之间共享。</p>
<p>当一个进程创建一个内核对象时，这个内核对象对应的结构体里有个引用计数器（它表示有多少个句柄指向该内核对象）。当其他进程打开（或复制）一个指向这个内核对象的句柄时，引用计数器就加1。当任一进程使用<code>CloseHandle</code>关闭指向该内核对象的句柄时，引用计数器便减1。只有当引用计数器减至0时，即没有任何进程持有指向该内核对象的句柄时，内核对象才会被销毁。（开发者通常被<code>CloseHandle</code>名字误导，以为该函数就是关闭释放内核对象。）</p>
<p>如下图，A进程通过<code>CreateProcess</code>创建了一个内核对象A，内核对象A引用计数器增加为1。在进程A的句柄表中，会有一个指向内核对象A的句柄（例如句柄编号1）。随后，进程B通过<code>OpenProcess</code>打开内核对象A的句柄，此时内核对象A的引用计数器增加为2。在进程B的句柄表中，也会有一个指向内核对象A的句柄（例如句柄编号12，因为B进程的句柄表中还有其他B进程用到的内核对象映射关系）。进程A和进程B都是通过自己的句柄表来使用内核对象A。当进程B使用<code>CloseHandle</code>关闭对内核对象A的句柄时，内核对象A的引用计数器减少为1，但对象不会释放，因为还有进程A的句柄指向它。只有当所有指向内核对象A的句柄都被关闭，引用计数器减为0时，内核对象A才会被销毁。</p>
<blockquote>
<p>每个进程都有自己的一个句柄表，这个句柄表是私有的，用于存储当前进程所拥有的所有句柄。这些句柄指向各种资源，包括文件、线程、进程等内核对象。句柄表中的每个句柄都有一个唯一的编号，但这些编号只在该进程的上下文中有意义。不同进程的句柄表彼此独立，因此一个句柄编号在一个进程中可能代表一个对象，在另一个进程中可能代表不同的对象或没有任何意义。比如拿A进程句柄表的Handle索引值比如1，到B的句柄表去找编号1对应的内核对象，这是没有意义的。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308222558026.png" alt="image-20240308222558026" /></p>
<p>但有一个内核对象是例外：线程内核对象。线程内核对象引用计数器为0后（只是说明没有任何人的句柄指向了这个内核对象），并不会结束相关联的线程，不会释放线程内核对象；进程内核对象象引用计数器为0后，并不会结束相关联的进程，不会释放进程内核对象。</p>
<p>如果想释放一个线程内核对象，需要满足两个条件：</p>
<ol>
<li>关闭线程</li>
<li>线程内核对象引用计数器为0</li>
</ol>
<p>如果想释放一个进程内核对象，需要满足两个条件：</p>
<ol>
<li>关闭进程（通过关闭进程里所有线程来关闭进程）</li>
<li>进程内核对象引用计数器为0</li>
</ol>
<p>一个进程至少有一个线程（通常称为主线程）。如果一个进程没有任何活动线程，那么它通常会结束。所以当一个进程里所有线程都结束了，进程也就会结束。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle?devlangs=cpp&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(HANDLEAPI%252FCloseHandle)%3Bk(CloseHandle)%3Bk(DevLang-C%252B%252B)%3Bk(TargetOS-Windows)%26rd%3Dtrue">CloseHandle</a></p>
<p>Closing a thread handle does not terminate the associated thread or remove the thread object. Closing a process handle does not terminate the associated process or remove the process object. To remove a thread object, you must terminate the thread, then close all handles to the thread. For more information, see <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/ProcThread/terminating-a-thread">Terminating a Thread</a>. To remove a process object, you must terminate the process, then close all handles to the process. For more information, see <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</p>
</blockquote>
<p><strong>例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR childProcessName[] = TEXT(<span class="string">&quot;C:/WINDOWS/system32/notepad.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));    <span class="comment">//置0</span></span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));    <span class="comment">//置0</span></span><br><span class="line"></span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);             <span class="comment">//填充该成员，记录结构体大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CreateProcess(</span><br><span class="line">        childProcessName,           <span class="comment">//进程名称</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//命令行参数</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//不继承进程句柄</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//不继承线程句柄</span></span><br><span class="line">        FALSE,                      <span class="comment">//不继承句柄</span></span><br><span class="line">        <span class="number">0</span>,                          <span class="comment">//没有创建标志</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//使用父进程环境变量</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">//使用父进程目录作为当前目录，可以自己设置目录</span></span><br><span class="line">        &amp;si,                        <span class="comment">//STARTUPINFOW结构体详细信息</span></span><br><span class="line">        &amp;pi)                        <span class="comment">//PROCESS_INFORMATION结构体进程信息</span></span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess Successfully! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess Error: %d \n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面这段代码，一开始这个程序的进程内核对象和线程内核对象创建后只有自己用，两个内核对象引用计数器都为1，然后执行了后面两行<code>CloseHandle</code>，进程内核对象和线程内核对象引用计数器都减为0。代码已经执行完了，发现记事本仍然可以使用。<u>即使线程的内核对象计数器为0，线程仍会继续执行，直到它自然结束或被强制终止；而线程没死，进程也不会死。</u>如果想释放掉线程内核对象，必须关掉线程（关闭记事本，点击右上角的“X”），关掉线程后线程内核对象引用计数器为0，此时线程内核对象被释放。又因为这个进程中没有活动线程了（一个进程只有在所有线程都已结束时才会结束），进程会结束，加之进程内核对象引用计数器也为0，所以进程内核对象这时才会释放。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240308224550673.png" alt="image-20240308224550673" /></p>
<h2 id="创建内核对象时设置该句柄是否可以允许被继承"><a class="markdownIt-Anchor" href="#创建内核对象时设置该句柄是否可以允许被继承"></a> 创建内核对象时，设置该句柄是否&quot;可以/允许&quot;被继承</h2>
<p>还是以这张图为例，一个父进程使用CreateProcess、CreateThread、CreateEvent、CreateFile等函数创建了A、B、C、D的内核对象，假设对应的索引值分别是1-A，2-B，3-C，4-D。调用这些函数传参时都有一个叫<code>LPSECURITY_ATTRIBUTES</code>类型的参数。</p>
<blockquote>
<p>这一点可以拿来判断创建的这个东西否是内核对象：Createxxx函数的参数列表中如果有<code>LPSECURITY_ATTRIBUTES</code>类型的参数，则这个object是内核对象</p>
</blockquote>
<div class="tag-plugin tabs" align="center"id="tab_209"><div class="nav-tabs"><div class="tab active"><a href="#tab_209-1">CreateEvent函数为例</a></div><div class="tab"><a href="#tab_209-2">CreateFileW函数为例</a></div><div class="tab"><a href="#tab_209-3">CreateThread函数为例</a></div><div class="tab"><a href="#tab_209-4">CreateProcess函数为例</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_209-1"><p>以CreateEvent函数为例，它的第一个参数是<code>LPSECURITY_ATTRIBUTES</code>类型的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateEventA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span><br><span class="line"><span class="params">  [in]           BOOL                  bManualReset,</span></span><br><span class="line"><span class="params">  [in]           BOOL                  bInitialState,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR                lpName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa?redirectedfrom=MSDN&amp;devlangs=cpp&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(SYNCHAPI%252FCreateEvent)%3Bk(CreateEvent)%3Bk(DevLang-C%252B%252B)%3Bk(TargetOS-Windows)%26rd%3Dtrue">CreateEventA</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, optional] lpEventAttributes</span><br></pre></td></tr></table></figure>
<p>A pointer to a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <strong>NULL</strong>, the handle cannot be inherited by child processes.</p>
<p>The <strong>lpSecurityDescriptor</strong> member of the structure specifies a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/SecAuthZ/security-descriptors">security descriptor</a> for the new event. If <em>lpEventAttributes</em> is <strong>NULL</strong>, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.</p>
</blockquote></div><div class="tab-pane" id="tab_209-2"><p>以CreateFileW函数为例，它的第四个参数是<code>LPSECURITY_ATTRIBUTES</code>类型的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateFileW</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           LPCWSTR               lpFileName,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwDesiredAccess,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwShareMode,</span></span><br><span class="line"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwCreationDisposition,</span></span><br><span class="line"><span class="params">  [in]           DWORD                 dwFlagsAndAttributes,</span></span><br><span class="line"><span class="params">  [in, optional] HANDLE                hTemplateFile</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFileW</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, optional] lpSecurityAttributes</span><br></pre></td></tr></table></figure>
<p>A pointer to a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.</p>
<p>This parameter can be <strong>NULL</strong>.</p>
<p>If this parameter is <strong>NULL</strong>, the handle returned by <strong>CreateFile</strong> cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.</p>
<p>The <strong>lpSecurityDescriptor</strong> member of the structure specifies a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> for a file or device. If this member is <strong>NULL</strong>, the file or device associated with the returned handle is assigned a default security descriptor.</p>
<p><strong>CreateFile</strong> ignores the <strong>lpSecurityDescriptor</strong> member when opening an existing file or device, but continues to use the <strong>bInheritHandle</strong> member.</p>
<p>The <strong>bInheritHandle</strong> member of the structure specifies whether the returned handle can be inherited.</p>
<p>For more information, see the Remarks section.</p>
</blockquote></div><div class="tab-pane" id="tab_209-3"><p>以CreateThread函数为例，它的第一个参数是<code>LPSECURITY_ATTRIBUTES</code>类型的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span><br><span class="line"><span class="params">  [in]            SIZE_T                  dwStackSize,</span></span><br><span class="line"><span class="params">  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,</span></span><br><span class="line"><span class="params">  [in, optional]  __drv_aliasesMem LPVOID lpParameter,</span></span><br><span class="line"><span class="params">  [in]            DWORD                   dwCreationFlags,</span></span><br><span class="line"><span class="params">  [out, optional] LPDWORD                 lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, optional] lpThreadAttributes</span><br></pre></td></tr></table></figure>
<p>A pointer to a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle can be inherited by child processes. If <em>lpThreadAttributes</em> is NULL, the handle cannot be inherited.</p>
<p>The <strong>lpSecurityDescriptor</strong> member of the structure specifies a security descriptor for the new thread. If <em>lpThreadAttributes</em> is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the primary token of the creator.</p>
</blockquote></div><div class="tab-pane" id="tab_209-4"><p>一个进程至少有一个活动线程，所以使用CreateProcess创建一个进程后，就有了一个进程内核对象和一个线程内核对象。</p>
<p>以CreateProcess函数为例：</p>
<ul>
<li>第3个参数是<code>LPSECURITY_ATTRIBUTES</code>类型的参数，表示CreteProcess后的<strong>进程内核对象的句柄</strong>是否&quot;允许/可以&quot;被继承</li>
<li>第4个参数是<code>LPSECURITY_ATTRIBUTES</code>类型的参数，表示CreteProcess后进程中的<strong>线程内核对象的句柄</strong>是否&quot;允许/可以&quot;被继承</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCWSTR lpApplicationName,                 <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPWSTR lpCommandLine,                      <span class="comment">//</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// 进程句柄是否允许/可以被继承</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">// 线程句柄是否允许/可以被继承</span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandles,                      <span class="comment">// </span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags,                     <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPVOID lpEnvironment,                      <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPCWSTR lpCurrentDirectory,                <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPSTARTUPINFOW lpStartupInfo,              <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// </span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw">CreateProcessW function</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, optional] lpProcessAttributes</span><br></pre></td></tr></table></figure>
<p>A pointer to a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new process object can be inherited by child processes. If <em>lpProcessAttributes</em> is <strong>NULL</strong>, the handle cannot be inherited.</p>
<hr />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, optional] lpThreadAttributes</span><br></pre></td></tr></table></figure>
<p>A pointer to a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether the returned handle to the new thread object can be inherited by child processes. If <em>lpThreadAttributes</em> is NULL, the handle cannot be inherited.</p>
</blockquote></div></div></div>
<p><code>LPSECURITY_ATTRIBUTES</code>是一个指向<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES结构体</a>的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_ATTRIBUTES</span> &#123;</span></span><br><span class="line">  DWORD  nLength;                       <span class="comment">// 该结构体大小</span></span><br><span class="line">  LPVOID lpSecurityDescriptor;          <span class="comment">// 指向SecurityDescriptor结构体的指针</span></span><br><span class="line">  BOOL   bInheritHandle;                <span class="comment">// 句柄能否被继承</span></span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>nLength：记录当前结构体的大小。很常见，windows的很多结构体都有这么一个字段</p>
</li>
<li>
<p>lpSecurityDescriptor：指向安全描述符（SecurityDescriptor结构体）的指针。<br />
A security descriptor includes information that specifies the following components of an object’s security:</p>
<ul>
<li>An owner <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">security identifier</a> (SID)</li>
<li>A primary group SID</li>
<li>A <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL)</li>
<li>A <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">system access control list</a> (SACL)</li>
<li>Qualifiers for the preceding items</li>
</ul>
<p>一般情况下不关注这个字段，置NULL，那么采用的安全设置就和父进程一样。（If the value of this member is <strong>NULL</strong>, the object is assigned the default security descriptor associated with the <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/ms721532(v=vs.85)"><em>access token</em></a> of the calling process.）</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-security_descriptor?redirectedfrom=MSDN">SECURITY_DESCRIPTOR</a></p>
<p>The <strong>SECURITY_DESCRIPTOR</strong> structure contains the security information associated with an object. Applications use this structure to set and query an object’s security status.</p>
<p>Because the internal format of a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">security descriptor</a> can vary, we recommend that applications not modify the <strong>SECURITY_DESCRIPTOR</strong> structure directly. For creating and manipulating a security descriptor, use the functions listed in See Also.</p>
</blockquote>
</li>
<li>
<p>bInheritHandle：句柄能否被继承</p>
<blockquote>
<p>A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is <strong>TRUE</strong>, the new process inherits the handle.</p>
</blockquote>
</li>
</ul>
<p>设置<code>SECURITY_ATTRIBUTES.bInheritHandle</code>字段为TRUE，设置该对象可以被继承，然后传参，那么Createxxx创建的这个内核对象就可以被继承。</p>
<p>另外，这里要再提一下句柄表，句柄表其实还有一列，用来表示这个句柄是否可以被继承。比如</p>
<ul>
<li>父进程使用CreateEvent创建了内核对象C，设置句柄不可继承。那么在句柄表中，C对象句柄那一行，标识该句柄是否可以被继承的字段就为0，表示不可以继承。</li>
<li>父进程使用CreatFile创建了内核对象D，设置句柄可以被继承。那么在句柄表中，D对象句柄那一行，标识该句柄是否可以被继承的字段就为1，表示可以被继承。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240309155728707.png" alt="image-20240309155728707" /></p>
<p><strong>例</strong></p>
<p>创建不可继承和可继承的内核对象</p>
<ul>
<li>直接传NULL</li>
<li>设置<code>SECURITY_ATTRIBUTES.bInheritHandle</code>字段为TRUE，设置该对象可以被继承，然后传参</li>
</ul>
<div class="tag-plugin tabs" align="center"id="tab_214"><div class="nav-tabs"><div class="tab active"><a href="#tab_214-1">CreateEvent</a></div><div class="tab"><a href="#tab_214-2">CreateFile</a></div><div class="tab"><a href="#tab_214-3">CreateThread</a></div><div class="tab"><a href="#tab_214-4">CreateProcess</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_214-1"><div class="tag-plugin tabs" align="center"id="tab_210"><div class="nav-tabs"><div class="tab active"><a href="#tab_210-1">不可继承</a></div><div class="tab"><a href="#tab_210-2">可继承</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_210-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个不可继承的事件对象</span></span><br><span class="line">    HANDLE hEvent = CreateEvent(</span><br><span class="line">        <span class="literal">NULL</span>,    <span class="comment">// lpEventAttributes 设置为 NULL，表示事件对象不可被继承</span></span><br><span class="line">        FALSE,</span><br><span class="line">        FALSE,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_210-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可继承的安全属性结构</span></span><br><span class="line">    SECURITY_ATTRIBUTES sa;</span><br><span class="line">    ZeroMemory (&amp;sa,<span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES));</span><br><span class="line">    </span><br><span class="line">    sa.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">    sa.lpSecurityDescriptor = <span class="literal">NULL</span>;          <span class="comment">// 默认使用父类的</span></span><br><span class="line">    sa.bInheritHandle = TRUE;                <span class="comment">// 设置 bInheritHandle 为 TRUE，表示事件对象可以被继承</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可继承的事件对象</span></span><br><span class="line">    HANDLE hEvent = CreateEvent(</span><br><span class="line">        &amp;sa,                                 <span class="comment">// 使用上面设置的可继承的安全属性</span></span><br><span class="line">        FALSE,  </span><br><span class="line">        FALSE,  </span><br><span class="line">        <span class="literal">NULL</span>   </span><br><span class="line">    );</span><br></pre></td></tr></table></figure></div></div></div></div><div class="tab-pane" id="tab_214-2"><div class="tag-plugin tabs" align="center"id="tab_211"><div class="nav-tabs"><div class="tab active"><a href="#tab_211-1">不可继承</a></div><div class="tab"><a href="#tab_211-2">可继承</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_211-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个现有文件，不允许继承</span></span><br><span class="line">   HANDLE hFile = CreateFile(</span><br><span class="line">       TEXT(<span class="string">&quot;example.txt&quot;</span>),        </span><br><span class="line">       GENERIC_READ,              </span><br><span class="line">       <span class="number">0</span>,                          </span><br><span class="line">       <span class="literal">NULL</span>,                       <span class="comment">// 安全属性设置为NULL，文件句柄不可继承</span></span><br><span class="line">       OPEN_EXISTING,             </span><br><span class="line">       FILE_ATTRIBUTE_NORMAL, </span><br><span class="line">       <span class="literal">NULL</span>                 </span><br><span class="line">   );</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_211-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可继承的安全属性结构</span></span><br><span class="line">  SECURITY_ATTRIBUTES sa;</span><br><span class="line">  ZeroMemory (&amp;sa,<span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES));</span><br><span class="line">  </span><br><span class="line">  sa.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">  sa.lpSecurityDescriptor = <span class="literal">NULL</span>;         <span class="comment">// 默认使用父类的</span></span><br><span class="line">  sa.bInheritHandle = TRUE;               <span class="comment">// 设置bInheritHandle为TRUE，文件句柄可继承</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开一个现有文件，允许继承</span></span><br><span class="line">  HANDLE hFile = CreateFile(</span><br><span class="line">      TEXT(<span class="string">&quot;example.txt&quot;</span>),      </span><br><span class="line">      GENERIC_READ,              </span><br><span class="line">      <span class="number">0</span>,                         </span><br><span class="line">      &amp;sa,                                <span class="comment">// 使用可继承的安全属性</span></span><br><span class="line">      OPEN_EXISTING,             </span><br><span class="line">      FILE_ATTRIBUTE_NORMAL,    </span><br><span class="line">      <span class="literal">NULL</span>                     </span><br><span class="line">  );</span><br></pre></td></tr></table></figure></div></div></div></div><div class="tab-pane" id="tab_214-3"><div class="tag-plugin tabs" align="center"id="tab_212"><div class="nav-tabs"><div class="tab active"><a href="#tab_212-1">不可继承</a></div><div class="tab"><a href="#tab_212-2">可继承</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_212-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">ThreadFunc</span><span class="params">(LPVOID lpParam)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程执行代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD ThreadId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个不可继承的线程</span></span><br><span class="line">    hThread = CreateThread(</span><br><span class="line">        <span class="literal">NULL</span>,                   <span class="comment">// lpThreadAttributes 设置为 NULL，线程句柄不可继承</span></span><br><span class="line">        <span class="number">0</span>,                      </span><br><span class="line">        ThreadFunc,             <span class="comment">// 线程函数</span></span><br><span class="line">        <span class="literal">NULL</span>,                   </span><br><span class="line">        <span class="number">0</span>,                     </span><br><span class="line">        &amp;ThreadId               <span class="comment">// 返回线程的ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他细节略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_212-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadFunc</span><span class="params">(LPVOID lpParam)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程执行代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD ThreadId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可继承的安全属性结构</span></span><br><span class="line">    SECURITY_ATTRIBUTES sa;</span><br><span class="line">    ZeroMemory (&amp;sa,<span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES));</span><br><span class="line">    </span><br><span class="line">    sa.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">    sa.lpSecurityDescriptor = <span class="literal">NULL</span>;         <span class="comment">// 默认使用父类的</span></span><br><span class="line">    sa.bInheritHandle = TRUE;               <span class="comment">// 设置 bInheritHandle 为 TRUE，线程句柄可继承</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可继承的线程</span></span><br><span class="line">    hThread = CreateThread(</span><br><span class="line">        &amp;sa,                    <span class="comment">// 使用可继承的安全属性</span></span><br><span class="line">        <span class="number">0</span>,                   </span><br><span class="line">        ThreadFunc,             <span class="comment">// 线程函数</span></span><br><span class="line">        <span class="literal">NULL</span>,                   </span><br><span class="line">        <span class="number">0</span>,                     </span><br><span class="line">        &amp;ThreadId               <span class="comment">// 返回线程的ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他细节略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div></div><div class="tab-pane" id="tab_214-4"><div class="tag-plugin tabs" align="center"id="tab_213"><div class="nav-tabs"><div class="tab active"><a href="#tab_213-1">不可继承</a></div><div class="tab"><a href="#tab_213-2">可继承</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_213-1"><p>都填NULL的话，表示这个进程的进程句柄和线程句柄不可继承</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个不可继承的进程</span></span><br><span class="line">CreateProcess(</span><br><span class="line">    TEXT(<span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>), </span><br><span class="line">    <span class="literal">NULL</span>,                                      </span><br><span class="line">    <span class="literal">NULL</span>,                                        <span class="comment">// lpProcessAttributes设置为NULL，进程句柄不可继承</span></span><br><span class="line">    <span class="literal">NULL</span>,                                        <span class="comment">// lpThreadAttributes设置为NULL，线程句柄不可继承</span></span><br><span class="line">    FALSE,                                       <span class="comment">// </span></span><br><span class="line">    <span class="number">0</span>,                                           <span class="comment">// </span></span><br><span class="line">    <span class="literal">NULL</span>,                                        <span class="comment">// </span></span><br><span class="line">    <span class="literal">NULL</span>,                                        <span class="comment">// </span></span><br><span class="line">    &amp;si,                                         <span class="comment">// </span></span><br><span class="line">    &amp;pi                                          <span class="comment">// </span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_213-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可继承的安全属性结构</span></span><br><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">ZeroMemory (&amp;sa,<span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES));</span><br><span class="line">sa.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">sa.lpSecurityDescriptor = <span class="literal">NULL</span>;         <span class="comment">// 默认使用父类的</span></span><br><span class="line">sa.bInheritHandle = TRUE;                       <span class="comment">// 设置bInheritHandle为TRUE，使句柄可继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个进程句柄和线程句柄可继承的进程</span></span><br><span class="line">CreateProcess(</span><br><span class="line">    TEXT(<span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>), </span><br><span class="line">    <span class="literal">NULL</span>,                                      </span><br><span class="line">    &amp;sa,                                         <span class="comment">// 设置 bInheritHandle 为 TRUE，进程句柄可继承</span></span><br><span class="line">    &amp;sa,                                         <span class="comment">// 设置 bInheritHandle 为 TRUE，线程句柄可继承</span></span><br><span class="line">    FALSE,                                       <span class="comment">// </span></span><br><span class="line">    <span class="number">0</span>,                                           <span class="comment">// </span></span><br><span class="line">    <span class="literal">NULL</span>,                                        <span class="comment">// </span></span><br><span class="line">    <span class="literal">NULL</span>,                                        <span class="comment">// </span></span><br><span class="line">    &amp;si,                                         <span class="comment">// </span></span><br><span class="line">    &amp;pi                                          <span class="comment">// </span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></div></div></div></div></div>
<h2 id="父进程句柄是否被子进程继承"><a class="markdownIt-Anchor" href="#父进程句柄是否被子进程继承"></a> 父进程句柄是否被子进程继承</h2>
<p>上面一小节说的是父进程中创建内核对象时表示这个句柄是否可以被继承。现在这一小节说的是子进程是否继承父进程的句柄表。</p>
<p>CreateProcess的第五个参数<code>bInheritHandles</code>就是用来表示创建的这个子进程是否继承父进程的句柄表的内容。</p>
<ul>
<li>如果继承，子进程将会得到父进程句柄表的内容（但不是完全得到，后面会说）</li>
<li>如果不继承，父进程的句柄表和子进程就没关系呗</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCWSTR lpApplicationName,                 <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPWSTR lpCommandLine,                      <span class="comment">//</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">// </span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandles,                      <span class="comment">// 是否继承句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags,                     <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPVOID lpEnvironment,                      <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPCWSTR lpCurrentDirectory,                <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPSTARTUPINFOW lpStartupInfo,              <span class="comment">// </span></span></span><br><span class="line"><span class="params">    LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// </span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw">CreateProcessW function</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] bInheritHandles</span><br></pre></td></tr></table></figure>
<p>If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.</p>
<p><strong>Terminal Services:</strong> You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.</p>
<p><strong>Protected Process Light (PPL) processes:</strong> The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a></p>
</blockquote>
<p>但请注意，如果创建子进程时选择继承，子进程只会继承父进程中可继承的句柄（inheritable handle）。比如父进程句柄表如下：</p>
<table>
<thead>
<tr>
<th>标识该句柄是否可以被继承（0表示不可以，1表示可以）</th>
<th>索引号</th>
<th>表示的内核对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>A</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>B</td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td>C</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>D</td>
</tr>
</tbody>
</table>
<p>子进程继承后的句柄表如下（可继承的就继承过来，不可继承的那行全部填0）：</p>
<table>
<thead>
<tr>
<th>标识该句柄是否可以被继承（0表示不可以，1表示可以）</th>
<th>索引号</th>
<th>表示的内核对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>B</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>如此一来，子进程便可通过继承来的这些句柄值与父进程共享内核对象了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E5%8F%A5%E6%9F%84%E8%A1%A8/image-20240309155747945.png" alt="image-20240309155747945" /></p>
<h2 id="串讲"><a class="markdownIt-Anchor" href="#串讲"></a> 串讲</h2>
<blockquote>
<p>文章前面是根据学习顺序写的，有推导过程，这个标题将前面的内容做一个串讲</p>
</blockquote>
<p>windows采用句柄表的方式让应用层使用内核对象（进程，线程，文件，Event，互斥体等）。每个进程都有自己私有的一个句柄表，句柄表在进程的EPROCESS结构体中，有三列：</p>
<ul>
<li>标识该句柄是否可以被继承</li>
<li>索引号</li>
<li>内核对象地址</li>
</ul>
<p>应用层通过Handle（句柄表中的索引号）来使用内核对象。</p>
</br>
<p>每个内核对象都有一个引用计数器，它表示有多少句柄指向该内核对象。如果有进程打开（或复制）一个指向这个内核对象的句柄时，引用计数器就加1；进程使用CloseHandle关闭指向该内核对象的句柄，引用计数器便减1。当引用计数器减至0时，即没有任何进程持有指向该内核对象的句柄时，内核对象才会被销毁。</p>
<p>线程内核对象和进程内核对象除外，即使线程的内核对象计数器为0，线程仍会继续执行；而线程没死，进程也不会死。</p>
<p>线程内核对象释放需要满足两个条件：</p>
<ol>
<li>关闭线程</li>
<li>线程内核对象引用计数器为0</li>
</ol>
<p>进程内核对象也一样：关闭进程，进程内核对象引用计数器为0。</p>
<p>如果一个进程里一个活动线程都没有了，进程也就结束了。</p>
</br>
<p>判断哪些是内核对象的两种方法：</p>
<ol>
<li>在MSDN<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle?devlangs=cpp&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(HANDLEAPI%2FCloseHandle)%3Bk(CloseHandle)%3Bk(DevLang-C%2B%2B)%3Bk(TargetOS-Windows)%26rd%3Dtrue">CloseHandle</a>函数页面有指出哪些是内核对象</li>
<li>Createxxx函数的参数列表中如果有<code>LPSECURITY_ATTRIBUTES</code>类型的参数，则这个object是内核对象。
<ul>
<li><code>LPSECURITY_ATTRIBUTES</code>是一个指向SECURITY_ATTRIBUTES结构体的指针，SECURITY_ATTRIBUTES结构体中有个成员叫<code>bInheritHandle</code>。
<ul>
<li>当<code>bInheritHandle</code>为TRUE时，表示句柄可以被继承</li>
<li>当<code>bInheritHandle</code>为FALSE时，表示句柄不可以被继承</li>
</ul>
</li>
</ul>
</li>
</ol>
</br>
<p>因为0环空间是所有进程共享的，所以内核对象是可以在不同进程之间共享的。</p>
<p>共享内核对象的两种方式：</p>
<ol>
<li>跨进程共享。进程A创建内核对象，进程B打开该内核对象</li>
<li>子进程继承父进程句柄，达到子父进程共享同一内核对象的效果。
<ul>
<li>CreateProcess第五个参数<code>bInheritHandles</code>用来表示创建的这个子进程是否继承父进程的句柄表的内容。
<ul>
<li>如果继承，只会继承父进程可继承的句柄（inheritable handle），父进程中不可继承的句柄那行全部填0</li>
</ul>
</li>
</ul>
</li>
</ol>
</br>
<p><strong>辨析</strong></p>
<p>CreateProcess第三个和第四个参数是表示进程句柄，线程句柄是否允许/可以被继承（“创建内核对象时，设置该句柄是否&quot;可以/允许&quot;被继承”这一标题的内容）<u>whether the handle can be inherited</u>(句柄能否被继承)</p>
<p>第五个参数bInheritHandles是表示创建的这个进程是否继承父进程的句柄表（“父进程句柄是否被子进程继承”这一标题的内容）<u>inherite the inheritable handle or not</u>(是否继承句柄)</p>
<p>两个的性质不一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCWSTR lpApplicationName,               </span></span><br><span class="line"><span class="params">    LPWSTR lpCommandLine,                     </span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// 创建的这个进程的进程句柄能否被继承</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">// 创建的这个进程的线程句柄能否被继承</span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandles,                      <span class="comment">// 是否继承父进程句柄表的内容</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags,                  </span></span><br><span class="line"><span class="params">    LPVOID lpEnvironment,                    </span></span><br><span class="line"><span class="params">    LPCWSTR lpCurrentDirectory,               </span></span><br><span class="line"><span class="params">    LPSTARTUPINFOW lpStartupInfo,              </span></span><br><span class="line"><span class="params">    LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<div class="article-footer reveal fs14"></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/Windows_API/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B.html">创建进程</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/Windows_API/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API.html">进程相关API</a></div></section></div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">wiki</span><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a href="/wiki/tags/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a><a href="/wiki/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a><a href="/wiki/tags/%E5%85%B6%E4%BB%96/">其他</a></div><div class="sitemap-group"><span class="fs14">关于</span><a href="/about/">关于</a></div></div><div class="text"><p>本站由 <a href="/">Misc</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0">Stellar 1.25.0</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.25.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".fancybox img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->






<!-- inject -->


  </div>
</body>
</html>
