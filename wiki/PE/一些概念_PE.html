<!DOCTYPE html>
<html lang='zh-CN'>


<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0" theme-name="Stellar" theme-version="1.25.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>PE：一些概念 - Misc010</title>

  
    <meta name="description" content="PE文件的两种状态 PE文件存在于两个不同的状态：在运行之前，它是存储在磁盘上的一个文件；当运行时，它被加载到内存中。磁盘上的文件和内存中的文件有不同的对齐要求。正是因为这两种状态下的对齐值存在差异，PE文件在从磁盘加载到内存时需要进行调整，这个过程通常被称为“拉伸”。  Section在内存中分配的空间大小 在Section中：  未初始化的数据（如声明了一些全局变量，但没有赋初值），在磁盘中">
<meta property="og:type" content="website">
<meta property="og:title" content="一些概念">
<meta property="og:url" content="https://misc0101.github.io/wiki/PE/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE.html">
<meta property="og:site_name" content="Misc010">
<meta property="og:description" content="PE文件的两种状态 PE文件存在于两个不同的状态：在运行之前，它是存储在磁盘上的一个文件；当运行时，它被加载到内存中。磁盘上的文件和内存中的文件有不同的对齐要求。正是因为这两种状态下的对齐值存在差异，PE文件在从磁盘加载到内存时需要进行调整，这个过程通常被称为“拉伸”。  Section在内存中分配的空间大小 在Section中：  未初始化的数据（如声明了一些全局变量，但没有赋初值），在磁盘中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226171105392.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231229145209597.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240428103355489.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105183200358.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240102161951590-17044460280991.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240106121208680.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105173636249.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105175315871.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231229111140794.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105180325707.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105180516477.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105180759650.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226163617209.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226163207475.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226163038669.png">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e07da3.png">
<meta property="og:image" content="https://bu.dusays.com/2022/10/24/63567d3e07da3.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227115611892.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227140612577.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227140725683.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227140849021.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227151147572.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227151432452.png">
<meta property="og:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227151548237.png">
<meta property="article:published_time" content="2023-12-26T07:08:12.000Z">
<meta property="article:modified_time" content="2023-12-26T07:08:12.000Z">
<meta property="article:author" content="Misc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://misc0101.github.io/Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226171105392.png">
  
  
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  
  
  <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">



  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1.2em" height="1.2em" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有项目</a><a class="title" href="/wiki/PE/Overview_PE.html"><div class="main" ff="title">PE</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/PE/" placeholder="在/wiki/PE/中搜索..."><svg t="1705074644177" class="icon search-icon" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc multi" id="data-toc" collapse="false"><div class="widget-header cap dis-select"><span class="name">基本概念</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/Overview_PE.html#start"><span class="toc-text">Overview</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/PE/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE.html"><span class="toc-text">一些概念</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#pe%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text"> PE文件的两种状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#section%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%88%86%E9%85%8D%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-text"> Section在内存中分配的空间大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%80%BC"><span class="toc-text"> 对齐值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%89%E4%BC%B8%E7%9A%84%E5%8F%8C%E9%87%8D%E5%90%AB%E4%B9%89"><span class="toc-text"> “拉伸”的双重含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5"><span class="toc-text"> 一些字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#imagebaseaddressofentrypoint"><span class="toc-text"> ImageBase+AddressOfEntryPoint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-text"> 实验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E4%B8%AA%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 3个地址之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rva%E5%92%8Cva%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text"> RVA和VA的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rva%E5%92%8Cfoa%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text"> RVA和FOA的转换</span></a></li></ol></li></ol></div></div><div class="widget-header cap dis-select"><span class="name">字段解读</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/DOS%E9%83%A8%E5%88%86.html"><span class="toc-text">DOS部分</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/PE%E5%A4%B4.html"><span class="toc-text">PE头</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E8%8A%82%E8%A1%A8.html"><span class="toc-text">节表</span></a></div></div><div class="widget-header cap dis-select"><span class="name">练习和项目</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E7%BB%83%E4%B9%A0_PE.html"><span class="toc-text">练习</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0_PE.html"><span class="toc-text">编程练习</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/PE%E8%A7%A3%E6%9E%90%E5%99%A8.html"><span class="toc-text">PE解析器</span></a></div></div><div class="widget-header cap dis-select"><span class="name">节操作</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81.html"><span class="toc-text">空白区添加代码</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E6%89%A9%E5%A4%A7%E8%8A%82.html"><span class="toc-text">扩大节</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E6%96%B0%E5%A2%9E%E8%8A%82.html"><span class="toc-text">新增节</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E5%90%88%E5%B9%B6%E8%8A%82.html"><span class="toc-text">合并节</span></a></div></div><div class="widget-header cap dis-select"><span class="name">数据目录表</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93.html"><span class="toc-text">静态链接库和动态链接库</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E5%AF%BC%E5%87%BA%E8%A1%A8.html"><span class="toc-text">导出表</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.html"><span class="toc-text">重定位表</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E5%AF%BC%E5%85%A5%E8%A1%A8.html"><span class="toc-text">导入表</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E7%BB%91%E5%AE%9A%E5%AF%BC%E5%85%A5%E8%A1%A8.html"><span class="toc-text">绑定导入表</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E8%B5%84%E6%BA%90%E8%A1%A8.html"><span class="toc-text">资源表</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/%E7%A7%BB%E5%8A%A8%E5%90%84%E7%A7%8D%E8%A1%A8.html"><span class="toc-text">移动各种表</span></a></div></div><div class="widget-header cap dis-select"><span class="name">其他</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/PE/To_Learn_List.html"><span class="toc-text">To Learn List</span></a></div></div></widget>

<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多：安全技术</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/C++_disassembly/%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5_C++_disassembly.html"><span class="title">C++反汇编</span><span class="excerpt">C++反汇编，总结版（To finish...）。</span></a><a class="item wiki" href="/wiki/Hook/%E7%9B%AE%E5%BD%95.html"><span class="title">Hook专题</span><span class="excerpt">Hook技术专题。</span></a><a class="item wiki" href="/wiki/Injection/%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%B3%A8%E5%85%A5.html"><span class="title">注入技术专题</span><span class="excerpt">注入的本质是将自己的数据放到目标进程空间中执行，没有一种注入技术是通杀无敌的。学习各种注入技术，在学习操作方法以外，还要深入了解其背后原理。万一哪天自己融会贯通发明了一种全新的注入技术呢？</span></a><a class="item wiki" href="/wiki/Protected_Mode/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8.html"><span class="title">Protected_Mode</span><span class="excerpt">滴水三期_保护模式笔记。</span></a><a class="item wiki" href="/wiki/cryptography/DES.html"><span class="title">密码学</span><span class="excerpt">一些加密算法原理和流程细节，目前包含：对称加密DES、AES、SM4、ZUC；非对称RSA和ElGamal。</span></a><a class="item wiki" href="/wiki/vuln_reproduction/%E7%9B%AE%E5%BD%95_%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.html"><span class="title">漏洞复现</span><span class="excerpt">漏洞复现。</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      
  





      


<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">项目</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/PE/Overview_PE.html">PE</a></div><div id="post-meta">
    <span>更新于&nbsp;<time datetime="2023-12-26T07:08:12.000Z">2023-12-26</time></span>
    </div></div></div>

<article class='md-text content wiki'>
<h1 class="article-title"><span>一些概念</span></h1>
<h2 id="pe文件的两种状态"><a class="markdownIt-Anchor" href="#pe文件的两种状态"></a> PE文件的两种状态</h2>
<p>PE文件存在于两个不同的状态：在运行之前，它是存储在磁盘上的一个文件；当运行时，它被加载到内存中。磁盘上的文件和内存中的文件有不同的对齐要求。正是因为这两种状态下的对齐值存在差异，PE文件在从磁盘加载到内存时需要进行调整，这个过程通常被称为“拉伸”。</p>
<h3 id="section在内存中分配的空间大小"><a class="markdownIt-Anchor" href="#section在内存中分配的空间大小"></a> Section在内存中分配的空间大小</h3>
<p>在Section中：</p>
<ul>
<li>未初始化的数据（如声明了一些全局变量，但没有赋初值），在磁盘中不占有空间，但当这个节载入内存后要给这些数据分配内存空间，随后initialize and use它们。</li>
<li>已初始化的数据（如声明了一些全局变量，并赋了初值），在磁盘中会占有空间。</li>
</ul>
<p>这意味着一个Secion因为含有未初始化的数据，导致会出现<code>Misc</code>（该节实际的大小）&gt;<code>SizeOfRawData</code>（该区块在磁盘文件中对齐后的大小）的情况出现，那么当该节载入内存后，实际分配的空间是Misc。相反，如果一个Secion的<code>Misc</code>（该节实际的大小）&lt;<code>SizeOfRawData</code>（该区块在磁盘文件中对齐后的大小），那么当该节载入内存后，实际分配的空间是SizeOfRawData。</p>
<p><u>小结，内存中Section分配的空间为max{Misc,SizeOfRawData}，哪个大按哪个分配。</u></p>
<p>但在实际操作过程中，编译器编译源文件时会算出这个节将来会在内存中用多大的空间，<strong>这会体现在VirtualAddress这个值上</strong>。所以当PE文件载入内存时的拉伸，对于节数据的展开，做法是依次对每个节进行拷贝：从PointerToRawData处拷贝SizeOfRawData大小的数据到VirtualAddress。</p>
<blockquote>
<p>如果按max{Misc,SizeOfRawData}来拷，可能会因为当前这个节的Misc太大，而拷到下一个节的数据。</p>
<p>（下面这个理论上是，但我改了Misc后就运行不了，未来再考证）</p>
<p>如果我们找一个exe，对那些Misc&gt;SizeOfRawData的节，随意修改Misc的值，该exe也能运行，这就证明了系统加载器拉伸时是按SizeOfRawData拷的。</p>
</blockquote>
<p>这样一来，那些未初始化的数据在内存中就有了位置，至于系统加载器后面做的事情，怎么找到这些未初始化的数据，这个目前我无法回答。</p>
<h3 id="对齐值"><a class="markdownIt-Anchor" href="#对齐值"></a> 对齐值</h3>
<p>PE在磁盘上，每个Section要对齐于<code>FileAlignment</code>，即区块的起始地址是<code>FileAlignment</code>的整数倍。<br />
PE在内存中运行时，每个Section要对齐于<code>SectionAlignment</code>，即区块的起始地址是<code>SectionAlignment</code>的整数倍。<br />
之间的间隙，会填充一些无效的字节（padding）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226171105392.png" alt="image-20231226171105392" /></p>
<blockquote>
<p>在学习对齐的过程中，会看到多种说法：</p>
<ul>
<li>xx对齐于xx</li>
<li>xx的起始地址能整除于xx</li>
<li>xx的大小能整除于xx</li>
</ul>
<p>其实只要按一条基本的概念就能推导出其他的说法。</p>
</blockquote>
<ul>
<li><code>FileAlignment</code>：PE文件在磁盘上的区块对齐值。</li>
<li><code>SizeOfHeaders</code>：DOS头+PE头+节表，按照<code>FileAlignment</code>对齐后的总大小。</li>
<li><code>PointerToRawData</code>：文件中某个区块在磁盘上的起始偏移地址。</li>
<li><code>SizeofRawData</code>：磁盘上某个区块对齐后的实际大小。</li>
</ul>
<p>基于<strong>区块起始地址需要对齐，即区块起始地址是文件对齐/内存对齐的整数倍</strong>这一基本概念，可以得出以下推论：</p>
<p>由于PE文件第一个节的数据起始地址需要根据<code>FileAlignment</code>进行对齐，可以推断出：</p>
<ul>
<li>DOS头+PE头+节表与第一个节的节数据之间（可能）要有填充</li>
<li>进一步推导出<code>SizeOfHeaders</code>（即DOS头+PE头+节表按照文件对齐后的总大小）必须是<code>FileAlignment</code>的整数倍。</li>
</ul>
<p>同样地，由于文件中第二个节的起始地址也需要对齐，可以推断出：</p>
<ul>
<li>在第一个节的数据结束后和第二个节的数据开始前之间有填充</li>
<li>进一步推导出第一个节的<code>SizeofRawData</code>（即该节在磁盘上对齐后的大小）是<code>FileAlignment</code>的整数倍。</li>
</ul>
<p>…<br />
第n个节数据，PE在内存中按内存对齐同理。</p>
<hr />
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>FileAlignment可能和SectionAlignment一样或不一样</span></summary><div class="body"><p>在计算机技术早期，由于硬件成本较高，硬盘容量有限，文件对齐值（FileAlignment）通常设定为200h，目的是为了节约宝贵的硬盘空间。随着时间的推移，硬件技术进步，人们对硬盘空间的关注减少，编译生成的exe文件的文件对齐值提升到了1000h。这样做的好处是，当exe文件被加载到内存时，其文件对齐值等于节对齐值（SectionAlignment），避免了内存加载时的拉伸过程，从而提高了程序的运行速度。这种做法以牺牲一定的硬盘空间为代价，提升了程序的执行效率，以空间换取了时间。</p></div></details></div>
<hr />
<p><strong>模块与模块之间的对齐</strong></p>
<p>OD，点击E按钮。可以看到一个exe进程空间中加载的模块。对齐，不仅体现在一个PE文件内部的对齐，PE文件与PE文件之间也有对齐。模块与模块之间的对齐值为10000h，即64k。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231229145209597.png" alt="image-20231229145209597" /></p>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>观测下64k对齐</span></summary><div class="body"><p>用OD拖进32位的notepad，找了两个相邻的模块</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240428103355489.png" alt="image-20240428103355489" /></p><table><thead><tr><th style="text-align:left">模块名</th><th>基址</th><th>大小</th><th>基址+大小</th></tr></thead><tbody><tr><td style="text-align:left">IMM32</td><td>75610000h</td><td>26000h</td><td>75636000h</td></tr><tr><td style="text-align:left">gdi32ful</td><td>75640000h</td><td></td><td></td></tr></tbody></table><p>模块IMM32末尾地址75636000h和下一个模块gdi32ful基址75640000h，之间，填充了4000h。发现模块一和模块二之间确实是按64k对齐，即10000h。换个看法，模块IMM32和模块gdi32ful的基址也是10000h的整数倍。</p><p>但不清楚为什么对齐值是64k，感觉像个魔数（magic number）。用段式和页式管理的知识也不清楚怎么凑出64k这个数。</p></div></details></div>
<h2 id="拉伸的双重含义"><a class="markdownIt-Anchor" href="#拉伸的双重含义"></a> “拉伸”的双重含义</h2>
<blockquote>
<p>个人对拉伸含义进行扩充，这是做FileBufferToImageBuffer那个函数时发现的，我认为把这个知识点加在这里比较好</p>
</blockquote>
<p>第一重：PE文件在磁盘上，对齐于FileAlignment，在内存中，对齐于SectionAlignment。因为两者的差异，当一个PE文件由磁盘载入到内存，需要做“拉伸”。</p>
<p>第二重：节数据中未初始化数据的“拉伸”展开。如果一个PE文件中的某个节数据因为含有未初始化的数据（如.bss节，或.bss已合并到.data节中）导致出现VitrualSize&gt;SizeOfRawData的情况。这部分未初始化的数据在文件中不占用空间，而在内存中要占有空间，也就是说系统加载器在内存中要给这些未初始化的数据，分空间，这样会使ImageBufer的大小&gt;FileBuffer的大小，也导致了“拉伸”</p>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>思考过程</span></summary><div class="body"><p>试想一下，如果一个PE文件FileAlignment==SectionAlignment，是否就不需要“拉伸”了，载入内存时的ImageBufer是否就和文件FileBuffer一样了？</p><div class="tag-plugin tabs" align="center"id="tab_103"><div class="nav-tabs"><div class="tab active"><a href="#tab_103-1">例1：飞鸽程序</a></div><div class="tab"><a href="#tab_103-2">例2：VS编译出的Hello World程序</a></div><div class="tab"><a href="#tab_103-3">例3：VC编译出的Hello World程序</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_103-1"><p>飞鸽的FileAlignment和SectionAlignment都是1000h。然后我们看节表，观察它各个节的信息</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105183200358.png" alt="image-20240105183200358" /></p><p>4个节的VirtualSize均&lt;SizeOfRawData，4个节的VirtualAddress==PointerToRawData。这说明ImageBuffer没有一点拉伸，ImageBuffer的大小和FileBuffer大小一样。通过SizeOfImage字段可以验证猜想：<br /><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240102161951590-17044460280991.png" alt="image-20240102161951590" /></p></div><div class="tab-pane" id="tab_103-2"><p>用VS编译如下代码生成的exe，这个exe中有一个完全不占磁盘空间的节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.textbss节，文件中起始地址PointerToRawData为0，SizeOfRawData为0。但到内存中这个节要用10000h大小的空间，编译器编译时就算好了每个节的VirtualAddress，在这里例子中就是划定了从内存VirtualAddress(1000h)开始，给那么多的空间给.textbss节用。</p><p>随后下一个节，.text节从VirtualAddress（11000h）作为起始地址。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240106121208680.png" alt="image-20240106121208680" /></p><p>你看，这是因为含有未初始化数据，在文件中不占用空间，但是到内存中，需要分配大小给这些数据，而导致的拉伸。</p><blockquote><p>不过这个exe的FileAlignment是200h，SectionAlignment是1000h，如果相等，这个例子就完美了，能看出因为节而导致的“拉伸”。</p></blockquote><p>更常见的情况，是后面的例3，.bss节的数据合并到另一个节中，导致那个节的Misc&gt;SizeOfRawData，即内存实际要用的空间比在磁盘上的多。</p></div><div class="tab-pane" id="tab_103-3"><p>用VC6编译如下代码生成的exe，FileAlignment和SectionAlignment都是1000h。然后我们看节表，观察它各个节的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105173636249.png" alt="image-20240105173636249" /></p><p>依次从上往下看，.text节、.rdata节的VirtualSize&lt;SizeOfRawData，因此VitrualAddress和PointerToRawData一样。<br />但是.data节，由于VirtualSize&gt;SizeOfRawData，导致.idata节的VirtualSize就比PointerToRawData大了。（因为.data占的地更多了，导致.data的节数据起始地址就变高了。）并且会持续影响到后面节的起始地址。<br />即使.reloc节的VirtualSize&lt;SizeOfRawData，.reloc节数据的VirtualAddress还是&gt;PointerToRawData。</p><p>现在用最后一个节.reloc的起始地址VirtualAddress，2B000+SizeOfRawData，按内存对齐，得到的值是2C000，也就是说ImageBuffer的大小至少是2C000。</p><p>用PE Tool看下SizeOfImage字段：刚好是2C000</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105175315871.png" alt="image-20240105175315871" /></p><p>比文件大小的值大，而这个文件的FileAlignment=SectionAlignment，但从FileBuffer-&gt;ImageBuffer还是拉伸了，因为某些节含有未初始化数据的导致Misc&gt;SizeOfRawData的原因。</p></div></div></div></div></details></div>
<h2 id="一些字段"><a class="markdownIt-Anchor" href="#一些字段"></a> 一些字段</h2>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231229111140794.png" alt="image-20231229111140794" /></p>
<p><code>SizeOfImage的大小</code>≥<code>最后一个节.VirtualAddress+max&#123;Misc,SizeOfRawData&#125;按内存对齐后的值</code></p>
<p>要不这个PE文件载入内存时因为空间大小申请错误，没法拉伸，也就没法运行</p>
<div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>实验：改这个值</span></summary><div class="body"><div class="tag-plugin tabs" align="center"id="tab_104"><div class="nav-tabs"><div class="tab active"><a href="#tab_104-1">默认，未修改</a></div><div class="tab"><a href="#tab_104-2">改大</a></div><div class="tab"><a href="#tab_104-3">改小</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_104-1"><p>默认是2C000</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105180325707.png" alt="image-20240105180325707" /></p></div><div class="tab-pane" id="tab_104-2"><p>由2C000改大，改为2D000</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105180516477.png" alt="image-20240105180516477" /></p></div><div class="tab-pane" id="tab_104-3"><p>由2C000改小，改为2B000</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20240105180759650.png" alt="image-20240105180759650" /></p></div></div></div></div></details></div>
<h2 id="imagebaseaddressofentrypoint"><a class="markdownIt-Anchor" href="#imagebaseaddressofentrypoint"></a> ImageBase+AddressOfEntryPoint</h2>
<p>扩展PE头中有两个字段：</p>
<ul>
<li><code>AddressOfEntryPoint</code>：程序执行入口RVA，指PE文件在内存拉伸展开后，程序从哪个地址开始执行。这个值是相对于ImageBase的偏移。</li>
<li><code>ImageBase</code>：内存镜像基址。指PE文件在内存中首选在哪个地址开始载入拉伸。</li>
</ul>
<p>当用户双击一个PE文件以运行一个程序时，系统会创建一个新的进程。每个进程都拥有一个独立的4GB的地址空间，其中上半部分（高2GB）是由操作系统所使用，而下半部分（低2GB）是分配给用户空间的。程序是无法直接访问操作系统所占用的高2GB空间的。在进程创建时，<code>ImageBase</code>字段定义了PE文件应当从哪个内存地址开始被加载和映射。一旦系统加载器完成了加载和映射工作，它会根据PE文件中的<code>AddressOfEntryPoint</code>字段指定的位置，跳转到代码区并开始执行程序代码。</p>
<blockquote>
<p>一个PE文件加载到进程空间中，ImageBase可能被其他PE文件占用，那就要换一个地址载入。这也是为什么一些值比如AddressOfEntryPoint是设计成相对于ImageBase的偏移，而不能直接写成绝对地址VA。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226163617209.png" alt="image-20231226163617209" /></p>
<h3 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h3>
<p>用十六进制编译器查看xp系统下notepad的AddressOfEntryPoint和ImageBase字段。两者两加：01000000+0000739D=0100739D。随后用OD载入notepad，看OD停下的OEP是否是刚才算出的值。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226163207475.png" alt="image-20231226163207475" /></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231226163038669.png" alt="image-20231226163038669" /></p>
<h2 id="3个地址之间的转换"><a class="markdownIt-Anchor" href="#3个地址之间的转换"></a> 3个地址之间的转换</h2>
<p>虚拟地址（VA，Virtual Address)：PE文件映射到内存后的绝对地址</p>
<p>相对虚拟地址（RVA，Relative Virtual Address）：相对于基地址ImageBase的偏移量</p>
<blockquote>
<p>映像基址/基地址（ImageBase）：PE文件在内存映像中的起始地址</p>
</blockquote>
<p>文件偏移地址（FOA，File Offset Address）：相对于文件头的偏移量，文件头起始值为0</p>
<h3 id="rva和va的转换"><a class="markdownIt-Anchor" href="#rva和va的转换"></a> RVA和VA的转换</h3>
<p>PE文件从内存中的ImageBase开始载入。VA-ImageBase得到的就是这个数据相对于ImageBase的偏移量</p>
<p>RVA=VA-ImageBase</p>
<h3 id="rva和foa的转换"><a class="markdownIt-Anchor" href="#rva和foa的转换"></a> RVA和FOA的转换</h3>
<div class="tag-plugin quot"><p class="content" type="text">RVA转FOA</p></div>
<div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />计算方法一：算出该数据距离所在节的偏移，再加上节.PointerToRawData</p></div>
<p>如果文件对齐值和内存对齐值一样，同一数据在磁盘文件中的偏移和在内存中的偏移相同，就不用转换。</p>
<p>如果文件对齐和内存对齐值的不同，会出现FOA(文件偏移地址)和VA(虚拟地址)的转换问题。<br />
因为PE文件中的区块有对齐要求</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/></mrow><annotation encoding="application/x-tex">\qquad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:2em;"></span></span></span></span>=&gt;<code>DOS+PE头+节表</code>与<code>第一个节的数据</code>之间有填充；<code>节数据</code>与<code>节数据</code>之间有填充</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"/></mrow><annotation encoding="application/x-tex">\qquad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:2em;"></span></span></span></span>=&gt;<code>DOS+PE头+节表</code>，<code>节数据</code>内部没有填充<br />
利用内部没有填充这一特点，我们算出某数据距离它所在节的偏移：<code>某数据RVA</code>-<code>该数据所在节.VirtualAddress</code>。<br />
随后，该数据的FOA就是：<code>该数据所在节.PointerToRawData</code>+<code>某数据距离它所在节的偏移</code></p>
<p>即某数据的FOA文件偏移 = 该数据所在节.PointerToRawData+（某数据的RVA–该数据所在节.VirtualAddress）</p>
<p>代码实现过程如下：</p>
<ol>
<li>
<p>某数据RVA地址=VA内存地址-ImageBase地址</p>
</li>
<li>
<p>通过RVA地址判断是否位于PE头中：</p>
<ul>
<li>
<p>如果是，那么RVA=FOA；</p>
</li>
<li>
<p>如果不是，通过该数据的RVA位于哪个节：</p>
<ul>
<li>通过<code>节.VirtualAddress</code>  ≤  RVA地址  ≤  <code>节.VirtualAddress</code>+<code>当前节内存对齐后的大小</code>，来判断该数据在哪个节中</li>
<li>差值  =  <code>RVA地址</code>-<code>节.VirtualAddress</code></li>
<li>FOA  =  <code>节.PointerToRawData</code>+<code>差值</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" />计算方法二：用该数据RVA-所在节的节偏移（多填充的量）</p></div>
<p>通过节偏移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">\Delta k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>=<code>节.VirtualAddress</code>-<code>节.PointerToRawData</code>来消除该节前面因为文件对齐值和内存对齐值不一致多出来的填充值。<br />
<strong>例</strong><br />
假设，<code>DOS+PE头+节表</code>与<code>第一个节的数据</code>之间，<code>节表一数据</code>与<code>节表二数据</code>之间，<strong>在文件中</strong>它们的填充间隙总和为x：<br />
<code>DOS+PE头+节表</code>与<code>第一个节的数据</code>之间，<code>节表一数据</code>与<code>节表二数据</code>之间，<strong>在内存中</strong>它们的填充间隙总和为y。</p>
<p>那么<code>节2.VirtualAddress</code>-<code>节2.PointerToRawData</code>，就能算出y比x多填充的值。</p>
<p>随后，用某数据的RVA-多填充的值，就是某数据的FOA</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227115611892.png" alt="image-20231227115611892" /></p>
<p><strong>例</strong><br />
已知全局变量的VA，通过PE文件来修改该全局变量的值</p>
<blockquote>
<p>已初始化的全局变量在PE文件中有空间</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address : %p\n&quot;</span>, &amp;g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value : 0x%x\n&quot;</span>, g);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行打印出的地址是变量g在进程4GB空间中的线性地址，虚拟地址VA</p>
</blockquote>
<div class="tag-plugin tabs" align="center"id="tab_105"><div class="nav-tabs"><div class="tab active"><a href="#tab_105-1">文件对齐值=内存对齐值</a></div><div class="tab"><a href="#tab_105-2">文件对齐值≠内存对齐值</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_105-1"><p>查看FileAlignment文件对齐和SectionAlignment内存对齐值，发现都是0x1000h</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227140612577.png" alt="image-20231227140612577" /></p>
<p>查该exe的ImageBase，为00400000。则RVA=00424A30-00400000=00024A30</p>
<p>因为文件对齐值=内存对齐值，所以FOA和RVA一样，去00024A30找这个值，修改这个值为0x77777777，然后重新运行exe。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227140725683.png" alt="image-20231227140725683" /></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227140849021.png" alt="image-20231227140849021" /></p></div><div class="tab-pane" id="tab_105-2"><div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><span>如果编译出的exe文件对齐和内存对齐一样，用LordPE对exe进行重建PE，把它们弄成不一样的</span></summary><div class="body"><p>打开LordPE，点击重建PE，选择Test.exe，PE重建功能中有压缩文件大小的功能，这里的压缩就是修改磁盘文件的对齐值，避免过多地因对齐而进行补0，使其少占用磁盘空间。</p><p>重建后的文件对齐是200h，内存对齐是1000h。</p></div></details><details class="folder" index="1"><summary><span>用VScode编译</span></summary><div class="body"><p>我用VScode编译出的exe，FileAlignment是200h，SectionAlighment是1000h。</p></div></details></div>
<p>查该exe的ImageBase，为00400000。则RVA=00424A30-00400000=00024A30</p>
<p>PE工具看各个区段的VirtualAddress，看出数据在.data区块。<br />
数据相对.data区块开头的偏移量为：00024A30-00024000=A30</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227151147572.png" alt="image-20231227151147572" /></p>
<p>.data的ROffset是11C00，+A30=12630h。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227151432452.png" alt="image-20231227151432452" /></p>
<p>去12630h找这个值，修改这个值为0x88888888，然后重新运行exe。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/../Typora_images/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5_PE/image-20231227151548237.png" alt="image-20231227151548237" /></p></div></div></div>



<div class="article-footer reveal fs14"></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/PE/Overview_PE.html">Overview</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/PE/DOS%E9%83%A8%E5%88%86.html">DOS部分</a></div></section></div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">wiki</span><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a href="/wiki/tags/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a><a href="/wiki/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a><a href="/wiki/tags/%E5%85%B6%E4%BB%96/">其他</a></div><div class="sitemap-group"><span class="fs14">关于</span><a href="/about/">关于</a></div></div><div class="text"><p>本站由 <a href="/">Misc</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0">Stellar 1.25.0</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.25.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.25.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".fancybox img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



  
  <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"onload="renderMathInElement(document.body);"></script>






<!-- inject -->


  </div>
</body>
</html>
